<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stanford CS144 Spring 2023</title>
      <link href="/2023/05/31/computer-Network/CS144/"/>
      <url>/2023/05/31/computer-Network/CS144/</url>
      
        <content type="html"><![CDATA[<h1 id="1-lab0-networking-warmup"><a class="markdownIt-Anchor" href="#1-lab0-networking-warmup"></a> 1.  lab0 networking warmup</h1><h2 id="11-set-up-gnulinux-on-your-computer"><a class="markdownIt-Anchor" href="#11-set-up-gnulinux-on-your-computer"></a> 1.1. Set up GNU/Linux on your computer</h2><p>ubuntu22.04LTS下执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> cmake gdb build-essential clang <span class="token punctuation">\</span>clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装g++12.3.0</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/ppa<span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> g++-12 <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer-Network/CS144/d6f4cf3e9c0ddf6dfec8cf56cdbf46a7.png" class=""><p>将minnow仓库上传到自己的仓库，参考<a href="https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private">这个方法</a><br />如果你做的是2023年之前的版本，需要用到sponge仓库，那么我<a href="https://github.com/Elite-zx/CS144-sponge">这里</a>有一份未被修改过的版本</p><h2 id="12-networking-by-hand"><a class="markdownIt-Anchor" href="#12-networking-by-hand"></a> 1.2. Networking by hand</h2><h3 id="121-fetch-a-web-page"><a class="markdownIt-Anchor" href="#121-fetch-a-web-page"></a> 1.2.1. Fetch a Web page</h3><p>先提前准备好这3行首部信息，连接成功后快速复制进去，避免连接断开(<code>Connection closed by foreign host.</code>)</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/hello</span> <span class="token http-version property">HTTP/1.1</span></span><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">cs144.keithw.org</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">close</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer-Network/CS144/c115d6890f5fd5aa7520dc617a5b121e.png" class=""><p>(Pretend to be a student at Stanford✌️)</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/lab0/elitezx</span> <span class="token http-version property">HTTP/1.1</span></span><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">cs144.keithw.org</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">close</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer-Network/CS144/dfd50d27a92f6fa60d1b2f2a923902a8.png" class=""><h3 id="122-send-yourself-an-email"><a class="markdownIt-Anchor" href="#122-send-yourself-an-email"></a> 1.2.2. Send yourself an email</h3><p>这个实现在 <em>自顶向下</em> 的实验中已经完成过了，就不再重复了</p><img src="/2023/05/31/computer-Network/CS144/d23d0311f3b4833f4d77f9aba232d1a2.png" class=""><h3 id="123-listening-and-connecting"><a class="markdownIt-Anchor" href="#123-listening-and-connecting"></a> 1.2.3. Listening and connecting</h3><p>netcat监听一个端口， telnet 连接到一个端口使用telnet连接到一个端口，该端口必须处于监听状态</p><img src="/2023/05/31/computer-Network/CS144/254604b0f9b24b1052e329f52117eb1f.png" class=""><img src="/2023/05/31/computer-Network/CS144/6da45053969b61df7a75cfb36704fc13.png" class=""><h2 id="13-writing-a-network-program-using-an-os-stream-socket"><a class="markdownIt-Anchor" href="#13-writing-a-network-program-using-an-os-stream-socket"></a> 1.3. Writing a network program using an OS stream socket</h2><h3 id="131-lets-get-startedfetching-and-building-the-starter-code"><a class="markdownIt-Anchor" href="#131-lets-get-startedfetching-and-building-the-starter-code"></a> 1.3.1. Let’s get started—fetching and building the starter code</h3><p>安装最新版的cmake，ubuntu22.04  follow <a href="https://askubuntu.com/a/1157132/1681772">here</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> minnowcmake <span class="token parameter variable">-S</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-B</span> buildcmake <span class="token parameter variable">--build</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer-Network/CS144/bc74865004fa7f18defa1fe09d61f59f.png" class=""><h3 id="132-modern-c-mostly-safe-but-still-fast-and-low-level"><a class="markdownIt-Anchor" href="#132-modern-c-mostly-safe-but-still-fast-and-low-level"></a> 1.3.2. Modern C++: mostly safe but still fast and low-level</h3><p>代码规范</p><h3 id="133-reading-the-minnow-support-code"><a class="markdownIt-Anchor" href="#133-reading-the-minnow-support-code"></a> 1.3.3. Reading the Minnow support code</h3><p>Adress</p><img src="/2023/05/31/computer-Network/CS144/7f7a17c918370d5a53fff8f0624c401c.png" class=""><p>file_descriptor</p><img src="/2023/05/31/computer-Network/CS144/399585efdc594c98c39eee207e8cb94f.png" class=""><p>socket</p><img src="/2023/05/31/computer-Network/CS144/a9b1e0847665ded2b05c50e9ede31e7d.png" class=""><p>TCPSocket</p><img src="/2023/05/31/computer-Network/CS144/51aa482e91ac4069a40b0a3ef6a6f84d.png" class=""><h3 id="134-writing-webget"><a class="markdownIt-Anchor" href="#134-writing-webget"></a> 1.3.4. Writing webget</h3><p>根据提供的类，可以很轻松的写出来（10行够了，但完整和规范）。注意write接受string_view的对象，但是该类不能使用’+'运算符，因此用string代替。string_view和string的区别在于string_view只能被访问而不能被修改( refer to a constant contiguous sequence),，而string可以追加、删除和修改字符</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_URL</span><span class="token punctuation">(</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> host<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> path <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// cerr &lt;&lt; "Function called: get_URL(" &lt;&lt; host &lt;&lt; ", " &lt;&lt; path &lt;&lt; ")\n";</span>  <span class="token comment">// cerr &lt;&lt; "Warning: get_URL() has not been implemented yet.\n";</span>  TCPSocket tcp_socket <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Address <span class="token function">target_addr</span><span class="token punctuation">(</span> host<span class="token punctuation">,</span> <span class="token string">"http"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span> target_addr <span class="token punctuation">)</span><span class="token punctuation">;</span>  string request <span class="token punctuation">&#123;</span> <span class="token string">"GET "</span> <span class="token operator">+</span> path <span class="token operator">+</span> <span class="token string">" HTTP/1.1\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// can not use '+' in string_view object</span>  cout <span class="token operator">&lt;&lt;</span> request<span class="token punctuation">;</span>  string header0 <span class="token punctuation">&#123;</span> <span class="token string">"Host: "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> header0<span class="token punctuation">;</span>  string_view header1 <span class="token punctuation">&#123;</span> <span class="token string">"Connection: close\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> header1<span class="token punctuation">;</span>  string_view empty_line <span class="token punctuation">&#123;</span> <span class="token string">"\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> empty_line<span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> request <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> header0 <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> header1 <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> empty_line <span class="token punctuation">)</span><span class="token punctuation">;</span>  string rcv_buffer<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>tcp_socket<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    tcp_socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span> rcv_buffer <span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> rcv_buffer<span class="token punctuation">;</span>    rcv_buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// destructor</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./apps/webget cs144.keithw.org /hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/31/computer-Network/CS144/87b796b15c232a403d24ed3180cd473e.png" class=""><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token parameter variable">--build</span> build <span class="token parameter variable">--target</span> check_webget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/31/computer-Network/CS144/70352ffb130b6bf7fbd2bad02b119435.png" class=""><h2 id="14-an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#14-an-in-memory-reliable-byte-stream"></a> 1.4. An in-memory reliable byte stream</h2><h3 id="141-target"><a class="markdownIt-Anchor" href="#141-target"></a> 1.4.1. target</h3><p>在 “An in-memory reliable byte stream” 这一小节中，文档要求你<strong>实现一个可靠的字节流</strong>。这个字节流需要满足以下几个条件：</p><ul><li>字节流是有限的：写入者可以结束输入，然后就不能再写入更多的字节。当读取者读到流的末尾时，它将到达“EOF”（文件结束），并且不能再读取更多的字节。</li><li>字节流也需要进行流量控制，以限制其在任何给定时间的内存消耗。对象在初始化时会有一个特定的_capacity：它在任何给定点愿意在自己的内存中存储的最大字节数。字节流将限制写入者在任何给定时刻可以写入的量，以确保流不会超过其存储容量。当读取者读取字节并从流中排出它们时，写入者被允许写入更多。</li><li>字节流的使用是在单线程中，你不需要担心并发的写入者/读取者、锁定或竞争条件。</li></ul><p>你需要实现以下的接口：<br />对于写入者：</p><ul><li>void push( std::string data ); // 将数据推送到流中，但只能推送可用容量允许的量。</li><li>void close(); // 表示流已经结束。不会再有更多的写入。</li><li>void set_error(); // 表示流出现了错误。</li><li>bool is_closed() const; // 流是否已经关闭？</li><li>uint64_t available_capacity() const; // 现在可以推送到流中的字节数是多少？</li><li>uint64_t bytes_pushed() const; // 累计推送到流中的总字节数。</li></ul><p>对于读取者：</p><ul><li>std::string_view peek() const; // 查看缓冲区中的下一个字节</li><li>void pop( uint64_t len ); // 从缓冲区中移除 <code>len</code> 个字节</li><li>bool is_finished() const; // 流是否已经结束（已关闭并完全弹出）？</li><li>bool has_error() const; // 流是否出现过错误？</li><li>uint64_t bytes_buffered() const; // 当前缓冲的字节数（已推送但未弹出）</li><li>uint64_t bytes_popped() const; // 累计从流中弹出的总字节数。</li></ul><p>你需要打开 src/byte_stream.hh 和 src/byte_stream.cc 文件，并实现提供这个接口的对象。在你开发字节流实现的过程中，你可以使用 cmake --build build --target check0 运行自动化测试。如果所有测试都通过，check0 测试将会运行你的实现的速度基准测试。</p><h3 id="142-source-code"><a class="markdownIt-Anchor" href="#142-source-code"></a> 1.4.2. source code</h3><p>byte_stream.hh</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ByteStream</span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">uint64_t</span> capacity_<span class="token punctuation">;</span>  <span class="token comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span>  std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> mem_buf<span class="token punctuation">;</span>  size_t bytes_pushed_cnt<span class="token punctuation">;</span>  size_t bytes_poped_cnt<span class="token punctuation">;</span>  <span class="token keyword">bool</span> is_end<span class="token punctuation">;</span>  <span class="token keyword">bool</span> is_err<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>byte_stream.cc</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">ByteStream</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> capacity <span class="token punctuation">)</span>  <span class="token operator">:</span> capacity_ <span class="token punctuation">&#123;</span> capacity <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> mem_buf <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> bytes_pushed_cnt <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> bytes_poped_cnt <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> is_end <span class="token punctuation">&#123;</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> is_err <span class="token punctuation">&#123;</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span> string data <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  size_t allowed_size <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  allowed_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> capacity_ <span class="token operator">-</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// flow-controlled</span>  data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> allowed_size <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> data <span class="token punctuation">)</span>    mem_buf<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>  bytes_pushed_cnt <span class="token operator">+=</span> allowed_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  is_end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">set_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  is_err <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">is_closed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> is_end<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">available_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> capacity_ <span class="token operator">-</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> bytes_pushed_cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>string_view <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> string_view <span class="token punctuation">&#123;</span> <span class="token operator">&amp;</span>mem_buf<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// const char*</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">is_finished</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> is_end <span class="token operator">&amp;&amp;</span> mem_buf<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">has_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> is_err<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">pop</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> len <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span> len<span class="token punctuation">,</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// avoid illegal len</span>  <span class="token keyword">int</span> _size <span class="token operator">=</span> len<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> _size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>    mem_buf<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bytes_poped_cnt <span class="token operator">+=</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_buffered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_popped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> bytes_poped_cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="143-result"><a class="markdownIt-Anchor" href="#143-result"></a> 1.4.3. result</h3><img src="/2023/05/31/computer-Network/CS144/a8993a0ccdbc79fc8603e6126bdda791.png" class=""> <h1 id="2-lab1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#2-lab1-stitching-substrings-into-a-byte-stream"></a> 2. lab1 stitching substrings into a byte stream</h1><h2 id="21-target"><a class="markdownIt-Anchor" href="#21-target"></a> 2.1. target</h2><p>将远程仓库的 <code>check1-startercode</code> 分支的更改合并到当前所在的main分支，重新cmake</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> merge origin/check1-startercodecmake <span class="token parameter variable">-S</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-B</span> buildcmake <span class="token parameter variable">--build</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这个实验和下一个实验中，你将实现一个TCP接收器：这个模块接收数据报，并将它们转换成一个可靠的字节流，以便应用程序从套接字中读取——就像你在Checkpoint 0中的webget程序从webserver中读取字节流一样。</p><p>TCP发送器将其字节流分割成短的段（子字符串，每个不超过约1460字节），以便它们每个都能装入一个数据报。但是，网络可能会重新排序这些数据报，或者丢弃它们，或者多次传送它们。接收器必须将这些段重新组装成它们开始时的连续字节流。</p><p>在这个实验中，你将编写一个负责这种重组的数据结构：<strong>一个Reassembler</strong>。它将接收子字符串，由一串字节和该字符串在更大流中的第一个字节的索引组成。流的每一个字节都有它自己的唯一索引，从零开始并向上计数。</p><img src="/2023/05/31/computer-Network/CS144/b93603f9efe81d5ff6627cb41ccc715c.png" class=""><h2 id="22-analyze"><a class="markdownIt-Anchor" href="#22-analyze"></a> 2.2. analyze</h2><img src="/2023/05/31/computer-Network/CS144/b9d0adf15b770596e7b145e3d3f2df50.png" class=""><p>首先理解内存限制的要求。ByteStream对象的capacity分为了两个部分，一个是用于字节流的buffer，用于存储重组好的有序字节流，这是对writer对象和reader对象而言的。一个是用于未重组的字节流的缓冲，可通过available_capacity()方法获取，这是reassembler对象而言的。因为capacity是固定的，意味着如果pop的频率太小，那么capacity被有序字节流填满，此时重组器reassembler会停止工作，因为它的存储空间available_capacity为0。</p><p>其次，实现这个reassembler最大的难点在于：如何<strong>处理重叠的子串</strong>。比如first_unassemble_index(期望接受的第一个有序字节)是’a’，但是先后来了子串’bc’，‘c’，这两个子串就要缓存在reassembler的内存空间中(大小为available capacity, 如果该值大于2的话)。我们需要在将c加入子串的时候，执行remove_overlapping操作，将这两个重叠子串合并为’bc’，这样确保reassembler中缓存空间中不存在重叠子串。换句话说，就是在新的子串要缓存时，在加入前先与缓存中重叠的子串执行合并操作，以确保加入后缓存中不存在重复子串，合并后bytes_pending（<code>unordered_bytes_size</code>）减去相应子串的大小。这样的目的是节省内存空间，并且在期望的有序字节达到<code>last_index + 1 == begin_index</code>时，也能快速的与缓存中的相邻子串合并然后通过writer的push函数push到reader的buffer中。</p><p>不仅如此，我们对新来的子串，在合并操作前，我们还要<strong>确保该子串是合法的</strong>，即该子串是在first_unassembled_index（<code>output.bytes_pushed()</code>）和first_unacceptable_index-1（<code>output.bytes_pushed()+output.available_capacity() - 1</code>）之间的，也就是说该子串的字节即不是已经被pop的，也不是到了buffer中的，更不是capacity之外的(否则会超出容量)，这个可以通过判断边界值做到。</p><p>在选择数据结果的问题上，我一开始为了效率（<code>string next_substring = unordered_bytes_buffer[first_index]</code>更快一点），选择了unordered_map,但是后来在test阶段，发现遍历reassembler的缓存unordered_bytes_buffer时，必须按first_index从小到大遍历，否则合并操作会出现遗漏，而unordered_map无法指定遍历顺序，因为哈希值我是不知道的，于是换成了能自动根据key值排序(默认从小到大)的map</p><p>在判断是否Finish的问题上，除了要满足达到接受方的流is_last_substring为true，还要满足reassembler已经通过writer的push函数将所有有序字节push到了buffer中，即<code>output.bytes_pushed() = first_index + data.size()</code></p><p>完成这个实验是不容易的，说实话我看把文档看懂让我究竟干什么都花了1个小时，花了一上午写好初始代码，结果一开始只能通过8个test用例，调试了一下午，逐步通过cap,dup…。这期间加入了很多cout语句（很管用），因为我对gdb还不咋熟悉，而且这文件也太多了。 最后测试到win又报错了，这个时候分析打印结果不太可行了，于是我硬着头皮又重新过了一遍自己的代码，发现是合并操作计算边界时+1,-1问题，最后成功通过test！</p><h2 id="23-source-code"><a class="markdownIt-Anchor" href="#23-source-code"></a> 2.3. source code</h2><h3 id="231-reassemblerhh"><a class="markdownIt-Anchor" href="#231-reassemblerhh"></a> 2.3.1 reassembler.hh</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Reassembler</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>  size_t next_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// the next ordered index,which will push to bytestream by writer</span>  size_t unordered_bytes_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> unordered_bytes_buffer <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// store unordered bytes</span>  <span class="token keyword">bool</span> byte_stream_end <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  size_t eof_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// function:let string legal</span>  <span class="token keyword">void</span> <span class="token function">process_substr</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> output <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// make sure no overlapping in reassembler buffer</span>  <span class="token keyword">void</span> <span class="token function">remove_overlap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="232-reassemblercc"><a class="markdownIt-Anchor" href="#232-reassemblercc"></a> 2.3.2 <a href="http://reassembler.cc">reassembler.cc</a></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"reassembler.hh"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"byte_stream.hh"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> first_index<span class="token punctuation">,</span> string data<span class="token punctuation">,</span> <span class="token keyword">bool</span> is_last_substring<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> output <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token function">process_substr</span><span class="token punctuation">(</span> first_index<span class="token punctuation">,</span> data<span class="token punctuation">,</span> output <span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"next_index: "</span> <span class="token operator">&lt;&lt;</span> next_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">==</span> next_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string next_substring <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"push to buffer!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> next_substring <span class="token punctuation">)</span><span class="token punctuation">;</span>    unordered_bytes_size <span class="token operator">-=</span> next_substring<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> first_index <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// key_type</span>  <span class="token punctuation">&#125;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_bytes_size: "</span> <span class="token operator">&lt;&lt;</span> unordered_bytes_size <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> is_last_substring <span class="token punctuation">)</span> <span class="token comment">// all bytes arrived</span>  <span class="token punctuation">&#123;</span>    byte_stream_end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    eof_index <span class="token operator">=</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> byte_stream_end <span class="token operator">&amp;&amp;</span> output<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> eof_index <span class="token punctuation">)</span> <span class="token comment">// all bytes pushed</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"All done!"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">process_substr</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> output <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* within the stream’s available capacity():   * [first_unassembled index,first unacceptable index]*/</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// empty input , will make last_index invalid (unsigned int -> -1 -> max int)</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"empty input!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  size_t begin_of_storage <span class="token operator">=</span> output<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// first_unassembled index</span>  size_t end_of_storage <span class="token operator">=</span> begin_of_storage <span class="token operator">+</span> output<span class="token punctuation">.</span><span class="token function">available_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// first unacceptable index -1</span>  size_t last_index <span class="token operator">=</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  next_index <span class="token operator">=</span> begin_of_storage<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"begin of storage: "</span> <span class="token operator">&lt;&lt;</span> begin_of_storage <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end_of_storage: "</span> <span class="token operator">&lt;&lt;</span> end_of_storage <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"last_index: "</span> <span class="token operator">&lt;&lt;</span> last_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> begin_of_storage <span class="token operator">></span> end_of_storage <span class="token punctuation">)</span> <span class="token comment">// buffer is full, waiting for ReadAll</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buffer is full and storage of reassembler is empty!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">></span> end_of_storage <span class="token operator">||</span> last_index <span class="token operator">&lt;</span> begin_of_storage <span class="token punctuation">)</span> <span class="token comment">// out of range</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index out of range!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">&lt;</span> begin_of_storage <span class="token operator">&amp;&amp;</span> last_index <span class="token operator">>=</span> begin_of_storage <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"keep tail!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> begin_of_storage <span class="token operator">-</span> first_index <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep tail</span>    first_index <span class="token operator">=</span> begin_of_storage<span class="token punctuation">;</span>                       <span class="token comment">// update first_index</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">>=</span> begin_of_storage <span class="token operator">&amp;&amp;</span> last_index <span class="token operator">></span> end_of_storage <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"keep head!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> end_of_storage <span class="token operator">-</span> first_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep head</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// cout &lt;&lt; "string process is done!" &lt;&lt; endl;</span>  <span class="token comment">// cout &lt;&lt; data &lt;&lt; endl;</span>  <span class="token function">remove_overlap</span><span class="token punctuation">(</span> first_index<span class="token punctuation">,</span> data <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cout &lt;&lt; "is not  overlap error" &lt;&lt; endl;</span>  unordered_bytes_buffer<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>  unordered_bytes_size <span class="token operator">+=</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">remove_overlap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span> iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    size_t last_index <span class="token operator">=</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    size_t begin_index <span class="token operator">=</span> iter<span class="token operator">-></span>first<span class="token punctuation">;</span>    size_t end_index <span class="token operator">=</span> iter<span class="token operator">-></span>first <span class="token operator">+</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"begin_index: "</span> <span class="token operator">&lt;&lt;</span> begin_index <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">"end_index: "</span> <span class="token operator">&lt;&lt;</span> end_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">"last_index: "</span> <span class="token operator">&lt;&lt;</span> last_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> last_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> begin_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exactly append!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      data <span class="token operator">+=</span> iter<span class="token operator">-></span>second<span class="token punctuation">;</span>      unordered_bytes_size <span class="token operator">-=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not use erase(key), it will casue iterator invalid</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Overlap between head and tail.</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">&lt;=</span> begin_index <span class="token operator">&amp;&amp;</span> begin_index <span class="token operator">&lt;=</span> last_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// = reason : "bc" "b"</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"append tail!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> end_index <span class="token operator">&lt;=</span> last_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// completely covered</span>        unordered_bytes_size <span class="token operator">-=</span> unordered_bytes_buffer<span class="token punctuation">[</span>begin_index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        data <span class="token operator">+=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> last_index <span class="token operator">-</span> begin_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        unordered_bytes_size <span class="token operator">-=</span> unordered_bytes_buffer<span class="token punctuation">[</span>begin_index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> begin_index <span class="token operator">&lt;=</span> first_index <span class="token operator">&amp;&amp;</span> first_index <span class="token operator">&lt;=</span> end_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// = reason: "bc" "c"</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"append head!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> last_index <span class="token operator">&lt;=</span> end_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        first_index <span class="token operator">=</span> begin_index<span class="token punctuation">;</span>        data <span class="token operator">=</span> iter<span class="token operator">-></span>second<span class="token punctuation">;</span>        unordered_bytes_size <span class="token operator">-=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        data <span class="token operator">=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> first_index <span class="token operator">-</span> begin_index <span class="token punctuation">)</span> <span class="token operator">+</span> data<span class="token punctuation">;</span>        unordered_bytes_size <span class="token operator">-=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        first_index <span class="token operator">=</span> begin_index<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token operator">++</span>iter<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after removing overlapping---"</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">"first_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">&lt;&lt;</span> <span class="token string">" last_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> unordered_bytes_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="24-result"><a class="markdownIt-Anchor" href="#24-result"></a> 2.4. result</h2><img src="/2023/05/31/computer-Network/CS144/61b17337a7d88a508fbce358e642c62e.png" class=""><h1 id="3-lab2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#3-lab2-the-tcp-receiver"></a> 3. lab2 the TCP receiver</h1><h2 id="31-translating-between-64-bit-indexes-and-32-bit-seqnos"><a class="markdownIt-Anchor" href="#31-translating-between-64-bit-indexes-and-32-bit-seqnos"></a> 3.1. Translating between 64-bit indexes and 32-bit seqnos</h2><img src="/2023/05/31/computer-Network/CS144/0c490d98cf317a4773f7a4451f66c0c0.png" class=""><p>首先要解决的问题是，TCP有限的字节序列字段造成的有限字节序列范围进而导致的回绕问题，我们需要在永不会溢出的64位绝对序号和会发生回绕的32位相对序号之间实现转换，因为对重组器来说，字节流是从0开始的不会回绕的序列。此外，TCP随机的初始字节序号(ISN)为这个问题增加了难度</p><img src="/2023/05/31/computer-Network/CS144/9f709e9806e18ae85d29faacc9785481.png" class=""><h3 id="311-wrapabsolute-seqno-to-seqno"><a class="markdownIt-Anchor" href="#311-wrapabsolute-seqno-to-seqno"></a> 3.1.1 wrap—absolute seqno to seqno</h3><p>把绝对序号转换为相对序号的wrap函数很简单，n的高32位表示绕了多少圈然后从0计数，带入这部分计算没有意义。因此截去n的高32位而将n的低32位与ISN相加即可得到目标相对序列（注释中有取余数的版本）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Wrap32 <span class="token class-name">Wrap32</span><span class="token double-colon punctuation">::</span><span class="token function">wrap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> n<span class="token punctuation">,</span> Wrap32 zero_point <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token comment">// return Wrap32 &#123; static_cast&lt;uint32_t>( ( n + zero_point.raw_value_ ) % ( 1ul &lt;&lt; 32 ) ) &#125;;</span>  <span class="token keyword">return</span> zero_point <span class="token operator">+</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="312-unwrap-seqno-to-absolute-seqno"><a class="markdownIt-Anchor" href="#312-unwrap-seqno-to-absolute-seqno"></a> 3.1.2 unwrap— seqno to absolute seqno</h3><p>这个函数给我干沉默了，我连别人的答案和解释都看不懂，说句惭愧的，我拿这玩意起码问了chatgpt几个小时，想了好几个小时，我都没整明白这个if语句是怎么来的，什么回绕之后ans要减去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，搞不懂。我说我在这个函数上磨了一天的时间都不夸张，还是理解不了，不管它了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">uint64_t</span> <span class="token class-name">Wrap32</span><span class="token double-colon punctuation">::</span><span class="token function">unwrap</span><span class="token punctuation">(</span> Wrap32 zero_point<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> checkpoint <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token keyword">uint64_t</span> uint32_range <span class="token operator">=</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span>  <span class="token keyword">uint32_t</span> offset <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>raw_value_ <span class="token operator">-</span> <span class="token function">wrap</span><span class="token punctuation">(</span> checkpoint<span class="token punctuation">,</span> zero_point <span class="token punctuation">)</span><span class="token punctuation">.</span>raw_value_<span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> ans <span class="token operator">=</span> checkpoint <span class="token operator">+</span> offset<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> offset <span class="token operator">>=</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token operator">&amp;&amp;</span> ans <span class="token operator">>=</span> uint32_range <span class="token punctuation">)</span> <span class="token comment">// ?</span>    ans <span class="token operator">-=</span> uint32_range<span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  <span class="token comment">// Your code here.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-implementing-the-tcp-receiver"><a class="markdownIt-Anchor" href="#32-implementing-the-tcp-receiver"></a> 3.2. Implementing the TCP receiver</h2><h3 id="321-receive"><a class="markdownIt-Anchor" href="#321-receive"></a> 3.2.1 receive</h3><p>对收到的message,首先要判断是否是SYN握手信息，并在收到此信息之后进入数据交换阶段（tcp连接已建立），因此要有一个bool变量<code>after_handshaking</code>标志现在是否处于三次握手之后的状态。在收到SYN后，因为SYN被置1的包的序号是发送端的随机初始序号ISN，因此将zero_point置为该值以便后续将相对序号<code>seqno</code>转变为绝对序号<code>absolute_seqno</code>。（为了声明和赋值zero_point成员变量，要在Wrap32类中添加指定的默认构造函数(= default)，复制构造函数和重载赋值运算符（这两个必须同时实现））</p><img src="/2023/05/31/computer-Network/CS144/9818e9d7cdd833e176a6dd96ca42a339.png" class=""><p>因为重组器对收到的字节流，从0编号，因此传递给reassembler的first_index要去除SYN所占的序号(如果存在SYN)，用<code>first_index = absolute_seqno + message.SYN + -1</code>就可以一步解决（boolean类型为true时，本质是为1，反正false为0）<br />因此receive的实现如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">receive</span><span class="token punctuation">(</span> TCPSenderMessage message<span class="token punctuation">,</span> Reassembler<span class="token operator">&amp;</span> reassembler<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> inbound_stream <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>after_handshaking <span class="token punctuation">)</span> <span class="token comment">// no handshaking</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> message<span class="token punctuation">.</span>SYN <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      after_handshaking <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// after handshaking</span>      zero_point <span class="token operator">=</span> Wrap32 <span class="token punctuation">&#123;</span> message<span class="token punctuation">.</span>seqno <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">uint64_t</span> checkpoint <span class="token operator">=</span> inbound_stream<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// first unassembled index</span>  <span class="token keyword">uint64_t</span> absolute_seqno <span class="token operator">=</span> <span class="token function">Wrap32</span><span class="token punctuation">(</span> message<span class="token punctuation">.</span>seqno <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span> zero_point<span class="token punctuation">,</span> checkpoint <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> first_index <span class="token operator">=</span> absolute_seqno <span class="token operator">+</span> message<span class="token punctuation">.</span>SYN <span class="token operator">+</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// since zero, remove SYN if exist</span>  reassembler<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> first_index<span class="token punctuation">,</span> message<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> message<span class="token punctuation">.</span>FIN<span class="token punctuation">,</span> inbound_stream <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="322-send"><a class="markdownIt-Anchor" href="#322-send"></a> 3.2.2 send</h3><p>TCP的接受端要向发送端反馈信息，实验的要求比实际情况是简化了的（不用为接受端的包生成随机初始序号），包括确认信息ackno和用于流量控制的窗口大小信息（rwnd, receiver window）window_size</p><ul><li>ackno：期望收到的下一个字节的序号（相对序号）</li><li>window_size：结合lab1和下图，可以看出window_size就是重组器用于排序的存储空间(storage)，可直接通过writer的available_capacity函数获得</li></ul><img src="/2023/05/31/computer-Network/CS144/a77e7e0ef331e6368c1bc5ff65569cd9.png" class=""><p>因此send函数的实现如下：<br />根据文档描述</p><blockquote><p>in TCP the SYN (beginning-of-stream) and FIN (end-of-stream) control flags are assigned sequence numbers. Each of these occupies one sequence number. (The sequence number occupied by the SYN flag is the ISN.) Each byte of data in the stream also occupies one sequence number.</p></blockquote><p>如果接受方收到一个message后流结束了(<code>inbound_stream.is_closed()</code> )则说明该流包含FIN，而标志流结束的FIN还会占用一个序列号，所以此时next_expected_seq需要额外再加1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TCPReceiverMessage <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">send</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Writer<span class="token operator">&amp;</span> inbound_stream <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  TCPReceiverMessage msg<span class="token punctuation">;</span>  <span class="token comment">/*window_size*/</span>  <span class="token keyword">uint64_t</span> _available_capacity <span class="token operator">=</span> inbound_stream<span class="token punctuation">.</span><span class="token function">available_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  msg<span class="token punctuation">.</span>window_size <span class="token operator">=</span> _available_capacity <span class="token operator">></span> UINT16_MAX <span class="token operator">?</span> UINT16_MAX <span class="token operator">:</span> _available_capacity<span class="token punctuation">;</span>  <span class="token comment">/*ackno*/</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>after_handshaking <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    msg<span class="token punctuation">.</span>ackno <span class="token operator">=</span> nullopt<span class="token punctuation">;</span> <span class="token comment">// or &#123;&#125; instead</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint64_t</span> next_expected_seq <span class="token operator">=</span> inbound_stream<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> inbound_stream<span class="token punctuation">.</span><span class="token function">is_closed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// FIN</span>      <span class="token operator">++</span>next_expected_seq<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>ackno <span class="token operator">=</span> zero_point <span class="token operator">+</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span> next_expected_seq <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wrap</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> msg<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-result"><a class="markdownIt-Anchor" href="#33-result"></a> 3.3. result</h2><img src="/2023/05/31/computer-Network/CS144/4ca2b48b339cd80c6d86e1d24d06da1e.png" class=""><h1 id="4-lab3-the-tcp-sender"><a class="markdownIt-Anchor" href="#4-lab3-the-tcp-sender"></a> 4. lab3 the TCP sender</h1><img src="/2023/05/31/computer-Network/CS144/0c490d98cf317a4773f7a4451f66c0c0.png" class=""><p>下面讲讲实现过程中遇到的难点和debug过程</p><h2 id="41tcp_senderhh"><a class="markdownIt-Anchor" href="#41tcp_senderhh"></a> 4.1tcp_sender.hh</h2><p><a href="https://github.com/Elite-zx/CS144/blob/main/src/tcp_sender.hh">tcp_sender.hh</a><br />在<code>tcp_sender.hh</code>实现一个Timer类，注意rest_time使用int64_t类型， 我一开始顺手写成uint64_t导致超时无法触发，debug后才发现。</p><p>发送端的payload类型是Buffer, 这是一个包含智能指针的类，这使得发送端缓存已发生但未确认的seg时，只是增加了对同一块内存的引用计数，而不会真的复制payload。这体现了文档中的这样一句话</p><blockquote><p>This turns out not to be very wasteful because the TCPSenderMessage’s payload is stored as a reference-counted read-only string (a Buffer object). So don’t  worry about it—it’s not actually copying the payload data.</p></blockquote><p>当你复制<code>TCPSenderMessage</code>对象时，<code>Buffer</code>对象的复制也将涉及到<code>std::shared_ptr&lt;std::string&gt;</code>的复制。在复制<code>std::shared_ptr</code>时，它不会创建一个新的字符串对象，而是创建一个新的智能指针，指向同一个字符串对象，并将该对象的引用计数加1。这就意味着新的<code>TCPSenderMessage</code>对象和原始的<code>TCPSenderMessage</code>对象共享相同的<code>payload</code>。当最后一个指向该字符串对象的<code>std::shared_ptr</code>被销毁（该seg被确认因此缓存被清除）时，<code>std::shared_ptr</code>将自动删除其管理的字符串对象，从而防止内存泄漏。</p><img src="/2023/05/31/computer-Network/CS144/f7c52fe07e3728ab4b4d5b84f335d6ce.png" class=""><h2 id="42-tcp_sendercc"><a class="markdownIt-Anchor" href="#42-tcp_sendercc"></a> 4.2. tcp_sender.cc</h2><p><a href="https://github.com/Elite-zx/CS144/blob/main/src/tcp_sender.cc">tcp_sender.cc</a></p><h3 id="421-设置fin位"><a class="markdownIt-Anchor" href="#421-设置fin位"></a> 4.2.1 设置FIN位</h3><p>发送方向接受方发送FIN被置true的包以标志流的结尾(marked with the SYN flag at the beginning of the stream, and FIN flag at the end.)</p><p>包含的FIN的包有两种情况</p><ul><li>一个数据包，其中FIN flag被置为true<br />即<strong>有可用空间时在段中搭载 FIN</strong>（Piggyback FIN in segment when space is available）<br />当outbound_stream中的数据均打包到data_seg中，stream is finished, 而接受窗口应该至少有一个空余字节(space is available))，此时要将最后一个数据包的FIN置1 (这里要多占一个字节）<br />看下图的测试用例，窗口的大小为8,而剩下的数据大小仅为4 bytes, 因此足以让最后一个数据包设置FIN位</li></ul><img src="/2023/05/31/computer-Network/CS144/d9d31cacab2e25fe8ec17789df9afc85.png" class=""><ul><li>单独的一个FIN flag 包，payload为0<br />这种情况出现中，流传输完毕后，接受窗口被填满，此时<strong>没有多余空间为最后一个数据包添加FIN位</strong>，因此发送方在接受方的接受窗口有空余时，再发送一个单独的FIN包<br />看下图的测试用例，数据包正好占用了7个空间，填满了当前窗口 rwnd = 0 ，因此此时不能设置FIN位。在后续收到新的rwnd= 1的后，接受方知道有空余位置了，发送一个单独的FIN包</li></ul><img src="/2023/05/31/computer-Network/CS144/780242ece281a0ca811c9b4811ea69dc.png" class=""><h3 id="422-debug"><a class="markdownIt-Anchor" href="#422-debug"></a> 4.2.2 debug</h3><p>遇到了一个很奇怪的测试用例&quot;SYN+FIN&quot;，这个用例要求我们同时设置SYN位和FIN位。首先发送方收到来自接受方的一个握手之前的ackno为nullopt的数据包(可能原因：网络延迟，旧链接断开之前的包在新链接建立之前达到)，接着发送方流向reader的流就关闭了，没有传出任何数据就关闭了。此时要求我们设置SYN+FIN的flag包，不包含任何数据负载。我只能在设置syn时检测流是否关闭从而通过这个测试用例，因为确实不知道什么情况下会有这样的包。</p><img src="/2023/05/31/computer-Network/CS144/fe364c4d14e753567f3b654f7ea523e5.png" class=""><h3 id="423-result"><a class="markdownIt-Anchor" href="#423-result"></a> 4.2.3 result</h3><img src="/2023/05/31/computer-Network/CS144/f9b40071ddfcc3d470d363c88538b467.png" class="">]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络自顶向下] Socket Programming Assignment + Miscellaneous Labs </title>
      <link href="/2023/05/24/computer-Network/socket-programming/"/>
      <url>/2023/05/24/computer-Network/socket-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="programming-tasks-of-computer-networking-a-topdown-approach"><a class="markdownIt-Anchor" href="#programming-tasks-of-computer-networking-a-topdown-approach"></a> Programming Tasks Of Computer-Networking-A-TopDown-Approach</h1><ul><li><p><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">WebServer</label></p></li><li><p><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">UDPPing</label></p></li><li><p><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">SMTP-Client</label></p></li><li><p><input type="checkbox" id="checkbox3" checked="true" /><label for="checkbox3">Proxy-Server</label></p></li><li><p><input type="checkbox" id="checkbox4" checked="true" /><label for="checkbox4">ABP-RDT</label></p></li><li><p><input type="checkbox" id="checkbox5" checked="true" /><label for="checkbox5">GBN-RDT</label></p></li></ul><h1 id="1-lab0-warmup"><a class="markdownIt-Anchor" href="#1-lab0-warmup"></a> 1 lab0 WarmUp</h1><h2 id="11-udp"><a class="markdownIt-Anchor" href="#11-udp"></a> 1.1. UDP</h2><ol><li><a href="http://UDPClient.py">UDPClient.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span> <span class="token comment"># ip or hostname , if is hostname,automatically carry out DNS lookup to find correspond ip</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span> <span class="token comment"># designate destination port number</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># create client socket(ipv4,udp), clientPort is automatically allocated by OS</span>message <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Input lowercase sentence:'</span><span class="token punctuation">)</span><span class="token comment"># message content and destination address(server_ip,server_ port),the clientAddress automatically add to the message by OS     </span>clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>modifiedMessage<span class="token punctuation">,</span> serverAddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># receive from server, 2048 is cache length</span><span class="token keyword">print</span><span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><a href="http://UDPServer.py">UDPServer.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span> <span class="token comment"># allocate server port number manually</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span><span class="token comment"># create server Socket(ipv4,udp)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># bind socket and port number, one socket one port number</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The server is ready to receive"</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    message<span class="token punctuation">,</span>clientAddress <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span> <span class="token comment"># receive message from client</span>    modifiedMessage <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done!"</span><span class="token punctuation">)</span>    serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>clientAddress<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>result</li></ol><img src="/2023/05/24/computer-Network/socket-programming/e93c1c9715ac60bb573dff2d805ff6c1.png" class=""><h2 id="12-tcp"><a class="markdownIt-Anchor" href="#12-tcp"></a> 1.2. TCP</h2><ol><li><a href="http://TCPClient.py">TCPClient.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span> <span class="token comment"># local host</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>   <span class="token comment"># welcoming socket</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#clientPort is automatically allocated by OS</span><span class="token comment"># knock at the welcoming door(welcomingsocket),this will initiate tcp three-way handshakes</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span> sentence<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Input lowercase sentence:'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># send message without server addree,since tcp connection is built</span>modifiedSentence <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>modifiedSentence<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><a href="http://TCPServer.py">TCPServer.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span> <span class="token comment"># welcoming socket</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># maximal connection number(at least 1)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The server is ready to receive'</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># create a new socket(connectionSocket) which is delicated to client</span>    sentence <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># receive message from connectionSocket</span>    capitalizedSentence <span class="token operator">=</span> sentence<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done!"</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>capitalizedSentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>result</li></ol><img src="/2023/05/24/computer-Network/socket-programming/c35cfd0227d5a85385ed4ec273af3c8e.png" class=""><img src="/2023/05/24/computer-Network/socket-programming/9dbdab3fe3d049875c34e21b56a2bde3.png" class=""><h1 id="lab1-web-server"><a class="markdownIt-Anchor" href="#lab1-web-server"></a> lab1  Web-Server</h1><h2 id="21-web-serverpy"><a class="markdownIt-Anchor" href="#21-web-serverpy"></a> 2.1. <a href="http://Web-Server.py">Web-Server.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#import socket module</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> sys <span class="token comment"># In order to terminate the program</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#Prepare a sever socket</span><span class="token comment">#Fill in start</span>serverPort <span class="token operator">=</span> <span class="token number">80</span> <span class="token comment"># allocate server port number manually</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment"># maximal connection number</span><span class="token comment">#Fill in end</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment">#Establish the connection</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    <span class="token comment">#Fill in start</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## create a new socket(connectionSocket) which is delicated to client</span>    <span class="token comment">#Fill in end</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment">#Fill in start</span>        message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># receive message from connectionSocket</span>        <span class="token comment">#Fill in end</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># get filename from string list message</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment">#Fill in start</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#Fill in end</span>        <span class="token comment">#Send one HTTP header line into socket</span>        <span class="token comment">#Fill in start</span>        header <span class="token operator">=</span> <span class="token string">'HTTP/1.1 200 OK\r\nConnection: close\r\nDate: Tue, 23 May 2023 11:14:01 GMT\r\nContent-Type: text/html\r\nContent-Length: %d\r\n\r\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># Comply with the HTTP response message format</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">#Fill in end</span>        <span class="token comment">#Send the content of the requested file to the client</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>        <span class="token comment">#Send response message for file not found</span>        <span class="token comment">#Fill in start</span>        header <span class="token operator">=</span> <span class="token string">'HTTP/1.1 404 Not Found'</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">#Fill in end</span>        <span class="token comment">#Close client socket</span>        <span class="token comment">#Fill in start</span>        <span class="token comment">#Fill in end</span>        serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#Fill in end</span>serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#Terminate the program after sending the corresponding data</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用以下命令可以检查端口号80是否被占用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> :8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>HelloWorld.html放在Web-Server.py同目录下，内容如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 36px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Hello,World! This is Elite-zx web server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="22-result"><a class="markdownIt-Anchor" href="#22-result"></a> 2.2. result</h2><img src="/2023/05/24/computer-Network/socket-programming/413b22962afb7e0a05c99a6b2663139f.png" class=""><h1 id="lab3-udppinger"><a class="markdownIt-Anchor" href="#lab3-udppinger"></a> lab3 UDPPinger</h1><h2 id="31-udppingerclientpy"><a class="markdownIt-Anchor" href="#31-udppingerclientpy"></a> 3.1. <a href="http://UDPPingerClient.py">UDPPingerClient.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">import</span> time serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span><span class="token punctuation">;</span>clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># timeout is 1 second </span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sendTime <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>     message <span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'Ping %d %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>sendTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>        modifiedMessage<span class="token punctuation">,</span> serverAddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>        rtt <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> sendTime        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Sequence %d: RTT = %.3fs  Reply from %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>rtt<span class="token punctuation">,</span>serverName<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception<span class="token punctuation">:</span> <span class="token comment"># time out Exception, socket.timeout is not from BaseException</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Sequence %d: Request timed out'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-udppingerserverpy"><a class="markdownIt-Anchor" href="#32-udppingerserverpy"></a> 3.2. <a href="http://UDPPingerServer.py">UDPPingerServer.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># We will need the following module to generate randomized lost packets</span><span class="token keyword">import</span> random<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># Create a UDP socket</span><span class="token comment"># Notice the use of SOCK_DGRAM for UDP packets</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token comment"># Assign IP address and port number to socket</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># Generate random number in the range of 0 to 10</span>    rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token comment"># Receive the client packet along with the address it is coming from</span>    message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token comment"># Capitalize the message from the client</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># If rand is less is than 4, we consider the packet lost and do not respond</span>    <span class="token keyword">if</span> rand <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span>    <span class="token comment"># Otherwise, the server responds</span>    serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-result"><a class="markdownIt-Anchor" href="#33-result"></a> 3.3. result</h2><img src="/2023/05/24/computer-Network/socket-programming/74e8a02e61f32df5efa4d22b1d92b233.png" class=""><h1 id="lab4-smtp-client"><a class="markdownIt-Anchor" href="#lab4-smtp-client"></a> lab4 SMTP-Client</h1><h2 id="41-smtp-mailclientpy"><a class="markdownIt-Anchor" href="#41-smtp-mailclientpy"></a> 4.1. <a href="http://SMTP-MailClient.py">SMTP-MailClient.py</a></h2><p>这里访问的是Gmail的服务器，因此多了2个额外的步骤</p><ul><li>建立TLS (Transport Layer Security) 连接，为了加密</li><li>在Google账户中开启双重验证，为Gmail设置单独的密码，直接用Google账户的密码AUTH LOGIN，Gmail服务器不认的，会返回<code>535-5.7.8 Username and Password not accepted</code>。如果账户密码正确，则返回<code>235 2.7.0 Accepted</code><br />注意账户密码使用base64编码，这可以通过<code>base64.b64encode</code>函数做到</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> base64<span class="token keyword">import</span> sslmsg <span class="token operator">=</span> <span class="token string">"\r\n Elite-ZX love computer networks!"</span>endmsg <span class="token operator">=</span> <span class="token string">"\r\n.\r\n"</span><span class="token comment"># Choose a mail server (e.g. Google mail server) and call it mailserver</span><span class="token comment">#Fill in start</span>mailServer <span class="token operator">=</span> <span class="token string">'smtp.gmail.com'</span>mailPort <span class="token operator">=</span> <span class="token number">587</span>fromAddress <span class="token operator">=</span> <span class="token string">'********@gmail.com'</span>toAddress <span class="token operator">=</span> <span class="token string">'********@qq.com'</span>username <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span><span class="token string">b'********@gmail.com'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>password <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span><span class="token string">b'********'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#Fill in end</span><span class="token comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span><span class="token comment">#Fill in start</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailServer<span class="token punctuation">,</span>mailPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#Fill in end</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'220 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Send HELO command and print server response.</span>heloCommand <span class="token operator">=</span> <span class="token string">'HELO Elite-zx\r\n'</span><span class="token keyword">print</span><span class="token punctuation">(</span>heloCommand<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>heloCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv1 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv1<span class="token punctuation">)</span><span class="token keyword">if</span> recv1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Send STARTTLS command and print server response</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'STARTTLS\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'220 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Create TLS connection</span>context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>clientSocket <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span><span class="token string">'smtp.gmail.com'</span><span class="token punctuation">)</span><span class="token comment"># Send AUTH LOGIN command </span>authLoginCommand<span class="token operator">=</span><span class="token string">'AUTH LOGIN\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>authLoginCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'334'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'334 reply not received from server'</span><span class="token punctuation">)</span><span class="token comment"># Send username</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span>username<span class="token operator">+</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'334'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'334 reply not received from server'</span><span class="token punctuation">)</span><span class="token comment"># Send password </span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span>password<span class="token operator">+</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'235'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'235 reply not received from server'</span><span class="token punctuation">)</span><span class="token comment"># Send MAIL FROM command and print server response.</span><span class="token comment"># Fill in start</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'MAIL FROM: &lt;'</span> <span class="token operator">+</span> fromAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'MAIL FROM: &lt;'</span> <span class="token operator">+</span> fromAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv2 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv2<span class="token punctuation">)</span><span class="token keyword">if</span> recv2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send RCPT TO command and print server response.</span><span class="token comment"># Fill in start</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'RCPT TO: &lt;'</span><span class="token operator">+</span> toAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'RCPT TO: &lt;'</span><span class="token operator">+</span> toAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv3 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv3<span class="token punctuation">)</span><span class="token keyword">if</span> recv3<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send DATA command and print server response.</span><span class="token comment"># Fill in start</span>DataCommand <span class="token operator">=</span> <span class="token string">'DATA\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>DataCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv4 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv4<span class="token punctuation">)</span><span class="token keyword">if</span> recv4<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'354'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'354 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send message data.</span><span class="token comment"># Fill in start</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Message ends with a single period.</span><span class="token comment"># Fill in start</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>endmsg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv5 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv5<span class="token punctuation">)</span><span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send QUIT command and get server response.</span><span class="token comment"># Fill in start</span>QuitCommand <span class="token operator">=</span> <span class="token string">'QUIT\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>QuitCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv6 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv6<span class="token punctuation">)</span><span class="token keyword">if</span> recv6<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'221'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'221 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="42-result"><a class="markdownIt-Anchor" href="#42-result"></a> 4.2. result</h2><img src="/2023/05/24/computer-Network/socket-programming/d23d0311f3b4833f4d77f9aba232d1a2.png" class=""><img src="/2023/05/24/computer-Network/socket-programming/b33d5322851ce8be0201013b6348a331.png" class=""><h1 id="lab5-proxyserver"><a class="markdownIt-Anchor" href="#lab5-proxyserver"></a> lab5 ProxyServer</h1><h2 id="51-setback-road"><a class="markdownIt-Anchor" href="#51-setback-road"></a> 5.1. setback road</h2><p>这个实验我踩了很多坑，一来是因为文档给出的源码与python3有很多不合的地方，二来网上没有很好的参考，包括<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES/blob/master/SocketProgrammingAssignment/%E4%BD%9C%E4%B8%9A4-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BD%9C%E4%B8%9A4-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%A7%A3%E7%AD%94.md">github上热度很高的那个参考</a>对我也不可行。因此我靠着添加try-except语句，stackoverflow以及chatgpt的分析，花了一个五六个小时总算是做出来了。<br />下面我将列举我踩的坑</p><ul><li>端口80默认绑定到http协议，因此访问https的网站将被拒绝连接。大多数网站即使你的URL是http还是会给你重定向到https，因此建议使用<a href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html%E8%BF%9B%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%96%87%E6%A1%A3%E9%87%8C%E6%8F%90%E5%88%B0%E7%9A%84www.google.com%E6%80%95%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A1%8C%E5%90%A7%F0%9F%A4%A8">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html进行结果测试，文档里提到的www.google.com怕是不可行吧🤨</a></li><li>关于split和partition的使用，目的是在URL中提取出源服务器gaia.cs.umass.edu和目标文件路径wireshark-labs/INTRO-wireshark-file1.html，要根据你访问的网站做调整</li><li>send函数内的参数均要加上用encode()处理，使参数从字符流变成字节流，否则会抛出<code>a bytes-like object is required, not 'str'</code>的异常</li><li><code>makefile()</code>函数返回一个与socket关联的文件对象，这里应该使用<code>fileobj = c.makefile('rw',None)</code>，则不是文档里的<code>fileobj = c.makefile('r', 0)</code>，首先参数0是python2中的，在python3已被替换为None, 而且如果用只读模式打开，后续write将会抛出不可写入的异常</li><li><code>fileobj.write(&quot;GET /&quot;.encode()+ filename.encode() + &quot; HTTP/1.0\r\n\r\n&quot;.encode())</code>的执行迟迟不结束，原来是发送的http请求先被放入了内部缓冲区等待发送，添加<code>fileobj.flush() </code>刷新缓冲区，立即发送请求</li><li>一开始参考了github上的代码直接转发message即<code>c.sendall(message.encode())</code>，可是浏览器总是会先发出先自动<code>GET /favicon.ico HTTP/1.1</code>的请求，查阅stackflow后，这个行为要修改html头部才能避免，因此只能采用文档提供的方法即自己构造HTTP请求（虽然浏览器在该请求之后还是会自动发出<code>GET /favicon.ico HTTP/1.1</code>请求😕）</li><li>因为目标路径文件包含一个子目录，因此要先在代理服务器下创建一个wireshark-labs的文件夹以避免<code>tmpFile = open(&quot;./&quot; + filename,&quot;wb&quot;)</code>抛出子目录不存在的异常）</li></ul><h2 id="52-proxyserverpy"><a class="markdownIt-Anchor" href="#52-proxyserverpy"></a> 5.2 <a href="http://ProxyServer.py">ProxyServer.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> sys<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment"># get listening port</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>'Usage <span class="token punctuation">:</span> <span class="token string">"python ProxyServer.py listening_port"</span>\n<span class="token punctuation">[</span>server_ip <span class="token punctuation">:</span> It <span class="token keyword">is</span> the listening\            port of Proxy Server'<span class="token punctuation">)</span>    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment"># Create a server socket, bind it to a port and start listening</span>tcpSerSock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment"># Fill in start.</span>tcpSerPort <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>tcpSerPort<span class="token punctuation">)</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment"># Fill in end.</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token comment"># Start receiving data from the client</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    tcpCliSock<span class="token punctuation">,</span> addr <span class="token operator">=</span> tcpSerSock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received a connection from: '</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>    <span class="token comment"># Fill in start.</span>    message <span class="token operator">=</span> tcpCliSock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Fill in end.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"message content: "</span> <span class="token punctuation">,</span> message<span class="token punctuation">)</span>    <span class="token comment"># Extract the filename from the given message</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"URL: "</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"filename: "</span> <span class="token punctuation">,</span> filename<span class="token punctuation">)</span>    fileExist <span class="token operator">=</span> <span class="token string">"false"</span>    <span class="token comment"># print(filetouse)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span><span class="token comment"># Check wether the file exist in the cache</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>        fileExist <span class="token operator">=</span> <span class="token string">"true"</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Target file exist!"</span><span class="token punctuation">)</span>        <span class="token comment"># ProxyServer finds a cache hit and generates a response message</span>        tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.0 200 OK\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-Type:text/html\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Fill in start.</span>        <span class="token comment"># send file content</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Fill in end.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Read from cache'</span><span class="token punctuation">)</span>    <span class="token comment"># Error handling for file not found in cache</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>        <span class="token keyword">if</span> fileExist <span class="token operator">==</span> <span class="token string">"false"</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Target file no exist!"</span><span class="token punctuation">)</span>            <span class="token comment"># Create a socket on the proxyserver</span>            <span class="token comment"># Fill in start.</span>            c <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>            <span class="token comment"># Fill in end.</span>            hostn <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"www."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># remove www. get hostname</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"source server host: "</span> <span class="token punctuation">,</span> hostn <span class="token punctuation">)</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                <span class="token comment"># Connect to the socket to port 80</span>                <span class="token comment"># Fill in start.</span>                c<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>hostn<span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"proxy server's socket connected to source server!"</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in end.</span>                <span class="token comment"># Create a temporary file on this socket and ask port 80</span>                <span class="token comment"># for the file requested by the client</span>                <span class="token comment">#print("will open fileobj!")</span>                <span class="token comment">#try:</span>                fileobj <span class="token operator">=</span> c<span class="token punctuation">.</span>makefile<span class="token punctuation">(</span><span class="token string">'rw'</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">)</span>                <span class="token comment">#except Exception as e:</span>                <span class="token comment">#    print("Exception occurred while making file:", str(e))</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"open fileobj!"</span><span class="token punctuation">)</span>                <span class="token comment"># approach + url + version of http + empty line + empty header</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>                    number <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"GET "</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> filename<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" HTTP/1.0\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>                    fileobj<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># Send immediately, do not wait</span>                <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Exception occurred while writing file:"</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"requested sent to source server!"</span><span class="token punctuation">)</span>                <span class="token comment"># Read the response into buffer</span>                <span class="token comment"># Fill in start.</span>                <span class="token comment">#c.sendall(message.encode())</span>                <span class="token comment">#buff = c.recv(2048)</span>                <span class="token builtin">buffer</span> <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                tcpCliSock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"buffer is ready!"</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in end.</span>                                <span class="token comment"># Create a new file in the cache for the requested file.</span>                tmpFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"./"</span> <span class="token operator">+</span> filename<span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in start.</span>                tmpFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">)</span>                tmpFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in end.</span>            <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Exception: "</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Illegal request"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># HTTP response message for file not found</span>            <span class="token comment"># Fill in start.</span>            tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.1 404 Not Found\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'File Not Found'</span><span class="token punctuation">)</span>            <span class="token comment"># Fill in end.</span>    <span class="token comment"># Close the client and the server sockets</span>    tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Fill in start.</span>tcpSerSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Fill in end.   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="53result"><a class="markdownIt-Anchor" href="#53result"></a> 5.3.result</h2><p>首次访问proxy server<br /><a href="http://localhost:8080/gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html">http://localhost:8080/gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html</a><br />代理服务器上没有目标文件，因此它向源服务器发出请求，在得到文件后转发给client并缓存目标文件在代理服务器本地</p><img src="/2023/05/24/computer-Network/socket-programming/010ebfd181aef963fb5dc1ee0e4d6c8c.png" class=""><p>client端获取成功</p><img src="/2023/05/24/computer-Network/socket-programming/b311d99e137e0737fee01f705f1f02a8.png" class=""><p>此时wireshark-labs目录下已经多了一个缓存文件</p><img src="/2023/05/24/computer-Network/socket-programming/db6ca4c65166d4a1cda7e465689748eb.png" class=""><p>再次访问proxy server，可以看到代理服务器直接返回了已缓存的文件</p><img src="/2023/05/24/computer-Network/socket-programming/51c4634ee69a357a132cb7d1c05dc65e.png" class=""><p>client端获取成功</p><img src="/2023/05/24/computer-Network/socket-programming/b763c137d8a41fca75d9cbc4c7da7c1d.png" class=""><h1 id="reliable-transport-protocol"><a class="markdownIt-Anchor" href="#reliable-transport-protocol"></a> Reliable Transport Protocol</h1><p><em>Tell me and I forget. Show me and I remember. Involve me and I understand.</em></p><h2 id="1-stop-and-wait-alternating-bit"><a class="markdownIt-Anchor" href="#1-stop-and-wait-alternating-bit"></a> 1. Stop And Wait / Alternating-Bit</h2><p>我实现的版本更像是rdt3.0，没有使用NAK，而是通过为ACK编号让接受方判断是否收到了正确的反馈信息，只要在接受方B没有收到目标packet时在ack_packet的acknum字段填入上次收到的packet序号即可。因为B反馈的ack_packet没有要求装入数据，因此ack_packet的payload字段为空，那么相应的checksum字段也不需要加上payload了，ack_packet的seqnum在该协议中没有约束。</p><p>为网络模拟器版本纠错，把exit()改成exit(0)<br />实验开始前，阅读文档提供的<a href="http://gaia.cs.umass.edu/kurose/transport/programming_assignment_QA.htm">问答</a>可以解决一些你的疑惑</p><h3 id="11-analyze"><a class="markdownIt-Anchor" href="#11-analyze"></a> 1.1 analyze</h3><p>发送方FSM，用A_status的4个值表示4种状态</p><img src="/2023/05/24/computer-Network/socket-programming/89b16b7b14b82b04ee59f46aab1a6b85.png" class=""><p>接受方的FSM，用B_status的2个值表示2种状态</p><img src="/2023/05/24/computer-Network/socket-programming/c3563a3317ec4f89aa04e5d5b7b003d9.png" class=""><h3 id="12-source-code"><a class="markdownIt-Anchor" href="#12-source-code"></a> 1.2. source code</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">/* ****************************************************************** ALTERNATING BIT AND GO-BACK-N NETWORK EMULATOR: VERSION 1.1  J.F.Kurose   This code should be used for PA2, unidirectional or bidirectional   data transfer protocols (from A to B. Bidirectional transfer of data   is for extra credit and is not required).  Network properties:   - one way network delay averages five time units (longer if there     are other messages in the channel for GBN), but can be larger   - packets can be corrupted (either the header or the data portion)     or lost, according to user-defined probabilities   - packets will be delivered in the order in which they were sent     (although some can be lost).**********************************************************************/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIDIRECTIONAL</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">/* change to 1 if you're doing extra credit */</span></span>                        <span class="token comment">/* and write a routine called B_output */</span><span class="token keyword">int</span> sndPkt_seq<span class="token punctuation">;</span>  <span class="token comment">// 0,1,0,1...</span><span class="token keyword">int</span> A_status<span class="token punctuation">;</span>    <span class="token comment">// 4 status in FSM rdt3.0, 0 is iniital status</span><span class="token keyword">int</span> B_status<span class="token punctuation">;</span>    <span class="token comment">// 2 status in FSM rdt2.2, waiting for packet 0 or 1</span><span class="token comment">/* a "msg" is the data unit passed from layer 5 (teachers code) to layer  */</span><span class="token comment">/* 4 (students' code).  It contains the data (characters) to be delivered */</span><span class="token comment">/* to layer 5 via the students transport level protocol entities.         */</span><span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* a packet is the data unit passed from layer 4 (students code) to layer */</span><span class="token comment">/* 3 (teachers code).  Note the pre-defined packet structure, which all   */</span><span class="token comment">/* students must follow. */</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> seqnum<span class="token punctuation">;</span>    <span class="token keyword">int</span> acknum<span class="token punctuation">;</span>    <span class="token keyword">int</span> checksum<span class="token punctuation">;</span>    <span class="token keyword">char</span> payload<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> cachedPkt<span class="token punctuation">;</span><span class="token comment">/********* STUDENTS WRITE THE NEXT SEVEN ROUTINES *********/</span><span class="token comment">/* called from layer 5, passed the data to be sent to other side */</span><span class="token function">A_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>A_status <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> A_status <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sender A is waiting for ACK!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// waiting for ACK;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> sndPkt<span class="token punctuation">;</span>    <span class="token comment">/*make_Pkt*/</span>    sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> sndPkt_seq <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>acknum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// not a ACKnowledged package</span>    sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">=</span> sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> sndPkt<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">+=</span> message<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>sndPkt<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> message<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A is sending packet %d !\n"</span><span class="token punctuation">,</span> sndPkt<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*cache_pkt*/</span>    cachedPkt <span class="token operator">=</span> sndPkt<span class="token punctuation">;</span>    <span class="token comment">/*udt_send(sndPKt)*/</span>    <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> sndPkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*start timer*/</span>    <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*switch status of A*/</span>    <span class="token operator">++</span>A_status<span class="token punctuation">;</span>    <span class="token operator">++</span>sndPkt_seq<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">B_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment">/* need be completed only for extra credit */</span>    <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 */</span><span class="token function">A_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>A_status <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> A_status <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// incorrect status</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token comment">/*no payload of ack packet*/</span>    <span class="token comment">/* notcorrupt and is target ACK*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">==</span> packet<span class="token punctuation">.</span>checksum <span class="token operator">&amp;&amp;</span> cachedPkt<span class="token punctuation">.</span>seqnum <span class="token operator">==</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ACK %d packet  is not corrupt!\n"</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* stop timer*/</span>        <span class="token function">stoptimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        A_status <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>A_status<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"corrupt or not target ACK %d! will timeout and retransmit!\n"</span><span class="token punctuation">,</span>               cachedPkt<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// corrupt or is not target ack ,waiting for timeout</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when A's timer goes off */</span><span class="token function">A_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sender A is retransmiting packet %d !\n"</span><span class="token punctuation">,</span> cachedPkt<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*udt_send*/</span>    <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cachedPkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*start timer*/</span>    <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following routine will be called once (only) before any other */</span><span class="token comment">/* entity A routines are called. You can use it to do any initialization */</span><span class="token function">A_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sndPkt_seq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// initial status of sender A---waiting for message from layer5</span>    A_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* Note that with simplex transfer from a-to-B, there is no B_output() */</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 at B*/</span><span class="token function">B_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> ack_packet<span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> tmp_checksum <span class="token operator">+=</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* notcorrupt and is target packet*/</span>    ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">==</span> packet<span class="token punctuation">.</span>checksum <span class="token operator">&amp;&amp;</span> B_status <span class="token operator">==</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"notcorrupt and target packet %d! sending right ACK!\n"</span><span class="token punctuation">,</span>               packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*extract*/</span>        <span class="token keyword">struct</span> <span class="token class-name">msg</span> extract_msg<span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>extract_msg<span class="token punctuation">.</span>data<span class="token punctuation">,</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*deliver_data*/</span>        <span class="token function">tolayer5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> extract_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> B_status<span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span>            ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>  <span class="token comment">// no payload</span>        <span class="token comment">/*make_Pkt*/</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>        B_status <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>B_status<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// switch B status</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"corrupt or not target packet! sending last receiving ACK!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> <span class="token punctuation">(</span>B_status <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span>            ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>  <span class="token comment">// no payload</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when B's timer goes off */</span><span class="token function">B_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following rouytine will be called once (only) before any other */</span><span class="token comment">/* entity B routines are called. You can use it to do any initialization */</span><span class="token function">B_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> B_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-result"><a class="markdownIt-Anchor" href="#12-result"></a> 1.2. result</h3><h4 id="21-no-loss-and-corruption"><a class="markdownIt-Anchor" href="#21-no-loss-and-corruption"></a> 2.1. no loss and corruption</h4><p>一来一回，运行正常， packet 0与ack 0对应，packet 1与ack 1对应</p><img src="/2023/05/24/computer-Network/socket-programming/ccfe78ace391eb03d86554132cc0c2a0.png" class=""><h4 id="22-loss-and-corruption"><a class="markdownIt-Anchor" href="#22-loss-and-corruption"></a> 2.2 loss and corruption</h4><p>虽然只设置了0.2的丢包率和损失率，但是实际上概率还是挺大的，可能是随机数生成器的问题，下面将分析部分输出来验证代码的正确性</p><p>A先发送packet0, B成功接受了packet0,但是反馈信息在layer3中被损坏，A收到损坏的ack信息后等待超时重传，重传2次的2个包都丢了，接着超时重传，发出的包又损坏了(这也太频繁了)，期间A收到来自上层layer5的数据包，但是由于这是stop and wait协议，在收到发出的包的确认之前不能发送新的包，因此A只打印它在等待ack的信息。B端收到A重传的数据包，发现这不是它想要的数据包，而是冗余的数据包，因此它丢弃该包（不上传到layer5），并重新对这个序号（最后一次成功收到的序号）的包发出确认，A端收到想要的确认后，发出packet 1</p><img src="/2023/05/24/computer-Network/socket-programming/5b35c846e62834a821321e293a9e051d.png" class=""><img src="/2023/05/24/computer-Network/socket-programming/37f5283f60325d87878bbd777a9bb644.png" class=""><img src="/2023/05/24/computer-Network/socket-programming/d5f2639399ae272b158f370885f2fbaa.png" class=""><h2 id="2-go-back-n"><a class="markdownIt-Anchor" href="#2-go-back-n"></a> 2. Go-Back-N</h2><h3 id="21-analyze"><a class="markdownIt-Anchor" href="#21-analyze"></a> 2.1 analyze</h3><p>基于任务1, 完成GBN版本是比较轻松的，编写加调试只花了3个小时。接受方只需维护接受到<strong>最后有序packet的序号last_rcv_seq</strong>即可，在收到失序的重复的packet时发出包含last_rcv_seq的ACK即可告诉发送方自己可以确认了包含last_rcv_seq之前的所有包。因为存在ack到达之前，发送方超时重传的现象，因此发送方可能会收到冗余的ack信息，因此要设置一个acknum小于base的分支</p><p>发送方维护base和nextseq两个变量以表示window的发送边界，base表示窗口内最早发送但是未确认的序号（最右侧，窗口左移），nextseq表示下一个待发送的序号。因此当base = nextseq时，说明此时窗口内已经的packet均是待发送状态，此时只需要停止计时器，等待发送后启动计时器</p><p>注意这期间只有唯一的计时器，该计时器在窗口移动时重新记时<br />发送方FSM与接受方FSM：<br />纠正下图的&quot;如果下一个分组未发送&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> “如果窗口内的包均被确认<code>base == nextsequm</code>，则停止计时器，此时窗口内均是未发送的包，见下图 ，否则说明窗口内还有发送但未确认的包，重开计时器”</p><img src="/2023/05/24/computer-Network/socket-programming/32d267d6b7b57841c28884749ca8b64b.png" class=""><h3 id="22-source-code"><a class="markdownIt-Anchor" href="#22-source-code"></a> 2.2 source code</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">/******************************************************************* ALTERNATING BIT AND GO-BACK-N NETWORK EMULATOR: VERSION 1.1  J.F.Kurose   This code should be used for PA2, unidirectional or bidirectional   data transfer protocols (from A to B. Bidirectional transfer of data   is for extra credit and is not required).  Network properties:   - one way network delay averages five time units (longer if there     are other messages in the channel for GBN), but can be larger   - packets can be corrupted (either the header or the data portion)     or lost, according to user-defined probabilities   - packets will be delivered in the order in which they were sent     (although some can be lost).**********************************************************************/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIDIRECTIONAL</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">/* change to 1 if you're doing extra credit */</span></span>                        <span class="token comment">/* and write a routine called B_output */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>   <span class="token comment">// window size of sliding-window protocol</span><span class="token keyword">int</span> last_rev_seq<span class="token punctuation">;</span>  <span class="token comment">// last receiving packet seq in receriver B</span><span class="token keyword">int</span> expected_seq<span class="token punctuation">;</span>  <span class="token comment">// expected packet sequence in receriver B</span><span class="token keyword">int</span> base<span class="token punctuation">;</span>          <span class="token comment">// start seq of sending window in sender A</span><span class="token keyword">int</span> nextseq<span class="token punctuation">;</span>       <span class="token comment">// next packet to be sent in the sending sliding window</span><span class="token comment">/* a "msg" is the data unit passed from layer 5 (teachers code) to layer  */</span><span class="token comment">/* 4 (students' code).  It contains the data (characters) to be delivered */</span><span class="token comment">/* to layer 5 via the students transport level protocol entities.         */</span><span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* a packet is the data unit passed from layer 4 (students code) to layer */</span><span class="token comment">/* 3 (teachers code).  Note the pre-defined packet structure, which all   */</span><span class="token comment">/* students must follow. */</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> seqnum<span class="token punctuation">;</span>    <span class="token keyword">int</span> acknum<span class="token punctuation">;</span>    <span class="token keyword">int</span> checksum<span class="token punctuation">;</span>    <span class="token keyword">char</span> payload<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> buffer<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// buffer in sending A in order to retransmit</span><span class="token comment">/* called from layer 5, passed the data to be sent to other side */</span><span class="token function">A_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextseq <span class="token operator">>=</span> base <span class="token operator">+</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sending window is full now!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// window is full</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* make pkt*/</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> sndPkt<span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> nextseq<span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>acknum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// not a acknowledged packet</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>sndPkt<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> message<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">=</span> sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> sndPkt<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">+=</span> sndPkt<span class="token punctuation">.</span>payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A is sending packet %d\n"</span><span class="token punctuation">,</span> nextseq<span class="token punctuation">)</span><span class="token punctuation">;</span>    buffer<span class="token punctuation">[</span>nextseq<span class="token punctuation">]</span> <span class="token operator">=</span> sndPkt<span class="token punctuation">;</span>    <span class="token comment">/*udt_send*/</span>    <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> sndPkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>base <span class="token operator">==</span> nextseq<span class="token punctuation">)</span>  <span class="token comment">// first packet of sending window, start timer</span>        <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>nextseq<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">B_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment">/* need be completed only for extra credit */</span>    <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 */</span><span class="token function">A_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">!=</span> packet<span class="token punctuation">.</span>checksum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>            <span class="token string">"ACK %d packet  is  corrupt! will timeout and retransmit all "</span>            <span class="token string">"packets in the sliding window!\n"</span><span class="token punctuation">,</span>            packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>packet<span class="token punctuation">.</span>acknum <span class="token operator">&lt;</span> base<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"duplicated ACK %d"</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ACK %d packet is not corrupt or duplicated! \n"</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*base = getacknum(rcvpkt) + 1 */</span>    base <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>base <span class="token operator">==</span> nextseq<span class="token punctuation">)</span>  <span class="token comment">// no packets sent in sliding window</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"no packet sent in sliding window! stop timer! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stoptimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>  <span class="token comment">// exist unacknowledged packet in the window</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>            <span class="token string">"The earliest sent packet is acknowledged, restart timer and move "</span>            <span class="token string">"sliding window!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stoptimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when A's timer goes off */</span><span class="token function">A_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*Go Back N  */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Elite-zx: sender A GO BACK N, from packet %d to packet %d \n"</span><span class="token punctuation">,</span> base<span class="token punctuation">,</span>           nextseq <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> base<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextseq<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following routine will be called once (only) before any other */</span><span class="token comment">/* entity A routines are called. You can use it to do any initialization */</span><span class="token function">A_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    nextseq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* Note that with simplex transfer from a-to-B, there is no B_output() */</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 at B*/</span><span class="token function">B_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> ack_packet<span class="token punctuation">;</span>    ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> tmp_checksum <span class="token operator">+=</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">==</span> packet<span class="token punctuation">.</span>checksum <span class="token operator">&amp;&amp;</span> packet<span class="token punctuation">.</span>seqnum <span class="token operator">==</span> expected_seq<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        last_rev_seq <span class="token operator">=</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>        <span class="token operator">++</span>expected_seq<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"notcorrupt and expected packet %d! sending right ACK %d!\n"</span><span class="token punctuation">,</span>               packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">,</span> last_rev_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*extract*/</span>        <span class="token keyword">struct</span> <span class="token class-name">msg</span> extract_msg<span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>extract_msg<span class="token punctuation">.</span>data<span class="token punctuation">,</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*deliver_data*/</span>        <span class="token function">tolayer5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> extract_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* make_pkt*/</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> last_rev_seq<span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span> ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>            <span class="token string">"corrupt or not expected packet %d (%d)! sending last receiving "</span>            <span class="token string">"ACK "</span>            <span class="token string">"%d!\n"</span><span class="token punctuation">,</span>            expected_seq<span class="token punctuation">,</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">,</span> last_rev_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> last_rev_seq<span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span> ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when B's timer goes off */</span><span class="token function">B_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following rouytine will be called once (only) before any other */</span><span class="token comment">/* entity B routines are called. You can use it to do any initialization */</span><span class="token function">B_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    last_rev_seq <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    expected_seq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23-result"><a class="markdownIt-Anchor" href="#23-result"></a> 2.3. result</h3><h4 id="21-no-loss-and-corruption-2"><a class="markdownIt-Anchor" href="#21-no-loss-and-corruption-2"></a> 2.1 no loss and corruption</h4><p>下面将分析部分输出来验证代码的正确性</p><p>A先发出两个packet，B对这两个packet进行了确认，A收到确认，窗口右移2次，此时窗口内没有已发送的包，因此暂停计时器。</p><img src="/2023/05/24/computer-Network/socket-programming/276f5e6671463694fb72993989cb865e.png" class=""><p>接着A发出packet2,3,4，B对这3个包逐一确认，但A在收到packet2的确认之前超时，A重传packet 2 to 4。B对packet2,3,4的ack到达A后，A移动窗口。B会收到冗余的packet 2,3,4，那么B会回复3个同样的ack 4信息，因为packet 4 是它最后收到的有序pkt。之后A会到收到冗余的ack4，A会打印说明自己收到了重复的ack信息。接着A继续发送packet5…</p><img src="/2023/05/24/computer-Network/socket-programming/e9228d9752502d65958cd87a1152e3c4.png" class=""><img src="/2023/05/24/computer-Network/socket-programming/558c8c6a161ba3715fdf367a10d34721.png" class=""><p>…</p><img src="/2023/05/24/computer-Network/socket-programming/1946975b88b4b65d58c88ded1a62c5b8.png" class=""><h4 id="22-loss-and-corruption-2"><a class="markdownIt-Anchor" href="#22-loss-and-corruption-2"></a> 2.2. loss and corruption</h4><p>下面将分析部分输出来验证代码的正确性</p><p>这里就简单说一下了。B对pkt 0的确认信息损失了，而此时A已经发出了0～2的pkt（其中pkt 1 丢失，pkt 2 损失）, 因此A要超时重传pkt 0～2（pkt 2 损失）, 因为B已经正确收到了pkt 0, 因此在收到冗余的pkt 0 时反馈ack 0, A成功收到ack 0 并移动窗口， 而B收到了重传的pkt1 而发送ack1信息…</p><img src="/2023/05/24/computer-Network/socket-programming/f29d4e4a3d2c09fa475072d991d20b95.png" class=""><img src="/2023/05/24/computer-Network/socket-programming/f70a5a55e0094826761fe3bdbcfc841b.png" class=""><p>…</p><img src="/2023/05/24/computer-Network/socket-programming/6dff28c981d2c604e4bcbca86ed88d93.png" class=""><p><a href="https://zhuanlan.zhihu.com/p/35390933">reference</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
          <category> Computer Network-ATopDownApproach </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HIT-OS]哈工大操作系统实验lab1~8</title>
      <link href="/2023/05/06/OS-Learning/HIT-OS-Labs/"/>
      <url>/2023/05/06/OS-Learning/HIT-OS-Labs/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><em>Learning operating system by coding it！</em></p><h1 id="实验0-实验环境搭建"><a class="markdownIt-Anchor" href="#实验0-实验环境搭建"></a> 实验0 实验环境搭建</h1><hr /><p><a href="https://hoverwinter.gitbooks.io/hit-oslab-manual/content/environment.html">reference1</a><br /><a href="https://blog.csdn.net/zy010101/article/details/108085192">reference2</a><br />遇到的问题：在编译linux0.11时，出现<code>fatal error：asm/ioctl.h: No such file or directory</code>，<code>loctl.h</code>这个文件是在库<code>linux-lib-dev</code>中的，而且我已经安装了这个库，但还是有这个错误</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/0fc97dc6618be181bcc508a1ae24096d.png" class=""><p>解决方法：使用i386版本的linux-libc-dev</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> linux-libc-dev:i386<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="实验1-操作系统的引导"><a class="markdownIt-Anchor" href="#实验1-操作系统的引导"></a> 实验1 操作系统的引导</h1><hr /><h2 id="1-改写bootsects"><a class="markdownIt-Anchor" href="#1-改写bootsects"></a> 1. 改写bootsect.s</h2><ol><li>我们只需要<code>bootsect.s</code>源码中打印字符串的部分，因为不涉及迁移<code>bootsect</code>从<code>0x07c00</code>到<code>0x90000</code>的操作，所以<code>bootsect.s</code>读入内存后还是在<code>0x07c00</code>的位置，因此要添加<code>mov es, #07c0</code>才能使<code>es:bp</code>指向正确的字符串起始位置。此外，<code>cx</code>参数的大小为字符串大小+6，这里的6是3个CR/LF (carriage return/line feed: 13 10)</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c8816d22b6b3d59ca96a5ac9155ffec9.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b3660aafb778e2e59f1b85d93bcfd830.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/1cfcbf9dea0e7cba56adf806615be13b.png" class=""><ol start="2"><li>改写<code>bootsect.s</code></li></ol><pre class="line-numbers language-none"><code class="language-none">entry _start_start:movah,#0x03! read cursor posxorbh,bhint0x10movcx,#34movbx,#0x0007! page 0, attribute 7 (normal)movbp,#msg1movax,#0x07c0moves,ax         ! set correct segment addressmovax,#0x1301! write string, move cursorint0x10inf_loop:        jmp inf_loop     ! keep not exitmsg1:.byte 13,10.ascii &quot;EliteX system is Loading ...&quot;.byte 13,10,13,10.org 510   ! jump over root_devboot_flag:.word 0xAA55         ! effective sign<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>要仅汇编<code>bootsect.s</code>得到<code>Image</code>，运行以下命令（在实模式下，as86工具用于汇编产生目标代码，ld86工具用于连接产生可执行文件）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">as86 <span class="token parameter variable">-0</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-o</span> bootsect.o bootsect.sld86 <span class="token parameter variable">-0</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> bootsect bootsect.o<span class="token function">dd</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>bootsect <span class="token assign-left variable">of</span><span class="token operator">=</span>Image <span class="token assign-left variable">skip</span><span class="token operator">=</span><span class="token number">32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>结果</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/0cdf798c3c7c3b0c98b5c22c198edb2b.png" class=""><h2 id="2-改写setups"><a class="markdownIt-Anchor" href="#2-改写setups"></a> 2. 改写setup.s</h2><h3 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> task1</h3><ol><li>在<code>setup.s</code>中写入<code>bootsect.s</code>的内容，对字符串信息作修改，修改<code>es</code>为<code>0x07e0</code>，因为<code>setup</code>在内存紧跟<code>bootsect</code>(0x07c00 + 0x200)之后 (这里将<code>cs</code>的值通过<code>ax</code>赋给<code>es</code>，因为此时<code>cs</code>的值就是<code>0x07e0</code>）)</li></ol><pre class="line-numbers language-none"><code class="language-none">entry _start_start:movah,#0x03! read cursor posxorbh,bhint0x10movcx,#25movbx,#0x0007! page 0, attribute 7 (normal)movbp,#msg1movax,csmoves,axmovax,#0x1301! write string, move cursorint0x10inf_loop:jmp inf_loop msg1:.byte 13,10.ascii &quot;Now we are in SETUP&quot;.byte 13,10,13,10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/aef3252bfb573b6b244bc26b131883fb.png" class=""><ol start="2"><li>在<code>bootsect.s</code>中添加源码中载入<code>setup</code>的部分，并修改<code>SETUPSEG</code>为<code>0x07e0</code>，原因还是在于我们没有移动<code>bootsect</code>**，**去掉循环并修改<code>SETUPLEN</code>为<code>2</code>，因为对我们的改写后的<code>setup</code>，仅需读入两个扇区就够了（其实一个扇区的大小也够了）</li></ol><pre class="line-numbers language-none"><code class="language-none">SETUPLEN &#x3D; 1SETUPSEG &#x3D; 0x07e0entry _start_start:movah,#0x03! read cursor posxorbh,bhint0x10movcx,#34movbx,#0x0007! page 0, attribute 7 (normal)movbp,#msg1movax,#0x07c0moves,axmovax,#0x1301! write string, move cursorint0x10load_setup:movdx,#0x0000! drive 0, head 0movcx,#0x0002! sector 2, track 0movbx,#0x0200! address &#x3D; 512, in INITSEGmovax,#0x0200+SETUPLEN! service 2, nr of sectorsint0x13! read itjncok_load_setup! ok - continuemovdx,#0x0000movax,#0x0000! reset the disketteint0x13jload_setupok_load_setup:jmpi0,SETUPSEG msg1:.byte 13,10.ascii &quot;EliteX system is Loading ...&quot;.byte 13,10,13,10.org 510   ! jump over root_devboot_flag:.word 0xAA55         ! effective sign<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>修改<code>linux-0.11/tool/build.c</code>注释掉最后部分，以便我们借助MakeFile编译<code>bootsect.s</code>与<code>setup.s</code>，而不用两个分别手动编译</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/631621eec969856642f202082e90dcae.png" class=""><ol start="4"><li>结果</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b3660aafb778e2e59f1b85d93bcfd830.png" class=""><h3 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> task2</h3><ol><li>我们需要<code>setup.s</code>源码中获取硬件信息的部分，需要解决的问题是将这些数据打印在屏幕上，利用了功能号为<code>0x0E</code>的<code>0x10</code>号中断，指导书写了一个<code>print_nl</code>来打印回车换行符，而我直接在打印的字符串中加入<code>13 10</code>实现回车换行</li></ol><pre class="line-numbers language-none"><code class="language-none">INITSEG  &#x3D; 0x9000entry _start_start:    mov ah,#0x03     ; read cursor pos    xor bh,bh    int 0x10    mov cx,#25       ; Print &quot;NOW we are in SETUP&quot;    mov bx,#0x0007    mov bp,#msg2     mov ax,cs        ; cs: 0x07e0    mov es,ax    mov ax,#0x1301    int 0x10; Get Cursor Pos    mov ax,#INITSEG    mov ds,ax    mov ah,#0x03    xor bh,bh    int 0x10    mov [0],dx  ; store in 9000:0; Get Memory Size    mov ah,#0x88    int 0x15    mov [2],ax      ; store in 9000:2; Get hd0 data    mov ax,#0x0000    mov ds,ax       ; modify ds    lds si,[4*0x41]    mov ax,#INITSEG    mov es,ax           mov di,#0x0004  ; store in 9000:4    mov cx,#0x10    rep    movsb! Be Ready to Print    mov ax,cs       ; 0x07e0    mov es,ax    mov ax,#INITSEG ; 9000    mov ds,ax; print Cursor Position    mov cx,#18    mov bx,#0x0007    mov bp,#msg_cursor    mov ax,#0x1301    int 0x10    mov dx,[0]  ; pass hex number through register dx to function print_hex    call    print_hex; print Memory Size    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#14    mov bx,#0x0007    mov bp,#msg_memory    mov ax,#0x1301    int 0x10    mov dx,[2]      call    print_hex; print KB    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#2    mov bx,#0x0007    mov bp,#msg_kb    mov ax,#0x1301    int 0x10; print Cyles    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#7    mov bx,#0x0007    mov bp,#msg_cyles    mov ax,#0x1301    int 0x10    mov dx,[4]    call    print_hex; print Heads    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#8    mov bx,#0x0007    mov bp,#msg_heads    mov ax,#0x1301    int 0x10    mov dx,[6]    call    print_hex; print Secotrs    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#10    mov bx,#0x0007    mov bp,#msg_sectors    mov ax,#0x1301    int 0x10    mov dx,[12]    call    print_hexinf_loop:    jmp inf_loopprint_hex:    mov    cx,#4print_digit:    rol    dx,#4   ; rotate left    mov    ax,#0xe0f     and    al,dl   ; fetch low 4 bits    add    al,#0x30    ; 0~9    cmp    al,#0x3a        jl     outp    add    al,#0x07    ; a~f , add more 0x07outp:    int    0x10    loop   print_digit    retmsg2:    .byte 13,10    .ascii &quot;NOW we are in SETUP&quot;    .byte 13,10,13,10msg_cursor:    .byte 13,10    .ascii &quot;Cursor position:&quot;msg_memory:    .byte 13,10    .ascii &quot;Memory Size:&quot;msg_cyles:    .byte 13,10    .ascii &quot;Cyls:&quot;msg_heads:    .byte 13,10    .ascii &quot;Heads:&quot;msg_sectors:    .byte 13,10    .ascii &quot;Sectors:&quot;msg_kb:    .ascii &quot;KB&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>结果</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/d83b172eeeb63114a561d5ea1e3942e7.png" class=""><h1 id="实验2-系统调用"><a class="markdownIt-Anchor" href="#实验2-系统调用"></a> 实验2 系统调用</h1><hr /><h2 id="1-编写接口函数iam-whoami"><a class="markdownIt-Anchor" href="#1-编写接口函数iam-whoami"></a> 1. 编写接口函数iam, whoami</h2><p>跟<code>write</code>一样，在接口函数文件内调用宏函数<code>_syscall1</code>或<code>_syscall2</code>（依参数个数而定），程序内包括后续用于测试系统调用的<code>main</code>函数。<br />iam.c</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span>   <span class="token comment">// 定义了这个宏，unistd.h中的一个条件编译块才会编译</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> iam<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">iam</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>whoami.c</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> whoami<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> username<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">whoami</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"username: %s\n"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-修改unistdh"><a class="markdownIt-Anchor" href="#2-修改unistdh"></a> 2. 修改unistd.h</h2><p>可以跳过这步，因为之后的编译过程所用到的<code>unistd.h</code>头文件并不在这个源码树下，而是在标准头文件<code>/usr/include</code>下。<br />在<code>linux-0.11/include/unistd.h</code>添加宏<code>_NR_whoami</code>、<code>_NR_iam</code>以在<code>_syscall*</code>函数中传递正确的参数给<code>0x80</code>号中断处理程序</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/825503e7b3bc733ec849543bef18bae4.png" class=""><h2 id="3-修改_sys_call_table函数表"><a class="markdownIt-Anchor" href="#3-修改_sys_call_table函数表"></a> 3. 修改_sys_call_table函数表</h2><p>在<code>linux-0.11/include/linux/sys.h</code>添加函数指针<code>sys_whoami</code>、<code>sys_iam</code>，函数在<code>sys_call_table</code>数组中的位置必须和在<code>&lt;unistd.h&gt;</code>文件中的<code>__NR_xxxxxx</code>的值对应上。在文件开头加上<code>extern</code>是让编译器在其它文件寻找这两个函数</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c5f54fc34542a48849bf640f523746c1.png" class=""><h2 id="4-实现函数sys_whoami-sys_iam"><a class="markdownIt-Anchor" href="#4-实现函数sys_whoami-sys_iam"></a> 4. 实现函数sys_whoami, sys_iam</h2><p>在<code>linux-0.11/kernel/iamwho.c</code>中编写最终的执行函数，执行这两个函数是系统调用的最后一步<br />在 Linux-0.11 内核中，<code>get_fs_byte</code> 和 <code>put_fs_byte</code> 函数用于在用户空间和内核空间之间传输数据。<br /><code>get_fs_byte</code> 函数从用户空间读取一个字节到内核空间。它接受一个指向用户空间内存地址的指针，并返回从该地址读取的字节。<br /><code>put_fs_byte</code> 函数则将一个字节从内核空间写入用户空间。它接受一个字节值和一个指向用户空间内存地址的指针。它将字节值写入指定的用户空间地址。<br />这两个函数在数据传输过程中起到了关键作用，使得内核可以与用户空间的应用程序进行安全地数据交换。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/segment.h></span>  <span class="token comment">// get_fs_byte, put_fs_byte</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;errno.h></span></span><span class="token keyword">char</span> str_pos<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sys_iam</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> c <span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        str_pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">23</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"elitezx lab2 string:  %s\n"</span><span class="token punctuation">,</span>str_pos <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_whoami</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">&lt;</span><span class="token function">strlen</span><span class="token punctuation">(</span>str_pos<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> str_pos<span class="token punctuation">[</span>ans<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">put_fs_byte</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>name<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-执行"><a class="markdownIt-Anchor" href="#5-执行"></a> 5. 执行</h2><p>关于这部分，指导书说的比较详细了，我这里再补充一些：挂载hdc目录到虚拟机操作系统上，实现hdc目录在linux-0.11与ubuntu22.04之间的文件共享，我们把用于系统调用的测试程序<code>iam.c</code>，<code>whoami.c</code>复制到hdc目录就可以在Bochs模拟器下的linux-0.11环境中编译执行这两个文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./mount-hdc <span class="token function">cp</span> iam.c whoami.c hdc/usr/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/e101da7028d27378793cef11f5352872.png" class=""><p>注意在<code>iam.c</code>,<code>whoami.c</code>程序内的头文件<code>&lt;unistd.h&gt;</code>是标准头文件，是由GCC编译器一同安装的，它们通常随着GCC一起打包并分发，通常位于<code>/usr/include</code>目录下，而不是在之前修过的源码树下的<code>include/unistd.h</code>, 因此我们要转入<code>hdc/usr/include</code>下修改<code>&lt;unistd.h&gt;</code>，加入两个宏<code>__NR_iam</code>,<code>__NR_whoami</code><br />编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> iam iam.cgcc <span class="token parameter variable">-o</span> <span class="token function">whoami</span> whoami.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-验证结果"><a class="markdownIt-Anchor" href="#6-验证结果"></a> 6. 验证结果</h2><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/821c28d5b04262d88ad0e48d4ad95bdf.png" class=""><h1 id="实验3-进程运行轨迹的跟踪与统计"><a class="markdownIt-Anchor" href="#实验3-进程运行轨迹的跟踪与统计"></a> 实验3 进程运行轨迹的跟踪与统计</h1><hr /><h2 id="1-前提"><a class="markdownIt-Anchor" href="#1-前提"></a> 1. 前提</h2><h3 id="11-系统调用times"><a class="markdownIt-Anchor" href="#11-系统调用times"></a> 1.1. 系统调用times</h3><p><code>times</code>系统调用接受一个<code>struct tms*</code>类型的参数，该结构体用于保存进程和其子进程的 CPU 时间信息，同时 times 系统调用会返回一个滴答数，即时钟周期数，该滴答数表示自OS启动以来经过的时钟周期数。<br /><code>struct tms</code>类型在<code>include/sys/times.h</code>中定义如下：</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/825503e7b3bc733ec849543bef18bae4.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c48cf07a034075a0d27348bf6dbac5e4.png" class=""><p><code>tms_stime</code>和<code>tms_utime</code>分别记录了进程在内核态和用户态下消耗的CPU时间总和，它们的和就是进程从开始执行到调用times系统调用所经过的时间。<code>tms_stime</code>和<code>tms_utime</code>并不包括进程在睡眠状态或等待I/O操作中所消耗的时间，因此它们的和也不等于进程的实际运行时间。<br />注意这里时间的单位是CPU的滴答时间（tick），一个滴答数表示两个时钟中断的间隔。在Linux系统中，时钟中断通常由硬件定时器产生，定时器会以固定的频率向CPU发送中断信号。**每当时钟中断发生时，内核会将当前进程的时间片计数器减 1，内核会检查当前进程的时间片（counter）是否已经用完，如果用完了，就将当前进程放到就绪队列中，然后调用调度函数 schedule 选择一个新的进程运行。**这个频率通常是100Hz，即一秒发生100次，也就是说时间中断的间隔为10ms（1/100s），每隔10ms就发生一次时钟中断，linux内核中的<code>jiffies</code>变量就记录了时间中断的个数，即滴答数。那么可以看出这里的时间单位既然是滴答数，而滴答数10ms产生一个，那么实际时间应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">ticks/100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> (秒)，100是常量<code>HZ</code>的值<br />由此，如果想获取一个进程从开始到结束的CPU使用时间，即用户态下CPU时间和内核态下CPU时间之和，可用如下函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/times.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">tms</span> t<span class="token punctuation">;</span>    clock_t clock_time<span class="token punctuation">;</span>    <span class="token comment">// 获取进程的CPU时间统计信息</span>    clock_time <span class="token operator">=</span> <span class="token function">times</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算进程的总的CPU时间</span>    <span class="token keyword">double</span> cpu_time <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>tms_utime <span class="token operator">+</span> t<span class="token punctuation">.</span>tms_stime<span class="token punctuation">)</span> <span class="token operator">/</span> HZ<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Total CPU time: %.2f seconds\n"</span><span class="token punctuation">,</span> cpu_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用到的<code>clock_t</code>在<code>include/time.h</code>中定义如下</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c48cf07a034075a0d27348bf6dbac5e4.png" class=""><h3 id="12-系统调用wait"><a class="markdownIt-Anchor" href="#12-系统调用wait"></a> 1.2. 系统调用wait</h3><p><code>wait</code> 函数是一个系统调用（位于<code>include/sys/wait.h</code>）。在Unix/Linux操作系统中，<code>wait</code>函数可以等待子进程结束，并获取子进程的退出状态。在使用<code>wait</code>函数时，如果子进程已经结束，<code>wait</code>函数会立即返回并返回子进程的退出状态；如果子进程还没有结束，<code>wait</code>函数会阻塞父进程，直到子进程结束并返回其退出状态。具体来说，<code>wait</code> 函数的作用如下：<br />1 如果当前进程没有子进程，<code>wait</code> 函数会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>ECHILD</code>，表示当前进程没有子进程需要等待。<br />2 如果当前进程有一个或多个子进程正在运行，调用 <code>wait</code> 函数会阻塞当前进程，直到其中一个子进程结束。当子进程结束时，<code>wait </code>函数会返回该子进程的进程 ID，并将该子进程的退出状态保存到一个整型变量<code>status</code>中。<br />3 如果当前进程有多个子进程正在运行，调用<code>wait</code>函数会等待其中任意一个子进程结束，并且无法指定要等待哪个子进程。如果需要等待特定的子进程，可以使用 <code>waitpid</code>函数代替<code>wait</code>函数。<br />需要注意的是，如果当前进程没有调用wait函数等待其子进程结束，那么当子进程结束时，其退出状态可能会一直保存在内核中，直到当前进程调用<code>wait</code>或<code>waitpid</code>函数获取该状态。如果当前进程没有获取子进程的退出状态，那么该子进程就会成为僵尸进程（Zombie Process），占用系统资源并且无法被正常清理。<br />因此，在编写多进程程序时，通常需要在父进程中调用<code>wait</code>或<code>waitpid</code>函数等待子进程结束，并获取其退出状态，以避免产生僵尸进程。</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/02fe9737164d08468c47ff985f1d6276.png" class=""><p>对linux0.11 wait函数必须接受一个<code>int</code>参数以保存子进程退出状态，如果你不想保存该信息，可传递<code>NULL</code>。而在现代linux中，该参数为可选参数。</p><h3 id="13-linux011中进程的state值"><a class="markdownIt-Anchor" href="#13-linux011中进程的state值"></a> 1.3. linux0.11中进程的state值</h3><p>在Linux 0.11中，进程状态可以被表示为以下几个值：</p><ol><li><code>TASK_RUNNING</code>：进程正在执行，也就是说CPU正在执行它的指令。但是，如果一个进程的状态为<code>TASK_RUNNING</code>，而它又没有占用CPU时间片运行，那么它就是处于就绪态。</li><li><code>TASK_INTERRUPTIBLE</code>：进程正在等待某个事件的发生（例如，等待用户输入、等待网络数据等），它已经睡眠，并且可以响应一个信号以退出等待状态。</li><li><code>TASK_UNINTERRUPTIBLE</code>：和<code>TASK_INTERRUPTIBLE</code>一样，进程也是正在等待某个事件的发生，但是进程在等待期间不会响应信号，直到事件发生后才会退出等待状态，比如I/O操作。</li><li><code>TASK_STOPPED</code>：进程已经被停止，通常是收到了一个SIGSTOP信号。</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/3d998177822f40110dc0de83e59313be.png" class=""><h2 id="2-processc"><a class="markdownIt-Anchor" href="#2-processc"></a> 2. process.c</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/times.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">void</span> <span class="token function">cpuio_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span> last<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu_time<span class="token punctuation">,</span> <span class="token keyword">int</span> io_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pid_t son_proc_pid<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>son_proc_pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cpuio_bound</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child_process_pid: %d\n"</span><span class="token punctuation">,</span> son_proc_pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">cpuio_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span> last<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu_time<span class="token punctuation">,</span> <span class="token keyword">int</span> io_time<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">tms</span> start<span class="token punctuation">,</span> pre<span class="token punctuation">;</span>clock_t sum_cpu_time <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>clock_t accumulate <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">times</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>sum_cpu_time <span class="token operator">&lt;</span> cpu_time<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">times</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>sum_cpu_time <span class="token operator">=</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>tms_utime <span class="token operator">-</span> start<span class="token punctuation">.</span>tms_utime <span class="token operator">+</span> pre<span class="token punctuation">.</span>tms_stime <span class="token operator">-</span> pre<span class="token punctuation">.</span>tms_stime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sum_cpu_time<span class="token operator">>=</span>last<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token function">sleep</span><span class="token punctuation">(</span>io_time<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>accumulate<span class="token operator">+=</span> io_time <span class="token operator">+</span> cpu_time<span class="token punctuation">)</span><span class="token operator">>=</span>last<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/4ca217256a1b821d07cb20ec055b3152.png" class=""><h2 id="3-生成log的前置工作"><a class="markdownIt-Anchor" href="#3-生成log的前置工作"></a> 3. 生成log的前置工作</h2><ol><li>修改<code>linux-0.11/init/main.c</code>，将文件描述符<code>3</code>与<code>process.log</code>关联。文件描述符是一个非负整数，它是操作系统内部用来标识一个特定文件的引用。</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/6d2047abf1eabe1da394c52980b55800.png" class=""><ol start="2"><li>在内核中添加<code>fprintk</code>函数用于在程序中调用以写入log文件</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">static</span> <span class="token keyword">char</span> logbuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> file<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> inode<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token operator">=</span><span class="token function">vsprintf</span><span class="token punctuation">(</span>logbuf<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment">/* 如果输出到stdout或stderr，直接调用sys_write即可 */</span>    <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"push %%fs\n\t"</span>            <span class="token string">"push %%ds\n\t"</span>            <span class="token string">"pop %%fs\n\t"</span>            <span class="token string">"pushl %0\n\t"</span>            <span class="token string">"pushl $logbuf\n\t"</span> <span class="token comment">/* 注意对于Windows环境来说，是_logbuf,下同 */</span>            <span class="token string">"pushl %1\n\t"</span>            <span class="token string">"call sys_write\n\t"</span> <span class="token comment">/* 注意对于Windows环境来说，是_sys_write,下同 */</span>            <span class="token string">"addl $8,%%esp\n\t"</span>            <span class="token string">"popl %0\n\t"</span>            <span class="token string">"pop %%fs"</span>            <span class="token double-colon punctuation">::</span><span class="token string">"r"</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span> <span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"ax"</span><span class="token punctuation">,</span><span class="token string">"cx"</span><span class="token punctuation">,</span><span class="token string">"dx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token comment">/* 假定>=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>file<span class="token operator">=</span>task<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>filp<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">/* 从进程0的文件描述符表中得到文件句柄 */</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        inode<span class="token operator">=</span>file<span class="token operator">-></span>f_inode<span class="token punctuation">;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"push %%fs\n\t"</span>            <span class="token string">"push %%ds\n\t"</span>            <span class="token string">"pop %%fs\n\t"</span>            <span class="token string">"pushl %0\n\t"</span>            <span class="token string">"pushl $logbuf\n\t"</span>            <span class="token string">"pushl %1\n\t"</span>            <span class="token string">"pushl %2\n\t"</span>            <span class="token string">"call file_write\n\t"</span>            <span class="token string">"addl $12,%%esp\n\t"</span>            <span class="token string">"popl %0\n\t"</span>            <span class="token string">"pop %%fs"</span>            <span class="token double-colon punctuation">::</span><span class="token string">"r"</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span> <span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span> <span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"ax"</span><span class="token punctuation">,</span><span class="token string">"cx"</span><span class="token punctuation">,</span><span class="token string">"dx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>修改fork.c</li></ol><p>进程在创建后就立马被设置为就绪态<code>TASK_RUNNING</code></p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/79ff16fbb9eb2d35d267aa2017761a11.png" class=""><ol start="4"><li>修改sched.c</li></ol><p>在进程的状态切换点打印进程的状态信息</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* *  linux/kernel/sched.c * *  (C) 1991  Linus Torvalds */</span><span class="token comment">/* * 'sched.c' is the main kernel file. It contains scheduling primitives * (sleep_on, wakeup, schedule etc) as well as a number of simple system * call functions (type getpid(), which just extracts a field from * current-task */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sys.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fdreg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/system.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/io.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/segment.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_S</span><span class="token expression"><span class="token punctuation">(</span>nr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_BLOCKABLE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token function">_S</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">_S</span><span class="token punctuation">(</span>SIGSTOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">void</span> <span class="token function">show_task</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">4096</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%d: pid=%d, state=%d, "</span><span class="token punctuation">,</span>nr<span class="token punctuation">,</span>p<span class="token operator">-></span>pid<span class="token punctuation">,</span>p<span class="token operator">-></span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%d (of %d) chars free in kernel stack\n\r"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">show_stat</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>NR_TASKS<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">show_task</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LATCH</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1193180</span><span class="token operator">/</span>HZ<span class="token punctuation">)</span></span></span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">mem_use</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">timer_interrupt</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">system_call</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">union</span> task_union <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> task<span class="token punctuation">;</span>    <span class="token keyword">char</span> stack<span class="token punctuation">[</span>PAGE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">union</span> task_union init_task <span class="token operator">=</span> <span class="token punctuation">&#123;</span>INIT_TASK<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">volatile</span> jiffies<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">long</span> startup_time<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>current <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>last_task_used_math <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">long</span> user_stack <span class="token punctuation">[</span> PAGE_SIZE<span class="token operator">>></span><span class="token number">2</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token operator">*</span> a<span class="token punctuation">;</span>    <span class="token keyword">short</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> stack_start <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token operator">&amp;</span> user_stack <span class="token punctuation">[</span>PAGE_SIZE<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token number">0x10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* *  'math_state_restore()' saves the current math information in the * old math state array, and gets the new ones from the current task */</span><span class="token keyword">void</span> <span class="token function">math_state_restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math <span class="token operator">==</span> current<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"fwait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"fnsave %0"</span><span class="token operator">::</span><span class="token string">"m"</span> <span class="token punctuation">(</span>last_task_used_math<span class="token operator">-></span>tss<span class="token punctuation">.</span>i387<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    last_task_used_math<span class="token operator">=</span>current<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>used_math<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"frstor %0"</span><span class="token operator">::</span><span class="token string">"m"</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>tss<span class="token punctuation">.</span>i387<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"fninit"</span><span class="token operator">::</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current<span class="token operator">-></span>used_math<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* *  'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. */</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>next<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&lt;</span> jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGALRM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>_BLOCKABLE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>blocked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">==</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">=</span>TASK_RUNNING<span class="token punctuation">;</span>                <span class="token comment">/*可中断睡眠 => 就绪*/</span>                <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">/* this is the scheduler proper: */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> NR_TASKS<span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token operator">--</span>p<span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">></span> c<span class="token punctuation">)</span>                c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">,</span> next <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>priority<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*编号为next的进程 运行*/</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>pid <span class="token operator">!=</span> task<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">-></span>pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/*时间片到时程序 => 就绪*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING<span class="token punctuation">)</span>            <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tR\t%d\n"</span><span class="token punctuation">,</span>task<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">switch_to</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token comment">/**当前进程  运行 => 可中断睡眠*/</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tW\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> current<span class="token punctuation">;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token comment">/**当前进程进程 => 不可中断睡眠*/</span>    <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tW\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp<span class="token operator">-></span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**原等待队列 第一个进程 => 唤醒（就绪）*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span>tmp<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">interruptible_sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span>current<span class="token punctuation">;</span>    repeat<span class="token operator">:</span>current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token comment">/**这一部分属于 唤醒队列中间进程，通过goto实现唤醒 队列头进程 过程中Wait*/</span>    <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tW\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**当前进程进程 => 可中断睡眠 同上*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp<span class="token operator">-></span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**原等待队列 第一个进程 => 唤醒（就绪）*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span>tmp<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**唤醒 最后进入等待序列的 进程*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * OK, here are some floppy things that shouldn't be in the kernel * proper. They are here because the floppy needs a timer, and this * was the easiest way of doing it. */</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> wait_motor<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span>  mon_timer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> moff_timer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> current_DOR <span class="token operator">=</span> <span class="token number">0x0C</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">ticks_to_floppy_on</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">extern</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> selected<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> mask <span class="token operator">=</span> <span class="token number">0x10</span> <span class="token operator">&lt;&lt;</span> nr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nr<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"floppy_on: nr>3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    moff_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span><span class="token comment">/* 100 s = very big :-) */</span>    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* use floppy_off to turn it off */</span>    mask <span class="token operator">|=</span> current_DOR<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>selected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mask <span class="token operator">&amp;=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span>        mask <span class="token operator">|=</span> nr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">!=</span> current_DOR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">outb</span><span class="token punctuation">(</span>mask<span class="token punctuation">,</span>FD_DOR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">^</span> current_DOR<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf0</span><span class="token punctuation">)</span>            mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">=</span> HZ<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>            mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        current_DOR <span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">floppy_on</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">ticks_to_floppy_on</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">sleep_on</span><span class="token punctuation">(</span>nr<span class="token operator">+</span>wait_motor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">floppy_off</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    moff_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token operator">*</span>HZ<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">do_floppy_timer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> mask <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span>mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> current_DOR<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mon_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>mon_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token function">wake_up</span><span class="token punctuation">(</span>i<span class="token operator">+</span>wait_motor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>moff_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            current_DOR <span class="token operator">&amp;=</span> <span class="token operator">~</span>mask<span class="token punctuation">;</span>            <span class="token function">outb</span><span class="token punctuation">(</span>current_DOR<span class="token punctuation">,</span>FD_DOR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>            moff_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIME_REQUESTS</span> <span class="token expression"><span class="token number">64</span></span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> jiffies<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> timer_list<span class="token punctuation">[</span>TIME_REQUESTS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span> next_timer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token keyword">long</span> jiffies<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jiffies <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> timer_list <span class="token punctuation">;</span> p <span class="token operator">&lt;</span> timer_list <span class="token operator">+</span> TIME_REQUESTS <span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>fn<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> timer_list <span class="token operator">+</span> TIME_REQUESTS<span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"No more time requests free"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>        p<span class="token operator">-></span>jiffies <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> next_timer<span class="token punctuation">;</span>        next_timer <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies <span class="token operator">&lt;</span> p<span class="token operator">-></span>jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p<span class="token operator">-></span>jiffies <span class="token operator">-=</span> p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies<span class="token punctuation">;</span>            fn <span class="token operator">=</span> p<span class="token operator">-></span>fn<span class="token punctuation">;</span>            p<span class="token operator">-></span>fn <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token operator">-></span>fn<span class="token punctuation">;</span>            p<span class="token operator">-></span>next<span class="token operator">-></span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>            jiffies <span class="token operator">=</span> p<span class="token operator">-></span>jiffies<span class="token punctuation">;</span>            p<span class="token operator">-></span>jiffies <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies<span class="token punctuation">;</span>            p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">do_timer</span><span class="token punctuation">(</span><span class="token keyword">long</span> cpl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> beepcount<span class="token punctuation">;</span>    <span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">sysbeepstop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beepcount<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>beepcount<span class="token punctuation">)</span>            <span class="token function">sysbeepstop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cpl<span class="token punctuation">)</span>        current<span class="token operator">-></span>utime<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        current<span class="token operator">-></span>stime<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next_timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        next_timer<span class="token operator">-></span>jiffies<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>next_timer <span class="token operator">&amp;&amp;</span> next_timer<span class="token operator">-></span>jiffies <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fn <span class="token operator">=</span> next_timer<span class="token operator">-></span>fn<span class="token punctuation">;</span>            next_timer<span class="token operator">-></span>fn <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            next_timer <span class="token operator">=</span> next_timer<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current_DOR <span class="token operator">&amp;</span> <span class="token number">0xf0</span><span class="token punctuation">)</span>        <span class="token function">do_floppy_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">--</span>current<span class="token operator">-></span>counter<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>counter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cpl<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_alarm</span><span class="token punctuation">(</span><span class="token keyword">long</span> seconds<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> old <span class="token operator">=</span> current<span class="token operator">-></span>alarm<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span>        old <span class="token operator">=</span> <span class="token punctuation">(</span>old <span class="token operator">-</span> jiffies<span class="token punctuation">)</span> <span class="token operator">/</span> HZ<span class="token punctuation">;</span>    current<span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token punctuation">(</span>seconds<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>jiffies<span class="token operator">+</span>HZ<span class="token operator">*</span>seconds<span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>pid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>father<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>uid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_geteuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>euid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getgid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>gid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getegid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>egid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_nice</span><span class="token punctuation">(</span><span class="token keyword">long</span> increment<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>priority<span class="token operator">-</span>increment<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        current<span class="token operator">-></span>priority <span class="token operator">-=</span> increment<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sched_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">desc_struct</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">16</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Struct sigaction MUST be 16 bytes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_tss_desc</span><span class="token punctuation">(</span>gdt<span class="token operator">+</span>FIRST_TSS_ENTRY<span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">.</span>tss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_ldt_desc</span><span class="token punctuation">(</span>gdt<span class="token operator">+</span>FIRST_LDT_ENTRY<span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">.</span>ldt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> gdt<span class="token operator">+</span><span class="token number">2</span><span class="token operator">+</span>FIRST_TSS_ENTRY<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>NR_TASKS<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        task<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>a<span class="token operator">=</span>p<span class="token operator">-></span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>a<span class="token operator">=</span>p<span class="token operator">-></span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Clear NT, so that we won't have troubles with that later on */</span>    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"pushfl ; andl $0xffffbfff,(%esp) ; popfl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ltr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lldt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb_p</span><span class="token punctuation">(</span><span class="token number">0x36</span><span class="token punctuation">,</span><span class="token number">0x43</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* binary, mode 3, LSB/MSB, ch 0 */</span>    <span class="token function">outb_p</span><span class="token punctuation">(</span>LATCH <span class="token operator">&amp;</span> <span class="token number">0xff</span> <span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* LSB */</span>    <span class="token function">outb</span><span class="token punctuation">(</span>LATCH <span class="token operator">>></span> <span class="token number">8</span> <span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* MSB */</span>    <span class="token function">set_intr_gate</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>timer_interrupt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">inb_p</span><span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">~</span><span class="token number">0x01</span><span class="token punctuation">,</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_system_gate</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>system_call<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sys_pause在Linux0.11中，<code>sys_pause()</code>系统调用的主要作用是让进程暂停执行，直到接收到一个信号。当进程调用<code>sys_pause()</code>系统调用时，它会将自己的状态设置为<code>TASK_INTERRUPTIBLE</code>，并且将其添加到等待信号队列中。然后，进程会进入睡眠状态，直到收到一个信号或者被其他进程显式地唤醒。<br />这个系统调用通常用于实现等待信号的操作，比如等待一个定时器信号或者等待一个IO操作完成的信号。在这种情况下，进程可以使用<code>sys_pause()</code>系统调用进入睡眠状态，而不必浪费CPU资源等待信号的到来。当信号到来时，内核会唤醒进程，并且将信号传递给进程的信号处理程序进行处理。<br />需要注意的是，在Linux 2.6以后的版本中，<code>sys_pause()</code>系统调用已经被废弃，被<code>sys_rt_sigsuspend()</code>系统调用所取代。<code>sys_rt_sigsuspend()</code>系统调用可以实现类似的等待信号的操作，并且提供更多的控制选项。</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/882778374b4a4e4e71d923210ac02fab.png" class=""><ol start="5"><li>修改exit.c</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_exit</span><span class="token punctuation">(</span><span class="token keyword">long</span> code<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">free_page_tables</span><span class="token punctuation">(</span><span class="token function">get_base</span><span class="token punctuation">(</span>current<span class="token operator">-></span>ldt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">get_limit</span><span class="token punctuation">(</span><span class="token number">0x0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free_page_tables</span><span class="token punctuation">(</span><span class="token function">get_base</span><span class="token punctuation">(</span>current<span class="token operator">-></span>ldt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">get_limit</span><span class="token punctuation">(</span><span class="token number">0x17</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_TASKS <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>father <span class="token operator">==</span> current<span class="token operator">-></span>pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>father <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_ZOMBIE<span class="token punctuation">)</span>                <span class="token comment">/* assumption task[1] is always init */</span>                <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">send_sig</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> task<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_OPEN <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>filp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">sys_close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iput</span><span class="token punctuation">(</span>current<span class="token operator">-></span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>pwd<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">iput</span><span class="token punctuation">(</span>current<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>root<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">iput</span><span class="token punctuation">(</span>current<span class="token operator">-></span>executable<span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>executable<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>leader <span class="token operator">&amp;&amp;</span> current<span class="token operator">-></span>tty <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        tty_table<span class="token punctuation">[</span>current<span class="token operator">-></span>tty<span class="token punctuation">]</span><span class="token punctuation">.</span>pgrp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math <span class="token operator">==</span> current<span class="token punctuation">)</span>        last_task_used_math <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>leader<span class="token punctuation">)</span>        <span class="token function">kill_session</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_ZOMBIE<span class="token punctuation">;</span>    current<span class="token operator">-></span>exit_code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%ld\tE\t%ld\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tell_father</span><span class="token punctuation">(</span>current<span class="token operator">-></span>father<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* just to suppress warnings */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>旁注：do_exit函数与sys_waitpid函数</strong></p><blockquote><p>在 Linux 0.11 中，<code>do_exit()</code> 函数负责终止一个进程。当一个进程调用 <code>do_exit()</code> 时，它会执行多个清理操作，包括释放进程持有的任何资源，如打开的文件和内存，并向父进程通知进程的退出状态。如果进程有任何子进程，则 <code>do_exit()</code> 也通过递归调用 <code>do_exit()</code> 终止它们。<br /><code>sys_waitpid() </code>函数用于等待子进程终止并检索其退出状态。当进程调用 <code>sys_waitpid()</code> 时，它会阻塞，直到其中一个子进程终止。如果子进程已经终止，<code>sys_waitpid() </code>将立即返回该子进程的退出状态。否则，它将继续阻塞，直到子进程终止。<br />除了等待特定的子进程外，<code>sys_waitpid() </code>还可以用于等待任何子进程终止，方法是通过传递<code> -1</code> 的 <code>pid</code> 参数。当一个进程有多个子进程并且想要等待第一个终止时，这很有用。</p></blockquote><h2 id="4-生成log"><a class="markdownIt-Anchor" href="#4-生成log"></a> 4. 生成log</h2><p>先共享文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mount-hdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>移动多进程程序<code>process.c</code>到linux-0.11目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> process.c hdc/usr/root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/02fe9737164d08468c47ff985f1d6276.png" class=""><p>编译运行, 最后执行一个<code>sync</code>命令，确保将文件系统中的所有缓存数据写入磁盘</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/79ff16fbb9eb2d35d267aa2017761a11.png" class=""><p><strong>旁注: sync命令</strong></p><blockquote><p>sync 命令是用于将文件系统中的所有缓存数据写入磁盘的命令。在 Linux 中，当一个进程修改了一个文件时，这个修改不会立即写入磁盘，而是会先被写入内存中的缓存，以提高文件系统的性能。然而，如果系统崩溃或出现其他问题，这些修改可能会丢失。因此，为了保证数据的完整性，我们需要将缓存数据定期地写入磁盘中。<br />sync 命令会将所有的缓存数据写入磁盘中，并将所有被修改的元数据（如 i-node、目录结构等）更新到磁盘中。这样可以保证所有的修改都被写入到磁盘中，从而避免了数据的丢失。通常在关机前执行 sync 命令，以确保所有数据都已被保存到磁盘中。<br />需要注意的是，执行 sync 命令并不能保证磁盘数据的完全一致性。在磁盘数据的写入过程中，如果发生了异常情况，可能会导致数据的损坏或丢失。因此，在执行 sync 命令后，建议再执行一次磁盘检查命令（如 fsck 命令）来确保文件系统的完整性。</p></blockquote><p>将生成的<code>process.log</code>移动到虚拟机下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mount-hdc<span class="token function">cp</span> hdc/var/process.log process.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看process.log，进程0在log关联文件描述符之前就已经在运行，因此未出现在log文件中<br /><img src="attachment/3e830a5c6e61ab255ee992dc5bac5593.png" alt="" /><img src="attachment/8e0524ec54ddb87b0a5e113d5fa1d7fa.png" alt="" /></p><h2 id="5-分析log"><a class="markdownIt-Anchor" href="#5-分析log"></a> 5. 分析log</h2><p>用指导书给的py脚本程序<code>stat_log.py</code>分析log文件，在分析之前将py脚本文件的第一行<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2</code>（已安装python2）以适配版本，否则在python3环境下<code>print</code>函数会出错<br />为该脚本文件分配可执行权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x stat_log.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行脚本，分析进程9、10、11、12的运行情况（多个指标：平均周转时间，平均等待时间）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./stat_log.py process.log <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token parameter variable">-g</span> <span class="token operator">|</span> <span class="token function">less</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/649840cfe743be95432ea8e447458260.png" class=""><h2 id="6-修改时间片重新分析log"><a class="markdownIt-Anchor" href="#6-修改时间片重新分析log"></a> 6. 修改时间片，重新分析log</h2><p>进程的时间片是进程的<code>counter</code>值，而counter在schedule函数中根据<code>priority</code>动态设置，因此进程的时间片受<code>counter</code>和<code>prioriy</code>两个变量的影响。进程的<code>priority</code>继承自父进程，进而所有进程的<code>priority</code>都来自于进程0 。<br />linux0.11中，<code>priority</code>和<code>counter</code>在<code>include/linux/sched.h</code>中定义</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/272c3457121ac25449d18a44519a3a56.png" class=""><p>我们修改这个值，然后重新执行process程序，分析log。</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/edf7c77ecdd9d23b77031b2b97969a17.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/edf7c77ecdd9d23b77031b2b97969a17.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/308e7fc00291185da771123b16b349b8.png" class=""><p>可以看到这里的时间平均周转时间变多了，有以下两种可能：</p><ol><li>当进程的执行时间很长时，增加时间片大小可能会导致进程在等待时间片结束时的等待时间变长，因为进程需要等待更长的时间才能获得 CPU</li><li>当进程的数量非常多时，增加时间片大小可能会导致进程在就绪队列中等待的时间变长，因为每个进程需要等待更长的时间才能获得 CPU。</li></ol><p>因此，时间片大小的设置需要根据具体情况进行调整，不能简单地认为增加时间片大小一定会减少平均周转时间。需要根据系统中进程的数量、执行时间等因素来选择合适的时间片大小，从而达到更好的系统性能。</p><h1 id="实验4-基于内核栈切换的进程切换"><a class="markdownIt-Anchor" href="#实验4-基于内核栈切换的进程切换"></a> 实验4 基于内核栈切换的进程切换</h1><hr /><p>我这个实验做的不是很好，建议本实验参考其他的博客</p><h2 id="1-修改schedule函数"><a class="markdownIt-Anchor" href="#1-修改schedule函数"></a> 1.  修改schedule函数</h2><p>在TSS切换中，依赖TR寄存器找到下一个进程的tss，从而实现切换，因此在switch_to中没有next的PCB。要在<code>switch_to</code>函数中，将TSS的切换改为内核栈的切换，首先要在<code>schedule</code>函数中给<code>switch_to</code>函数传入next的PCB。因为这里没有TSS的切换，需要再单独做LDT表的切换。<br />在函数声明中，参数列表是从左到右依次列出的，而在函数栈帧中，参数是从右到左依次压入的。因此调用<code>switch_to</code>函数后，当前进程的内核中依次压入了LDT(next)，pnext和返回地址<br />因为这里涉及函数调用和栈，所以补充一下<code>%esp</code>和<code>%ebp</code>的知识：</p><blockquote><p>ESP寄存器用于指向当前栈帧的顶部，即栈中当前可用的最高地址。而EBP寄存器则通常用于指向当前函数的栈帧，也称为帧指针。EBP寄存器存储的是当前栈帧的起始位置，也就是栈中当前函数的参数和局部变量存储的位置。在函数执行期间，ESP寄存器的值会随着栈中数据的压入和弹出而不断变化，以保持其始终指向当前栈帧的顶部。而EBP寄存器的值通常不会被修改，以保持其一直指向当前函数的栈帧。这样可以确保函数能够正确地访问和修改栈帧中的参数、局部变量和返回地址等信息，而不会干扰其他函数的栈帧。<br />在函数调用过程中，处理器会将该函数的参数值和返回地址等信息压入当前函数的栈帧中，并将ESP寄存器的值减少相应的字节数。如果在函数执行期间没有再将其他数据压入栈中，那么ESP寄存器的值将等于EBP寄存器的值，即它们都指向栈帧的底部。需要注意的是，函数栈帧的大小通常是在编译时确定的，因此在函数调用前，编译器就已经为该函数分配了足够的栈空间。如果在函数执行期间需要动态分配更多的栈空间，那么ESP和EBP寄存器的值就会发生变化，以指向新分配的栈空间的位置<br />因此，ESP指向栈帧的顶部，EBP指向栈帧的起始位置，两者配合使用，能够在函数执行期间正确地访问和修改栈帧中的数据。</p></blockquote><p><strong>旁注：LDT表实现进程间的地址隔离</strong></p><blockquote><p>在x86架构中，进程与LDT（Local Descriptor Table）有密切的关系，LDT可以用来隔离和保护不同进程的地址空间。<br />LDT是一种描述符表，用于存储局部数据段和局部代码段的信息。与全局描述符表（GDT）不同，LDT表是针对每个进程单独维护的，每个进程都可以有自己的LDT表。LDT表的主要作用是实现地址空间的隔离，以保护、不同进程的内存空间不被其他进程访问或修改。<br />在x86架构中，进程的地址空间通常被划分为多个段，每个段都有自己的基地址和大小。通过使用LDT表中的描述符，可以将进程的地址空间划分为多个不同的段，并且每个进程都有自己独立的LDT表，这样可以实现不同进程的地址空间之间的隔离和保护。<strong>进程中的所有数据段和代码段都必须使用LDT中的描述符进行描述，以便在进程运行时能够正确地访问和修改这些段中的数据</strong>。<br />在Linux 0.11内核中，进程的LDT表存储在进程控制块（PCB）中，每个进程都有自己独立的LDT表。当进程被调度执行时，LDT表的选择子被存储在进程的TSS（Task State Segment）中，用于访问进程的LDT表。通过使用LDT表，可以实现不同进程之间的地址空间隔离和保护，提高系统的安全性和稳定性。<br />总之，LDT表是实现进程地址空间隔离和保护的重要手段，可以帮助操作系统实现不同进程之间的资源隔离和保护。在x86架构下，LDT表和进程的地址空间划分密切相关，每个进程都有自己独立的LDT表和地址空间划分。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>next<span class="token punctuation">,</span>c<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pnext <span class="token operator">=</span> <span class="token operator">&amp;</span>init_task<span class="token punctuation">.</span>task <span class="token punctuation">;</span>  <span class="token comment">//指向下一个进程的PCB的PCB指针,初始化指向进程0</span><span class="token comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&lt;</span> jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGALRM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>_BLOCKABLE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>blocked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">==</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">=</span>TASK_RUNNING<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* this is the scheduler proper: */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">=</span> NR_TASKS<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">></span> c<span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">,</span> next <span class="token operator">=</span> i<span class="token punctuation">,</span> pnext <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>priority<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">switch_to</span><span class="token punctuation">(</span>pnext<span class="token punctuation">,</span> <span class="token function">_LDT</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  传递下一个进程的PCB (切换执行序列)和LDT (切换内存空间)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-修改switch_to函数"><a class="markdownIt-Anchor" href="#2-修改switch_to函数"></a> 2. 修改switch_to函数</h2><p><code>switch_to</code>函数是一个宏函数，位于<code>include/linux/sched.h</code>中，我们先注释掉这个原版<code>switch_to</code>，在<code>kernel/system_call.s</code>中编写新的<code>switch_to</code>函数。</p><pre class="line-numbers language-none"><code class="language-none">ESP0&#x3D; 0x04KERNEL_STACK    &#x3D; 0x0C # kernel_stack变量在task_struct中的偏移量switch_to:        pushl %ebp     # 压入C函数schedule的栈帧        movl %esp,%ebp # 将当前进程的栈顶指针esp拷贝给%ebp，使它指向刚刚压入的esp值        pushl %ecx     # 这几个寄存器可能是调用函数schedule中用到的寄存器，因此先保存        pushl %ebx        pushl %eax        movl 8(%ebp),%ebx   #取出传入的pnext参数，即下一个进程的PCB指针        cmpl %ebx,current           je 1f               # next是否是当前进程，如果是，则向前(Forward)跳转到标号1开始执行，不执行转换# PCB        movl %ebx,%eax        xchgl %eax,current  # exchange value, 切换进程PCB, 此时%eax指向当前进程，current指向下一个进程# TSS 使用户栈能找到内核栈，借用进程0的tss保存内核栈的esp0信息        movl tss, %ecx  # 在kernel&#x2F;sched.c中定义tss &#x3D; &amp; init_task.task.tss        addl $4096, %ebx   # 让ebx指向页表最高地址处，这里也是内核栈的基址        movl %ebx, ESP0(%ecx) # 修改tss中的esp0(偏移量为4)，使它指向内核栈的栈顶位置，此时就是栈基址# switch kernel_stack   切换的关键        movl %esp, KERNEL_STACK(%eax) # 取出CPU.esp 保存到当前进程的PCB中，task_struct中需要添加kernel_stack变量，并修改INIT_TASK        movl 8(%ebp),%ebx # 重新取出下一个进程的PCB        movl KERNEL_STACK(%ebx), %esp # 将下一个进程的PCB中的内核栈的栈顶信息esp放入CPU中# switch LDT        movl 12(%ebp), %ecx  # 取出传入的 LDT(next)参数        lldt %cx  # lldt指令用于将LDT的段选择子加载到LDTR寄存器中，LDTR寄存器是一个16位的寄存器，存储LDT的段选择子，硬件根据LDTR在GDT中查找以获取LDT的地址        movl $0x17,%ecx  # 重置 fs寄存器        mov %cx,%fs        cmpl %eax,last_task_used_math        jne 1f        clts1:          popl %eax  # 返回C函数schedule，恢复寄存器(特别是帧指针%ebp)        popl %ebx        popl %ecx        popl %ebp        ret.align 2first_return_from_kernel:  # 一段包含iret的代码，用于返回用户栈        popl %edx        popl %edi        popl %esi        pop %gs        pop %fs        pop %es        pop %ds        iret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/272c3457121ac25449d18a44519a3a56.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/2486dfe436507ac24b973c6b4c513e77.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><h2 id="3-修改copy_process函数"><a class="markdownIt-Anchor" href="#3-修改copy_process函数"></a> 3.  修改copy_process函数</h2><p>在fork.c的copy_process部分添加以下代码用于设置进程的内核栈， 并注释掉设置tss的部分</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*set up kernel stack *&#x2F;long * krnstack &#x3D;(long)(PAGE_SIZE + (long)p);*(--krnstack) &#x3D; ss &amp; 0xffff;  # 压入SS:SP*(--krnstack) &#x3D; esp;*(--krnstack) &#x3D; eflags;*(--krnstack) &#x3D; cs &amp; 0xffff;  # 压入CS:IP*(--krnstack) &#x3D; eip;*(--krnstack) &#x3D; ds &amp; 0xffff;*(--krnstack) &#x3D; es &amp; 0xffff;*(--krnstack) &#x3D; fs &amp; 0xffff;*(--krnstack) &#x3D; gs &amp; 0xffff;*(--krnstack) &#x3D; esi;*(--krnstack) &#x3D; edi;*(--krnstack) &#x3D; edx;*(--krnstack) &#x3D; (long) first_return_from_kernel; &#x2F;&#x2F; a code segment with iret instruction*(--krnstack) &#x3D; ebp;*(--krnstack) &#x3D; ecx;*(--krnstack) &#x3D; ebx;*(--krnstack) &#x3D; 0;p-&gt;kernel_stack &#x3D; krnstack;  # 设置PCB中的内核栈栈顶指针信息为初始化后的栈顶指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验5-信号量的实现与应用"><a class="markdownIt-Anchor" href="#实验5-信号量的实现与应用"></a> 实验5 信号量的实现与应用</h1><h2 id="1-前提-2"><a class="markdownIt-Anchor" href="#1-前提-2"></a> 1. 前提</h2><h3 id="1-系统调用open打开文件"><a class="markdownIt-Anchor" href="#1-系统调用open打开文件"></a> (1) 系统调用open打开文件</h3><p>要使用系统调用方式打开文件，可以使用 open 系统调用。该系统调用的原型定义在 &lt;fcntl.h&gt; 头文件中，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，pathname 参数是要打开的文件名，可以是相对路径或绝对路径，可以包含目录名和文件名；flags 参数是打开文件的选项和标志，比如只读、只写、追加、创建等；mode 参数是创建文件时的权限，仅在创建文件时使用，可以指定文件的读写权限。<br />常用的打开选项和标志包括：</p><ul><li>O_RDONLY：只读模式打开文件。</li><li>O_WRONLY：只写模式打开文件。</li><li>O_RDWR：读写模式打开文件。</li><li>O_CREAT：如果文件不存在则创建文件。</li><li>O_TRUNC：如果文件已存在则清空文件内容。</li><li>O_APPEND：在文件末尾追加内容。</li><li>O_EXCL：在创建文件时，如果文件已存在则返回错误。</li></ul><p>如果成功打开文件，系统调用返回一个非负整数，即文件描述符（file descriptor），用于后续访问文件内容。如果出错，则返回一个负值，表示出错的类型。<br />对第2个参数flags，可以使用了<code>|</code>运算符将多个选项参数组合在一起。这是因为 open 系统调用的选项参数是一个位掩码，每个选项都有一个对应的位标志，可以使用位运算符组合多个选项。<br />对第3个参数mode，文件的访问权限是一个八进制数，表示文件的所有者、所属组和其他用户对文件的访问权限。<br />每个访问权限位的含义如下：</p><ul><li>读权限：4</li><li>写权限：2</li><li>执行权限：1</li></ul><p>在使用 open 系统调用创建文件时，可以通过一个八进制数来指定文件的访问权限。通常情况下，可以将三个访问权限位组合在一起，得到一个八进制数，作为 mode 参数传递给 open 系统调用。例如，如果要将文件的访问权限设置为所有用户都有<strong>写</strong>权限，可以使用以下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_WRONLY<span class="token punctuation">,</span> <span class="token number">0222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 0开头的数字表示这是一个八进制数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-系统调用write写入文件"><a class="markdownIt-Anchor" href="#2-系统调用write写入文件"></a> (2) 系统调用write写入文件</h3><p>在 C 语言中，write 函数用于向文件或者文件描述符写入数据，其函数原型为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>write 函数的三个参数分别表示：</p><ol><li>fd：文件描述符，它是一个整数，用于指定要写入数据的文件或设备。在 Linux 系统中，标准输入、标准输出和标准错误分别对应文件描述符 0、1 和 2。用户可以使用 open 函数打开其他文件或设备，并获得相应的文件描述符。</li><li>buf：指向要写入数据的缓冲区的指针。在写入数据之前，用户需要将数据存储在缓冲区中，然后将缓冲区的地址传递给 write 函数。</li><li>count：要写入的字节数。用户需要指定要写入数据的长度，以字节数为单位。如果缓冲区中的数据长度小于 count，则 write 函数只会写入部分数据；如果缓冲区中的数据长度大于 count，则 write 函数只会写入 count 字节的数据。</li></ol><p>当 write() 函数成功写入数据时，内核会更新文件偏移量，以便下一次读写操作从正确的位置开始。<br />需要注意的是，write 函数返回值是 ssize_t 类型，表示成功写入的字节数，如果返回值为负数，则表示写入失败。</p><h3 id="3-系统调用read从文件读取数据"><a class="markdownIt-Anchor" href="#3-系统调用read从文件读取数据"></a> (3) 系统调用read从文件读取数据</h3><p>在 Linux 系统中，read() 是一个用于从文件描述符中读取数据的系统调用。该调用的原型如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>read() 函数有三个参数：</p><ol><li>fd：要读取的文件的文件描述符。</li><li>buf：用于存储读取数据的缓冲区。</li><li>count：要读取的字节数。</li></ol><p>read() 函数会从指定的文件描述符 fd 中读取 count 个字节的数据，并将其存储到 buf 缓冲区中。函数返回实际读取的字节数，如果读取出错，则返回 -1。<br />read() 函数在读取数据时可能会阻塞进程，直到有数据可读或发生错误。如果读取到文件末尾，函数返回 0。如果读取的字节数小于 count，则可能是因为已经到达文件末尾或者因为发生了错误。<br />当使用 read() 函数读取数据时，内核会将文件偏移量更新为读取数据后的下一个位置。例如，如果你使用 read() 函数从文件的位置 100 处读取 50 个字节的数据，则文件偏移量会从 100 更新为 150 (100~149)。这样，下一次读取数据操作将从文件位置 150 处开始。使用 lseek() 函数可以显式地设置文件偏移量。<br />read() 函数可以用于读取文件、套接字、管道等类型的文件描述符。</p><h3 id="4-系统调用lseek移动文件指针"><a class="markdownIt-Anchor" href="#4-系统调用lseek移动文件指针"></a> (4) 系统调用lseek移动文件指针</h3><p>lseek函数用于在文件中移动文件指针的位置。该函数的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// off_t 是long的别名，在&lt;sys/types.h>中定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，fd 是已打开文件的文件描述符，offset 是需要移动的偏移量，whence 则用于指定相对于何处进行偏移，其取值可以为 SEEK_SET、SEEK_CUR 或 SEEK_END。这三个常量在&lt;unistd.h&gt; 头文件中定义</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/ee06a722e7ba781e506f36fd67cfc32c.png" class=""><ul><li>当 whence 值为 SEEK_SET时，文件指针将被设置为相对于文件开头偏移 offset 个字节的位置。</li><li>当 whence 值为 SEEK_CUR时，文件指针将被设置为相对于当前位置偏移 offset 个字节的位置。</li><li>当 whence 值为 SEEK_END时，文件指针将被设置为相对于文件末尾偏移 offset 个字节的位置。</li></ul><p>lseek() 函数返回新的文件指针位置，如果出现错误则返回 -1。通过调用 lseek() 函数可以实现随机访问文件的功能，比如读取文件中的任意部分内容、覆盖文件中的任意部分内容等。</p><h2 id="2-创建semaphore类型"><a class="markdownIt-Anchor" href="#2-创建semaphore类型"></a> 2. 创建semaphore类型</h2><p>在<code>include/linux/sem.h</code>写入以下内容</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_SEM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_SEM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span>   <span class="token comment">// for task_struct definition</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_TABLE_LEN</span> <span class="token expression"><span class="token number">20</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME_LEN</span><span class="token expression"><span class="token number">20</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">semaphore</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span>SEM_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>queue<span class="token punctuation">;</span>   <span class="token comment">// wait queue</span><span class="token punctuation">&#125;</span><span class="token class-name">sem_t</span><span class="token punctuation">;</span><span class="token class-name">sem_t</span> sem_table<span class="token punctuation">[</span>SEM_TABLE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建信号量相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建信号量相关的系统调用"></a> 3. 创建信号量相关的系统调用</h2><p>在<code>kernel/sem.c</code>中写入以下内容，包括信号量的创建<code>sys_sem_open</code>，P操作<code>sys_sem_wait</code>，V操作<code>sys_sem_post</code>，和释放信号量<code>sys_sem_unlink</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/tty.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/fdreg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/system.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/io.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/segment.h></span></span><span class="token comment">// #include&lt;string.h>  // avoid unknowned error</span><span class="token keyword">int</span> cnt<span class="token punctuation">;</span>   <span class="token comment">// the number of semaphores in sem_table, auto initial to zero</span><span class="token class-name">sem_t</span> <span class="token operator">*</span> <span class="token function">sys_sem_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> name_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> isExist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> sem_name_len <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> kernel_sem_name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"\0"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token class-name">sem_t</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>name_len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>         kernel_sem_name<span class="token punctuation">[</span>name_len<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token operator">++</span>name_len<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">// printk("name_len: %d\tstrlen: %d\n",name_len,strlen(kernel_sem_name));</span><span class="token keyword">if</span><span class="token punctuation">(</span>name_len <span class="token operator">></span> SEM_NAME_LEN<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">/*find duplicate*/</span><span class="token punctuation">&#123;</span>sem_name_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// printk("%d:%s!\t%d:%s!\n",sem_name_len,sem_table[cnt].name,name_len,kernel_sem_name);</span><span class="token keyword">if</span><span class="token punctuation">(</span>sem_name_len <span class="token operator">==</span> name_len <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kernel_sem_name<span class="token punctuation">,</span> sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>isExist <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>isExist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//printk("i am consumer!\n");</span>p <span class="token operator">=</span> sem_table<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>sem_table<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> kernel_sem_name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// printk("ID:(%d)\t %d\t%s!\t%d\t%s!\n",cnt,strlen(sem_table[cnt].name),sem_table[cnt].name,strlen(kernel_sem_name),kernel_sem_name);</span>sem_table<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>p <span class="token operator">=</span> sem_table<span class="token operator">+</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span>        <span class="token comment">//printk("i am producer!\n");</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sys_sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>sem<span class="token operator">-></span>value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>sem<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sys_sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>sem<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>sem<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_sem_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> name_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>name_len<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">++</span>name_len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>name_len <span class="token operator">></span> SEM_NAME_LEN<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">char</span> kernel_sem_name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>name_len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>kernel_sem_name<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> isExist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> sem_name_len <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sem_name_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sem_name_len <span class="token operator">==</span> name_len <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kernel_sem_name<span class="token punctuation">,</span> sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>isExist <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>isExist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> tmp <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>tmp<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sem_table<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> sem_table<span class="token punctuation">[</span>tmp<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// overwrite</span><span class="token punctuation">&#125;</span><span class="token operator">--</span>cnt<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将sys_function添加到内核的系统调用已在lab2讲解过，这里只上截图</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c15ef0cb21a3f300d2f857ed2dfe1f93.png" class=""><p>修改Makefile</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/86a7f4e3d5fbd9a340787a51970cdda0.png" class=""><h2 id="4-创建生产者-消费者进程"><a class="markdownIt-Anchor" href="#4-创建生产者-消费者进程"></a> 4. 创建生产者-消费者进程</h2><p>在<code>pc.c</code>中写入以下内容</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem_open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_wait<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_post<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> sem_unlink<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_CONSUMER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_PRODUCTS <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> pro_nr<span class="token punctuation">,</span> csm_pro_nr<span class="token punctuation">;</span> <span class="token comment">/*product number, consumed product number*/</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> FILENAME <span class="token operator">=</span> <span class="token string">"/usr/root/buffer_file"</span><span class="token punctuation">;</span> <span class="token comment">/*default buffer file*/</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token operator">*</span>full<span class="token punctuation">,</span> <span class="token operator">*</span>empty<span class="token punctuation">;</span><span class="token keyword">int</span> f_in<span class="token punctuation">;</span>   <span class="token comment">/* for producer*/</span><span class="token keyword">int</span> f_out<span class="token punctuation">;</span>  <span class="token comment">/* for consumer*/</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> file_name <span class="token operator">=</span> argc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> FILENAME<span class="token punctuation">;</span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token keyword">int</span> cnt<span class="token punctuation">;</span> <span class="token comment">/* must declare cnt here */</span><span class="token comment">/*open buffer file */</span>f_in <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> O_CREAT<span class="token operator">|</span>O_TRUNC<span class="token operator">|</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f_out <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span>O_TRUNC<span class="token operator">|</span>O_RDONLY<span class="token punctuation">,</span> <span class="token number">0444</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*create semaphores*/</span>mutex <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>full <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>empty <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*parent process as producer*/</span>pro_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\t producer created!\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>pro_nr <span class="token operator">&lt;</span> NR_PRODUCTS<span class="token punctuation">)</span> <span class="token comment">/*until product all products then producer exit*/</span><span class="token punctuation">&#123;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>pro_nr <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">lseek</span><span class="token punctuation">(</span>f_in<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*10 products per turn*/</span><span class="token function">write</span><span class="token punctuation">(</span>f_in<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>pro_nr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pro_nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\t produces product %d!\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> pro_nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>pro_nr<span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*child process create child processes to be consumer*/</span><span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>cnt <span class="token operator">=</span> NR_CONSUMER<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\t consumer %d created!\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> NR_CONSUMER<span class="token operator">-</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>csm_pro_nr <span class="token operator">==</span> NR_PRODUCTS<span class="token punctuation">)</span> <span class="token keyword">goto</span> OK<span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">read</span><span class="token punctuation">(</span>f_out<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>csm_pro_nr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>csm_pro_nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">/*end of file,reset*/</span><span class="token punctuation">&#123;</span><span class="token function">lseek</span><span class="token punctuation">(</span>f_out<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span>f_out<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>csm_pro_nr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>csm_pro_nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid:%d:\t consumer %d consume product %d\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">,</span> NR_CONSUMER<span class="token operator">-</span>cnt<span class="token punctuation">,</span>csm_pro_nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>OK<span class="token operator">:</span><span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>f_in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>f_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-验证结果"><a class="markdownIt-Anchor" href="#5-验证结果"></a> 5. 验证结果</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#current catalogue: OSLab5</span>./mount-hdc<span class="token comment">#更新标准库</span><span class="token function">cp</span> include/unistd.h hdc/usr/include   <span class="token function">cp</span> include/linux/sem.h hdc/usr/include <span class="token comment">#run</span><span class="token function">cp</span> pc.c hdc/usr/root./run<span class="token comment">#在bochs中执行</span>gcc <span class="token parameter variable">-o</span> pc pc.c./pc <span class="token operator">></span> sem_output <span class="token comment"># 将输出结果重定向到文件sem_output，便于查看</span><span class="token function">sync</span>  <span class="token comment">#将所有的缓存数据写入磁盘，lab3中出现过</span><span class="token comment">#回到ubuntu执行</span>./mount-hdc<span class="token function">cp</span> hdc/usr/root/sem_output sem_outputgedit sem_output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/86a7f4e3d5fbd9a340787a51970cdda0.png" class=""><p>查看sem_output验证信号量机制的正确性</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>可以看出，producer每生产一轮，即填满容量为10的缓冲区后，5个consumer就开始消耗缓冲区，消耗完后producer又生产一轮，直到达到最大产品数量<code>NR_PRODUCTS = 50</code>(0~49)后退出，consumer在消耗完所有产品后也退出<br /><a href="https://www.cnblogs.com/mirage-mc/p/12913993.html">reference</a></p><h1 id="实验6-地址映射与共享"><a class="markdownIt-Anchor" href="#实验6-地址映射与共享"></a> 实验6 地址映射与共享</h1><h2 id="1-跟踪地址翻译过程"><a class="markdownIt-Anchor" href="#1-跟踪地址翻译过程"></a> 1. 跟踪地址翻译过程</h2><ol><li>启动调试，获取i的逻辑地址为<code>ds:0x3004</code>，ds表明该地址属于由ds寄存器指示的段 (后续称ds段)</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/be0fe056a34a3f0d79a4adbf9469162b.png" class=""><ol start="2"><li>通过段表(LDT)，确定ds段的起始地址，进而将逻辑地址转化为虚拟地址。段表由LDTR指示，运行命令<code>sreg</code>查看LDTR的值，该寄存器用于从GDT中取出进程的LDT地址</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/96f0f5111b99db234b71b696fffa6d9b.png" class=""><p>LDTR的值为<code>0x68 = 0x0000 0000 0110 1000</code>，取3~15位表示段选择子<code>1101</code>，说明目标LDT在GDT的第13项(从0索引)<br />GDT的地址已经由gdtr指出为<code>0x00005cb8</code>，因为GDT每项段描述符占8个字节，因此查看GDT的<code>0x00005cb8+8*13</code>处的8个字节，这8个字节就是目标LDT的段描述符</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>根据段描述符的结构，从0x<strong>52d0</strong>0068 0x<strong>00</strong>0082<strong>fd</strong>(0~64bits）提取出<code>0x00fd52d0</code>，这就是目标LDT的基地址</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>ds段的基地址由ds寄存器(段选择子)在LDT中指示，我们先用<code>sreg</code>查看ds的值</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/96f0f5111b99db234b71b696fffa6d9b.png" class=""><p>段选择子ds的值是0x0017 = 0x <strong>0000 0000 0001 0</strong>111 (16bits)，根据段选择子的结构</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c15ef0cb21a3f300d2f857ed2dfe1f93.png" class=""><p>从ds中提取出段选择符的索引<code>0x10</code>，可见ds段在LDT的第3项(从0编号)，于是接下来查看目标LDT的前四项(每项占四个字节)</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/96f0f5111b99db234b71b696fffa6d9b.png" class=""><p>获取了目标LDT中第3个段描述符的数据: 0x<strong>0000</strong>3fff 0x<strong>10</strong>c0f3<strong>00</strong>，根据段描述符的结构，提取出基地址: <code>1000 0000</code>，自此我们可以将<code>i</code>逻辑地址转化为虚拟地址(线性地址)了<br />虚拟地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>0000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>3004</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>3004</mn></mrow><annotation encoding="application/x-tex">base +offset=0x1000\,0000 + 0x3004 =0x1000\,3004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span></p><ol start="3"><li>将虚拟地址映射到的物理地址</li></ol><p>根据虚拟地址结构，可知<code>0x1000 3004 = 0x0001 0000...0000 0011 000..0 0100</code>表示的物理地址在页目录64对应的页表中，页号为3(页号连续，因此由第3个页表项指示)，页内偏移为4</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>内存中页目录表的位置由寄存器CR3指示，使用<code>creg</code>查看CR3寄存器的值</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>CR3的值为0x00000000，所以页目录表从地址0x00000000开始，我们要获取第64项，页目录表每项占4个字节，因此使用<code>xp /2w 0+64*4</code>查看第64项的内容</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/be0fe056a34a3f0d79a4adbf9469162b.png" class=""><p>得到第64个页目录项的内容为: 0x<strong>00fa7</strong>027 0x00000000，根据页目录项的结构，前20位表示所指向的页表的地址的高20位 (<a href="https://stackoverflow.com/questions/26858196/why-does-page-directory-entries-need-20-bits-to-point-210-page-tables">why</a>）为<code>0x00fa7</code>，因为页表物理地址的低12位为0（对齐到4KB的倍数），因此页表的最终的物理地址为<code>0x00fa7000</code></p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>一个页表项占4个字节，使用<code>xp /2w 0x00fa7000+4*3</code>查找目标页表的第3个页表项(物理页框)</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>得到第3个页表项的内容为0x<strong>00fa6</strong>067 0x00000000<br />根据页表项的结构，前20项表示物理页框的高20位地址: 0x00fa6 (物理页面大小为4KB，基地址与4KB对齐，为 0x**** **** **** **** **** 0000 0000 0000) ,因此目标物理页框的基地址为0x00fa6000</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>最后我们加上页内偏移4，得到最终的物理地址<code>0x00fa6004</code></p><ol start="4"><li>验证</li></ol><p>执行<code>xp /w 0x00fa6004</code>查看我们确定的物理地址的数据内容</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/be0fe056a34a3f0d79a4adbf9469162b.png" class=""><p>这个值与<code>i</code>在程序中的值相一致<br />用命令<code>setpmem 0x00fa6004 4 0</code>将<code>0x00fa6004</code>开始的4个字节(i为int型)全部设置为0，即设置i为0，则程序从原本的无限循环中退出</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><h2 id="2-添加共享内存功能"><a class="markdownIt-Anchor" href="#2-添加共享内存功能"></a> 2. 添加共享内存功能</h2><h3 id="1-前提-通过brk划分虚拟内存"><a class="markdownIt-Anchor" href="#1-前提-通过brk划分虚拟内存"></a> (1) 前提: 通过brk划分虚拟内存</h3><p>进程栈和堆之间的内存空间可以映射到共享的物理页面，brk作为指向进程堆的末尾的指针（即下图中处于下方的虚线），将brk加上进程数据段在虚拟内存中的基址，便可以得到brk的虚拟地址，以这个地址为起点，划分出大小为PAGE_SIZE的虚拟内存，再将这部分虚拟内存通过<code>put_page</code>映射到共享内存上<br /><img src="https://i.stack.imgur.com/1aV6B.png#from=url&amp;id=Lavvc&amp;originHeight=193&amp;originWidth=128&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" /></p><h3 id="2-创建用于管理共享内存的数据结构"><a class="markdownIt-Anchor" href="#2-创建用于管理共享内存的数据结构"></a> (2) 创建用于管理共享内存的数据结构</h3><p><code>linux-0.11/include/linux/shm.h</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SHM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__SHM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_SIZE</span> <span class="token expression"><span class="token number">32</span> </span><span class="token comment">/*Maximum number of shared pages*/</span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">key_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">shm</span><span class="token punctuation">&#123;</span>        <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>          <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> page<span class="token punctuation">;</span> <span class="token comment">/*shared page address */</span><span class="token punctuation">&#125;</span>shm<span class="token punctuation">;</span>shm shm_list<span class="token punctuation">[</span>SHM_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-创建共享内存相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建共享内存相关的系统调用"></a> (3) 创建共享内存相关的系统调用</h3><p><code>linux-0.11/kernel/shm.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span> <span class="token comment">/*for current define*/</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/shm.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/mm.h></span> <span class="token comment">/* PAGE_SIZE,get_free_page */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token comment">/*function: apply for a shared page, return shm_id according to key*/</span><span class="token keyword">int</span> <span class="token function">sys_shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">void</span><span class="token operator">*</span> page<span class="token punctuation">;</span>      <span class="token comment">/*printk("hello, i am here for debug!\n");*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">></span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token comment">/*size beyond border*/</span>        <span class="token punctuation">&#123;</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"size beyond PAGE_SIZE!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>SHM_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>   <span class="token comment">/*constructed before*/</span>                <span class="token punctuation">&#123;</span>                        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"constructed before!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        page <span class="token operator">=</span> <span class="token function">get_free_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span>   <span class="token comment">/*no free memory*/</span>        <span class="token punctuation">&#123;</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"no free page!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                errno <span class="token operator">=</span> ENOMEM<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"shmget get memory's address is 0x%08x\n"</span><span class="token punctuation">,</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>SHM_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token comment">// record for manage</span>                <span class="token punctuation">&#123;</span>                        shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>                         shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>                        shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>                        <span class="token keyword">return</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/*shm_list is full and key is invalid*/</span>        <span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sys_shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> data_base<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> brk<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>shmid<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> shmid<span class="token operator">>=</span>SHM_SIZE <span class="token operator">||</span> shm_list<span class="token punctuation">[</span>shmid<span class="token punctuation">]</span><span class="token punctuation">.</span>page <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        data_base <span class="token operator">=</span> <span class="token function">get_base</span><span class="token punctuation">(</span>current<span class="token operator">-></span>ldt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*I know get_base from copy_mem() function*/</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"current data_base = 0x%08x, new page = 0x%08x\n"</span><span class="token punctuation">,</span>data_base<span class="token punctuation">,</span>shm_list<span class="token punctuation">[</span>shmid<span class="token punctuation">]</span><span class="token punctuation">.</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* brk is the end of heap section,         * the virtual memory space between heap and stack can map to shared physical page,         * so slice this part of virtual memory to map the shared page */</span>        <span class="token comment">/*logic address convert to virtual address by adding base address*/</span>        brk <span class="token operator">=</span> current<span class="token operator">-></span>brk<span class="token operator">+</span>data_base<span class="token punctuation">;</span>        current<span class="token operator">-></span>brk <span class="token operator">+=</span>PAGE_SIZE<span class="token punctuation">;</span>        <span class="token function">put_page</span><span class="token punctuation">(</span>shm_list<span class="token punctuation">[</span>shmid<span class="token punctuation">]</span><span class="token punctuation">.</span>page<span class="token punctuation">,</span> brk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>current<span class="token operator">-></span>brk <span class="token operator">-</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*logic address*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-创建生产者进程"><a class="markdownIt-Anchor" href="#4-创建生产者进程"></a> (4) 创建生产者进程</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem_open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_wait<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_post<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> sem_unlink<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    <span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> shmget<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> shmat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmid<span class="token punctuation">)</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> NR_PRODUCTS <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> SHM_KEY <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_id<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment">/*point to the shared memory*/</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">/* products number */</span>    <span class="token keyword">int</span> buffer_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token class-name">sem_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token operator">*</span>full<span class="token punctuation">,</span> <span class="token operator">*</span>empty<span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    full <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    empty <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    shm_id <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>SHM_KEY<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_id <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shm_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_PRODUCTS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span>buffer_pos<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\tproducer produces product %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer_pos <span class="token operator">=</span> <span class="token punctuation">(</span>buffer_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>BUFFER_SIZE<span class="token punctuation">;</span>  <span class="token comment">/*end of the buffer,refresh*/</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-创建消费者进程"><a class="markdownIt-Anchor" href="#5-创建消费者进程"></a> (5) 创建消费者进程</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem_open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_wait<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_post<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> sem_unlink<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> shmget<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> shmat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmid<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_PRODUCTS <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> SHM_KEY <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_id<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> used_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/*products count*/</span>    <span class="token keyword">int</span> buffer_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token operator">*</span>full<span class="token punctuation">,</span> <span class="token operator">*</span>empty<span class="token punctuation">;</span>mutex <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>full <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>empty <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        shm_id <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>SHM_KEY<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_id <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shm_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d consumer consumes products %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ptr<span class="token punctuation">[</span>buffer_pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer_pos <span class="token operator">=</span> <span class="token punctuation">(</span>buffer_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>BUFFER_SIZE<span class="token punctuation">;</span>  <span class="token comment">/*end of the buffer,refresh*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>used_cnt <span class="token operator">==</span> NR_PRODUCTS<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-添加到系统调用和修改makefile"><a class="markdownIt-Anchor" href="#6-添加到系统调用和修改makefile"></a> (6) 添加到系统调用和修改MakeFile</h3><ol><li>添加到系统调用</li></ol><p>如之前的lab一样，验证结果时将unistd.h复制到hdc/usr/include目录下，记得将shm.h也复制到对应目录中</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/e8b42fd0449952451907b1e0f34ce770.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9b9b2cd55c94679c33508fb4312374e4.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9b9b2cd55c94679c33508fb4312374e4.png" class=""><ol start="2"><li>修改MakeFile</li></ol><p><code>linux-0.11/kernel/Makefile</code></p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/e8b42fd0449952451907b1e0f34ce770.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9b9b2cd55c94679c33508fb4312374e4.png" class=""><h3 id="7-踩的坑"><a class="markdownIt-Anchor" href="#7-踩的坑"></a> (7) 踩的坑</h3><ol><li>编译shm.c时，总是出现<code>parse error before int</code>的错误，耗时调试了一个小时还是无法解决，Google后发现原因在于linux0.11下的C标准为C89，要求声明变量的语句只能出现在非声明语句的前面 (声明同时又赋值语句的可以)</li><li>lab5的sem.c写的有问题，consumer进程一直处于sleep状态，添加了几条打印语句后发现，consumer进程和producer进程未使用同一套信号量，原因在于sem.c的sys_sem_open函数内定义kernel_sem_name未显式的初始化，我以为该变量会<a href="https://stackoverflow.com/questions/18688971/c-char-array-initialization-what-happens-if-there-are-less-characters-in-the-st">默认初始化为0值</a> (‘\0’)，但在c89的标准下，未显式初始化的字符数组不会被默认初始化，这将导致未知的行为，发现这点花了我不少时间。在显式初始化<code>char kernel_sem_name[25]=&#123;&quot;\0&quot;&#125;;</code>后结果正确</li><li>consumer进程会出现&quot;kernel panic: trying to free free page&quot;，出现这个问题的原因是producer进程和consumer进程共用一个页面，producer生产完全部产品后先退出同时释放共享内存，这将导致consumer进程退出时试图释放已经释放的页面，解决方法是注释掉memery.c文件中free_page函数中的相关panic语句</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c1c065677d7c02278e139b2ba94820eb.png" class=""><h2 id="3-验证结果"><a class="markdownIt-Anchor" href="#3-验证结果"></a> 3. 验证结果</h2><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/e8b42fd0449952451907b1e0f34ce770.png" class=""><pre class="line-numbers language-none"><code class="language-none">.&#x2F;mount-hdccp hdc&#x2F;usr&#x2F;root&#x2F;c_output c_output.txtcp hdc&#x2F;usr&#x2F;root&#x2F;p_output p_output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h1 id="实验7-终端设备的控制"><a class="markdownIt-Anchor" href="#实验7-终端设备的控制"></a> 实验7 终端设备的控制</h1><h2 id="1-添加新的f12响应函数"><a class="markdownIt-Anchor" href="#1-添加新的f12响应函数"></a> 1. 添加新的f12响应函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> switch_by_f12_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">press_f12_handle</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>switch_by_f12_flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        switch_by_f12_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        switch_by_f12_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c1c065677d7c02278e139b2ba94820eb.png" class=""><h2 id="2-设置响应函数入口"><a class="markdownIt-Anchor" href="#2-设置响应函数入口"></a> 2. 设置响应函数入口</h2><p>键盘输入后，操作系统会将键盘扫描码做为下标，调用key_table函数数组中保存的与该按键对应的响应函数，因此要让CPU在按下f12之后跳转到新的响应函数执行需要修改key_table，从该数组一旁的注释就可以看出f12对应的scan code是88D (58H)</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/c1c065677d7c02278e139b2ba94820eb.png" class=""><h2 id="3-修改con_write函数"><a class="markdownIt-Anchor" href="#3-修改con_write函数"></a> 3. 修改con_write函数</h2><p>con_write函数执行最终的输出显示器操作，该函数先用GETCH从输出缓冲区中提取一个字节字符到变量<code>c</code>，再写入显存中。我们根据flag修改变量<code>c</code>的值即可，为了实验结果更可观，我们选择只对字母和数字的输出进行转换</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h2 id="4-修改ttyh"><a class="markdownIt-Anchor" href="#4-修改ttyh"></a> 4. 修改tty.h</h2><p>在头文件中包含<code>switch_by_f12_flag</code>变量和响应函数的声明，以便在其他文件中使用</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h2 id="5-验证结果-2"><a class="markdownIt-Anchor" href="#5-验证结果-2"></a> 5. 验证结果</h2><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h1 id="实验8-proc文件系统的实现"><a class="markdownIt-Anchor" href="#实验8-proc文件系统的实现"></a> 实验8 proc文件系统的实现</h1><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><h3 id="vsprintf函数"><a class="markdownIt-Anchor" href="#vsprintf函数"></a> vsprintf函数</h3><p>vsprintf 是一个C库函数，用于将可变参数列表（va_list）中的值格式化为字符串，并将结果字符串存储在指定的字符数组（缓冲区）中。vsprintf 是 sprintf 函数的可变参数版本，通常在需要处理可变数量参数的情况下使用。<br />vsprintf 函数的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数说明：</p><ol><li>str：指向目标字符数组（缓冲区）的指针，用于存储格式化后的字符串。</li><li>format：一个格式字符串，它描述了如何将参数列表中的值格式化为字符串。格式字符串可以包含普通字符和转换说明符（例如 %d、%s 等）。</li><li>ap：一个 va_list 类型的参数列表，用于存储需要格式化的值。</li></ol><p>返回值：vsprintf 函数返回写入目标字符数组（不包括最后的空字符）的字符数。如果发生错误，返回负值。<br />因为该函数接受一个va_list类型的参数而不是一个通常使用的可变参数，因此我们要使用va_start函数获取一个va_list的参数<br />va_start 是C语言标准库中的一个宏，用于处理可变参数列表。va_start 用于在可变参数函数中初始化一个 va_list 类型的变量，使其指向传入的第一个可变参数。通常与 va_arg 和 va_end 宏一起使用，分别用于访问可变参数列表中的参数和完成参数列表的处理 (va_end释放为 va_list 类型的变量分配的资源)。<br />va_start 宏的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">va_start</span><span class="token punctuation">(</span>va_list ap<span class="token punctuation">,</span> last_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>ap：一个 va_list 类型的变量，用于存储指向可变参数列表的状态。</li><li>last_arg：函数参数列表中最后一个<strong>固定参数</strong>的名称 (可变参数在固定参数之后)。在初始化 va_list 时，va_start 会找到此固定参数在内存中的位置，从而确定可变参数列表的起始位置。</li></ol><h3 id="mknod系统调用"><a class="markdownIt-Anchor" href="#mknod系统调用"></a> mknod系统调用</h3><p>mknod 系统调用用于创建特殊文件（设备文件）在文件系统中。特殊文件通常用于表示设备，如字符设备和块设备。字符设备通常用于表示可逐字符读写的设备，如终端设备；块设备通常用于表示可按块读写的设备，如磁盘设备。本实验用它来创建proc文件。<br />mknod 系统调用的主要参数包括：</p><ol><li>路径名（pathname）：要创建的特殊文件的路径名。</li><li>文件模式（mode）：描述新创建的特殊文件类型和权限的位掩码。文件类型可以是字符设备（S_IFCHR）或块设备（S_IFBLK）。</li><li>设备号（dev）：设备号用于唯一标识设备。通常分为主设备号和次设备号。主设备号用于标识设备类型或驱动程序，而次设备号用于标识同一类型设备的实例。</li></ol><p>当调用 mknod 系统调用时，操作系统会执行以下操作：</p><ol><li>根据提供的路径名找到目标目录。</li><li>在目标目录中创建一个新的目录项，设置其文件名和 inode 号(更新目录树)。</li><li>分配一个新的 inode，并将其与目录项关联。</li><li>设置 inode 的属性，如文件类型（字符设备或块设备）、权限和设备号等。</li><li>更新文件系统元数据，如目录和 inode 的更改时间等。</li></ol><p>创建特殊文件后，应用程序可以使用设备文件与相应的设备进行通信。例如，通过 open、read、write 和 ioctl 系统调用与设备驱动程序进行交互。这使得设备操作看起来与普通文件操作相似，简化了应用程序的开发。</p><h2 id="添加proc类型文件"><a class="markdownIt-Anchor" href="#添加proc类型文件"></a> 添加proc类型文件</h2><p>OS根据文件类型选择不同处理函数，从而实现对不同类型的文件的操作，我们先在linux0.11中添加proc类型文件，之后再编写对应的处理函数就能完成proc文件系统的添加了。</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/40e187fa3aba0142eecbbd33961b9403.png" class=""><h2 id="修改mknod系统调用"><a class="markdownIt-Anchor" href="#修改mknod系统调用"></a> 修改mknod系统调用</h2><p>我们已经提到，mknod用于创建特殊文件，即块设备文件和字符流文件。现在我们要给它添加对proc文件的支持。</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h2 id="创建proc目录文件proc普通文件"><a class="markdownIt-Anchor" href="#创建proc目录文件proc普通文件"></a> 创建proc目录文件，proc普通文件</h2><p>在系统初始化时，根目录文件挂载之后 (这样传递给mknod的路径才有效)，创建proc文件系统的目录文件和文件。<br />因为此时在用户态，因此要通过添加系统调用的方式使用mkdir和mknod，而不能直接使用sys_mkdir和sys_mknod</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><h2 id="验证文件是否创建成功"><a class="markdownIt-Anchor" href="#验证文件是否创建成功"></a> 验证文件是否创建成功</h2><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><p>可以看到，我们已经成功在根目录下创建了proc目录文件，并在该文件下创建了proc普通文件，这三个文件分别表示系统进程信息，系统硬件信息，系统存储信息<br />这里使用cat输出了一行信息和一行报错，要明白这两条信息怎么来的，首先要知道cat命令背后执行了什么操作: 用sys_open打开一个文件，用sys_read将文件内容读入缓冲区，最后用printf打印缓冲区的内容到屏幕上</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><p>通过查看sys_read的源码，我们可以找到这两条信息的来源。当sys_read打开proc类型文件没有对应的处理函数时，就会出现这两条信息，因此我们接下来为proc类型文件编写对应的处理函数proc_read即可</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><p>为proc文件添加处理分支</p><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><h2 id="编写proc文件处理函数"><a class="markdownIt-Anchor" href="#编写proc文件处理函数"></a> 编写proc文件处理函数</h2><p>添加<code>linux-0.11/fs/proc_read.c</code>，这里只完成了进程信息的获取</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/segment.h></span>  <span class="token comment">// put_fs_byte</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span>  <span class="token comment">// process-related variables: task struct, FIRST_TASK</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span>       <span class="token comment">//  vs_start va_end</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">char</span> krnbuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'\0'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> va_list args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">// initalize args to first changeable parameter</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// vsprintf function returns the number of characters written to the buffer</span>    i <span class="token operator">=</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">get_psinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> buf_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span>                          <span class="token string">"pid\tstate\tfather\tcounter\tstart_time\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK<span class="token punctuation">;</span> p <span class="token operator">>=</span> <span class="token operator">&amp;</span>FIRST_TASK<span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>father<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span>                <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>start_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> buf_offset<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">proc_read</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>pos<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos <span class="token operator">/</span> BLOCK_SIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// already read a whole block, start write</span>    <span class="token punctuation">&#123;</span>        <span class="token function">get_psinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>krnbuf<span class="token punctuation">[</span><span class="token operator">*</span>pos <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// end of message</span>        <span class="token function">put_fs_byte</span><span class="token punctuation">(</span>krnbuf<span class="token punctuation">[</span><span class="token operator">*</span>pos <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span>                    buf <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// synchronous replication</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>pos <span class="token operator">+=</span> i<span class="token punctuation">;</span> <span class="token comment">// change f_pos</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token comment">// return the actual number of bytes read</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改makefile"><a class="markdownIt-Anchor" href="#修改makefile"></a> 修改Makefile</h2><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><h2 id="验证结果"><a class="markdownIt-Anchor" href="#验证结果"></a> 验证结果</h2><img src="/2023/05/06/OS-Learning/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><p><a href="https://www.cnblogs.com/mirage-mc/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/">reference</a></p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HIT-OS]哈工大操作系统Notes</title>
      <link href="/2023/05/06/OS-Learning/HIT-OS/"/>
      <url>/2023/05/06/OS-Learning/HIT-OS/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>学完整个哈工大的操作系统课程，做完所有labs, 用了一个月多一点的时间，有这样一个伴随着lab的操作系统课程入门，是一件很值得高兴的事情，毕竟直接去看<em>操作系统概念</em>或<em>现代操作系统</em>是一件很乏味的事情。那些实验，对我一个OS新手，确实有点难度，但是学习从来都是一个从不会到会再到熟练精通的过程，有意义的事情再晚去做，它依旧是有意义的，从这里开始，做正确的事情。结合自己的理解和chatgpt的帮助写下了这篇笔记，目的是在于学完计算机网络之后能快速把OS的知识拾起来，也想要帮助其他学习HIT-OS的人</p><h1 id="1-操作系统的引导"><a class="markdownIt-Anchor" href="#1-操作系统的引导"></a> 1. 操作系统的引导</h1><h2 id="1-bootsect载入os"><a class="markdownIt-Anchor" href="#1-bootsect载入os"></a> 1) bootsect载入OS</h2><ol><li>PC刚开机时，CPU处于实模式，这个模式下CPU按照<code>CS&lt;&lt;4 + IP</code>的形式寻址，此时<code>CS:IP</code>指向<code>0xFFFF0</code>,即存储在ROM上的BIOS程序，于是CPU自动执行BIOS程序，这段程序首先检查硬件设施，接着从磁盘读入首扇区（主引导扇区-Master Boot Record-MBR，共512个字节）到内存<code>0x07c00</code>处，并设置<code>CS:IP</code>指向这个地址</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/68c822853ca0f63de658940ba09b7003.png" class=""><ol start="2"><li>CPU开始执行MBR的程序，即<code>bootsect</code>(作用：将磁盘上的操作系统读入内存，计算机本质上是CPU取指执行，要让操作系统发挥作用，首先得把它加载到内存上)**，**这段程序先将自己（整个首扇区256 words）转移到新地址<code>0x90000</code>处（目的在于腾出位置存放操作系统，原因在于防止后续移动操作系统覆盖了<code>setup</code>），并跳转到该新地址处继续执行后面的指令</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/8f19c8e6410929f9f8eadf10f37a2ccd.png" class=""><ol start="3"><li>后续指令从磁盘的第2个扇区开始读入四个扇区(扇区从1开始编号，也就是说读取首扇区后面的四个扇区，即<code>set-up</code>模块)到<code>0x90200</code>处，即首扇区之后</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/8f19c8e6410929f9f8eadf10f37a2ccd.png" class=""><ol start="4"><li>读入setup模块后，在屏幕上打印一段信息：<code>&quot;Loading system ...&quot;</code>，<code>es:bp</code>指向字符串的起始位置，<code>cx</code>存储要打印的字符数信息，然后读入<code>system</code>模块(也就是操作系统主体)，至此<code>bootsect</code>执行完毕，操作系统被从磁盘读入了内存，接着CPU开始执行<code>setup</code></li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/dd5ff3c83ce1679eab6d51fba602f527.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/848f00e31ae9e6e18106b6038356b61c.png" class=""><h2 id="2-setup建立os"><a class="markdownIt-Anchor" href="#2-setup建立os"></a> 2) setup建立OS</h2><ol><li>操作系统要想掌控计算机就需要先知道计算机的基本信息 ，于是<code>setup</code>首先通过系统调用获取计算机内存大小（扩展内存：RAM中高于1MB的部分），并将这一信息放在地址<code>0x90002</code>处。接着<code>setup</code>将<code>system</code>模块移动到内存<code>0x0</code>处，该模块将一直占用从<code>0x0</code>开始的这段内存</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/19429a3d7d01b10593c4e4448702d955.png" class=""><ol start="2"><li>接着CPU显然就该开始执行<code>system</code>模块了，<code>setup</code>通过<code>jmpi 0, 8</code>这条指令跳转到<code>system</code>模块，但是在这之前，<code>setup</code>要完成CPU从实模式到保护模式的切换，本质上就是将寻址模式由<code>segment:offset</code>16位寻址模式(<code>cs&lt;&lt;4 : ip</code>，寻址范围：1MB)，转变为这样一种32位寻址模式（寻址范围4GB）：CS不再是段寄存器，而是一个段选择子，表示的不再是段地址，而是表示一个在GDT（全局描述符表）中的表项的位置，每个表项是64位但能抽取出一个32位的段地址，将该地址与ip（此时变为32位ip，之前是16位）相加后，得到最终地址。<code>setup</code>完成这样的转换的方法是将<code>cr0</code>寄存器的最后一位置0。至此，<code>jmpi 0, 8</code>不再被解释为<code>jmp 0x80</code>而是解释为<code>jmp 0x0000</code>，于是CPU开始执行<code>0x0</code>地址开始的<code>system</code>模块 （注意下图的DPL，在后续讲用户态-内核态时会用到）</li></ol><p><strong>旁注:</strong></p><blockquote><p>CS 寄存器的值实际上是一个 16 位的段选择子，它指向了一个描述代码段的段描述符，该段描述符中包含了代码段的起始地址、大小、特权级别等信息。当 CPU 执行代码时，会根据 CS 寄存器中的段选择子和段描述符来确定代码段的位置和访问权限</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/82696a312b38b2caffbed1decdebe663.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/c8c8680d6369eb064a9fb0434b0b3d31.png" class=""><h2 id="3-head初始化os"><a class="markdownIt-Anchor" href="#3-head初始化os"></a> 3) head初始化OS</h2><ol><li>这里的初始化指的是OS为管理各种计算机硬件如内存而初始化多个数据结构，以掌控这些硬件信息，在步入<code>head</code>之前，我们应当思考一个问题，那就是操作系统内核是由许多文件组成的，内核编译后形成<code>image</code>，<code>image</code>就是一个<code>bootsect-setup-system</code>结构的二进制文件，叫做内核映像，把这个内核映像放在一个计算机磁盘的首扇区便可以如前文那样启动操作系统，那么内核编译是如何保证<code>bootsect.s</code>编译得到的<code>bootsect</code>置于<code>image</code>文件的首部呢，如何保证<code>bootsect-setup-system</code>这样的结构呢？而且<code>system</code>模块内也有很多可执行文件，其中位于第一部分的就是由<code>head.s</code>编译得到的<code>head</code>，如何保证<code>head</code>位于<code>system</code>的头部呢？     答案是利用<code>MakeFile</code>工具，这里简单叙述一下<code>MakeFile</code>：</li></ol><blockquote><p>MakeFile是一个用于自动化构建程序的工具。它是一个文本文件，其中包含了构建程序所需的指令和依赖关系，它可以使用依赖关系来控制编译的顺序。如果某个目标文件依赖于其他文件，那么在编译这个目标文件之前，需要先编译它所依赖的文件。可以使用依赖关系来控制编译的顺序。如果某个目标文件依赖于其他文件，那么在编译这个目标文件之前，需要先编译它所依赖的文件。</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/cc9b4103bc02a8d67f35043fedfface7.png" class=""><pre><code>   因此通过利用`MakeFile`我们可以控制在编译结果中各部分的先后顺序</code></pre><ol start="2"><li><code>head</code>完成一些初始化的操作，如初始化GDT（用于寻址，<code>setup</code>部分只是为了跳转到<code>system</code>而部分初始化了该表）, IDT（用于调用中断处理程序，只是创建一个空的 IDT 表，还未填入中断门等内容），页表。<code>head</code>部分与之前的<code>bootsect</code>和<code>setup</code>在汇编语言上也不同，由于CPU从实模式转换到保护模式，因此<code>head</code>由32位汇编语言构成，<code>ax</code>变为<code>eax</code>，汇编指令也从intel 8086格式转变为AT&amp;T格式</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/9fe1343ecdbd946c3404a678738f74d7.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/ba11b3ecaddba2f5b95962aa2edd2a17.png" class=""><ol start="3"><li><code>head</code>在设置完页表后会跳转到<code>main</code>，这个函数由<code>main.c</code>文件编译得到，跳转方式利用了函数调用的栈机制：<code>head</code>先压入<code>main</code>的地址，在执行<code>ret</code>后，栈中弹出该地址赋给<code>cs:ip</code>，CPU跳转到<code>main</code>开始执行。<code>head</code>在压入<code>main</code>之前压入了<code>L6</code>，这样做会导致从<code>main</code>返回后系统进入<code>L6：jmp L6</code>的死循环，计算机就会死机，因此<code>main</code>函数永远不会返回</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/9fe1343ecdbd946c3404a678738f74d7.png" class=""><h2 id="4-main继续初始化os"><a class="markdownIt-Anchor" href="#4-main继续初始化os"></a> 4) main继续初始化OS</h2><p><code>main</code>继续完成初始化OS的操作（包括设置中断门填充IDT表：<code>trap_init</code>，<code>sched_init</code>），这里主要讲一下对内存的初始化，OS用数组管理内存，对每个字节，OS用<code>0</code>表示该字节空闲（内存位图BitMap），从<code>mem_init</code>部分的代码可以看出这里使用了之前<code>setup</code>初始化的计算机内存大小信息，并以一个页（4K）为单位初始化内存信息</p><img src="/2023/05/06/OS-Learning/HIT-OS/33260348d45935dfc16fd4da8e94e9a0.png" class=""><p><img src="attachment/d0b5436e3bd694ef9dadbf62a885e8f4.png" alt="" /><img src="attachment/49e195de46edde2a13a3d612e3f4436f.png" alt="" /></p><hr /><h1 id="2-彻底理解系统调用"><a class="markdownIt-Anchor" href="#2-彻底理解系统调用"></a> 2. 彻底理解系统调用</h1><h2 id="1os接口的本质是os提供的函数"><a class="markdownIt-Anchor" href="#1os接口的本质是os提供的函数"></a> 1）OS接口的本质是OS提供的函数</h2><p>无论用户是通过命令行还是图形界面来操作计算机，本质上都是在运行C语言程序，而这些C语言程序不同于普通的C语言程序的点在于它们调用了特殊的函数，即OS提供的函数，去完成特定的任务，如用<code>fork</code>函数创建一个进程，用<code>open</code>函数打开一个文件。因此这些C语言程序与OS打交道的方式就是这些函数调用，进而完成对计算机硬件的操作，所以我们可以得出OS提供给用户的接口就是这些特殊的函数，用户通过函数调用来使用它们。这里的函数调用有另外的术语，叫系统调用（system call）</p><blockquote><p>系统调用（System call）是操作系统内核提供给应用程序使用的一组编程接口，它们允许应用程序请求操作系统内核执行某些特权操作，例如读写文件、创建进程、网络通信等。应用程序可以通过系统调用与操作系统内核进行交互，从而获得操作系统提供的各种服务和资源。<br />系统调用通常是操作系统内核提供的一组函数或指令，应用程序可以通过调用这些函数或指令来请求操作系统内核执行某些操作。系统调用的实现通常是由操作系统内核提供的一组中断服务例程或系统调用门（System Call Gate）来完成的。当应用程序发起系统调用时，操作系统内核会根据系统调用号来确定要执行的操作，并在内核态下执行相应的操作，最后将结果返回给应用程序。</p></blockquote><h2 id="2dpl-cpl机制分离用户态和内核态"><a class="markdownIt-Anchor" href="#2dpl-cpl机制分离用户态和内核态"></a> 2）DPL-CPL机制分离用户态和内核态</h2><p>系统调用之所以不同于普通的函数调用，就在于它能执行其它函数所不能执行的操作，如访问在OS内核（地址<code>0x0</code>开始的那段内存）的数据，那为什么普通函数不能直接访问OS内核呢？这源自于OS内核所在的内存叫内核段（对应内核态），应用程序所在的内存叫用户段(对应用户态)。之前我们提到过的<code>GDT</code>，<code>head</code>阶段在初始化它时，会将所有内存段（代码段，数据段）的信息写入<code>GDT</code>，其中就包括内存段的<code>DPL(Descriptor Privilege Level)</code>信息，该信息表示各内存段的的优先级。对于OS内核所在的内存段，<code>DPL</code>是<code>0</code>，也就是最高优先级。对应用程序所在的内存段，<code>DPL</code>是<code>3</code>，也就是最低优先级。<br />讲到这里，我们已经知道了应用程序和OS内核所在的内存段的优先级不同（称前者在用户段，后者在内核段），且该信息由<code>DPL</code>记录并保存在<code>GDT</code>这一数据结构中。那么要实现这两个态的隔离，即用户段不能访问优先级高于它的内核段，要涉及<code>CPL</code>的概念：</p><blockquote><p>CPL 表示当前代码的运行特权级别。在执行代码时，CPL 将根据代码段描述符中的 DPL 来设置。如果 CPL 等于或高于代码段描述符中的 DPL，则允许代码执行。否则，就会发生“General Protection Fault”（GPF）异常，导致程序终止。</p></blockquote><p>也就是说，当CPU在执行应用程序时，CS:IP指向用户段的指令，CPU根据当前代码段的DPL设置<code>CPL</code>（CS的最后两位）为<code>3</code>。如果应用程序此时要访问OS内核，那么CPU会先比较CS中的<code>CPL</code>和描述OS内核优先级的<code>DPL</code>，如果<code>DPL&gt;=CPL</code>则说明目标代码段的优先级不如当前代码段的优先级高，可以直接访问，但是在这里<code>0&gt;=3</code>不成立，所以不可以直接访问。以上机制均是由计算机硬件实现。既然用户段不能访问内核段，但用户段又有这个需求，所以才有了系统调用，给了用户段间接访问内核段的途径</p><img src="/2023/05/06/OS-Learning/HIT-OS/613a60198a2c9acd2ef05b06c201e63c.png" class=""><h2 id="3进入内核-int-0x80-中断"><a class="markdownIt-Anchor" href="#3进入内核-int-0x80-中断"></a> 3）进入内核: int 0x80 中断</h2><p>在用户程序中使用的系统调用，如<code>fork</code>，<code>open</code>等函数，本质上是一段含有中断的代码，这个中断指的就是<code>int 0x80</code>中断指令，执行这条指令能够让CPU从用户态转换到内核态。现在用一个例子来更详细的说明：<br />我现在编写了一个C程序并在里面调用了<code>open</code>函数，CPU执行<code>open</code>函数内部的<code>int 0x80</code>指令就会引发<code>0x80</code>号中断，然后OS就会根据中断向量号<code>0x80</code>查找中断向量表进而执行相应的中断处理程序。<code>0x80</code>号中断对应的中断处理程序是专门用于处理系统调用的，这个程序完成这样一件事情：根据传入的<code>open</code>这个系统调用的系统调用号（在<code>%eax</code>中）查找相应的系统调用处理函数，并转去执行该函数完成打开文件操作，并将结果返回给用户程序。</p><img src="/2023/05/06/OS-Learning/HIT-OS/60e7bd6e50d50fb77b707637148c0e04.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/d363fbe15afd12811daeb0a66ede9589.png" class=""><p>可见，一个系统调用完成的特定操作本质上是OS内核中的对应的系统调用处理函数完成的。它之所以是一个面向用户的接口，就在于虽然用户不能像普通函数调用那样直接调用它，但用户可以通过<code>int 0x80</code>对应的中断例程和传递系统调用号给<code>0x80</code>号中断例程（已经打包在系统库里的接口函数中，因此我们只用直接调用<code>open</code>函数即可，而不用编写包含<code>int 0x80</code>指令并传递系统调用号参数的程序）进而在该中断例程中完成对系统调用处理函数的调用<br /><strong>旁注: 系统调用号</strong></p><blockquote><p>系统调用号（System Call Number）是一个与特定系统调用相关联的唯一整数，用于在用户程序和操作系统内核之间标识和调用特定的系统调用。每个系统调用都有一个与之对应的系统调用号。当用户程序需要请求操作系统的服务时，它会通过将系统调用号传递给内核来指明需要执行哪个系统调用。<br />以下是系统调用号的一些基本概念：</p><ol><li>分配：操作系统为每个可用的系统调用分配一个唯一的系统调用号。这些号码通常是连续的整数，从0开始。</li><li>查找：当用户程序需要调用某个系统调用时，它需要知道相应的系统调用号。这些号码可以在操作系统的文档或头文件（例如，对于Linux系统，可以查看unistd.h）中找到。</li><li>使用：用户程序通过将系统调用号和其他必要的参数传递给内核来发起系统调用。这通常通过使用特殊的指令（如x86架构上的int指令）触发软件中断来实现。</li><li>内核处理：内核收到系统调用请求后，会根据系统调用号查找相应的处理函数并执行。处理函数完成请求后，将结果返回给用户程序。</li></ol></blockquote><p>系统调用号充当了用户程序和操作系统内核之间的接口，使得用户程序能够以一种可靠且一致的方式请求操作系统的服务。</p><p>**旁注：软中断与硬中断 **</p><blockquote><p>内中断和外中断是计算机系统中两种不同类型的中断。它们的主要区别在于中断的来源和触发方式。</p><ol><li>内中断（内部中断）： 内中断是由处理器内部的事件或程序执行过程中出现的异常触发的。它们通常与正在执行的指令或处理器的状态有关。内中断的常见类型包括：</li></ol><ul><li>软件中断：由特定的指令（如x86架构上的int指令）在程序中显式触发的中断。<strong>软件中断通常用于实现系统调用，让用户程序能够请求操作系统的服务。</strong></li><li>陷阱（Trap）：在执行某些特定指令时自动触发的中断。陷阱用于处理特殊情况，如整数除以零、浮点数溢出或无效指令等。</li><li>断点（Breakpoint）：用于调试程序的一种中断。当程序执行到某个预先设置的断点时，处理器会触发一个中断，允许调试器检查程序的状态。</li></ul><ol start="2"><li>外中断（外部中断）： 外中断是由处理器外部的硬件设备发出的信号触发的。它们通常与外部事件或设备的状态变化有关。当一个硬件设备需要处理器的注意时（例如，读取数据、处理错误或通知状态改变），它会发送一个中断请求（IRQ）信号给处理器。处理器会在适当的时机响应这个中断请求，暂停当前的任务并执行相应的中断处理程序。外中断的常见类型包括：</li></ol><ul><li>I/O设备中断：由外部输入/输出设备触发，如键盘、鼠标、硬盘等。</li><li>计时器中断：由系统计时器触发，用于实现多任务调度、时间管理等功能。</li><li>电源管理中断：由电源管理系统触发，用于处理电源相关事件，如电池电量低或休眠唤醒等。</li></ul></blockquote><p>总之，内中断与外中断的主要区别在于它们的来源：内中断由处理器内部的事件或异常触发，而外中断由外部硬件设备发出的信号触发。不过，无论是内中断还是外中断，处理器在接收到中断信号后都会执行相应的中断处理程序，以处理中断事件。</p><p><strong>旁注：中断类型码与中断向量号</strong></p><blockquote><ol><li>中断类型码：中断类型码是一种用于区分不同类型的中断和异常的编码。在x86架构中，常见的中断类型码有如下几种：<ul><li>外部中断（硬件中断）：由外部设备（如键盘、鼠标、定时器等）产生的中断。</li><li>软件中断：由程序主动触发的中断，例如通过int指令（在x86架构中）。</li><li>异常：由处理器在执行指令时检测到的错误或异常条件引发的中断，如除以零、非法操作码、内存访问越界等。</li></ul></li><li>中断向量号：中断向量号是一个唯一标识中断源的整数，用于在中断向量表（实模式下）或中断描述符表（保护模式下）中索引到对应的中断处理程序。中断向量号通常与中断类型码相关联，例如在x86架构中，一个设备的外部中断请求（IRQ）可能会被映射到一个特定的中断向量号。</li><li>中断号：中断号通常是指中断向量号，它是一个整数，用于唯一标识中断源。在实际应用中，中断号和中断向量号这两个术语通常可以互换使用。</li></ol></blockquote><p>总之，中断类型码用于区分中断的类型（硬件中断、软件中断或异常），而中断向量号（中断号）则用于在中断处理表中唯一标识和索引到对应的中断处理程序。</p><h2 id="4从printf函数出发到int-0x80"><a class="markdownIt-Anchor" href="#4从printf函数出发到int-0x80"></a> 4）从printf函数出发到int 0x80</h2><h3 id="1-迈向int-0x80printf函数内部"><a class="markdownIt-Anchor" href="#1-迈向int-0x80printf函数内部"></a> 1. 迈向int 0x80：printf函数内部</h3><p>首先，我们查看<code>printf</code>的内部。以下是一个基于GNU C库的<code>printf</code>函数的简化实现，以展示其内部机制：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token keyword">int</span> done<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>    done <span class="token operator">=</span> <span class="token function">vfprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> done<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">vfprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> written <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//调用vsnprintf将可变参数转化为字符数组格式</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">vsnprintf</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> ap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//将字符数组写入标准输出流</span>    written <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>written <span class="token operator">!=</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> written<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>printf</code>函数本身只是将可变参数封装到<code>vfprintf</code>函数中，并将标准输出流<code>stdout</code>作为参数传递给<code>vfprintf</code>。<code>vfprintf</code>函数负责将可变参数格式化为一个字符数组，并将该字符数组写入标准输出流。在该函数中，我们看到它调用了<code>vsnprintf</code>函数来将可变参数格式化为字符数组，并使用<code>write</code>系统调用将该字符数组写入标准输出流中。<br />在<code>vfprintf</code>函数中，<code>vsnprintf</code>函数将可变参数转换为字符数组格式，并将其存储在<code>buffer</code>数组中。然后，<code>write</code>系统调用将该字符数组写入标准输出流中，使用文件描述符为<code>STDOUT_FILENO</code>（等同于标准输出流）。当<code>write</code>系统调用返回时，它返回写入的字节数。</p><h3 id="2-迈向int-0x80write函数内部"><a class="markdownIt-Anchor" href="#2-迈向int-0x80write函数内部"></a> 2. 迈向int 0x80：write函数内部</h3><p>那么<code>write</code>系统调用背后又是什么样呢？让我们来查看<code>write</code>函数的内部</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token function">_syscall3</span><span class="token punctuation">(</span><span class="token class-name">ssize_t</span><span class="token punctuation">,</span> write<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在理解了宏函数<code>_syscall3</code>之后可以看出，这里的<code>_syscall3</code>宏展开之后便是一个返回值为<code>int</code>的<code>write</code>函数</p><h3 id="3-迈向int-0x80_syscall3宏函数"><a class="markdownIt-Anchor" href="#3-迈向int-0x80_syscall3宏函数"></a> 3. 迈向int 0x80：_syscall3宏函数</h3><p>一步一步来，接着我们查看<code>_syscall3</code>宏函数的定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall3</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span>name<span class="token punctuation">,</span>type1<span class="token punctuation">,</span>arg1<span class="token punctuation">,</span>type2<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span>type3<span class="token punctuation">,</span>arg3<span class="token punctuation">)</span> </span></span>type <span class="token function">name</span><span class="token punctuation">(</span>type1 arg1<span class="token punctuation">,</span>type2 arg2<span class="token punctuation">,</span>type3 arg3<span class="token punctuation">)</span> \<span class="token punctuation">&#123;</span> \<span class="token keyword">long</span> __res<span class="token punctuation">;</span> \__asm__ <span class="token keyword">volatile</span> <span class="token punctuation">(</span> \<span class="token string">"int $0x80"</span> \<span class="token operator">:</span> <span class="token string">"=a"</span> <span class="token punctuation">(</span>__res<span class="token punctuation">)</span> \<span class="token operator">:</span> <span class="token string">"0"</span> <span class="token punctuation">(</span>__NR_##name<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"b"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"c"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> \<span class="token string">"d"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \<span class="token function">__syscall_return</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>__res<span class="token punctuation">)</span><span class="token punctuation">;</span> \<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们逐行的解析<code>_syscall3</code>宏函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall3</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span>name<span class="token punctuation">,</span>type1<span class="token punctuation">,</span>arg1<span class="token punctuation">,</span>type2<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span>type3<span class="token punctuation">,</span>arg3<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>预处理器指令<code> #define</code>将宏<code>_syscall3</code> 定义为一个具有八个参数的宏函数，即将<code>_syscall3</code>映射为后续的代码块。如果程序中出现该宏定义（write函数内部），那么将在编译预处理阶段被替换为后续的代码块。<br />其中，各参数的含义如下：</p><ul><li>type：定义系统调用的返回值类型，如 int、long 等。</li><li>name：定义系统调用的名称，如 open、read 等。</li><li>type1、type2、type3：定义系统调用的参数类型。</li><li>arg1、arg2、arg3：定义系统调用的参数名称。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">type <span class="token function">name</span><span class="token punctuation">(</span>type1 arg1<span class="token punctuation">,</span>type2 arg2<span class="token punctuation">,</span>type3 arg3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是 <code>_syscall3</code> 宏定义中的第二行，它定义了一个函数，该函数的名称为 <code>name</code>，它有三个参数 <code>arg1</code>、<code>arg2</code> 和 <code>arg3</code>，它的返回值类型为 <code>type</code>。这个函数是系统调用的入口点，它将通过汇编指令触发系统调用，并返回系统调用的结果。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">&#123;</span> \    <span class="token keyword">long</span> __res<span class="token punctuation">;</span> \    __asm__ <span class="token keyword">volatile</span> <span class="token punctuation">(</span> \        <span class="token string">"int $0x80"</span> \        <span class="token operator">:</span> <span class="token string">"=a"</span> <span class="token punctuation">(</span>__res<span class="token punctuation">)</span> \        <span class="token operator">:</span> <span class="token string">"0"</span> <span class="token punctuation">(</span>__NR_##name<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"b"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"c"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> \          <span class="token string">"d"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \    <span class="token function">__syscall_return</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>__res<span class="token punctuation">)</span><span class="token punctuation">;</span> \<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是 <code>_syscall3 </code>宏定义中的其它部分，它是 <code>name</code> 函数的函数体，其中使用了嵌入式汇编语言。宏函数的传入参数要用括号括起来，保证宏展开后运算的正确性。<br />函数体中的第一行定义了一个 <code>long</code> 类型的变量 <code>__res</code>，用于存储系统调用的返回值。变量名前面的双下划线是为了避免与用户定义的变量名冲突。<br />第二行使用了 <code>asm</code> 关键字定义了一个内联汇编代码块，它使用了 <code>volatile</code> 关键字，告诉编译器不要对代码进行优化。在汇编代码中，使用了 <code>int $0x80</code> 指令触发系统调用，接着的两个冒号是给<code>int $0x80</code>传参，其中的<code>_NR_##name</code> 是一个宏，<code>## </code>运算符是一种预处理器运算符，它用于将两个标识符连接成一个新的标识符。在这里，它将<code>_NR</code> 和 <code>name</code> 连接起来，得到宏<code>_NR_write</code>,这个宏定义在<code>&lt;unistd.h&gt;</code>的开头），它将 <code>name</code> 参数转换为系统调用的编号（即数字4，这就是系统调用号）并赋给寄存器<code>%eax</code>。</p><img src="/2023/05/06/OS-Learning/HIT-OS/7e450d69c1d03c9011f11f0b067acb76.png" class=""><p>在 <code>_syscall3</code> 宏定义中，asm 内联汇编语言块中使用了冒号（:）运算符来指定输入操作数（Input Operand）和输出操作数（Output Operand），操作数的格式为 <code>&quot;constraint&quot; (C expression)</code>。<br />其中，<code>constraint</code> 是操作数的约束符，用于指定操作数应该存放在哪个寄存器或内存位置，<code>C expression</code> 是操作数的 C 语言表达式，用于指定操作数的值。<br />在这里，<code>&quot;=a&quot;</code>、<code>&quot;0&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code> 和 <code>&quot;d&quot;</code> 都是操作数的约束符，它们的含义如下：</p><ul><li>“=a”：表示将返回值存放在寄存器 eax 中。</li><li>“0”：表示将系统调用号存放在寄存器 eax 中。</li><li>“b”：表示将第一个参数的值存放在寄存器 ebx 中。</li><li>“c”：表示将第二个参数的值存放在寄存器 ecx 中。</li><li>“d”：表示将第三个参数的值存放在寄存器 edx 中。</li></ul><p><code>int 0x80 </code>指令执行时，会将 <code>eax</code> 寄存器中的值作为系统调用号，<code>ebx</code>、<code>ecx</code>、<code>edx</code> 寄存器中的值分别作为系统调用的第一个、第二、第三个参数。因此，要向<code> int 0x80</code> 指令传递参数，可以将参数存储在寄存器中，然后通过 asm 内联汇编语言块传递给 <code>int 0x80</code> 指令。<br />这些约束符在汇编代码中对应的位置使用了百分号（%）符号进行引用，如 %0 表示第一个操作数，%1 表示第二个操作数，以此类推。在这个例子中，“%0”、“%1”、“%2”、“%3”、“%4” 分别对应返回值、系统调用号、第一个参数、第二个参数和第三个参数。</p><img src="/2023/05/06/OS-Learning/HIT-OS/a2c1f6510d1747ac9f31f9caaa5f0cf6.png" class=""><h3 id="4-步入int-0x80中断门"><a class="markdownIt-Anchor" href="#4-步入int-0x80中断门"></a> 4. 步入int 0x80：中断门</h3><p>中断门(gate)是IDT表的一个表项的内容，代表了一个中断处理程序的段选择子和偏移地址（即中断入口地址），它包含以下信息：</p><blockquote><ul><li>中断服务程序的段选择器</li><li>中断服务程序的偏移地址</li><li>一些标志位，如特权级（DPL）和类型（如任务门、中断门、陷阱门等）</li></ul></blockquote><p>当发生中断或异常时，处理器会根据中断向量号在中断描述符表（IDT）中查找相应的中断门，然后跳转到关联的处理程序进行处理。<br />这个IDT表很像我在学习实模式汇编时遇到的中断向量表，这两个表有如下关系，因为操作系统在引导阶段就以及步入了保护模式，因此我们用到的都是IDT表（实模式是早期计算机中的一种工作模式，现已逐渐淘汰）</p><blockquote><ol><li>中断向量表：中断向量表是实模式下（16位）用于存储中断处理程序入口地址的表。它通常位于内存的低地址（例如0x0000）。在实模式下，每个中断向量占用4个字节，前两个字节是段地址，后两个字节是偏移地址。中断向量表的大小是固定的，共有256个向量，因此占用1KB（1024字节）的内存空间。</li><li>IDT表：IDT表（中断描述符表）是保护模式下（32位或64位）用于存储中断门和异常门描述符的表。IDT表的每个条目包含了处理程序的段选择子、入口地址、特权级和类型等信息。与实模式下的中断向量表不同，IDT表的大小是可变的，可以根据需要设置表的大小和地址。</li></ol></blockquote><p>因此要执行<code>int 0x80</code>的中断处理程序，首先就要得到它的中断门。我们在引导过程的时候已经提到过，IDT表在<code>head</code>阶段初始化，在<code>main</code>阶段填充正确的值。下面展示了OS到底是如何初始化0x80号中断的中断门：</p><ol><li><code>main</code>阶段调用<code>kernel/sched.c</code>中的<code>sched_init</code>函数，该函数内调用了<code>set_system_gate(0x80, &amp;system_call)</code>，<code>&amp;system_call</code>代表了中断处理程序地址</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/d363fbe15afd12811daeb0a66ede9589.png" class=""><ol start="2"><li><code>set_system_gate</code>是<code>include/asm/system.h</code>文件中的一个宏函数，用于设置系统调用（0x80号中断）的中断门。从这个宏函数的定义可以看出，它又调用了<code>_set_gate</code>函数</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/7e450d69c1d03c9011f11f0b067acb76.png" class=""><ol start="3"><li><code>_set_gate</code>也是<code>include/asm/system.h</code>文件中的一个宏函数，它用于设置各种门描述符，包括系统调用中断门。<code>_set_gate</code> 接受四个参数：<code>gate_addr</code>（中断门描述符在 IDT 表中的地址）、<code>type</code>（门类型）、<code>dpl</code>（特权级）和 <code>addr</code>（中断处理程序的地址，这里是<code>&amp;system_call</code>），并根据这些参数设置门描述符。</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/532ab5bef0f2b1fbcb4e3a75616980cc.png" class=""><p><code>_set_gate</code>看起来挺复杂，其实就做了这样几件事：在IDT表项中填入了中断处理程序<code>system_call</code>的入口地址，设置段选择子为8（CS，对应段地址 0)，DPL为3。<br /><strong>旁注：OS中，什么是描述符</strong></p><blockquote><p>在操作系统中，描述符是一种数据结构，它提供了关于内存段或系统资源（如文件、设备等）的元数据。在x86架构的保护模式下，描述符的主要作用是对内存段进行描述，以支持内存保护和虚拟内存管理。描述符通常存储在描述符表（例如，全局描述符表 GDT 或局部描述符表 LDT）中。<br />描述符中包含的信息有：</p><ol><li>基地址：内存段的起始地址。</li><li>段限长：内存段的大小，通常以字节数表示。</li><li>访问权限：段的读/写/执行权限。</li><li>特权级：指定内存段的特权级别（0-3）。在x86架构中，有4个特权级，其中0级为最高特权级，3级为最低特权级。</li><li>段类型：段的类型，例如数据段、代码段等。</li><li>存在标志：表示描述符是否有效。</li></ol></blockquote><p>描述符在操作系统中扮演着关键角色，主要用于内存管理、进程隔离以及处理程序调用（例如，系统调用、中断和异常处理）。描述符提供了一种抽象层，使得操作系统能够对内存和其他系统资源进行更精细的控制。</p><blockquote><p>在理解描述符时，我们可以将其看作是一组存储了某个对象或资源的信息的数据结构，例如内存段描述符存储了一个内存段的起始地址、大小、访问权限、特权级等信息。这些信息可以被操作系统或处理器用于执行相应的操作，例如访问内存、执行代码等。<br />然而，描述符并不是指针。描述符存储的信息是直接编码在描述符的字段中，而不是存储在某个内存位置上并使用指针进行访问。在x86架构中，段描述符和门描述符的格式和编码规则是由处理器规定的，不同类型的描述符具有不同的字段和编码方式。<br />当处理器需要使用某个描述符时，它会从描述符表（GDT或LDT）中读取相应的描述符，然后使用其中的信息执行相应的操作。例如，当需要访问一个内存段时，处理器会从GDT或LDT中读取该内存段的描述符，并使用其中的信息计算出内存段的物理地址，然后进行访问。<br />因此，描述符是一种用于存储某个对象或资源的信息的数据结构，与指针不同，它不是用于访问内存位置的工具，而是用于提供某个对象或资源的信息的编码方式。</p></blockquote><p><strong>旁注：什么是门描述符</strong></p><blockquote><p>在x86架构中，IDT（中断描述符表）的每个表项占用64位。表项的结构称为门描述符。门描述符定义了一个中断或异常处理程序的入口点、特权级别以及其他相关信息。根据处理程序的类型和特权级别，门描述符可以表示中断门、陷阱门或任务门。<br />门描述符的结构如下：</p><img src="/2023/05/06/OS-Learning/HIT-OS/60e7bd6e50d50fb77b707637148c0e04.png" class=""><p>总之，IDT表项是64位，包含了门描述符的信息。门描述符定义了中断或异常处理程序的入口点和相关属性。中断门是门描述符的一种类型，用于处理硬件和软件中断。</p></blockquote><h3 id="5-步入int-0x80从用户态到内核态"><a class="markdownIt-Anchor" href="#5-步入int-0x80从用户态到内核态"></a> 5. 步入int 0x80：从用户态到内核态</h3><p>上一步我们说了<code>0x80</code>号中断门的设置过程，最后该中断门(描述符)的<code>DPL</code>字段被设置为<code>3</code>。操作系统在用户程序中执行<code>int 0x80</code>试图跳转到内核的中断程序程序时，CPU检查此时的<code>CPL</code>为<code>3</code>，目标代码段的<code>DPL</code>也为<code>3</code>，此时满足<code>DPL&gt;=CPL</code>，因此可以从用户段跳转到内核段。接着，根据中断门中的段选择子设置CS，偏移地址设置IP。注意，因为段选择子是<code>8(1000)</code>,因此CS的最后两位被设置为0，即<code>CPL</code>又被设置为0，符合系统初始化时为OS内核段设置的优先级。由此可见之所以专门将<code>0x80</code>号中断用于系统调用，就在于其中断处理程序描述符的<code>DPL</code>为3，因此提供给用户一个契机进入内核，并在进入内核后，将<code>CPL</code>修改为0</p><h3 id="6-int-0x80中断处理程序system_call"><a class="markdownIt-Anchor" href="#6-int-0x80中断处理程序system_call"></a> 6. int 0x80中断处理程序：system_call</h3><p>最后一步，CPU开始执行中断处理程序<code>system_call</code>，该函数先通过一个函数表（函数指针表）<code>_sys_call_table</code>调用处理函数<code>sys_write</code>完成写入的操作（这个才是整个系统调用过程中真正实现功能的部分，涉及内存）。这里的<code>_sys_call_table(,%eax,4)</code>中的<code>%eax</code>是中断向量号，加上4倍偏移是因为在函数表<code>_sys_call_table</code>中每个函数的地址（函数指针）占4个字节。<br />至此，我们基本完成了printf函数的系统调用过程</p><img src="/2023/05/06/OS-Learning/HIT-OS/e6d3379fc4d365ff408c77b2babf4d21.png" class=""><p><img src="attachment/e01a62cd2c34aaab94c959af6be846d3.png" alt="" /><img src="attachment/532ab5bef0f2b1fbcb4e3a75616980cc.png" alt="" /></p><hr /><h1 id="3-多进程与多线程"><a class="markdownIt-Anchor" href="#3-多进程与多线程"></a> 3. 多进程与多线程</h1><p>本章主要先讲述线程，因为线程不涉及内存的切换，通过线程切换将执行序列的切换（主要是栈）讲清楚之后，再通过在linux0.11环境下执行fork中断的实际例子看进程的切换</p><h2 id="1多进程是为了充分利用cpu"><a class="markdownIt-Anchor" href="#1多进程是为了充分利用cpu"></a> 1）多进程是为了充分利用CPU</h2><p>给CPU设置一个PC值，它便可以执行程序，如果CPU在执行程序中途遇到<code>I/O</code>操作，那么它在<code>I/O</code>结束之前将无法继续执行下一步指令。因此出于管理好CPU就是充分利用CPU的准则，CPU应当离开当前进程，转而去执行其它进程，在<code>I/O</code>结束后（且CPU空闲）时再返回继续执行该进程<br />这一过程涉及了多进程，计算机中有多个进程在跑，即并发（同时出发，交替执行）。为了完成进程间的切换，OS应当记录进程切换时的状态以便在返回时可以正确的继续执行，这些进程的状态记录在进程的PCB（一个结构体）中。进程区别于程序最大的一点就在于OS需要记录进程的状态，而对程序不需要</p><h2 id="2os用-pcb队列状态-管理多进程"><a class="markdownIt-Anchor" href="#2os用-pcb队列状态-管理多进程"></a> 2）OS用 PCB+队列+状态 管理多进程</h2><p>PCB记录单个进程的信息，OS将多个进程的PCB根据进程状态组织成队列，如就绪队列，等待队列，以及正在执行的单个进程</p><img src="/2023/05/06/OS-Learning/HIT-OS/e36a2a99955dab7372f26e5f6c54cea0.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/172349e0413d8582ce691ac2f1abecf3.png" class=""><h2 id="3多进程的要素调度算法切换过程内存隔离合理的推进顺序"><a class="markdownIt-Anchor" href="#3多进程的要素调度算法切换过程内存隔离合理的推进顺序"></a> 3）多进程的要素：调度算法，切换过程，内存隔离，合理的推进顺序</h2><p>①调度算法用于CPU交替执行进程时选择下一个进程 ②进程的切换，要从进程A切换到进程B，那么先保存当前CPU中的各个值到进程A的PCB中，再将进程B的PCB各值载入CPU ③如果各进程间的内存不独立，那么一个进程运行时就可能修改另一个进程的数据，造成错误，因此各进程要使用不同的映射表以将同一逻辑地址映射到不同的物理地址，形成内存隔离 ④ 进程的合作，典型的就是消费者-生产者的例子，要保证合作正确，要求进程间有着合理的推进顺序</p><img src="/2023/05/06/OS-Learning/HIT-OS/840754c4bede736bec5534802d03b4c2.png" class=""><h2 id="4多线程提高了进程的执行速度和响应度"><a class="markdownIt-Anchor" href="#4多线程提高了进程的执行速度和响应度"></a> 4）多线程提高了进程的执行速度和响应度</h2><p>进程由指令序列和资源（如内存，网络连接等）组成，线程就是一个进程中的一部分执行序列。因为一个进程中的多个线程间共享资源，因此在线程间切换时仅涉及指令序列的切换（对用户级线程，就像函数调用），进而较之进程间的切换，线程间的切换速度更高。多线程能够提高进程的执行速度，当进程的一个线程 (内核级线程) 先入<code>I/O</code>操作时，可以切换到另一个线程继续利用CPU，同时，多线程 (内核级线程) 还可以利用多核CPU（多个处理器，同一内存映射）的优势，使得多个线程可以在不同的CPU核上并行执行，从而进一步提高系统的并发度和效率。多线程还能提高进程的响应度，比如网页的加载，加载文字的进程执行好了就切换到显示进程，而不是等文字图片视频全部加载好了再执行显示进程。过多的线程会导致线程切换的开销增大，从而降低系统的效率，因此线程的数量也是一个_trade-off _问题</p><h2 id="52个用户级线程2个栈2个tcb"><a class="markdownIt-Anchor" href="#52个用户级线程2个栈2个tcb"></a> 5）2个用户级线程：2个栈，2个TCB</h2><p>用户级线程（ULT）对OS不可见，因此不可访问硬件资源，也不能利用多核CPU（为线程分配处理器硬件，需要线程进入OS内核）<br />两个栈：对2个用户级线程，如果共用一个栈，那么将可能导致函数返回时CPU转去执行另一个线程，而不是通过我们的<code>Yield</code>函数，这会造成意料之外的错误。为每个线程分配一个栈（栈顶信息保存在TCB中），那么在一个线程中由函数调用导致的地址返回将不会跳出本线程。<br /><code>Yield</code>函数：该函数要实现线程间的切换，直观的可能认为该函数内部应该有<code>jmp</code>指令实现跳转，但实际上该函数并不存在该指令，而是通过函数返回机制实现跳转，当<code>Yield</code>函数结束时，栈中弹出的返回地址就已经是进程2的了，<code>CS:IP</code>被赋值为该地址，由此CPU转到进程2执行，因此该函数内部仅有两个线程栈的切换</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    TCB1<span class="token punctuation">.</span>esp <span class="token operator">=</span> CPU<span class="token punctuation">.</span>esp<span class="token punctuation">;</span>    CPU<span class="token punctuation">.</span>esp <span class="token operator">=</span> TCB2<span class="token punctuation">.</span>esp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即更新当前线程的栈顶值并保存到该线程的TCB中，并将下一个线程的栈顶值赋给CPU中的<code>%esp</code>，<code>Yield</code>函数结束返回时完成跳转</p><img src="/2023/05/06/OS-Learning/HIT-OS/a660c4c01c2033e2876e3574083862bd.png" class=""><p><code>ThreadCreate</code>函数：要创建一个线程，就要分配给它需要的TCB，栈，并将栈顶信息存储在TCB中，以及将函数入口地址压入栈</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ThreadCreate</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token comment">// A is function address</span><span class="token punctuation">&#123;</span>    TCB<span class="token operator">*</span> tcb <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// allocate TCB</span>    <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// allocate stack</span>    <span class="token operator">*</span>stack <span class="token operator">=</span> A <span class="token punctuation">;</span>    tcp<span class="token punctuation">.</span>esp <span class="token operator">=</span> stack<span class="token punctuation">;</span>  <span class="token comment">// store stack pointer</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>旁注：TCB与PCB的区别</strong></p><blockquote><p>在操作系统中，TCB（Thread Control Block，线程控制块）和PCB（Process Control Block，进程控制块，在进程表中）是分别管理线程和进程的数据结构。以下是两者之间的区别：<br />TCB（线程控制块）：线程控制块是一个数据结构，用于存储有关进程中单个线程的信息。线程是进程中的轻量级、独立执行路径，共享同一地址空间和资源。TCB通常包含以下内容：</p><ol><li>线程ID：分配给线程的唯一标识符。</li><li>线程状态：线程的当前状态（例如就绪、运行、等待或已终止）。</li><li>程序计数器：线程将执行的下一条指令的地址。</li><li>CPU寄存器：线程上次执行时的CPU寄存器的值。</li><li>堆栈指针：指向线程在内存中的私有堆栈的指针。</li><li>调度和优先级信息：关于线程的优先级和调度要求的详细信息。</li></ol></blockquote><p>PCB（进程控制块）：进程控制块是一个数据结构，用于存储有关进程的信息。进程是运行程序的实例，具有自己的地址空间和资源。PCB包含以下内容：</p><blockquote><ol><li>进程ID：分配给进程的唯一标识符。</li><li>进程状态：进程的当前状态（例如就绪、运行、等待或已终止）。</li><li>程序计数器：进程将执行的下一条指令的地址。</li><li>CPU寄存器：进程上次执行时的CPU寄存器的值。</li><li>内存管理信息：关于分配给进程的内存的详细信息，包括基地址和限制地址。</li><li>I/O状态信息：关于进程使用的打开文件和I/O设备的信息。</li><li>调度和优先级信息：关于进程的优先级和调度要求的详细信息。</li><li>TCB列表：线程控制块列表，每个线程对应一个。</li></ol></blockquote><p>总之，TCB管理有关进程中单个线程的信息，而PCB管理有关整个进程的信息，包括所有线程。两者对于操作系统有效地管理和调度进程和线程都是必不可少的。</p><h2 id="62个内核级线程2套栈切换的5个步骤"><a class="markdownIt-Anchor" href="#62个内核级线程2套栈切换的5个步骤"></a> 6）2个内核级线程：2套栈，切换的5个步骤</h2><p>一个内核级线程有一套栈（用户级栈+内核级栈）。内核级栈中压入了用户级栈的<code>cs:ip</code>、<code>ss:sp</code>以便内核级线程能从内核态返回用户态<br />KLT就是能进入OS内核的ULT吗？</p><blockquote><p>不，内核级线程不是可以进入操作系统内核的用户级线程。内核级线程和用户级线程是截然不同的概念，它们在操作系统中的管理方式也不同。<br />内核级线程（Kernel-level Thread，简称KLT）是由操作系统内核直接管理和调度的线程。内核知道这些线程的存在，并对它们的调度、管理和协调拥有完全的控制权。内核级线程可以属于一个或多个进程，<strong>它们既可以在用户模式下运行（执行用户代码时），也可以在内核模式下运行（执行系统调用或内核代码时）</strong>。<br />另一方面，用户级线程（User-level Thread，简称ULT）是一种由用户空间库管理的轻量级线程，无需内核干预。操作系统并不知道这些线程的存在，所以它们的管理、调度和协调都由用户级库处理。用户级线程在用户模式下运行，只有在进行系统调用时才能进入内核模式，但此时内核并不知道线程上下文本身，而是将整个进程视为一个单元。<br />总之，内核级线程不是可以进入操作系统内核的用户级线程。它们是在操作系统中以不同方式管理的独立实体。</p></blockquote><p><strong>旁注：ULT和KLT的区别</strong></p><blockquote><p>用户级线程和内核级线程是在操作系统中实现线程的两种不同方法。线程允许任务并发执行，从而更有效地利用系统资源并提高整体系统性能。以下是它们之间的主要区别：</p><ol><li>管理：</li></ol></blockquote><p>○ 用户级线程（User-level Threads，简称ULTs）由用户空间库管理，无需内核干预。这意味着操作系统不知道这些线程的存在，管理、调度和协调都由用户级库处理。</p><blockquote><p>○ 内核级线程（Kernel-level Threads，简称KLTs）由操作系统内核直接管理。内核知道这些线程的存在，并对它们的调度、管理和协调拥有完全的控制权。<br />2. 调度：</p></blockquote><p>○ ULTs由用户空间库调度，这意味着它们可以有自己的自定义调度策略。<strong>内核不知道这些线程的调度，所以如果一个用户级线程阻塞，可能导致整个进程阻塞</strong>。</p><blockquote><p>○ KLTs由内核调度，内核使用系统范围的策略来确定它们的执行顺序。如果一个内核级线程阻塞，内核可以调度同一进程中的另一个线程，防止整个进程被阻塞。<br />3. 上下文切换：</p></blockquote><p>○ ULTs的上下文切换开销较低，因为切换发生在用户空间，不需要转换到内核模式。这使得用户级线程的上下文切换更快。</p><blockquote><p>○ KLTs的上下文切换开销较高，因为它们涉及从用户模式到内核模式的转换，然后再返回。这使得内核级线程的上下文切换更慢。<br />4. 可移植性：</p></blockquote><p>○ ULTs通常具有更好的可移植性，因为它们是通过用户空间库实现的，不依赖于内核级线程支持。这使得它们可以在不同的操作系统上使用，只需进行最少的更改。</p><blockquote><p>○ KLTs的可移植性较差，因为它们依赖于内核对线程的支持，这在不同的操作系统之间可能存在差异。<br />5. 资源共享：</p></blockquote><p>○ ULTs共享相同的资源，如文件描述符和内存，因为它们属于同一个进程。这使得线程间通信和同步更容易。</p><blockquote><p>○ KLTs可以属于不同的进程，这意味着它们可能拥有独立的资源，使得线程间通信和同步更复杂。<br />总之，用户级线程提供了更好的可移植性和较低的上下文切换开销，但由于内核对它们的调度不了解，它们的调度受到限制。另一方面，内核级线程提供了更好的调度和资源共享，但上下文切换开销更高，可移植性较差。</p></blockquote><p>切换的5个步骤:<br />线程A_用户栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>interrupt</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{\text{interrupt}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.100502em;vertical-align:-0.01100000000000012em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.089502em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">interrupt</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000012em;"><span></span></span></span></span></span></span></span></span>线程A_内核栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>线程A_TCB<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>线程B_TCB<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>线程B_内核栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>iret</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{\text{iret}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.100502em;vertical-align:-0.01100000000000012em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.089502em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">iret</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000012em;"><span></span></span></span></span></span></span></span></span>线程B_用户栈。</p><img src="/2023/05/06/OS-Learning/HIT-OS/257036f48e30c46dedcbdf50015da107.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/6275de0a9feabb7b06a305b4e04ba190.png" class=""><p>下面以系统调用<code>fork()</code>为中断，详细讲解这个5个步骤</p><h3 id="1-从fork中断开始用户栈到内核栈"><a class="markdownIt-Anchor" href="#1-从fork中断开始用户栈到内核栈"></a> 1. 从fork()中断开始，用户栈到内核栈</h3><p>初始状态时，一个用户程序在运行，此时使用它的用户栈。当它在程序中调用系统调用函数<code>fork()</code>时，根据前面我们讲解的系统调用背后发生的故事，CPU会转去执行<code>_syscall*</code>函数，并会执行到<code>int 0x80</code>指令。当CPU开始执行<code>int 0x80</code>之前，会将此时的<code>CS:IP</code>和<code>SS:IP</code>压入内核栈（通过tss找到）中，因为此时<code>int 0x80</code>还没开始执行，也就是说，CPU还未跳转到内核段中的中断处理程序<code>system_call</code>去执行，因此此时的<code>CS:IP</code>和<code>SS:IP</code>都是用户程序的，即<code>SS:IP</code>指向是用户栈，<code>CS:IP</code>指向的是用户程序中<code>int 0x80</code>的下一条指令。接着CPU执行<code>int 0x80</code>之后，CPU跳转到内核段的<code>system_call</code>执行，此时<code>SS:IP</code>转变为指向内核栈</p><img src="/2023/05/06/OS-Learning/HIT-OS/a660c4c01c2033e2876e3574083862bd.png" class=""><h3 id="2-判断阻塞执行schedule预置中断出口"><a class="markdownIt-Anchor" href="#2-判断阻塞执行schedule预置中断出口"></a> 2. 判断阻塞，执行schedule，预置中断出口</h3><p>CPU开始执行内核函数<code>system_call</code>，该函数首先压入一堆寄存器，因为是刚进入内核，因此这些寄存器还是之前用户态的值，这么做的目的是保存用户程序的状态。接着<code>system_call</code>通过查找函数表<code>_sys_call_table</code>调用<code>sys_fork</code>函数。执行完<code>sys_fork</code>函数之后，OS通过检查该线程PCB的<code>state</code>变量是否为<code>0</code>判断该线程是否变为阻塞态 或 该线程的时间片是否用完，再决定是否执行调度（schedule）</p><img src="/2023/05/06/OS-Learning/HIT-OS/97bcb18bfbfeb7e9317be7ad13681c7d.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/02e77af27b1c4e865e36db8907ca7b63.png" class=""><p>在<code>reschedule</code>函数中，先压入了包含<code>iret</code>指令的代码段的起始地址（标号：<code>ret_from_sys_call</code>）作为中断出口，然后跳转到<code>schedule</code>函数（位于<code>kernel/sched.c</code>）执行调度，即执行5段论的中间3段</p><img src="/2023/05/06/OS-Learning/HIT-OS/6275de0a9feabb7b06a305b4e04ba190.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/42cd427d395bd0887302dfbe5f3a095f.png" class=""><h3 id="3-执行切换过时的硬件切换-tss机制和现代的软件切换-tcb机制"><a class="markdownIt-Anchor" href="#3-执行切换过时的硬件切换-tss机制和现代的软件切换-tcb机制"></a> 3. 执行切换，过时的硬件切换-TSS机制和现代的软件切换-TCB机制</h3><p>在<code>schedule</code>函数中调用了<code>switch_to(next)</code>函数（位于<code>include/linux/sched.h</code>）用于完成切换5段论的中间三段，这里的<code>next</code>是根据调度算法选择的另一个进程的PCB（linux0.11没有线程的概念，因此这里称进程）。</p><img src="/2023/05/06/OS-Learning/HIT-OS/d198271aa8a29539467dd82ee47ef6ad.png" class=""><p>在linux-0.11中，线程切换使用了TSS机制：</p><img src="/2023/05/06/OS-Learning/HIT-OS/40edff8d78bfb0c20b5b843703546e03.png" class=""><p>关于TSS, 进行几点说明：</p><ol><li><strong>TSS实际上就是保存了一堆寄存器值的数据结构，这堆寄存器的值又体现了进程的当前状态</strong></li></ol><blockquote><p>任务状态段（Task State Segment，TSS）是x86架构中用于支持硬件任务切换的一种内存数据结构。TSS包含了与一个特定任务（例如，进程或线程）相关的信息，如CPU寄存器的值、段选择器和其他一些特定于任务的数据。<br />在x86架构中，任务切换可以通过硬件实现，使用任务寄存器（Task Register，TR）指向当前任务的TSS。当发生任务切换时，处理器会自动保存<strong>当前任务的状态</strong>到当前任务的TSS，并从新任务的TSS加载新任务的状态。<br />尽管TSS提供了一种硬件级别的任务切换机制，但它在实际应用中的效率较低，因为硬件任务切换涉及大量的内存访问和处理器操作。因此，许多现代操作系统，包括Linux，选择使用软件任务切换，即使用编程手段保存和恢复任务上下文，而不是依赖硬件实现的TSS机制。</p></blockquote><ol start="2"><li><strong>TSS的内容是TCB的子部分</strong></li></ol><blockquote><p>任务状态段（Task State Segment，TSS）是一种用于保存任务（进程或线程）状态的数据结构。然而，TSS是一种特定于x86体系结构的硬件数据结构，用于支持硬件任务切换。它在内存中存储任务的上下文信息，包括寄存器值、特权级等。<br />线程控制块（Thread Control Block，TCB）与TSS有相似之处，但它是一种软件概念，而不是硬件概念。TCB是操作系统用于表示和管理线程的内核数据结构。它通常包括线程上下文（如寄存器值）、线程状态、优先级、调度信息等。与TSS类似，TCB也用于在任务切换时保存和恢复线程的上下文信息。<br />尽管TSS和TCB都涉及保存任务状态信息，但它们在概念上和用途上有所不同：</p><ol><li>硬件与软件：TSS是一种硬件数据结构，特定于x86架构，用于支持硬件任务切换。而TCB是一种软件数据结构，由操作系统实现，用于管理线程。</li><li>依赖与通用性：TSS依赖于特定的CPU架构（如x86），而TCB是一种通用的操作系统概念，可以在多种CPU架构上实现。</li><li>作用域：TSS主要关注任务的硬件状态，例如寄存器值和特权级。而TCB除了保存线程的硬件状态，还包括其他与线程管理和调度相关的信息，如线程状态、优先级等。</li></ol></blockquote><p>总之，虽然TSS和TCB在保存任务状态方面有相似之处，但它们分别代表硬件和软件层面的概念。在现代操作系统中，通常使用软件任务切换（通过TCB）而不是硬件任务切换（通过TSS），因为软件任务切换更加高效且易于维护。</p><ol start="3"><li><strong>TSS机制下的线程切换</strong></li></ol><blockquote><p>假设我们有两个线程：线程A和线程B，它们各自有一个任务状态段（TSS）。我们将通过x86硬件任务切换机制实现从线程A切换到线程B。以下是使用TSS机制进行线程切换的步骤：</p><ol><li>为线程A和线程B创建TSS：首先，在内存中分配两个TSS结构，分别用于保存线程A和线程B的状态。每个TSS包含了线程的寄存器值、段选择器等信息。同时，我们需要为每个线程创建一个对应的TSS描述符，并将它们添加到全局描述符表（Global Descriptor Table，GDT）中。</li><li>设置任务寄存器（TR）：将任务寄存器（TR）设置为当前线程（线程A）的TSS描述符在GDT中的选择器。这告诉处理器当前正在执行的任务的TSS在哪里。</li><li>准备进行任务切换：为了从线程A切换到线程B，我们需要执行一个特殊的指令（<code>ljmp</code>）来触发硬件任务切换。这需要使用线程B的TSS描述符在GDT中的选择器作为操作数。</li><li>触发硬件任务切换：当处理器检测到这个特殊的指令，它会自动执行以下操作：<ul><li>保存线程A的当前状态到线程A的TSS中，包括通用寄存器、段寄存器、标志寄存器、指令指针等。</li><li>更新线程A的TSS中的任务链接字段，使其指向线程B的TSS。这用于在将来返回线程A时进行任务切换。</li><li>将任务寄存器（TR）更新为线程B的TSS描述符在GDT中的选择器。</li><li>从线程B的TSS加载线程B的状态，包括通用寄存器、段寄存器、标志寄存器、指令指针等。</li><li>更新线程B的TSS中的任务链接字段，使其指向线程A的TSS。</li></ul></li><li>开始执行线程B：处理器已经完成了从线程A到线程B的任务切换，现在开始执行线程B的代码。</li></ol></blockquote><p>任务链接字段是任务状态段（Task State Segment，TSS）中的一个字段，用于在硬件任务切换过程中保存与当前任务关联的前一个任务的信息。任务链接字段中存储的是前一个任务的TSS选择器，该选择器指向全局描述符表（Global Descriptor Table，GDT）中相应的TSS描述符。这样，在将来需要从线程B切换回线程A时，处理器可以通过线程B的任务链接字段找到线程A的TSS，并完成任务切换。</p><blockquote><p>通过以上步骤，我们完成了从线程A切换到线程B的任务切换。需要注意的是，这个过程完全由硬件自动完成，而不需要操作系统通过编程手段来保存和恢复任务状态。然而，正如前面所提到的，硬件任务切换效率较低，因此现代操作系统通常使用软件任务切换机制。</p></blockquote><p><strong>旁注：iret指令不仅弹出CS:IP</strong></p><blockquote><p>iret（中断返回）指令是x86架构中用于从中断或异常处理程序返回的指令。它不仅仅弹出代码段寄存器（CS）和指令指针（IP），而且在中断或异常处理程序返回时会将一些其他重要的寄存器值恢复到原始状态。<br />具体来说，当执行iret指令时，处理器会执行以下操作：</p><ol><li>弹出标志寄存器（FLAGS）的值，并恢复其内容。</li><li>弹出代码段寄存器（CS）的值，并恢复其内容。</li><li>弹出指令指针（IP）的值，并恢复其内容。</li></ol></blockquote><p>在中断和异常处理程序中，处理器还会自动将其他重要寄存器的值压入栈中，例如堆栈段寄存器（SS）和堆栈指针（SP）。在这种情况下，执行iret指令时，处理器还需要从栈中弹出这些寄存器的值。</p><blockquote><p><strong>总之，iret指令不仅仅弹出CS和IP，还负责恢复其他相关寄存器的值，从而使处理器能够在中断或异常处理程序结束后继续执行原始代码。需要注意的是，iret指令不会弹出整个函数栈上的所有内容，而只会弹出保存在栈上的这些寄存器值。</strong><br />现代操作系统使用软件切换，通过如用户级程序那样编程实现：保存当前CPU中的<code>%esp</code>值到进程A，将进程B的<code>%esp</code>值加载到CPU，通过<code>ret</code>弹出进程B内核栈的函数返回地址赋值给IP，而该函数地址（标号：<code>ret_from_sys_call</code>）是一段包含<code>iret</code>的代码，由此接着CPU会执行到<code>iret</code>指令，从进程B的内核栈中弹出用户代码所在的<code>CS:IP</code>，状态寄存器<code>FLAGS</code>，<code>SS:IP</code>，从而切换到进程B的用户代码执行，并且使用的栈也切换为用户栈</p></blockquote><p><img src="attachment/40edff8d78bfb0c20b5b843703546e03.png" alt="" /><img src="attachment/d198271aa8a29539467dd82ee47ef6ad.png" alt="" /></p><h2 id="7fork函数从父进程创建子进程关键在copy_process函数"><a class="markdownIt-Anchor" href="#7fork函数从父进程创建子进程关键在copy_process函数"></a> 7）fork函数从父进程创建子进程，关键在copy_process函数</h2><h3 id="1-进入copy_process函数"><a class="markdownIt-Anchor" href="#1-进入copy_process函数"></a> 1. 进入<code>copy_process</code>函数</h3><p>CPU执行<code>sys_fork</code>函数（位于<code>kernel/system_call.s</code>），将在内核栈中压入的寄存器当作参数传递给<code>copy_process</code>（位于<code>kernel/fork.c</code>），这里可以看见<code>copy_process</code>原型的参数顺序刚好与系统调用进入内核时的压栈顺序相反。这些寄存器代表了父进程的状态，将用于<code>copy_process</code>创建子进程</p><img src="/2023/05/06/OS-Learning/HIT-OS/9f2dfda5f53b12dff0c5b678c0230fe1.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/545f6b671736fb44dfde1345b0c75cff.png" class=""><h3 id="2-为子进程分配pcb"><a class="markdownIt-Anchor" href="#2-为子进程分配pcb"></a> 2. 为子进程分配PCB</h3><p>在<code>copy_processs</code>函数内部，首先调用了<code>get_free_page</code>函数为子进程分配了大小为一个页表（结合第一章，大小为4KB）的内存，进程的PCB将会放在这段内存里（后续会看到这段内存还作为了子进程的内核栈）。<code>get_free_page</code>函数会在内核的内存管理系统中找到一个尚未使用的物理页面，并返回一个指向该页面起始地址的指针（通过内存位图<code>mem_map</code>,回忆第一章，0代表空闲）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">get_free_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// allocate new memory page to child process</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着<code>copy_process</code>在新进程的PCB中设置各种状态（例如进程号、进程状态等），为新进程分配一个新的进程号(PID)，并初始化其各种状态，如进程状态、父进程ID、时间片计数器等。</p><img src="/2023/05/06/OS-Learning/HIT-OS/a7dc7f4a3fb6f6a4c1c13204acce6c2e.png" class=""><h3 id="3-为子进程创建内核栈"><a class="markdownIt-Anchor" href="#3-为子进程创建内核栈"></a> 3. 为子进程创建内核栈</h3><p>子进程的内核栈是通过设置子进程的 TSS 结构体中的 <code>esp0</code>和<code>ss0</code>字段来实现的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-></span>tss<span class="token punctuation">.</span>esp0 <span class="token operator">=</span> PAGE_SIZE <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于系统给PCB指针<code>p</code>分配了1页新内存,所以<code>PAGE_SIZE + (long) p</code> 让 <code>esp0</code>正好指向该页顶端  ( 还记得吗? 栈是由高地址到低地址堆起来的 ) 。<br />当然，我们还需要设置<code>ss0</code>，<code>p-&gt;tss.ss0 = 0x10</code> 语句的作用是设置子进程的内核栈所在的段选择子（Segment Selector）为内核数据段（Kernel Data Segment）的选择子，0x10 是内核数据段选择子的值。设置子进程的内核栈所在的段选择子为内核数据段的选择子，可以确保子进程的内核栈位于内核数据段中，从而使子进程可以访问内核中的数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ss0 <span class="token operator">=</span> <span class="token number">0x10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样, <code>ss0:esp</code>就用作了子进程在内核态执行时的栈顶指针, 子进程拥有的页表的高地址开始的部分就用作了子进程的栈。<br /><strong>旁注：esp与esp0</strong></p><blockquote><p>esp 和 esp0 都是x86架构下的寄存器。<br />esp（Extended Stack Pointer）是x86架构下的栈指针寄存器，用于指向当前栈顶的位置。在进程执行期间，esp 寄存器通常用于指向进程的用户栈或内核栈的栈顶位置。<br /><strong>esp0 是x86架构下的TSS（Task State Segment）结构体中的一个字段，用于指示内核栈的栈顶位置</strong>。当一个进程从用户态切换到内核态时，操作系统需要使用该进程的内核栈，以保存该进程在内核态执行期间使用的寄存器状态等信息。因此，内核需要知道该进程的内核栈的位置。在Linux 0.11版本中，进程的TSS结构体中的 esp0 字段存储了该进程的内核栈的起始位置，当该进程从用户态切换到内核态时，内核将使用 esp0 中存储的值来确定该进程的内核栈的栈顶位置。<br />需要注意的是，在Linux 0.11版本中，由于没有使用分段机制，TSS中的段基地址为0，因此 esp0 存储的是相对于物理内存起始位置的偏移量。在进程切换时，内核需要将 esp0 中的偏移量加上物理内存的起始地址，以计算出实际的内核栈顶指针位置。</p></blockquote><h3 id="4-将父进程状态复制给子进程"><a class="markdownIt-Anchor" href="#4-将父进程状态复制给子进程"></a> 4. 将父进程状态复制给子进程</h3><p><code>copy_process</code>将父进程的状态赋值给子进程。前面我们提到过，TSS是一个保持进程当前状态的数据结构，而进程的状态是由一堆寄存器体现的，因此在这一步中，<code>copy_process</code>将传入的寄存器参数全部用于初始化子进程的TSS，由此完成状态的复制。</p><img src="/2023/05/06/OS-Learning/HIT-OS/5e39b3abb1bc5e7f4330d928004e1682.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/97bcb18bfbfeb7e9317be7ad13681c7d.png" class=""><p>注意这里，子进程<code>eip</code>、<code>esp</code>、<code>ss</code>等寄存器均是父进程的值，而这些值是在父进程进入内核时压入的值，因此这些值是父进程在用户状态下的值，由此可见，子进程和父进程共享用户栈，因为它们的<code>ss:esp</code>指向了同一个。并且无论是子进程还是父进程，返回用户状态时，都会返回到同一条语句的位置( <code>int 0x80</code>的下一条指令)，因为它们的<code>CS:IP</code>指向了同一个地址</p><img src="/2023/05/06/OS-Learning/HIT-OS/9f2dfda5f53b12dff0c5b678c0230fe1.png" class=""><p><strong>旁注：父子进程共享用户栈，只存在于早期linux中</strong></p><blockquote><p>CPU进程调度中，子进程独立于父进程吗？<br />在CPU进程调度中，子进程是独立于父进程的。当一个进程创建了一个子进程后，子进程会拥有自己的进程ID，并且会复制父进程的内存空间和代码段。这样，子进程就可以独立地运行，并且可以在其自己的地址空间中执行代码。子进程的运行不会影响父进程的运行，而且子进程可以与父进程并行执行。但是，子进程可以通过进程间通信（IPC）机制与父进程进行通信，以便共享信息和资源。<br />要是父进程结束了，父进程伴随的用户空间也释放了，那子进程怎么执行？子进程不是和父进程共享用户空间吗？<br />当父进程结束时，它的用户空间会被释放，但是子进程并不会受到影响。子进程在创建时会复制父进程的内存空间和代码段，这些内存空间和代码段被子进程独立地使用，因此子进程并不与父进程共享用户空间。这意味着，即使父进程已经结束，子进程仍然可以继续运行，并且可以在其自己的地址空间中执行代码。<br />需要注意的是，当父进程结束时，子进程的父进程ID会被设置为1，也就是init进程的ID。这是因为在Unix-like操作系统中，init进程是所有进程的祖先进程，当一个进程的父进程结束时，它的父进程ID会被设置为init进程的ID。<br />你这么说，那为什么在linux0.11中，子进程和父进程指向同样的用户栈<br />在早期的Linux内核版本（如0.11版本）中，子进程确实会与父进程共享用户空间，包括用户栈。这是因为在这个版本的内核中，子进程的创建是通过在父进程的地址空间中复制一个新的进程描述符来实现的。这个新的进程描述符包含了子进程的所有信息，包括代码段、数据段、堆栈和文件描述符等。因此，子进程和父进程共享同样的用户栈。<br />不过，在后来的版本中，Linux内核对进程创建和管理进行了改进，子进程的创建不再与父进程共享用户空间。现代的Linux内核中，子进程会创建自己的用户栈，这样就可以避免子进程和父进程之间的干扰和冲突。<br />那子进程怎么执行与父进程一样的用户代码？<br />在现代的Linux内核中，子进程创建时会复制父进程的代码段、数据段和堆栈等信息，但是子进程会创建自己的用户栈。这样，子进程就可以在自己的用户栈上执行与父进程相同的用户代码，而不会与父进程共享用户栈。子进程和父进程执行相同的代码，但是它们在不同的用户栈上执行，这样就可以避免子进程和父进程之间的干扰和冲突。<br />需要注意的是，子进程复制父进程的代码段、数据段和堆栈等信息是通过写时复制（Copy-on-Write，COW）技术来实现的。这意味着，当父进程或子进程需要修改这些信息时，内核会为它们分配新的内存空间，而不是在原来的内存空间中进行修改。这样可以避免父进程和子进程之间的内存冲突，提高系统的性能和稳定性。<br />子进程复制的代码段，是int 0x80之后的部分吗，我认为不包含是父进程调用fork函数之前的部分<br />您的理解是正确的。在现代的Linux内核中，子进程复制的代码段包含了父进程调用fork函数之后的所有代码，但是不包括调用fork函数之前的代码。这是因为在调用fork函数之前的代码是父进程的独有部分，而在调用fork函数之后的代码是父进程和子进程共享的部分。<br />具体来说，当父进程调用fork函数时，内核会为子进程创建一个新的进程描述符，并复制父进程的代码段、数据段和堆栈等信息。但是，由于fork函数是在父进程中调用的，因此子进程不会复制调用fork函数之前的代码。子进程从fork函数返回的位置开始执行，这个位置是在int 0x80指令之后的位置，也就是父进程调用fork函数之后的位置。<br />需要注意的是，子进程和父进程之间的区别是子进程会从fork函数返回0，而父进程会从fork函数返回子进程的进程ID。这样，父进程和子进程就可以通过返回值来区分彼此。</p></blockquote><h3 id="5-进程的返回值"><a class="markdownIt-Anchor" href="#5-进程的返回值"></a> 5. 进程的返回值</h3><blockquote><p>从父进程返回的是子进程的PID，从子进程返回的是0</p></blockquote><p><code>cope_process</code>到了尾声，它将创建的子进程的PID作为返回值，即将寄存器<code>%eax</code>设置为子进程的PID值，由此<code>sys_fork</code>返回子进程PID。</p><img src="/2023/05/06/OS-Learning/HIT-OS/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><p>如果在执行<code>sys_fork</code>函数时父进程<strong>没有</strong>遇到阻塞，即不会在执行完<code>sys_fork</code>之后调用<code>reschedule</code>函数，那么中断处理程序<code>system_call</code>函数就会返回子进程的PID，进而在用户态<code>fork</code>函数的<code>int 0x80</code>指令结束后<code>%eax</code>的值就是子进程PID，并作为返回值<code>res</code>返回给用户程序</p><img src="/2023/05/06/OS-Learning/HIT-OS/545f6b671736fb44dfde1345b0c75cff.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/77ee6da89546a4114df2d33fbf821a72.png" class=""><p>子进程的<code>%eax</code>在创建时被设置为<code>0</code>，在父进程中，如果创建好了子进程，但如果后续遇到了阻塞，执行了<code>reschedule</code>函数，调度到了子进程，执行进程的切换，CPU开始执行子进程。那么从子进程返回时，是返回到父进程相同的用户程序位置。因此在用户程序可以对<code>fork</code>的返回值进行判断，如果为<code>0</code>则是从子进程返回，反之从父进程返回。<br />看一个示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am son!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS/77ee6da89546a4114df2d33fbf821a72.png" class=""><p>这里的输出表明，父进程先被执行，<code>fork</code>函数返回子进程的PID，输出<code>&quot;I am father !&quot;</code>。后续再执行子进程，<code>fork</code>函数返回<code>0</code>，输出<code>&quot;I am son !&quot;</code><br />什么情况下会先输出<code>&quot;I am son !&quot;</code>，再输出<code>&quot;I am father!&quot;</code>呢？<br />当父进程创建好了子进程之后遇到阻塞，或者时间片用完了，CPU就会执行调度程序<code>schedule</code>，调度到子进程，那么子进程就会先于父进程执行。不仅如此，在多核CPU上，子进程和父进程可能同时执行，如果子进程执行的更快，也会先执行输出<br />下面我们来验证一下：<br />在<code>fork</code>之后，父进程在打印<code>&quot;I am father&quot;</code>之前先调用<code>wait</code>函数等待子进程结束后再继续执行。那么如果子进程还没有结束或开始执行，<code>wait</code>函数会阻塞父进程，开始执行子进程，直到子进程结束并返回其退出状态。因此一定会先输出<code>&quot;I am son !&quot;</code>，再输出<code>&quot;I am father!&quot;</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am son!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS/69e55d7cd42de97dab21bb828f85738e.png" class=""><h2 id="8-详解schedule函数"><a class="markdownIt-Anchor" href="#8-详解schedule函数"></a> 8) 详解schedule函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>next<span class="token punctuation">,</span>c<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token comment">// 进程表</span><span class="token comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>  <span class="token comment">// 唤醒的收到信息的等待进程</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&lt;</span> jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGALRM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>_BLOCKABLE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>blocked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">==</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">=</span>TASK_RUNNING<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* this is the scheduler proper: */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// counter有两个含义</span>        <span class="token comment">// 1. 进程运行过程中动态变化的优先级值 (priority是初始优先级，在进程创建时分配)</span>        <span class="token comment">// 2. 进程的时间片</span>c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">=</span> NR_TASKS<span class="token punctuation">;</span> <span class="token comment">// 最大的进程数</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 进程在进程表中的索引值 = PID - 1 ，这里是指向最后一个进程的后一个位置</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token operator">--</span>p<span class="token punctuation">)</span>  <span class="token comment">// 减法先执行，因此不会发生越界访问</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token comment">// 这个if语句，用于在所有就绪态的进程中</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">,</span> next <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 挑出counter值最大的那个，</span>                                              <span class="token comment">// 这里的counter可视为含义1-优先级，即挑出优先级最大的那个</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 挑出了counter设置为next，跳出</span>                <span class="token comment">// 所有就绪态的进程的剩余可执行时间均为0，则挑不出可以执行的next，即表示所有就绪进程的时间片都用完了，</span>        <span class="token comment">// 那么就需要重置时间片。如何重置呢？</span>        <span class="token comment">// 根据进程的初始优先级priority,将所有进程重置时间片(包括阻塞态的进程)，priority越大，counter越大, </span>        <span class="token comment">// 具体来说就是将当前counter值翻倍，再加上初始优先级priority</span>        <span class="token comment">// 由此可见，进程如果被多次执行这条语句，其优先级会越来越大。而阻塞的进程才会被多次执行该语句，</span>        <span class="token comment">// 因此在阻塞状态下越久的进程，优先级counter的值会越大，保证了这样的进程转为就绪态后能立即执行，避免了饥饿</span>        <span class="token comment">// 因此该函数是时间片轮转调度和优先级调度的结合，并只用了一个counter变量</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>priority<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">switch_to</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// next就是选择的进程在进程表中的索引</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-信号量实现进程的走走停停"><a class="markdownIt-Anchor" href="#9-信号量实现进程的走走停停"></a> 9) 信号量实现进程的走走停停</h2><p>多进程的合理推进体现在进程能在正确的地方停下，并在符合条件的情况下继续执行，即正确的走走停停。多进程通过对信号量(semaphore)的检测(test)和设置(set)实现这一点。下面以经典的生产者-消费者为例讲述这个概念<br />消费者向BUFFER索取资源时，对信号量有以下逻辑</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">P</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span> <span class="token comment">// 消费资源</span><span class="token punctuation">&#123;</span>    <span class="token operator">--</span>s<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token comment">// 索取一个资源</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">sleep</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果资源数为负数，则说明资源是欠缺状态，该进程进入睡眠(停)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生产者向缓冲区BUFFER写入时，对信号量有以下逻辑</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">V</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span> <span class="token comment">// 生产资源</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>s<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">// 生产一个资源</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token function">wakeup</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果资源增1后为非正数，那之前资源必然欠缺，必然有进程在睡眠，因此唤醒(走)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，通过对信号量的test&amp;&amp;set能够实现进程的走走停停</p><img src="/2023/05/06/OS-Learning/HIT-OS/022618c6c2df7c53f1385e093b46d9bf.png" class=""><h2 id="10-临界区机制对信号量提供保护"><a class="markdownIt-Anchor" href="#10-临界区机制对信号量提供保护"></a> 10) 临界区机制对信号量提供保护</h2><p>进程对信号量执行修改时，可能会因为时间片结束而阻塞，CPU转去执行其它进程，而其它进程也可能修改同一信号量，这将造成信号量的语义错误，例如对资源信号量<code>s</code>的修改</p><img src="/2023/05/06/OS-Learning/HIT-OS/5fd1fddb244160f8985c8162d69751f1.png" class=""><p>这种错误，归根结底是不可预知的调度顺序造成的，因此我们引入临界区的概念：<br />临界区就是在同一时刻只能有一个进程进入的代码段，这个代码段的作用是修改信号量，因此每个进程都有这个代码段，但同一时刻只能有一个进程进入该代码段进行修改操作，避免了一个进程修改到中途，而另一个进程执行修改的情况</p><img src="/2023/05/06/OS-Learning/HIT-OS/022618c6c2df7c53f1385e093b46d9bf.png" class=""><p>对以上结构，有以下3个原则：</p><img src="/2023/05/06/OS-Learning/HIT-OS/07b1a26be34a52d64824abce91c15e76.png" class=""><h2 id="11-进入临界区的算法"><a class="markdownIt-Anchor" href="#11-进入临界区的算法"></a> 11） 进入临界区的算法</h2><h3 id="1-轮转法turn"><a class="markdownIt-Anchor" href="#1-轮转法turn"></a> 1. 轮转法（turn）</h3><p>通过一个变量，实现互斥关系<br />这个方法存在的问题在于，如果P0进入临界区并退出后，P1一直得不到调度，而P0也因为设置了turn =1 而无法进入临界区，不满足有空让进</p><img src="/2023/05/06/OS-Learning/HIT-OS/7210c3d6fbde68b1e7705b12b56e6d38.png" class=""><h3 id="2-标记法flag"><a class="markdownIt-Anchor" href="#2-标记法flag"></a> 2. 标记法（flag）</h3><p>为每个进程分配一个标记，在进入区通过检测其它进程的标签检测是否有其它进程想进入临界区，如果没有，则进入临界区<br />这个方法的问题在于，如果P0执行完<code>flag[0] = true</code>语句后阻塞，调度到P1，那么此时<code>flag[0]</code>，<code>flag[1]</code>都是true，将没有进程能进入临界区</p><img src="/2023/05/06/OS-Learning/HIT-OS/022618c6c2df7c53f1385e093b46d9bf.png" class=""><h3 id="3-peterson算法"><a class="markdownIt-Anchor" href="#3-peterson算法"></a> 3. Peterson算法</h3><img src="/2023/05/06/OS-Learning/HIT-OS/d589f866c98c4ea05c31a837ae10ba82.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/75eb7fac02ee199b822f199e5e69d09f.png" class=""><h3 id="4-多个进程-面包店算法"><a class="markdownIt-Anchor" href="#4-多个进程-面包店算法"></a> 4. 多个进程: 面包店算法</h3><img src="/2023/05/06/OS-Learning/HIT-OS/75eb7fac02ee199b822f199e5e69d09f.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/07b1a26be34a52d64824abce91c15e76.png" class=""><h3 id="5-硬件方法-关中断开中断"><a class="markdownIt-Anchor" href="#5-硬件方法-关中断开中断"></a> 5. 硬件方法: 关中断，开中断</h3><p><code>cli()</code>置标志寄存器的IF位为0，CPU不响应可屏蔽中断（时钟中断属于可屏蔽中断），即关中断。<code>sli()</code>置标志寄存器的IF位为1，CPU响应可屏蔽中断。这样保证了在执行临界区代码时，进程不会因为时间片用完了而调度，间接实现了原子操作<br />但由于多核CPU有多个处理器，而进程执行<code>cli</code>和<code>sti</code>只能影响正在执行它的核，而不能保证其它处理器是不响应可屏蔽中断的状态，因此其它核可能执行会进入临界区的进程，引发信号量错误</p><img src="/2023/05/06/OS-Learning/HIT-OS/0cf71efb20d9854b0a1e6e1cfb8a3252.png" class=""><h3 id="6-原子指令法"><a class="markdownIt-Anchor" href="#6-原子指令法"></a> 6. 原子指令法</h3><img src="/2023/05/06/OS-Learning/HIT-OS/7210c3d6fbde68b1e7705b12b56e6d38.png" class=""><h2 id="12-sleep_on中隐藏的队列"><a class="markdownIt-Anchor" href="#12-sleep_on中隐藏的队列"></a> 12) sleep_on中隐藏的队列</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> current<span class="token punctuation">;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        tmp<span class="token operator">-></span>state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>队列就隐藏在这两条语句中：<code>tmp = *p;</code> <code>*p=current</code><br />这条语句让<code>p</code>指向的指针(图中用空白方块表示) 指向 当前进程的PCB <code>current</code>，而让一个临时变量<code>tmp</code>指向原队列中的队首PCB，<code>tmp</code>存储在当前进程的内核栈中，因此在执行这个进程时，可以通过tmp找到等待队列的下一个进程，而在“下一个进程”的内核栈中也有一个临时变量<code>tmp</code>指向“下下个进程”，因此这个队列通过每个进程中的tmp链接起来了</p><img src="/2023/05/06/OS-Learning/HIT-OS/a05e697174deb4b8d970e125f4076696.png" class=""><p>当进程被重新唤醒后，进程从上次停下的地方即sleep_on函数中的<code>schedule</code>语句之后继续执行，因此执行的是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        tmp<span class="token operator">-></span>state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//  唤醒下一个进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果存在这样一种调度顺序，即唤醒下一个进程后，CPU就调度到下一个进程，那么被唤醒的进程就将不断的唤醒等待队列中的下一个进程，直至唤醒所有进程，然后由schdule函数决定调度谁。这样做对等待同一信号量的多个进程来说，就不只是先来先执行了，而是优先级高的执行（结合P操作中的<code>while</code>语句(而不是常规的<code>if</code>语句)）</p><h1 id="4-内存管理"><a class="markdownIt-Anchor" href="#4-内存管理"></a> 4. 内存管理</h1><h2 id="1-进程载入内存-运行时重定位"><a class="markdownIt-Anchor" href="#1-进程载入内存-运行时重定位"></a> 1) 进程载入内存: 运行时重定位</h2><p>运行时重定位，也就是常说的动态重定位，下面以一个例子来讲述<br />假设进程中有一个函数调用指令<code>call 0x40</code>(假设该语句在段的起始位置)，该语句的目标地址是<code>0x40</code>（即相对于段的偏移量是<code>0x40</code>），当进程被载入内存的空闲区域后，<code>call 0x40</code>位于地址<code>0x1000</code>，那么实际上该该语句要跳转的目标在地址<code>0x1040</code>处，但是如果没有地址转换机制，CPU在<code>call 0x40</code>时只会跳转到<code>0x40</code>处，这将产生错误。因此我们需要有一种在执行语句时(即程序执行时)能够进行地址转换的机制。<br />运行时重定位就是这样一种机制，操作系统在进程载入内存时，记下它在内存中的起始地址（即基地址，在这个例子中是<code>0x1000</code>）放入进程的PCB中。当调度到这个进程时，OS将PCB中的基地址写入CPU的基地址寄存器（EBX），在执行进程的指令时，操作系统会将指令中的地址（称逻辑地址）加上基地址寄存器中保存的基地址得到物理地址，并将这个计算得到的物理地址作为目标地址。<br />这里对逻辑地址进行阐述：</p><blockquote><p>进程的逻辑地址就是将其看作从 0 开始的一段程序。每个进程在其逻辑地址空间中都有自己的“私有”视图，包括代码、数据、堆和栈等不同的内存区域。进程在编写和执行时，通常会使用这些逻辑地址来访问内存。<br />逻辑地址的一个优点是它们允许程序员专注于程序本身的逻辑结构，而无需关心底层的物理内存布局。逻辑地址空间为进程提供了一个抽象层，使其看起来就像它是在一个独立的、从 0 开始的内存空间中运行。<br />操作系统负责将这些逻辑地址转换为虚拟地址（如果使用了段表的话），然后再将虚拟地址转换为物理地址。这种地址转换机制使得每个进程都可以在自己的地址空间中独立运行，同时确保它们不会相互干扰或访问其他进程的内存。</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/07b1a26be34a52d64824abce91c15e76.png" class=""><h2 id="2-运行时重定位助力进程的交换"><a class="markdownIt-Anchor" href="#2-运行时重定位助力进程的交换"></a> 2) 运行时重定位助力进程的交换</h2><p>当进程阻塞时，操作系统可能会选择将其从内存中换出（swap out），以释放内存资源供其他进程使用。当进程重新成为就绪态并被CPU调度到时，进程需要重新载入内存，那么此时进程所在的内存可能就不是之前的那个内存地址，根据运行时重定位机制，此时进程PCB中关于进程基地址的信息被更新，因此进程换出换入后仍然可以继续正确的执行，而不会发生错误的内存访问。<br />编译时重定位（静态重定位）之所以被淘汰，就是因为它不支持进程换入换出过程中进程地址的变化，进程只能放入内存的固定位置，该机制在程序被编译时根据进程即将载入的位置而修改程序的源码，例如进程将载入内存地址<code>0x1000</code>处（所以该机制还要预留内存，确保这个内存空闲），那么编译器在编译它时，将修改<code>call 0x40</code>为<code>call 0x1040</code>。</p><h2 id="3-进程分段"><a class="markdownIt-Anchor" href="#3-进程分段"></a> 3) 进程分段</h2><p>进程之所以要分段（编译器的任务），是因为不同的程序需要访问的数据和代码具有不同的特点和访问权限，需要分别存储在不同的内存区域中，以便操作系统进行管理和保护。<br />常见的进程内存分段包括代码段、数据段、堆栈段等。</p><blockquote><p>代码段（Code Segment）用于存储程序的可执行代码，包括函数、指令和常量等。代码段通常具有只读权限，即程序在执行过程中无法修改代码段中的内容。这种只读权限可以保证程序执行的安全性，防止程序意外修改自身的代码。<br />数据段（Data Segment）用于存储程序中已经初始化的全局变量、静态变量和常量等。数据段通常具有读写权限，允许程序在执行过程中修改数据段中的数据。由于数据段中的数据通常是程序的重要状态，因此需要进行合理的管理和保护。<br />堆栈段（Heap and Stack Segment）用于存储程序执行时动态分配的内存和函数调用时的局部变量、参数、返回值等。堆和栈通常是分开的，其中堆用于存储动态分配的内存，而栈用于存储函数调用时的临时数据。堆和栈的大小是动态变化的，因此需要进行动态的内存管理和保护。</p></blockquote><p>通过将进程内存分为不同的段，操作系统可以针对不同的段进行不同的内存管理和保护，从而提高程序的安全性和稳定性。<br />同时，进程内存分段还有助于提高内存的利用率，从而提高系统的性能和效率。进程内存分段可以提高内存利用率的原因主要有以下两点：</p><blockquote><ol><li>内存分段可以针对不同类型的数据和代码进行优化存储。例如，代码段通常具有只读权限，因此可以共享一份代码段数据，以便节约内存空间。另外，堆和栈的大小是动态变化的，因此需要进行动态的内存管理和分配，从而提高内存利用率。</li><li>内存分段可以提高内存的可重用性和共享性。不同进程中的相同类型的数据和代码可以共享一份内存空间，从而避免重复分配内存空间，提高内存利用率。例如，操作系统可以将多个进程中相同的动态链接库代码段共享一份内存空间，从而节约内存空间。</li></ol></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/a05e697174deb4b8d970e125f4076696.png" class=""><h2 id="4-进一步认识ldt与gdt"><a class="markdownIt-Anchor" href="#4-进一步认识ldt与gdt"></a> 4) 进一步认识LDT与GDT</h2><p>内存中进程的各段是分离的，而CPU访问指令/数据的方式是&lt;段号，段内偏移&gt;，因此要访问进程中的指令/数据，CPU就需要知道进程各段的起始地址，这个信息就保存在进程的段表中，即LDT (Local Descriptor Table) 。进程在执行指令和访问数据时，先查询LDT获取基地址，进而得到目标地址，再执行操作。<br />这里再详细阐述一下CPU保护模式下用于寻址的段选择子(以CS为例)</p><blockquote><p>CS是在x86架构中的一个寄存器，用于存储CPU当前正在执行的代码段的段选择子。段选择子是一个16位的值，包含了两部分信息：段描述符表中该段描述符的索引值（Index，可以理解为段号），以及一个RPL（Request Privilege Level）字段，用于限制当前进程的访问权限。在执行指令时，CPU会使用CS中存储的段选择子来访问GDT（Global Descriptor Table）或LDT（Local Descriptor Table）中的段描述符，并从中获取当前代码段的基地址和限长等信息，从而计算出代码段中指令的实际物理地址。<br />每当CPU加载一个新的段选择子时，它会将对应的段描述符缓存到GDTR指定的内存区域中。这个缓存区域称为段描述符缓存（Descriptor Cache）。这样，在下一次访问同一个段时，CPU就可以直接从段描述符缓存中获取对应的段描述符，而不需要再次访问GDT。这种缓存机制可以提高内存访问效率，并减少对GDT的访问次数。</p><img src="/2023/05/06/OS-Learning/HIT-OS/7210c3d6fbde68b1e7705b12b56e6d38.png" class=""><p>段描述符（64bits）是在GDT或LDT中的一个数据结构，用于描述一个内存段的基地址、限长、访问权限等信息。在程序执行过程中，操作系统通过段描述符来管理和保护内存段，从而保证程序的安全性和稳定性。段选择子则是用于访问GDT或LDT中的段描述符的索引值，它的值决定了CPU将访问哪个段描述符。</p><img src="/2023/05/06/OS-Learning/HIT-OS/a05e697174deb4b8d970e125f4076696.png" class=""><p>需要注意的是，在x86架构中，一个进程可以使用多个代码段和数据段，每个段都由一个段描述符描述。因此，程序执行过程中需要使用多个段选择子来访问不同的段描述符。除了CS寄存器之外，还有DS（Data Segment）、SS（Stack Segment）、ES（Extra Segment）等寄存器，用于存储访问不同段的段选择子。</p></blockquote><p>LDT是正确执行和访问进程的关键，因此每个进程都维护一个自己的LDT，在进程切换时，LDT表也要随之切换（见lab4）。</p><img src="/2023/05/06/OS-Learning/HIT-OS/a85afbd69b690948359583ead1d13729.png" class=""><p>现在对1)中提到的“进程载入内存时将基地址放入PCB中”进行更正：</p><blockquote><p>在将进程载入内存时，操作系统会初始化该进程的LDT表（也是一个段）并写入该进程的内存空间中，操作系统会将LDT表的段选择子写入该进程的TSS（Task State Segment）中的LDT表寄存器字段中。（将LDT与PCB关联）<br />当该进程被调度执行时，CPU会从该进程的TSS中获取LDTR（LDT Register）中的值，并将其加载到CPU的LDTR中，以便该进程能够正确地访问自己的局部内存段。因此，LDTR的值会从该进程的PCB中获取，并在进程载入内存时被设置。<br />LDT表的存储位置由LDTR中的地址决定。LDTR是一个48位的寄存器，它由一个16位的段选择子和一个32位的线性地址组成。当CPU需要访问LDT表时，它会从LDT表寄存器中读取段选择子，从而确定要访问的LDT表在GDT（Global Descriptor Table）中的位置。然后，<strong>CPU会使用段选择子从GDT中读取LDT表的段描述符，并从中获取LDT表在内存中的起始地址</strong>。</p><img src="/2023/05/06/OS-Learning/HIT-OS/f79658fdbb805322f1a6a578ef030add.png" class=""></blockquote><p>区别GDT与LDT：</p><blockquote><p>在x86架构中，GDT（Global Descriptor Table）是一个全局的段描述符表，用于存储系统中所有进程和内核所使用的段描述符。而LDT（Local Descriptor Table）表则是每个进程都有自己的局部段描述符表，用于存储进程的局部段描述符。<br />因此，GDT和LDT是两个不同的概念，不应混淆。GDT是系统级的全局段描述符表，用于存储所有进程和内核所使用的段描述符，而LDT是进程级的局部段描述符表，用于存储进程的局部段描述符。<br />具体来说，在x86架构中，每个进程都有自己的LDT表，用于存储进程的局部段描述符。LDT表通常存储在进程的内存空间中，与其他数据和代码一起存储在进程的用户地址空间中。而GDT则是一个全局的段描述符表，用于存储系统中所有进程和内核所使用的段描述符。GDT表通常存储在系统的内存空间中，并由操作系统维护和管理。<br />因此，GDT和LDT是两个不同的概念，GDT是系统级的全局段描述符表，而LDT是进程级的局部段描述符表，它们在作用和范围上是不同的，不能混淆。</p></blockquote><h2 id="5-内存分区-有关进程所需内存"><a class="markdownIt-Anchor" href="#5-内存分区-有关进程所需内存"></a> 5) 内存分区-有关进程所需内存</h2><p>进程的段要载入内存，那么OS就要给进程分配空闲的内存，我们称内存中离散的空闲内存为空闲分区。对整个内存，OS可建立空闲分区表和已分配分区表来管理内存</p><img src="/2023/05/06/OS-Learning/HIT-OS/a85afbd69b690948359583ead1d13729.png" class=""><p>对进程的段内存请求，OS有多种算法来决定分配从哪个空闲分区分配内存给它，比如首先适配(简单，执行速度快)，最佳适配(会产生内存碎片，空闲分区越来越小)，最差适配(将导致没有特别大的分区)</p><img src="/2023/05/06/OS-Learning/HIT-OS/a85afbd69b690948359583ead1d13729.png" class=""><p>这种可变空闲分区机制将导致大量的内存碎片问题，即内存明明还有足够的空闲，但是都是一堆碎片分区，以至于任何一个分区都不足以装下进程的一个段，这造成了内存的浪费。一个自然而然的想法是重新调整内存，将碎片分区整合在一起，但在执行这个内存操作时，进程显然是不能继续执行的，因为它的地址在变化中，这将导致CPU的低效，用户的体验感也不好。因此才有了内存分页的机制</p><img src="/2023/05/06/OS-Learning/HIT-OS/00b606854598c5ba4b5d5647c190adcf.png" class=""><h2 id="6-内存分页-有关物理内存"><a class="markdownIt-Anchor" href="#6-内存分页-有关物理内存"></a> 6) 内存分页-有关物理内存</h2><p>将内存划分为一个一个大小固定的单位，称之为页（回忆OS的启动部分的<code>mem_init</code>函数，操作系统在启动时就通过<code>mem_map</code>将内存分成一页一页的，通常是4K），内存分页使用离散的、大小固定的页面来为进程分配内存，这将彻底消除内存碎片问题，因为它不存在内存分区那样因为太小而不能分配给进程的问题，因为页的分配可以是离散的（进程的同一个段在内存中可能不连续）。唯一可能产生的内存浪费就是当进程请求的内存空间大小不是页面大小的整数倍，那么最后一页可能会有一些未使用的空间，但这个未使用的空间仅仅只是一个页面内的空闲空间（所以是很小的内存浪费），而不会导致内存碎片的产生（因为已经分配出去了，只是进程没有使用）。</p><img src="/2023/05/06/OS-Learning/HIT-OS/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><p>在内存分页机制下，进程的同一个段（Segment）可能会被分成多个页面（Page）并散布在内存中的不同位置，这意味着进程的同一个段在内存中可能不连续。这种情况发生的原因是，内存分页的单位是页面而不是段，进程的段可能跨越多个页面。我们要引入新的数据结构来实现进程逻辑地址到物理地址的转换。我们要为进程的各段维护一个<strong>页表</strong>(Page Table)，将段的逻辑页号/虚拟页号映射到物理页框号，下面以一个逻辑地址-&gt;物理地址的计算例子展现页表的作用<br />对逻辑地址<code>0x2240</code>（对虚拟地址也是同样的，因为进程的虚拟地址也是一个从0开始的一段内存），我们(MMU)先计算它在段的第几个页号上：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>0</mn><mi>x</mi><mn>2240</mn></mrow><mrow><mn>4</mn><mi>K</mi></mrow></mfrac><mo>=</mo><mn>0</mn><mi>x</mi><mn>2240</mn><mo>≫</mo><mn>12</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\frac{0x2240}{4K} = 0x2240\gg12 = 0x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">2</span><span class="mord mtight">2</span><span class="mord mtight">4</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">2</span></span></span></span><br />因此该地址在段的第2个页面上，通过查询段的页表，可知段的第2个页面对应的物理页框号为3，所以该逻辑地址对应的实际物理地址为<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>4</mn><mi>K</mi><mo>+</mo><mn>0</mn><mi>x</mi><mn>240</mn><mo>=</mo><mn>3</mn><mo>≪</mo><mn>12</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>240</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>3240</mn></mrow><annotation encoding="application/x-tex">3*4K + 0x240=3\ll12 +0x240 = 0x3240</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span></span></span></span></p><img src="/2023/05/06/OS-Learning/HIT-OS/f79658fdbb805322f1a6a578ef030add.png" class=""><h2 id="7-多级页表-书本的章和节的思想"><a class="markdownIt-Anchor" href="#7-多级页表-书本的章和节的思想"></a> 7) 多级页表-书本的章和节的思想</h2><p>假设一个进程的虚拟地址空间为 4GB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>字节），物理地址空间为 1GB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> 字节），页面大小为 4KB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>字节），那么它的页表项数量将达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32} / 2^{12} = 2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> 个，需要占用大约 4MB 的内存空间。如果直接使用单级页表来管理进程的地址空间，需要在内存中维护一个包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个页表项的页表。由于页表项数量巨大，而且大部分页表项并不会被频繁使用，这样会导致内存空间的浪费和访问效率的降低。为了解决这个问题，操作系统通常采用多级页表来管理进程的地址空间。多级页表将页表划分为多个级别，每个级别的页表包含一部分页表项。例如，两级页表结构中，第一级页表包含多个页目录项，每个页目录项指向一个第二级页表，第二级页表包含多个页表项。当进程访问某个虚拟地址时，操作系统会首先查询第一级页表，找到对应的页目录项，然后再查询第二级页表，找到对应的页表项，从而确定该虚拟地址对应的物理地址。<br />下面是一个简单的多级页表实例：<br />假设一个进程的虚拟地址空间为 4GB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>字节），物理地址空间为 1GB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> 字节），页面大小为 4KB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>字节），采用两级页表结构。第一级页表包含 1024 个页目录项，每个页目录项大小为 4 字节，第二级页表包含 1024 个页表项，每个页表项大小也为 4 字节。这样，每个页表项对应一个 4KB 的物理页框，每个页目录项指向一个 4MB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>×</mo><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><mn>4</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1024\times4KB = 4MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>） 的虚拟地址空间。<br />当进程访问一个虚拟地址 0x12345678 (在这之前，根据段表，将指令中的地址转换为虚拟地址) 时，需要将该虚拟地址转换为对应的物理地址。首先，操作系统根据虚拟地址的高 10 位（0x12345，即除以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>或地址右移22位 以确定在哪个页目录项）查询第一级页表，找到对应的页目录项。假设该页目录项对应的第二级页表的物理地址为 0x12340000。然后，操作系统根据虚拟地址的中间 10 位（0x6）查询第二级页表，找到对应的页表项。假设该页表项对应的物理页框的物理地址为 0x56780000。最终，操作系统将虚拟地址 0x12345678 映射到物理地址 0x56785678，这个物理地址是进程所使用的实际物理地址，可以用于实际的内存访问操作。<br />在上面的例子中，使用两级页表可以将每个页表的大小降低到 8KB（一级4KB+二级4KB<em>1），而不是使用单级页表时需要的 4MB。这样可以降低页表的访问开销和内存空间的浪费，提高系统的内存利用率和性能。多级页表的级数可以根据需要进行调整，以适应不同的内存管理需求和硬件环境。<br />页目录表和二级页表都在内存中，页目录项并不是始终被填满的。在使用分页机制的情况下，页目录项和页表项只会在需要时才会被填充。当进程访问一个新的虚拟地址时，如果对应的页目录项或页表项不存在，则操作系统会通过<strong>缺页异常</strong>等方式将其填充到内存中。因此，<strong>只有进程实际使用的虚拟地址才会被映射到物理地址，而未使用的虚拟地址则不会被映射到物理地址，也就不会占用额外的内存空间</strong>。这种按需分配的方式可以有效地节省内存空间，提高系统的内存利用率。因此实际上所有页表(一级页表+二级页表)在内存占的内空间为**一级页表4KB+二级页表4KB</em>有效页目录项个数**，比如下图，使用了两个页目录项，因此页表总内存为<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>B</mi><mo>+</mo><mn>4</mn><mi>K</mi><mi>B</mi><mo>×</mo><mn>3</mn><mo>=</mo><mn>16</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4KB+4KB\times3=16KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></p><img src="/2023/05/06/OS-Learning/HIT-OS/3e62cb394c3e34f04693136b17ab094f.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/a85afbd69b690948359583ead1d13729.png" class=""><h2 id="8-tlb一种缓存"><a class="markdownIt-Anchor" href="#8-tlb一种缓存"></a> 8) TLB：一种缓存</h2><p>可以将TLB（Translation Lookaside Buffer）视为一种缓存，但它不是用于缓存数据的Cache，而是用于缓存虚拟地址到物理地址的转换结果，这样CPU就可以避免多次访问内存中的多级页表，从而提高访问速度。</p><img src="/2023/05/06/OS-Learning/HIT-OS/50bc769c1e6db59af741f48d8624ac96.png" class=""><h2 id="9-虚拟内存段页结合"><a class="markdownIt-Anchor" href="#9-虚拟内存段页结合"></a> 9) 虚拟内存：段页结合</h2><p>这里引入了虚拟地址空间的概念</p><blockquote><p>进程的虚拟地址空间是指进程可以使用的虚拟地址的范围。在使用分页机制的情况下，进程的虚拟地址空间通常被划分为多个页，每个页的大小为固定的值，例如4KB或2MB。进程的虚拟地址空间通常包括代码段、数据段、堆、栈等不同的区域，每个区域都有自己的起始地址和大小。操作系统会通过段表或页表将进程的逻辑地址映射到实际的物理地址，从而让进程可以访问到内存中的数据和指令。<br />操作系统负责管理页表，它为每个进程维护一个独立的页表。当进程被创建时，操作系统会为它分配一块虚拟地址空间，并为这个进程创建一个页表。操作系统还会将页表中的一些页表项设置为无效，这些页表项对应的虚拟页面还没有被分配物理内存。当进程访问这些无效的虚拟页面时，操作系统会触发一个缺页异常，然后根据需要为这个虚拟页面分配物理内存并更新页表。这个过程被称为页面调度。<br />进程的虚拟地址空间可以保证每个进程都有自己独立的地址空间，互不干扰，同时也可以避免不同进程之间的内存冲突和竞争。</p></blockquote><p>进程有独立的虚拟地址空间（包括虚拟页号），在执行访存指令时，有以下的地址转换:<br />逻辑地址(指令中的地址) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>段表</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{段表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113309999999998em;vertical-align:-0.010999999999999899em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.100331em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">段</span><span class="mord cjk_fallback mtight">表</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.010999999999999899em;"><span></span></span></span></span></span></span></span></span>虚拟地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>页表</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{页表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113309999999998em;vertical-align:-0.010999999999999899em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.100331em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord cjk_fallback mtight">页</span><span class="mord cjk_fallback mtight">表</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.010999999999999899em;"><span></span></span></span></span></span></span></span></span>物理地址</p><img src="/2023/05/06/OS-Learning/HIT-OS/7c0c3e8a239918e820904293bd7101c2.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/f79658fdbb805322f1a6a578ef030add.png" class=""><h2 id="10-copy_mem函数创建子进程页表"><a class="markdownIt-Anchor" href="#10-copy_mem函数创建子进程页表"></a> 10) copy_mem函数创建子进程页表</h2><p><code>copy_mem</code>用于在创建子进程的过程中被<code>copy_process</code>调用，该函数做了以下3件事</p><ol><li>为子进程分配虚拟内存，创建子进程的段表（LDT），可以看出linux0.11毕竟是早期的版本，不能保证进程的虚拟地址从0开始，而是根据进程号划分</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/7c0c3e8a239918e820904293bd7101c2.png" class=""><ol start="2"><li>复制父进程的页目录表和二级页表</li></ol><p>子进程和父进程共用物理内存页，但是各自要有独立的页表，因此子进程复制父进程的页表作为自己的页表<br />这里调用了<code>copy_page_tables</code>函数，该函数以父进程段基址和子进程段基址为参数，在Linux 0.11中，通过将段基址右移 22 位，可以得到页目录表的索引。接着，将这个索引乘以页表项大小（4字节）再加上页目录表的线性基地址（0xffc00000），就可以计算出页目录项的线性地址。然后，根据这个线性地址，我们可以找到对应的页表基址。<br />这里补充一下页目录表基址与CR3寄存器</p><blockquote><p>操作系统为每个进程设置了一个独立的页目录表，以管理进程的虚拟内存。每个进程的页目录表在物理内存中具有不同的位置，但为了简化内存管理和地址转换，操作系统将当前运行进程的页目录表映射到线性地址（虚拟地址） 0xffc00000。这样做的目的是在处理当前进程的虚拟地址时，可以方便地访问其页目录表。<br />为实现这一目标，操作系统在切换进程时会执行以下操作：</p><ol><li>操作系统将新进程的页目录表物理基地址加载到 CR3 寄存器中。CR3 寄存器用于告诉内存管理单元（MMU）当前活动的页目录表的物理基地址。</li><li>操作系统将当前运行进程的页目录表映射到线性地址（虚拟地址） 0xffc00000。这意味着操作系统会在页目录表中设置一个特殊的页目录项，将页目录表在虚拟内存中的基址设置为0xffc00000。这样，无论当前运行的是哪个进程，操作系统都可以通过这个固定的线性地址访问其页目录表，实际的物理基地址保存在CR3寄存器中。</li></ol></blockquote><p>通过这种方式，操作系统能够在逻辑层面统一访问当前运行进程的页目录表，简化了地址转换和内存管理过程。</p><p>在函数中遍历父进程的页目录项，同时为子进程的页目录项申请一页内存来保存对应的二级页表。并在这个新申请的二级页表中，原封不动的拷贝父进程对应的那个二级页表</p><img src="/2023/05/06/OS-Learning/HIT-OS/313f021e7970f73347285023bba01bc6.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/41342817f9984b2f94c18bdf98dcf39b.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/3336ab49b12ce0804a6b44d522450081.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/db29d6bd5960e875b3baee55aa391979.png" class=""><p>通过<code>copy_mem</code>函数，子进程就拥有了自己的页表，并且指向和父进程同样的物理内存页(被标记为已读)，此时还未实现父子进程的内存分离</p><img src="/2023/05/06/OS-Learning/HIT-OS/3433e861e5085ced9ca3c7be18ad26e6.png" class=""><p>当子进程想往内存中某个地址写入数据时，因为原内存页被设置为只读，而且要保证子进程和父进程的内存分离，因此OS为子进程想要写入的地址分配新的物理内存页，并修改子进程的页表，这就是写时复制</p><blockquote><p>写时复制：当父进程或子进程需要修改信息时，内核会为它们分配新的内存空间，而不是在原来的内存空间中进行修改<br />在使用写时复制（Copy-on-Write，简称 COW）机制时，父子进程在一开始并不会为自己分配独立的内存空间，而是共享相同的物理内存页面。此时，这些共享的物理内存页面会被设置为只读。当父进程或子进程试图修改这些共享页面时，会触发一个缺页异常。<br />当操作系统捕获到这个缺页异常时，它会检查异常原因。如果是因为试图写入只读页面，操作系统会采取以下操作：</p><ol><li>为引发异常的进程分配一个新的物理内存页面。</li><li>将原来共享的只读页面的内容复制到新分配的物理内存页面中。</li><li>更新引发异常的进程的页表，将对应的虚拟地址映射到新分配的物理内存页面。</li><li>将新分配的物理内存页面设置为可写。</li></ol></blockquote><p>这样，引发异常的进程现在有了一个可写的内存页面，包含原先共享页面的内容。而原来的只读共享页面仍然保留在内存中，供其他进程（例如父进程或其他共享该页面的子进程）使用。当没有进程再使用这个只读页面时，操作系统会将其回收并释放相应的物理内存空间。</p><img src="/2023/05/06/OS-Learning/HIT-OS/43730badbe2bf10c4a157a6d9194936f.png" class=""><h2 id="11-内存换入"><a class="markdownIt-Anchor" href="#11-内存换入"></a> 11) 内存换入</h2><ol><li>存在的原因</li></ol><p>因为进程的虚拟内存大于实际的物理内存，因此将进程只当前使用到的数据/代码页从磁盘换入内存，该机制支撑着虚拟内存机制。</p><blockquote><p>内存换入（paging in）是操作系统的内存管理策略，通过将磁盘上的数据或代码页换入物理内存，使得进程能够访问所需的资源。这种策略的主要优点是提高了内存利用效率，允许多个进程共享有限的物理内存资源。<br />由于进程的虚拟内存通常大于实际的物理内存，操作系统需要在磁盘上存储这些虚拟内存页面。当进程需要访问某个虚拟内存页面时，操作系统会检查该页面是否已经在物理内存中。如果页面不在物理内存中，操作系统会将其从磁盘换入物理内存。</p></blockquote><p>因此进程的虚拟页一开始并没有映射到物理页，只有在请求了该虚拟页后，OS才会将它换入内存物理页并将它与虚拟页映射，这种技术可以提高系统的可用内存</p><img src="/2023/05/06/OS-Learning/HIT-OS/bbea916ea56dfc9a947de21da0b02567.png" class=""><ol start="2"><li>缺页中断</li></ol><p>当进程尝试访问一个不在物理内存中的虚拟地址时，会触发缺页中断。缺页中断是一种硬件中断，用于通知操作系统进程试图访问一个不在物理内存中的虚拟页面。<br />操作系统接收到缺页中断时，它会执行以下操作：</p><ol><li>确定引发缺页中断的虚拟地址（放入<code>cr2</code>寄存器）和相应的虚拟页面。</li><li>检查该虚拟页面是否已经在磁盘上存储（例如，存储在交换分区或文件映射中）。如果是，则进行内存换入操作，将虚拟页面从磁盘加载到物理内存中。</li><li>更新进程的页表，将虚拟地址映射到新加载的物理内存页面。</li><li>恢复进程的执行，使其能够访问所需的虚拟页面</li></ol><p>请注意，这里的内存换入操作可能会导致其他物理内存页面被换出（如果没有空闲页），以便为新换入的页面腾出空间。操作系统会根据内存管理策略（如 LRU 算法）选择一个合适的页面进行换出。</p><img src="/2023/05/06/OS-Learning/HIT-OS/3433e861e5085ced9ca3c7be18ad26e6.png" class=""><ol start="3"><li>缺页中断的代码实现</li></ol><p>缺页中断处理程序<code>_page_fault</code>的主体是调用的<code>_do_no_page</code>函数，它完成3三件事</p><ol><li>确定虚拟页号</li><li>申请物理内存页，将虚拟页放入物理内存页</li><li>修改页表（建立映射）</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><h2 id="12-内存换出"><a class="markdownIt-Anchor" href="#12-内存换出"></a> 12) 内存换出</h2><p>在前一节内存换入已经提到，当物理内存已满时，内存换入之前应该先进行内存换出，将一页淘汰以腾出空闲页，那么选择哪一页淘汰就是内存换出的核心问题，这里主要讲3个算法，用缺页次数评价算法优劣</p><ol><li>FIFO</li></ol><p>这个算法的主要问题在于，可能刚刚换出的内存页，下一次就要换入，增加了磁盘读写次数，耗时高</p><img src="/2023/05/06/OS-Learning/HIT-OS/bbea916ea56dfc9a947de21da0b02567.png" class=""><ol start="2"><li>LRU</li></ol><p>LRU算法的全称是“Least Recently Used”，即最近最少使用算法。LRU算法利用了<strong>局部性原理</strong>，将最近最少使用的页面置换出去，以便为新的页面腾出空间。这样可以提高页面命中率，减少缺页中断，从而提高系统的性能。</p><img src="/2023/05/06/OS-Learning/HIT-OS/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><ol start="3"><li>clock</li></ol><p>Clock算法是一种用于操作系统页面置换的<strong>近似最近最少使用（LRU）算法</strong>。由于实际实现真正的LRU算法需要较高的计算和维护成本(修改页面时要将它设置为正确的时间戳)，Clock算法被设计为一种相对简单且高效的替代方案。Clock算法的主要思想是模拟一个循环队列（类似时钟指针），在其中记录物理内存页面的访问情况<br />相比于LRU要维护一个复杂的数据结构，Clock算法为在每个页面条目中添加一个访问位，机制如下图</p><img src="/2023/05/06/OS-Learning/HIT-OS/be45e9be004d61829c5b03272132030c.png" class=""><p>具体来说，如果相对于一个R=0的页面（该页面在上一次时钟相遇时R从1置为0），时钟走完一圈回到该页面时，该页面访问位还是0，则说明该页面一圈的时间内(最近的时间)未被访问过，因此选择该页换出。<br />到现在，Clock还只有一个指针，那么引出第二个指针的目的，就在于定时的将页面的访问位置0，该指针遍历速度要更快，原因在于当缺页很少时，页面均是R=1,因此按照我们之前的说法，clock算法是将一圈R=1的页面置为0，然后换出为起点的页面，该算法退化为了FIFO算法，而且还有另外一种可能，页面被置0后被访问，可能导致页面永远不会被换出</p><blockquote><p>在Clock算法中，定期清除访问位（R位）是为了防止一些页面的访问位一直保持为1，导致它们永远不会被置换。如果不定期清除访问位，那么一些频繁访问的页面的访问位会始终保持为1，这将导致它们在页面置换过程中永远不会被选中。<br />通过定期清除访问位，Clock算法可以确保每个页面都有被置换的可能性。当访问位被清除时，页面的“优先级”被重置，这样算法在下一次页面置换时将重新考虑所有页面。这有助于Clock算法更好地平衡内存资源，使得所有页面都有被换出的机会。<br />定期清除访问位的策略可以根据系统的需求和实际情况进行调整。在一些情况下，可能会选择在每次页面置换时清除一定数量的访问位；在其他情况下，可能会设置一个定时器，在固定时间间隔后清除所有访问位。具体的策略取决于系统的性能需求和资源限制。</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/00b606854598c5ba4b5d5647c190adcf.png" class=""><p>OS中的颠簸现象：</p><blockquote><p>颠簸（Thrashing）现象是指在操作系统中，当内存资源过度分配给多个进程时，导致大量的缺页中断和频繁的页面置换，使得系统的整体性能急剧下降。颠簸现象通常发生在系统的物理内存资源不足以满足所有运行进程的需求时。<br />当颠簸发生时，进程之间会竞争有限的内存资源，从而导致频繁的缺页中断。由于大量时间花费在处理缺页中断、页面换入和换出等内存管理任务上，进程实际的计算工作几乎无法进行。这导致系统运行缓慢，用户体验极差</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/55386b9183e912238f4ef08482495438.png" class=""><h1 id="5-设备驱动与文件系统"><a class="markdownIt-Anchor" href="#5-设备驱动与文件系统"></a> 5. 设备驱动与文件系统</h1><h2 id="cpu如何使用外设"><a class="markdownIt-Anchor" href="#cpu如何使用外设"></a> CPU如何使用外设</h2><p>我们由简至繁，先看看CPU本质上是如何使用外设的。<br />CPU使用外设，本质上是对外设的端口 (端口的本质是寄存器) 进行写命令（out xx, al）完成的。</p><blockquote><p>更详细的说，CPU通过与外设的端口进行通信来使用外设。在硬件层面，这些端口通常与设备的寄存器相关联，这些寄存器包含用于配置设备和控制设备行为的数据。通过对这些寄存器进行读写，CPU可以实现对外设的控制。通常，操作系统会使用设备驱动程序（Device Drivers）来与外设进行通信。设备驱动程序是一种特殊的软件，可以将CPU发出的指令转换成与特定硬件设备兼容的命令。操作系统通过调用设备驱动程序提供的接口，从而实现对外设的控制。</p></blockquote><p>而设备受到CPU的指令后开始工作，在工作完成后向CPU发出中断信号，CPU就转去执行中断处理程序。<br />以上描述中CPU要干的就两件事，一个是向设备写，一个是中断处理。那么在设备驱动的相关代码中有关写指令和中断处理以外的其他指令，旨在提供给上层用户一个统一的接口 ，避免因设备的不同或设备厂商不同，而导致写操作成为一个复杂的事情。以向显示器输出为例，无论显示器是什么牌子的，通过这个统一的接口，用户都可以用printf打印语句。</p><img src="/2023/05/06/OS-Learning/HIT-OS/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><p>这里提到的统一的接口，就是操作系统两大视图中的<strong>文件视图</strong>，用户使用外设，只需要处理设备对应的设备文件即可。设备文件是一种特殊类型的文件，它允许应用程序和操作系统以文件的形式与硬件设备进行交互。这种抽象简化了应用程序对外设的访问，因为它们可以像操作普通文件一样操作设备文件。但底层实现仍然依赖于设备驱动程序，以及通过端口（寄存器）与外设进行通信。<br />**旁注: **</p><blockquote><p>设备驱动程序与设备文件<br />/dev目录下的设备文件并不包含设备驱动程序本身。设备文件是Linux和类Unix操作系统中设备驱动程序与用户程序之间的接口。它们充当了一种抽象层，允许用户程序通过标准的文件I/O操作（如打开、读取、写入和关闭文件）与底层硬件设备进行交互。<br />设备文件通常分为字符设备文件和块设备文件。这两类设备文件在/dev目录下，以设备文件的形式表示。每个设备文件都有一个设备号（包括主设备号和次设备号），用于唯一标识该设备。操作系统使用设备号在内部映射到相应的设备驱动程序。<br />设备驱动程序本身是内核的一部分，负责管理硬件设备，并为用户程序提供了一组操作函数。当用户程序对设备文件执行I/O操作时，操作系统会根据设备号找到相应的设备驱动程序，然后调用设备驱动程序提供的操作函数来处理用户程序的请求。这样，设备驱动程序实际上是在内核空间执行的，而设备文件则位于用户空间。</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/be45e9be004d61829c5b03272132030c.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/00b606854598c5ba4b5d5647c190adcf.png" class=""><h2 id="向显示器输出"><a class="markdownIt-Anchor" href="#向显示器输出"></a> 向显示器输出</h2><p>printf函数内部将可变参数转换为字符数组格式，并将其存储在<code>buffer</code>数组中。然后，用系统调用sys_write将该字符数组写入标准输出流中，这在第二章讲述系统调用时说过，在这一章我们从<code>sys_write</code>接着向下探索以解开设备驱动程序的面纱</p><img src="/2023/05/06/OS-Learning/HIT-OS/be45e9be004d61829c5b03272132030c.png" class=""><h3 id="从文件描述符fd到目标inode"><a class="markdownIt-Anchor" href="#从文件描述符fd到目标inode"></a> 从文件描述符fd到目标inode</h3><p>我们先了解<strong>操作系统怎么通过文件描述符fd找到目标inode</strong>，再谈sys_open如何建立这个映射关系的，就知道sys_write是如何通过fd获取目标inode的了<br />源码中出现的filp数组是进程PCB中的文件指针数组，它包含指向全局文件表（file_table）中相应文件表项的指针，将进程的文件描述符（整数值）映射到全局文件表中的文件表项<br />全局文件表（file_table）则是系统级别的，<strong>文件表中的每个条目指向一个 inode</strong>，因此它将文件描述符映射到系统中的 inode。<br />所以通过文件描述符fd当做filp数组的索引<code>current-&gt;filp[fd]</code>得到对应的文件表项指针，再通过文件表的映射，就能够找到目标文件的inode <code>struct m_inode *inode_ptr = file_ptr-&gt;f_inode</code>。inode是一个结构体，存储了目标文件的相关信息，比如文件大小/类型/创建日期等，因为外设被OS抽象为设备文件，因此inode还存储了设备的信息，OS通过inode提供的信息确定了要写入的目标设备的信息（设备号），进而选择接下来的分支<br />而sys_open是如何建立这个映射关系的呢</p><blockquote><ol><li>解析文件路径：sys_open 首先根据提供的文件路径名找到对应的 inode。这个过程涉及到遍历目录结构和搜索目录项，最终找到目标文件的 inode。(open_namei函数)</li><li>在全局文件表中分配一个文件表项：接着，sys_open 在全局文件表（file_table）中分配一个空闲的文件表项，并将找到的 inode 指针存储在该文件表项的 f_inode 字段中。此外，还会设置文件访问模式（读、写或读写）和文件操作指针等信息。</li><li>在进程的文件指针数组中分配一个文件描述符：然后，在当前进程的文件指针数组（filp）中分配一个文件描述符（fd），并将其指向全局文件表中的相应文件表项。通常，文件描述符会分配为当前进程中最小可用的整数。例如 0、1、2 等。在 Linux 系统中，0、1、2 分别对应了标准输入（stdin）、标准输出（stdout）和标准错误（stderr）</li><li>返回文件描述符给进程</li></ol></blockquote><p>至此， sys_open 系统调用建立了从文件描述符（fd）到进程的文件指针数组（filp）、全局文件表（file_table）和 inode 的映射关系之后，进程可以使用文件描述符执行后续的文件操作。</p><blockquote><p>当进程需要进行文件操作时，例如读取、写入或关闭文件，它会使用已分配的文件描述符（fd）作为参数调用相应的系统调用，如 sys_read、sys_write 或 sys_close。<br />这些系统调用会根据文件描述符（fd）查找进程的文件指针数组（filp），以获取指向全局文件表（file_table）中相应文件表项的指针。接着，它们会访问文件表项中的 inode 指针，找到与文件关联的 inode。有了 inode，操作系统可以根据文件元数据和数据块指针来执行具体的文件操作。<br />这种从文件描述符到 inode 的映射关系使得进程可以方便地访问和操作文件，同时操作系统可以有效地管理文件资源和追踪文件状态。</p></blockquote><img src="/2023/05/06/OS-Learning/HIT-OS/be45e9be004d61829c5b03272132030c.png" class=""><p>看下图源码，sys_write通过用文件描述符索引filp数组( <code>current-&gt;filp[fd]</code>)得到文件表条目，再通过文件表条目得到inode (<code>file-&gt;f_inode</code>)</p><img src="/2023/05/06/OS-Learning/HIT-OS/9a986e22ba33aa2f07fb537819658b5d.png" class=""><p>通过溯源操作系统的初始化过程，可以知道文件描述符0(标准输入stdin),1(标准输出stdout),2(标准错误stderr)均指向设备驱动文件<code>dev/tty0</code></p><img src="/2023/05/06/OS-Learning/HIT-OS/9a986e22ba33aa2f07fb537819658b5d.png" class=""><h3 id="rw_char函数与crw_char数组"><a class="markdownIt-Anchor" href="#rw_char函数与crw_char数组"></a> rw_char函数与crw_char数组</h3><p><code>sys_write</code>函数根据inode，判断目标设备是不是字符设备 (根据设备类型进行分支)，如果是，则向<code>rw_char</code>函数传入设备的设备号(也是inode中的信息)，该函数以设备号为索引通过<code>crw_char</code>数组找到并调用相应的设备驱动程序rw_ttyx（这里开始真正执行内核中的设备驱动程序！ rw: read or write）</p><ol><li>crw_char数组：crw_char数组（在fs/char_dev.c文件中定义）是字符<strong>设备驱动程序的注册表</strong>。数组中的每个元素都指向一个字符设备驱动程序的操作函数表。crw_char数组使用设备号作为索引，将设备号映射到相应的设备驱动程序。在printf向显示器输出的过程中，/dev/tty0的设备号为4，对应于TTY设备驱动程序。</li><li>rw_char函数：rw_char函数（在fs/char_dev.c文件中定义）是一个通用的读/写函数，用于处理字符设备的读写操作。rw_char函数根据传入的设备号查找crw_char数组，然后调用相应设备驱动程序的读或写方法。在printf向显示器输出的过程中，sys_write函数会调用rw_char函数，传入设备号4（对应于/dev/tty0）以及要写入的字符串。</li></ol><p>到目前为止，操作系统根据设备文件的inode结构体提供的信息，进行了分支，并通过设备号信息跳转到相应的设备驱动程序执行</p><img src="/2023/05/06/OS-Learning/HIT-OS/9a986e22ba33aa2f07fb537819658b5d.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/4558f12f037760ce42478fc1c563f99a.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><h3 id="tty_write函数与con_write函数"><a class="markdownIt-Anchor" href="#tty_write函数与con_write函数"></a> tty_write函数与con_write函数</h3><p><code>rw_ttyx</code>根据传入的rw (值为write) 参数进行分支，调用<code>tty_write</code>函数，该函数先判断输出缓冲区是否满，如果满了则先sleep该进程，反之将字符串放入输出缓冲区中，最后调用<code>tty-&gt;write</code>函数进行输出。tty_write函数通过调用tty-&gt;write方法将字符串传递给con_write函数，con_write函数执行最终的输出显示器操作，它处理字符串输出到显示器的具体细节。它将字符串中的每个字符发送到视频内存（显存），并根据需要更新光标位置。当字符串全部写入显存后，显示器将自动显示更新后的内容。对于简单的文本输出，如使用printf函数，显示器不会向CPU发出中断。<br /><img src="attachment/f1c8bb9ffed9738a412d85eba74d5094.png" alt="" /><img src="attachment/f1c8bb9ffed9738a412d85eba74d5094.png" alt="" /></p><img src="/2023/05/06/OS-Learning/HIT-OS/990a158e557216d612b143f9269cceb8.png" class=""><p>**旁注: **在Linux和类Unix操作系统中，设备通常分为两类：字符设备和块设备。这两种类型的设备在数据访问方式和操作模式上有显著的区别。</p><ol><li>字符设备： 字符设备是基于字节流的设备，这意味着它们以顺序方式处理数据，一个字节接一个字节。对于这些设备，用户可以直接读写数据，无需考虑数据在设备中的实际存储位置。字符设备的典型例子包括终端（如tty设备）、串行端口以及其他一些硬件接口。在Linux中，字符设备通常在/dev目录下以设备文件的形式表示。</li><li>块设备： 块设备是基于数据块的设备，这意味着它们处理固定大小的数据块，而不是字节流。块设备通常用于存储大量数据，例如硬盘驱动器、闪存设备和CD-ROM驱动器。与字符设备不同，块设备的读写操作需要考虑数据在设备中的实际存储位置，因为它们允许随机访问数据块。在Linux中，块设备同样位于/dev目录下，以设备文件的形式表示。</li></ol><p>总之，字符设备和块设备是两种不同类型的设备，它们在数据访问方式和操作模式上有显著的区别。字符设备基于字节流，处理数据的方式是顺序的，而块设备基于数据块，允许随机访问数据。在Linux操作系统中，这两种类型的设备都在/dev目录下以设备文件的形式表示。</p><h2 id="用键盘输入"><a class="markdownIt-Anchor" href="#用键盘输入"></a> 用键盘输入</h2><p>键盘输入是一个中断事件</p><ol><li>当按下键盘时，键盘控制器会检测到按键事件，并将扫描码（Scan Code）存储在其内部缓冲区中，键盘控制器向键盘发送中断请求信号。</li><li>CPU检测到IRQ1中断信号，并暂停当前执行的任务，根据IRQ找到并执行相应的中断处理程序<code>_keyboard_interrupt</code>，该程序从键盘控制器的数据端口0x60处读取其内部缓冲区的数据</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/990a158e557216d612b143f9269cceb8.png" class=""><ol start="3"><li>keyboard_interrupt 被调用后，会将键盘扫描码做为下标，调用key_table函数数组中保存的与该按键对应的响应函数，响应函数通过key_map找到相应的字符ascill码</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><ol start="4"><li>在将扫描码转换为ASCII字符后，keyboard_interrupt会处理特殊按键（如Shift、Ctrl、Alt等）和组合键，然后将最终的字符放入输入缓冲区read_q。</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/7244d292d962167035026ae6d17647cd.png" class=""><ol start="5"><li>如果TTY设备的回显（echo）功能已启用，keyboard_interrupt会将字符发送给当前TTY设备的输出函数con_write。这个函数会将字符写入显存，从而在屏幕上显示该字符。</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/9bc6319e4399ae16eed295b023956965.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><p>旁注</p><blockquote><p>什么是IRQ<br />硬件设备发送给 CPU 的中断请求信号（IRQ）通常是一个简单的电平信号，用于通知 CPU 有一个需要处理的中断事件。IRQ 信号的内容本身非常简单，它主要起到通知 CPU 的作用，而不包含详细的中断信息或指令。IRQ 信号能引发中断的原因在于 CPU 对这些信号的设计和处理方式。<br />当硬件设备需要 CPU 的注意时（例如读取数据、处理错误或通知状态改变），它会发送一个 IRQ 信号给 CPU。CPU 上有一些专用的引脚（称为中断请求引脚）用于接收这些信号。每个硬件设备通常都有一个与之关联的 IRQ 编号，用于在 CPU 和硬件设备之间进行识别。<br />收到 IRQ 信号后，CPU 会根据信号的优先级和当前状态来决定何时处理这个中断。在适当的时机，CPU 会暂停当前任务，然后查询中断向量表，找到与收到的 IRQ 编号对应的中断处理程序的地址，并跳转到该地址开始执行中断处理程序。<br />IRQ 信号本身并不包含 int 指令或其他类似的处理器指令。实际上，IRQ 信号与处理器指令是分开的，它们只是用于通知 CPU 有一个需要处理的中断事件。处理器在接收到 IRQ 信号后，会根据内部逻辑和中断处理机制来执行相应的中断处理程序。</p></blockquote><h2 id="使用生磁盘"><a class="markdownIt-Anchor" href="#使用生磁盘"></a> 使用生磁盘</h2><img src="/2023/05/06/OS-Learning/HIT-OS/9bc6319e4399ae16eed295b023956965.png" class=""><p>我们自下而上，逐步学习从生磁盘到文件视图的背后机制，现在我们忽略文件视图的封装，看进程如果要直接读写生磁盘，该怎么做</p><h3 id="第1层抽象盘块"><a class="markdownIt-Anchor" href="#第1层抽象盘块"></a> 第1层抽象—盘块</h3><p>CPU要向磁盘写入，那么先要确定目标扇区在磁盘中的的位置，那么就需要知道一个三维坐标信息，即磁道号(柱面号C)、磁头号(H)和扇区号(S)。有了这个信息，再执行out指令，就可以完成磁盘的写入了。由于这个坐标信息比较复杂，比进程来说很不友好，因此我们现在进行第一层抽象，即进程只传递盘块号给操作系统（实际上是设备驱动程序），由操作系统将这个盘块号转换为(C,H,S)的扇区坐标</p><img src="/2023/05/06/OS-Learning/HIT-OS/9bc6319e4399ae16eed295b023956965.png" class=""><p>盘块号是操作系统为了对磁盘进行第一层抽象而进行的第一层编址，因为同一进程使用盘块号相邻的盘块，而磁盘读写时间主要受寻道时间影响，因此编址后盘块号相邻的盘块最好处于同一磁道（这样就不用寻道了）。因此盘块由相邻的多个扇区组成，因此扇区号也遵循这个编址原则</p><img src="/2023/05/06/OS-Learning/HIT-OS/3b8752aa64ad18267791470721e6da11.png" class=""><p><strong>为什么要引入盘块号，而不是直接传递扇区号呢？</strong><br />启动磁盘读写是一个耗时的事情(寻道+旋转+传输)，因此应该尽可能多的在一次磁盘操作中多读取，这样读写速度也就更快(传输速度只占一次磁盘读写耗时的很小部分)。（在磁盘读写操作中，寻道时间和旋转延迟通常是磁盘读写时间中最耗时的部分。因此，在进行磁盘读写操作时，将更多的数据读入内存缓存中，并尽可能减少读写次数，可以最大程度地减少磁盘寻道和旋转时间的影响，提高磁盘读写的效率和速度。） 因此操作系统引入盘块的概念，<strong>盘块（disk block）是文件系统管理磁盘空间的基本单位，文件系统通过盘块号来标识文件在磁盘上的位置</strong>，而磁盘读写的基本单位是扇区。扇区是磁盘上最小可寻址的物理存储单元，而盘块是操作系统中逻辑上抽象的单位，其大小可以是多个扇区(512bytes)的整数倍<br />盘块大小越大，读写速度就会越快。这是因为，当操作系统需要读取一个文件时，在一次磁盘操作中它会将整个盘块读入内存，而不是一个个字节逐个读取。盘块越大，每次读取的数据就越多，这可以减少磁盘读写操作的次数，从而提高读写速度。<br /><strong>为什么盘块越大，空间利用率越低？</strong><br />即使一个文件只有1KB的数据，因为盘块（disk block）是文件系统管理磁盘空间的基本单位，因此如果盘块大小为4KB，则它也会占用4KB的磁盘空间，剩余的3KB空间（内部碎片）就会浪费掉。因此，盘块越大，文件所占用的磁盘空间就会变大，但实际数据却变少，导致空间利用率降低。</p><img src="/2023/05/06/OS-Learning/HIT-OS/91f8530d210c0afbc11dc7f156acc96b.png" class=""><h3 id="第2层抽象请求队列"><a class="markdownIt-Anchor" href="#第2层抽象请求队列"></a> 第2层抽象—请求队列</h3><p>CPU执行进程的速度远快于磁盘读写，因此同一时间会存在多个未处理的磁盘读写请求 (这我们的语境中，这个请求是进程发出读写目标盘块号的请求)，因此要形成一个请求队列。再按照合理的调度算法处理这些请求</p><img src="/2023/05/06/OS-Learning/HIT-OS/abe14f751c02e58f30a4e7a5a93ced04.png" class=""><ol><li>FCFS</li></ol><p>效率低</p><img src="/2023/05/06/OS-Learning/HIT-OS/d58b62057cba4063b2048411aa900d27.png" class=""><ol start="2"><li>SSTF</li></ol><p>最少寻找时间优先，即离磁头最近的先处理，与进程调度的短作业优先算法类似，也会导致饥饿问题</p><img src="/2023/05/06/OS-Learning/HIT-OS/0cb652a062d03a762e9aa2db9cce8ced.png" class=""><ol start="3"><li>Scan</li></ol><p>扫描算法，不存在饥饿问题，但不公平，对中间的盘块号处理快于两边（中间的占便宜）</p><img src="/2023/05/06/OS-Learning/HIT-OS/91f8530d210c0afbc11dc7f156acc96b.png" class=""><ol start="4"><li>C-Scan</li></ol><p>电梯算法，在复位过程中不处理中间的盘块号，保证了公平性</p><img src="/2023/05/06/OS-Learning/HIT-OS/bad850a635a87757a071d989bebb0ba5.png" class=""><img src="/2023/05/06/OS-Learning/HIT-OS/c75f8ca18d39ef3fddd1587ba8229288.png" class=""><h2 id="从字符流到磁盘块"><a class="markdownIt-Anchor" href="#从字符流到磁盘块"></a> 从字符流到磁盘块</h2><p>现在我们在盘块号的基础上进一步抽象（第3层抽象），得到文件视图，文件在用户来看就是字符序列，一个字节接一个字节，用户可以处理这些字节数据而不用在乎数据的实际存储位置。<br />文件是用户角度的概念，它是由一系列字符组成的数据流。在文件被写入磁盘时，操作系统需要将字符流映射到磁盘块上，以便在需要时可以快速读取文件数据。<br />为了实现字符流到磁盘块的映射，文件系统通常会将一个文件分割成若干个固定大小的块，这些块被称为磁盘块。当一个文件被写入磁盘时，操作系统会将文件分割成若干个磁盘块，并将每个磁盘块映射到磁盘上的一个或多个扇区。</p><img src="/2023/05/06/OS-Learning/HIT-OS/0cb652a062d03a762e9aa2db9cce8ced.png" class=""><p>接下来讲述映射的几种方式</p><h3 id="连续存储"><a class="markdownIt-Anchor" href="#连续存储"></a> 连续存储</h3><p>连续存储是一种将文件连续地存储在磁盘上的方式。在连续存储方式下，文件被分为若干个大小相等的磁盘块，并且这些磁盘块在磁盘上是连续存储的。操作系统通过维护文件的起始位置和长度信息，可以快速地定位和读取整个文件。<br />连续存储的优点是读取速度快，但缺点是文件大小固定，不易扩展(可能会覆盖后续的文件)，且容易产生外部碎片。</p><img src="/2023/05/06/OS-Learning/HIT-OS/0cb652a062d03a762e9aa2db9cce8ced.png" class=""><h3 id="链式存储"><a class="markdownIt-Anchor" href="#链式存储"></a> 链式存储</h3><p>链式存储是一种将文件存储在多个不连续的磁盘块上的方式。在链式存储方式下，每个磁盘块除了存储文件数据外，还包含一个指向下一个磁盘块的指针。操作系统通过遍历磁盘块链表，可以读取整个文件。<br />链式存储的优点是文件大小可变，且可以避免外部碎片，但缺点是需要额外的指针开销，且读取速度比连续存储慢。</p><img src="/2023/05/06/OS-Learning/HIT-OS/c75f8ca18d39ef3fddd1587ba8229288.png" class=""><h3 id="索引存储"><a class="markdownIt-Anchor" href="#索引存储"></a> 索引存储</h3><p>索引存储是一种将文件的元数据和磁盘块的地址保存在<strong>索引块</strong>中的方式。在索引存储方式下，每个文件都对应一个或多个索引块(对大文件)，每个索引块中保存若干个磁盘块的地址。操作系统通过读取文件的索引块，可以快速地定位和读取文件。<br />索引存储的优点是可以快速定位和读取文件，且文件大小可变，但缺点是需要额外的索引块开销，且索引块也可能发生外部碎片。<br /><img src="attachment/2cf522c02b738c3a9a4c96c80234c33e.png" alt="" /><img src="attachment/5a31bc2eac3f158a3ab27b9977767a41.png" alt="" /></p><h2 id="从字符流到磁盘块的实现"><a class="markdownIt-Anchor" href="#从字符流到磁盘块的实现"></a> 从字符流到磁盘块的实现</h2><p>我们从sys_write出发，该函数通过3个参数信息（文件描述符fd, 内存缓冲区buffer, 计数count）完成了字符流到盘块的映射和目标盘块的修改</p><h3 id="通过文件描述符fd找到inode"><a class="markdownIt-Anchor" href="#通过文件描述符fd找到inode"></a> 通过文件描述符fd找到inode</h3><p>在本节开头已经讲过如何通过fd找到目标inode，主要是通过将文件描述符当做filp数组的索引，再通过文件表的映射，能够找到目标文件的inode。inode可以视为文件的FCB，它存储了文件的元数据(即文件的描述性信息，例如文件的名称、类型、大小、创建日期、修改日期、访问权限等,还包括索引块的信息)，sys_write用<code>S_ISREG(inode-&gt;i_mode)</code>检查目标文件的类型，如果是普通文件(而不是设备文件)，则调用file_write来执行具体的写入操作</p><img src="/2023/05/06/OS-Learning/HIT-OS/fd5a4776cf86d89024df3cd3df72a1a8.png" class=""><h3 id="file_write函数"><a class="markdownIt-Anchor" href="#file_write函数"></a> file_write函数</h3><img src="/2023/05/06/OS-Learning/HIT-OS/0cb652a062d03a762e9aa2db9cce8ced.png" class=""><p>file_write函数要想向完成对目标磁盘块的写入，那么它需要完成两件事情</p><ol><li>确定字符流的起点和终点</li></ol><p>由参数<code>file</code>获取文件操作指针的开始位置，即字符流的起点。file是一个指向文件表条目的指针，通过它可以获取文件操作指针等信息。然后加上参数count便能获取字符流的终点。<br />看下图源码，<code>file_write</code>先查看文件的打开标志是否是追加(<code>O_APPEND</code>)，如果是则将待写入位置pos置为文件末尾(<code>i_size</code>)，否则置pos为文件当前偏移量（文件操作指针的开始位置）</p><img src="/2023/05/06/OS-Learning/HIT-OS/35544cba9edd344712efa981d76f7912.png" class=""><ol start="2"><li>确定目标盘块号</li></ol><p>create_block返回目标盘块号，它利用了两个参数inode和pos/BLOCK_SIZE</p><ol><li>inode参数：inode结构中包含了关于文件的元数据，如文件大小、权限等。更重要的是，它还包含了直接索引、间接索引、双间接索引和三间接索引指针，这些指针用于查找文件数据所在的磁盘块。<strong>通过提供inode参数，create_block函数可以访问这些索引指针，从而找到和分配新的磁盘块。</strong></li><li>pos/block_size参数：pos/block_size表示文件中逻辑盘块号。这个信息对于<strong>确定应该使用哪个索引级别</strong>（直接索引、间接索引等）非常重要。例如，对于较小的文件，pos/block_size可能位于直接索引范围内，这意味着可以直接使用inode结构中的直接索引指针来访问数据盘块。而对于较大的文件，可能需要使用间接索引或更高级别的索引来查找数据盘块。通过传递pos/block_size参数，create_block函数可以根据文件操作指针和文件大小选择合适的索引级别，从而正确地分配和映射新的磁盘块。</li></ol><img src="/2023/05/06/OS-Learning/HIT-OS/bad850a635a87757a071d989bebb0ba5.png" class=""><ol start="3"><li>执行读写操作</li></ol><p>使用<strong>bread函数读取盘块的数据</strong>。bread负责将指定的盘块数据从磁盘读取到内存中。即将目的盘块号放入电梯队列后续内容就是生磁盘的使用了(算出C,H,S进行磁盘读写)<br />如果该盘块已经在内存缓冲区中，bread会直接返回指向该缓冲区的指针。否则，它会分配一个新的缓冲区，从磁盘读取数据，然后返回指针。每个盘块只进行一次磁盘读写操作，以下是读写count个字符的源码（这部分还是直接看linux0.11源码完全注释比较好🙏）<br /><strong>旁注: 磁盘数据缓冲区</strong></p><blockquote><p>磁盘块的<strong>数据缓冲区</strong>是操作系统用于在内存中暂时存储磁盘块数据的区域。当应用程序需要读取或写入磁盘块时，操作系统会将磁盘块的数据读取到缓冲区中，然后在缓冲区中进行读取或写入操作。这样可以减少磁盘I/O操作的次数，提高文件系统的性能。缓冲区还可以被用于实现文件系统的高级功能，如文件系统缓存和延迟写入等。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    block <span class="token operator">=</span> <span class="token function">create_block</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> pos <span class="token operator">/</span> BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    bh <span class="token operator">=</span> <span class="token function">bread</span><span class="token punctuation">(</span>inode<span class="token operator">-></span>i_dev<span class="token punctuation">,</span> block<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//bh（缩写为buffer head）实际上是一个指向buffer_head结构的指针，而不是直接指向磁盘缓冲区。</span>                                    <span class="token comment">//buffer_head结构包含了关于磁盘缓冲区的信息，例如磁盘设备号、块号、脏标志等。</span>                                    <span class="token comment">//buffer_head结构中有一个成员变量b_data，这是一个指向实际磁盘缓冲区的指针。</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> pos <span class="token operator">%</span> BLOCK_SIZE<span class="token punctuation">;</span>     <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> c <span class="token operator">+</span> bh<span class="token operator">-></span>b_data<span class="token punctuation">;</span>    bh<span class="token operator">-></span>b_dirt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> BLOCK_SIZE <span class="token operator">-</span> c<span class="token punctuation">;</span>    pos <span class="token operator">+=</span> c<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>c<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>buf<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数据从源缓冲区（buf）拷贝到目标缓冲区（bh->b_data）。这个循环一次处理一个字节，直到当前盘块的数据被写满。</span>    <span class="token punctuation">&#125;</span>                               <span class="token comment">// 注意，这个循环并不涉及磁盘读写操作，因为bh->b_data指向的是磁盘在内存中的缓冲区。</span>    <span class="token function">brelse</span><span class="token punctuation">(</span>bh<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在内层while循环结束后，brelse函数被调用以释放bh。这个函数会检查缓冲区是否被标记为脏（bh->b_dirt），</span>                <span class="token comment">// 如果是，则在适当的时机将数据写回磁盘。这意味着磁盘读写操作不会频繁发生，而是在数据准备好写回磁盘时进行。</span><span class="token punctuation">&#125;</span>filp<span class="token operator">-></span>f_pos <span class="token operator">=</span> pos<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/OS-Learning/HIT-OS/35544cba9edd344712efa981d76f7912.png" class=""><h3 id="文件视图"><a class="markdownIt-Anchor" href="#文件视图"></a> 文件视图</h3><p>对设备文件的inode存储着不同的信息，有主设备号，设备类型等，但在用户看来，无论是磁盘还是外设，均是以文件的形式展现，这也印证了那句linux哲学<br />“Everything is a file”</p><img src="/2023/05/06/OS-Learning/HIT-OS/f0ba7c8f2c72156377deff8ba877cfb1.png" class=""><h2 id="目录树"><a class="markdownIt-Anchor" href="#目录树"></a> 目录树</h2><p>前面提到，我们用文件描述符fd获取相应文件的inode，程序中的fd是由sys_open系统调用返回得到的，而sys_open接受一个文件路径名作为参数，因此sys_open一定能完成这样一件事情: 根据文件路径名找到目标inode，为其创建一个文件表项，并返回一个文件描述符，用户可以通过这个文件描述符在后续操作中访问文件。<br />磁盘在用户看来，就是一个目录树，用户通过提供文件路径就可以访问目标文件。这得益于OS提供的第4层抽象，OS通过引入目录文件将整个磁盘抽象为目录树<br /><img src="attachment/f0ba7c8f2c72156377deff8ba877cfb1.png" alt="" /><img src="attachment/2b35f973b51169eaec9bfb7f361896d5.png" alt="" /><br />我们现在以查找<code>/my/data/a</code>为例讲述目录树背后的机制<br />目录树要完成的就是能够通过用户提供的路径名找到目标文件的inode, 后续找到目标磁盘块并写入的工作由前3层抽象完成。那么怎么找到inode呢？我们需要有一个根目录<code>‘/’</code>，在这个根目录文件对应的数据块下存放它所包含的子文件和子目录的目录项。目录项（directory entry）通常包含文件名和相应的 inode 号。为什么不直接在当前目录文件对应的数据块存放子目录的inode呢？因为这样会使得查找的成本高，载入不必要的数据，因此只存放文件名以供查找和inode号以获取下一级子目录的数据块</p><img src="/2023/05/06/OS-Learning/HIT-OS/bad850a635a87757a071d989bebb0ba5.png" class=""><p>于是我们用find_entry函数在根目录文件的数据块上逐个寻找与<code>my</code>匹配的目录项，并通过这个目录项获取到目录文件my的inode号。接着，我们使用 iget 函数根据找到的 inode 号在inode数组中获取相应的inode。对每一级目录，我们不断执行这个过程，首先在根目录中查找 my，然后在 my 目录中查找 data，最后在 data目录中查找 file。每一步都需要使用 find_entry 和 iget 函数来获取相应的目录项和 inode 结构。</p><img src="/2023/05/06/OS-Learning/HIT-OS/2b35f973b51169eaec9bfb7f361896d5.png" class=""><p><strong>旁注： inode数组</strong></p><blockquote><p>在磁盘上，inode 以数组的形式组织。这个数组被称为 inode 表。inode 表中的每个元素都是一个固定大小的 inode 结构。文件系统中的每个文件和目录都有一个唯一的 inode 号，用于在 inode 表中定位其对应的 inode 结构。inode 号从 1 开始（注意，inode 号 0 是保留的，不表示任何文件或目录）。<br />当需要访问一个文件或目录的元数据时，首先需要从磁盘上的 inode 数组（即 inode 表）中读取相应的 inode 结构。</p></blockquote><p><img src="attachment/2b35f973b51169eaec9bfb7f361896d5.png" alt="" /><img src="attachment/2cf522c02b738c3a9a4c96c80234c33e.png" alt="" /></p><img src="/2023/05/06/OS-Learning/HIT-OS/2cf522c02b738c3a9a4c96c80234c33e.png" class="">]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu界面Mac化</title>
      <link href="/2023/03/27/notes/ubuntu_mac/"/>
      <url>/2023/03/27/notes/ubuntu_mac/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>最终效果:<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904915178-2b8d446d-4d5f-42d7-9850-d5a4c0dc0bcf.png#averageHue=%232dc92b&amp;clientId=u8ce3d915-14ae-4&amp;from=paste&amp;height=565&amp;id=ueeea8242&amp;name=image.png&amp;originHeight=848&amp;originWidth=1914&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=159245&amp;status=done&amp;style=none&amp;taskId=u5fb92b60-b558-40fb-9a44-b1f4da5e687&amp;title=&amp;width=1276" alt="image.png" /></p><h1 id="1-安装gnome-tweaks"><a class="markdownIt-Anchor" href="#1-安装gnome-tweaks"></a> 1. 安装GNOME Tweaks</h1><p>这个软件可以让你配置Ubuntu的交互界面，你可以在Ubuntu自带的由GNOME Software 下载<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679900946204-c742a5d9-a91a-4b67-8a85-b82a66b80d98.png#averageHue=%235e5e5e&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u117233a8&amp;name=image.png&amp;originHeight=743&amp;originWidth=1084&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=75219&amp;status=done&amp;style=none&amp;taskId=uaaab7274-262a-40dc-b6b7-e1858e9749d&amp;title=&amp;width=568.760009765625" alt="image.png" /></p><span id="more"></span><p><a name="i6Rr5"></a></p><h1 id="2下载安装模拟mac风格的交互界面主题whitesur-gtk-theme"><a class="markdownIt-Anchor" href="#2下载安装模拟mac风格的交互界面主题whitesur-gtk-theme"></a> 2.下载安装模拟Mac风格的交互界面主题<a href="https://github.com/vinceliuice/WhiteSur-gtk-theme">WhiteSur-gtk-theme</a></h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/vinceliuice/WhiteSur-gtk-theme.git<span class="token builtin class-name">cd</span> WhiteSur-gtk-theme./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a name="dH9pb"></a></p><h1 id="3-下载mac图标集"><a class="markdownIt-Anchor" href="#3-下载mac图标集"></a> 3. 下载Mac图标集</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/vinceliuice/WhiteSur-icon-theme<span class="token builtin class-name">cd</span>  WhiteSur-icon-theme./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a name="cwXmK"></a></p><h1 id="4-解除gnome-tweak-tool-中的扩展禁用状态"><a class="markdownIt-Anchor" href="#4-解除gnome-tweak-tool-中的扩展禁用状态"></a> 4. 解除Gnome Tweak Tool 中的扩展禁用状态</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901490751-dac0bd23-34aa-40db-a176-024e2f42459f.png#averageHue=%234d4c4c&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=400&amp;id=u37ab7a7f&amp;name=image.png&amp;originHeight=625&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=100597&amp;status=done&amp;style=none&amp;taskId=u1f3960dc-937b-4e46-b496-68fe90b71d4&amp;title=&amp;width=668.16" alt="image.png" /><br />安装<code>chrome-gnome-shell</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> chrome-gnome-shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着跳转到<a href="https://extensions.gnome.org/extension/19/user-themes/">User Themes</a><br />安装该插件并开启<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901620872-e69d3a78-b565-4b13-9736-46750d55fe6b.png#averageHue=%23fcfcfb&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=272&amp;id=uaa079ca5&amp;name=image.png&amp;originHeight=425&amp;originWidth=1447&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=60616&amp;status=done&amp;style=none&amp;taskId=uf904ddd5-8741-44fd-b6ad-7a7442b5c3c&amp;title=&amp;width=926.08" alt="image.png" /><br />解决<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901649198-a2f7d303-960f-4b35-b96e-0bc7c8ae464b.png#averageHue=%23353534&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u3191091d&amp;name=image.png&amp;originHeight=609&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=76490&amp;status=done&amp;style=none&amp;taskId=u79e6d1ca-ed2a-420f-9c0b-caec1b63807&amp;title=&amp;width=668.16" alt="image.png" /></p><p><a name="p4iNI"></a></p><h1 id="5-安装mac风格的dock"><a class="markdownIt-Anchor" href="#5-安装mac风格的dock"></a> 5. 安装Mac风格的Dock</h1><p>安装并开启<a href="https://extensions.gnome.org/extension/307/dash-to-dock/">Dash to Dock</a>，并可自行设置Dock样式<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679903078052-658ae42a-c311-4990-93f7-dc8700c3ddb5.png#averageHue=%23696969&amp;clientId=u33b15efd-72b8-4&amp;from=paste&amp;height=437&amp;id=ub859c8a3&amp;name=image.png&amp;originHeight=683&amp;originWidth=1385&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=168939&amp;status=done&amp;style=none&amp;taskId=u7cf1d85f-9a5e-4770-8407-ce5971d3b0b&amp;title=&amp;width=886.4" alt="image.png" /></p><p><a name="EAoF9"></a></p><h1 id="6-将交通灯移动到窗口右侧"><a class="markdownIt-Anchor" href="#6-将交通灯移动到窗口右侧"></a> 6. 将交通灯移动到窗口右侧</h1><p>在GNOME Tweaks -&gt; Window Titlebars -&gt; Left<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904374525-112bf886-c3ed-4b08-8636-460188802e21.png#averageHue=%23393938&amp;clientId=u053a5944-acf3-4&amp;from=paste&amp;height=429&amp;id=u3ec2f613&amp;name=image.png&amp;originHeight=643&amp;originWidth=1066&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=79002&amp;status=done&amp;style=none&amp;taskId=u3d4a3f13-0d2f-4d62-9dff-3a863f75003&amp;title=&amp;width=710.6666666666666" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> gadget </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU CS15213: CSAPP</title>
      <link href="/2023/03/06/CSAPP-Lab/CSAPP-LAB/"/>
      <url>/2023/03/06/CSAPP-Lab/CSAPP-LAB/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1-datalab"><a class="markdownIt-Anchor" href="#lab1-datalab"></a> lab1 dataLab</h1><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><p>确保有一个linux系统，并已经执行过以下两条命令:<br />安装gcc：<code>sudo apt-get install build-essential</code><br />安装<a href="https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea">gcc的交叉编译环境</a>.)：<code>sudo apt-get install gcc-multilib</code>，因为实验的程序需要以32位方式编译<br />在<a href="http://csapp.cs.cmu.edu/3e/labs.html">CMU的CSAPP网站</a>上下载实验所需资料，包括** README, Writeup，Self-Study Handout，** 这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件</p><h2 id="1bitxorxy"><a class="markdownIt-Anchor" href="#1bitxorxy"></a> 1.bitXor(x,y)</h2><p>要用~和&amp;实现异或^，即将结果中 1-0，0-1对应的位设置为1<br />x&amp;y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br />(<sub>x&amp;</sub>y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br />两个做交集即为结果。（位向量可以表示集合，&amp;，|，~可视为 交，并，补操作）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*bitXor - x^y using only ~ and &amp; Example: bitXor(4, 5) = 1Legal ops: ~ &amp;Max ops: 14Rating: 1*/</span><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span>  <span class="token operator">~</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token operator">&amp;</span><span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// if regardless '+' is illegal:(~x&amp;y) + ((x)&amp;(~y)) or ~((x&amp;y) + ((~x)&amp;(~y)))</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin"></a> 2.tmin</h2><p>最简单的一题：<code>000...001</code> --&gt; <code>1000...000</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* tmin - return minimum two's complement integer Legal ops: ! ~ &amp; ^ | + &lt;&lt; >>Max ops: 4Rating: 1*/</span><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3istmaxx"><a class="markdownIt-Anchor" href="#3istmaxx"></a> 3.isTmax(x)</h2><p>这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了<code>!((~x) + (~x))</code>，但<a href="https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471">测试结果出乎意料</a>，加法溢出导致了未知的行为。<br />根据 Tmax +1 = Tmin 的性质可以得出 ,  <code>100...000</code> + <code>011...111</code> = <code>111..1111</code> (-1)，可得出<code>!(~x^(x+1))</code>（^可替换为+）<br />处理特例-1： -1同样会产生结果1，根据 <code>-1+1==0</code>,<code>Tmax+1!=0</code>，进而<code>!(-1+1) !=0</code> ，<code>!(Tmax+1) ==0</code>.<br />所以<code>对Tmax, x+(x+1) = x</code> , <code>对-1,x+(x+1)!=x</code><br />用<code>x+(x+1)</code> 替换原式中的第一项x，最终得出结果：<code>!(~((x+!(x+1))^(x+1)))</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*isTmax - returns 1 if x is the maximum, two's complement number,and 0 otherwise egal ops: ! ~ &amp; ^ | +Max ops: 10Rating: 1*/</span><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment">// !((~x) + (~x));  it should be right, the operator "!" seem to not work</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4alloddbitsx"><a class="markdownIt-Anchor" href="#4alloddbitsx"></a> 4.allOddBits(x)</h2><p>这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br />用好异或即可解决：构造<code>101...1010</code>，再用该数提取x中的奇数位，最后再与<code>101...1010</code>比较</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* allOddBits - return 1 if all odd-numbered bits in word set to 1where bits are numbered from 0 (least significant) to 31 (most significant)Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1Legal ops: ! ~ &amp; ^ | + &lt;&lt; >>Max ops: 12Rating: 2*/</span><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> allOdd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xAA</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">0xAA</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">0xAA</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xAA</span><span class="token punctuation">;</span> <span class="token comment">// 10101010..101</span>  <span class="token keyword">return</span> <span class="token operator">!</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>allOdd <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">^</span> allOdd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5isasciidigitx"><a class="markdownIt-Anchor" href="#5isasciidigitx"></a> 5.isAsciiDigit(x)</h2><p>有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验—用异或执行比较操作。<br />x的最后四位，3bit 与 1,2bit不能同时为1，因而有<code>!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)))</code>，难点在于怎么处理好式中三部分的逻辑关系</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') *   Example: isAsciiDigit(0x35) = 1. *            isAsciiDigit(0x3a) = 0. *            isAsciiDigit(0x05) = 0. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 15 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> mask1 <span class="token operator">=</span> <span class="token number">0x3</span><span class="token punctuation">;</span>   <span class="token comment">// 000...0011</span>  <span class="token keyword">int</span> mask2 <span class="token operator">=</span> <span class="token number">0xA</span><span class="token punctuation">;</span>   <span class="token comment">// 1010</span>  <span class="token keyword">int</span> mask3 <span class="token operator">=</span> <span class="token number">0xC</span><span class="token punctuation">;</span>   <span class="token comment">// 1100</span>  <span class="token keyword">return</span>  <span class="token operator">!</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">^</span>mask1<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>mask2<span class="token punctuation">)</span><span class="token operator">^</span>mask2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>mask3<span class="token punctuation">)</span><span class="token operator">^</span>mask3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6conditional"><a class="markdownIt-Anchor" href="#6conditional"></a> 6.conditional</h2><p>比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br />涉及的操作是把x转化为0与1两个值，再把<code>000...0001</code>转化为<code>111...1111</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  * conditional - same as x ? y : z  *   Example: conditional(2,4,5) = 4 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >>  *   Max ops: 16 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span>  judge <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x=0 -> judge=1,whereas x!=0 -> judge=0</span>  judge <span class="token operator">=</span> <span class="token punctuation">(</span>judge <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment">// 000...000 or 111...111</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>judge<span class="token punctuation">)</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>judge<span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7islessorequalx-y"><a class="markdownIt-Anchor" href="#7islessorequalx-y"></a> 7.isLessOrEqual(x, y)</h2><p>可通过减法<code>y-x&gt;=0</code>判断<code>x&lt;=y</code>，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br />那么这题就涉及加法溢出,需要对<code>x+uw  y</code>结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br />更好的想法是<strong>分析式子</strong><code>**y-x**</code><strong>并加入一个conditional操作</strong>：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  * isLessOrEqual - if x &lt;= y  then return 1, else return 0  *   Example: isLessOrEqual(4,5) = 1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 24 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Tmin <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment">// 100...0000</span>  <span class="token keyword">int</span> signY <span class="token operator">=</span> Tmin <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>  <span class="token keyword">int</span> signX <span class="token operator">=</span> Tmin <span class="token operator">&amp;</span> x<span class="token punctuation">;</span>  <span class="token keyword">int</span> judge <span class="token operator">=</span> <span class="token punctuation">(</span>signY <span class="token operator">^</span> signX<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span>   x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>judge<span class="token operator">&amp;</span>signX<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>judge<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">+</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span>Tmin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8logicalnegx"><a class="markdownIt-Anchor" href="#8logicalnegx"></a> 8.logicalNeg(x)</h2><p>这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br />于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的<strong>positive overflow</strong>现象，即 Tmax + x ，对任意x&gt;0均会使结果变为负数，符号位由0 --&gt;1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致<a href="http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3">undefined behavior</a>）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  * logicalNeg - implement the ! operator, using all of  *              the legal operators except ! *   Examples: logicalNeg(3) = 0, logi'calNeg(0) = 1 *   Legal ops: ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 4  */</span><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Tmin <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> Tmax <span class="token operator">=</span> <span class="token operator">~</span>Tmin<span class="token punctuation">;</span>  <span class="token keyword">int</span> signX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>Tmin<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>signX<span class="token operator">^</span><span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> Tmax<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0x1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0x1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9howmanybitsx"><a class="markdownIt-Anchor" href="#9howmanybitsx"></a> 9.howManyBits(x)</h2><p>这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：<strong>当数的符号位为1时，将数按符号位扩展之后其值不会变</strong>，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br />要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -&gt; 0010)<br />按二分法逐步缩小范围，找到最左边的1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* howManyBits - return the minimum number of bits required to represent x in *             two's complement *  Examples: howManyBits(12) = 5 *            howManyBits(298) = 10 *            howManyBits(-5) = 4 *            howManyBits(0)  = 1 *            howManyBits(-1) = 1 *            howManyBits(0x80000000) = 32 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *  Max ops: 90 *  Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> b16<span class="token punctuation">,</span>b8<span class="token punctuation">,</span>b4<span class="token punctuation">,</span>b2<span class="token punctuation">,</span>b1<span class="token punctuation">,</span>b0<span class="token punctuation">;</span>  <span class="token keyword">int</span> signX <span class="token operator">=</span> x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>signX<span class="token punctuation">)</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>signX<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// if x is negative, let sign bit:1-> 0</span>    b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 16 bits exist 1 or not</span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b16<span class="token punctuation">;</span>  b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 8 bits </span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b8<span class="token punctuation">;</span>  b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 4 bits </span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b4<span class="token punctuation">;</span>    b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 2 bits </span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b2<span class="token punctuation">;</span>   b1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ensure 31 bits or not </span>  x <span class="token operator">=</span> x<span class="token operator">>></span>b1<span class="token punctuation">;</span>  b0 <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> b0<span class="token operator">+</span>b1<span class="token operator">+</span>b2<span class="token operator">+</span>b4<span class="token operator">+</span>b8<span class="token operator">+</span>b16<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1: sign bit</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10floatscale2uf"><a class="markdownIt-Anchor" href="#10floatscale2uf"></a> 10.floatScale2(uf)</h2><p>先对题目做出一点解释：传入一个<code>unsigned</code>类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br /><strong>整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论</strong><br />注意点：对normalized，f* 2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么<code>frac = frac &lt;&lt;1</code>，这也使得denormalized能转化到normalized (smoothly)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//float</span><span class="token comment">/*  * floatScale2 - Return bit-level equivalent of expression 2*f for *   floating point argument f. *   Both the argument and result are passed as unsigned int's, but *   they are to be interpreted as the bit-level representation of *   single-precision floating point values. *   When argument is NaN, return argument    // revision: NaN or infinity *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> musk_exp<span class="token punctuation">,</span>musk_frac<span class="token punctuation">,</span>sign<span class="token punctuation">,</span>exp<span class="token punctuation">,</span>frac<span class="token punctuation">,</span>result<span class="token punctuation">;</span>  musk_exp <span class="token operator">=</span> <span class="token number">0xFF</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>  musk_frac <span class="token operator">=</span> <span class="token number">0x7FFFFF</span><span class="token punctuation">;</span>  exp <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> musk_exp<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">;</span>  frac <span class="token operator">=</span> uf <span class="token operator">&amp;</span> musk_frac<span class="token punctuation">;</span>  sign <span class="token operator">=</span> <span class="token number">0x1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span> <span class="token operator">&amp;</span> uf<span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0xFF</span>  <span class="token punctuation">)</span> <span class="token comment">// NaN</span>     result <span class="token operator">=</span> uf<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span> <span class="token comment">// denormalized</span>  <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>frac <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span>  <span class="token comment">// -0.0</span>           result <span class="token operator">=</span> uf<span class="token punctuation">;</span>        <span class="token keyword">else</span>     <span class="token comment">// +0.0</span>           result <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>          <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>        frac <span class="token operator">=</span> frac <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> sign<span class="token operator">+</span> <span class="token punctuation">(</span>exp<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">+</span> frac<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">!=</span> <span class="token number">0x0</span> <span class="token operator">&amp;&amp;</span> exp <span class="token operator">!=</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token comment">// normalized</span>  <span class="token punctuation">&#123;</span>     exp <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>     result <span class="token operator">=</span> sign<span class="token operator">+</span> <span class="token punctuation">(</span>exp<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">+</span> frac<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11floatfloat2intuf"><a class="markdownIt-Anchor" href="#11floatfloat2intuf"></a> 11.floatFloat2Int(uf)</h2><p>浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br />对题目的解释：返回浮点数f的int型表示，如输入<code>12345.0 (0x4640E400)</code>, 正确输出为<code>12345 (0x3039)</code><br />注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E&gt;31时，属于out of range</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  * floatFloat2Int - Return bit-level equivalent of expression (int) f *   for floating point argument f. *   Argument is passed as unsigned int, but *   it is to be interpreted as the bit-level representation of a *   single-precision floating point value. *   Anything out of range (including NaN and infinity) should return *   0x80000000u. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span> <span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> musk_exp<span class="token punctuation">,</span>musk_frac<span class="token punctuation">,</span>exp<span class="token punctuation">,</span>frac<span class="token punctuation">,</span>sign<span class="token punctuation">,</span>E<span class="token punctuation">,</span>Bias<span class="token punctuation">,</span>result<span class="token punctuation">;</span>  musk_exp <span class="token operator">=</span> <span class="token number">0xFF</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>  musk_frac <span class="token operator">=</span> <span class="token number">0x7FFFFF</span><span class="token punctuation">;</span>  exp <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> musk_exp<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">;</span>  frac <span class="token operator">=</span> uf <span class="token operator">&amp;</span> musk_frac<span class="token punctuation">;</span>  sign <span class="token operator">=</span> <span class="token number">0x1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span> <span class="token operator">&amp;</span> uf<span class="token punctuation">;</span>  Bias <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0xFF</span>  <span class="token punctuation">)</span> <span class="token comment">// NaN or infinity</span>     result <span class="token operator">=</span> <span class="token number">0x80000000u</span><span class="token punctuation">;</span>       <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span>     result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">!=</span> <span class="token number">0x0</span> <span class="token operator">&amp;&amp;</span> exp <span class="token operator">!=</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token comment">// normalized</span>  <span class="token punctuation">&#123;</span>     E <span class="token operator">=</span> exp <span class="token operator">-</span>Bias<span class="token punctuation">;</span>  <span class="token comment">// bit_num of fraction</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>E <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>E<span class="token operator">></span><span class="token number">31</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token number">0x80000000u</span><span class="token punctuation">;</span>     <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>        frac <span class="token operator">=</span> frac<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">23</span><span class="token operator">-</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> E<span class="token punctuation">)</span> <span class="token operator">+</span> frac <span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>sign <span class="token operator">==</span> <span class="token number">0x1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">)</span>           result <span class="token operator">=</span> <span class="token operator">-</span> result<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12floatpower2x"><a class="markdownIt-Anchor" href="#12floatpower2x"></a> 12.floatPower2(x)</h2><p>注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  * floatPower2 - Return bit-level equivalent of the expression 2.0^x *   (2.0 raised to the power x) for any 32-bit integer x. * *   The unsigned value that is returned should have the identical bit *   representation as the single-precision floating-point number 2.0^x. *   If the result is too small to be represented as a denorm, return *   0. If too large, return +INF. *  *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while  *   Max ops: 30  *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> exp<span class="token punctuation">,</span>frac<span class="token punctuation">,</span>E<span class="token punctuation">,</span>Bias<span class="token punctuation">,</span>result<span class="token punctuation">;</span>  Bias <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  E <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">0x1</span> <span class="token operator">||</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>     frac <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>     exp <span class="token operator">=</span> E<span class="token operator">+</span>Bias<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">></span> <span class="token number">254</span><span class="token punctuation">)</span>  <span class="token comment">// 1111 1110</span>        <span class="token punctuation">&#123;</span>           exp <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>           result <span class="token operator">=</span> exp <span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token operator">+</span>frac<span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>exp<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">+</span> frac<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="consequence"><a class="markdownIt-Anchor" href="#consequence"></a> consequence</h2><p><code>make</code><br /><code>./driver.pl</code></p><h3 id="-swig28-"><a class="markdownIt-Anchor" href="#-swig28-"></a> <img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a4c293cc441f32d00b3dbc0cdac50ab4.png" class=""></h3><hr /><h1 id="lab2-bomblab"><a class="markdownIt-Anchor" href="#lab2-bomblab"></a> lab2 bombLab</h1><h2 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> phase_1</h2><ol><li>反汇编<code>main</code>函数：<code>read_line</code>函数之后寄存器<code>%rax</code>和<code>%rdi</code>存储了我们输入的字符串的首地址(后续的phase都是如此)</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/d0b5436e3bd694ef9dadbf62a885e8f4.png" class=""><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=128&amp;id=u1267f1f6&amp;originHeight=128&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=59576&amp;status=done&amp;style=none&amp;taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&amp;width=1060" alt="验证%rdi指向输入字符串(1)" title="验证%rdi指向输入字符串(1)" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=77&amp;id=ubbe401e0&amp;originHeight=77&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=31472&amp;status=done&amp;style=none&amp;taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&amp;width=723" alt="验证%rdi指向输入字符串(2)" title="验证%rdi指向输入字符串(2)" /></p><ol start="2"><li>反汇编<code>strings_not_equal</code>函数：该函数在输入字符串与目的字符串相同时，将寄存器<code>%rax</code>（通常用作函数返回值）赋值为0 (1 vice versa)</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/82696a312b38b2caffbed1decdebe663.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/68c822853ca0f63de658940ba09b7003.png" class=""><ol start="3"><li>反汇编<code>phase_1</code>函数：<code>strings_not_equal</code>函数返回值为0时，<code>test %eax, %eax</code>能使<code>je 0x400ef7&lt;phase_1+23&gt;</code>执行，phase_1 defused (explode vice versa)</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/19429a3d7d01b10593c4e4448702d955.png" class=""><ol start="4"><li>至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用<code>strings_not_equal</code>函数之前赋值的<code>%esi：0x402400</code>寄存器中</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/848f00e31ae9e6e18106b6038356b61c.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/dd5ff3c83ce1679eab6d51fba602f527.png" class=""><h2 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> phase_2</h2><ol><li>反汇编<code>read_six_numbers</code>函数：可以推断出其实现了<code>sscanf(input, &quot;%d %d %d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6)</code>的功能，其中<code>&amp;a1~&amp;a6</code>分别在1)<code>%rcx:0x4(%rsi)</code>2)<code>%r8:0x8(%rsi)</code>3)<code>%r9:0xc(%rsi)</code>4)<code>%rsp:0x10(%rsi)</code>5)<code>0x8(%rsp):0x14(%rsi), 0x18(%rsi) </code> 前3个指针存储在寄存器中传递给<code>sscanf</code>函数，后三个指针存储在为<code>read_six_numbers</code>函数分配的栈空间中,可以推断出<code>%rsi</code>为一个含有六个元素的数组的首地址</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/49e195de46edde2a13a3d612e3f4436f.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/848f00e31ae9e6e18106b6038356b61c.png" class=""><ol start="2"><li>反汇编<code>phase_2</code>函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a2c1f6510d1747ac9f31f9caaa5f0cf6.png" class=""><ol start="3"><li>自此，我们可以判断出这六个数字分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>1</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>3</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>4</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2^0,2^1,2^2,2^3,2^4,2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/cc9b4103bc02a8d67f35043fedfface7.png" class=""><h2 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h2><ol><li>反汇编<code>phase_3</code>：从<code>(%esi)</code>的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(<code>cmpl 0x7,0x8(rsp)</code>)，并根据这个值执行间接跳转操作(<code>jmp *0x402470(,rax,8)</code>)</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/8f19c8e6410929f9f8eadf10f37a2ccd.png" class=""><ol start="2"><li>查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的<code>0x8(%rsp</code>：1 2 3 4 5 6 7</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/ba11b3ecaddba2f5b95962aa2edd2a17.png" class=""><ol start="3"><li>根据后续的赋值-跳转指令，可以得到对应的7个<code>0xc(%rsp)</code>：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)</li></ol><p><img src="attachment/9fe1343ecdbd946c3404a678738f74d7.png" alt="" /><img src="attachment/49e195de46edde2a13a3d612e3f4436f.png" alt="" /><br /><img src="attachment/c8c8680d6369eb064a9fb0434b0b3d31.png" alt="" /><img src="attachment/8f19c8e6410929f9f8eadf10f37a2ccd.png" alt="" /><img src="attachment/c8c8680d6369eb064a9fb0434b0b3d31.png" alt="" /><img src="attachment/cc9b4103bc02a8d67f35043fedfface7.png" alt="" /><img src="attachment/cc9b4103bc02a8d67f35043fedfface7.png" alt="" /><img src="attachment/49e195de46edde2a13a3d612e3f4436f.png" alt="" /><img src="attachment/33260348d45935dfc16fd4da8e94e9a0.png" alt="" /></p><h2 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> phase_4</h2><ol><li>反汇编<code>phase_4</code>函数：开头部分具有与<code>phase_3</code>函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(<code>cmpl $0xe, 0x8(%rsp)</code>)，之后函数调用<code>func4</code>函数，传入三个参数<code>%edx</code>, <code>%esi</code>, <code>0x8(%rsp)</code>。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(<code>test %eax, %eax</code>)。后续的<code>cmpl $0x0, 0xc(%rsp)</code>足以确定第2个值为0</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/e36a2a99955dab7372f26e5f6c54cea0.png" class=""><ol start="2"><li>反汇编<code>func4</code>函数：出现了<code>func4</code>调用自身的情况，所以<code>func4</code>是一个递归函数。第1部分将<code>%rax</code>赋值为<code>%edx</code>-<code>%esi</code>,再加上它的最高位(<code>%rax &gt;&gt; 31</code>)，接着执行算数右移。这里加上最高位的原因在于，当后续<code>%rax</code>在递归中值减少为-1时，最高位是符号位1，两者相加能保证<code>%rax</code>始终大于等于0，结合后续汇编内容，可以推断出第一个值<code>0x8(%rsp)</code>应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果<code>%ecx &gt; %edi</code>，那么就使<code>%ecx</code>变为<code>%esi</code>到<code>%edx</code>的中间值(<code>lea -0x1(%rcx), %edx</code>)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回<code>phase_4</code>的<code>%rax</code>值为1</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/e6d3379fc4d365ff408c77b2babf4d21.png" class=""><ol start="3"><li>自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)</li></ol><p><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /><br /><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /></p><h2 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> phase_5</h2><ol><li>反汇编<code>phase_5</code>函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> index<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// %rax</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>index <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>index <span class="token operator">=</span> index<span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">;</span> <span class="token comment">// take lower four bits</span>dest<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// dest: (%rsp+0x10+%rax) source: 0x4024b0</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">string_not_equal</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// target: 0x40245e --- "flyers"</span>      <span class="token comment">//defuse</span><span class="token keyword">else</span>   <span class="token function">explode_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/257036f48e30c46dedcbdf50015da107.png" class=""><ol start="2"><li>分别查看<code>source: 0x4024b0</code>和<code>target: 0x40245e</code>处的字符串，我们要做的就是使输入字符串形成的索引值能够从<code>0x4024b0</code>处的字符集中提取出 “flyers”</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/60e7bd6e50d50fb77b707637148c0e04.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/d363fbe15afd12811daeb0a66ede9589.png" class=""><ol start="3"><li>我们的输入字符串每个字符在内存中占一个byte，<code>movzbl (%rbx, %rax, 1), %ecx</code>说明了一次循环提取一个字符，并只取该字符的低四位(<code>and $0xf, %edx</code>)作为索引值</li><li>首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw</li></ol><p><img src="attachment/e01a62cd2c34aaab94c959af6be846d3.png" alt="" /><img src="attachment/e6d3379fc4d365ff408c77b2babf4d21.png" alt="" /></p><h2 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> phase_6</h2><ol><li>thinking process</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// %r12d</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy <span class="token operator">=</span> input<span class="token punctuation">;</span> <span class="token comment">// mov %rsp, %r13</span><span class="token keyword">int</span> val<span class="token punctuation">;</span> <span class="token comment">// %eax</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    val <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input_copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x0(%r13)</span>    val <span class="token operator">=</span> val<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">></span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 元素值不得大于6</span>            <span class="token operator">++</span>a1<span class="token punctuation">;</span> <span class="token comment">// add $0x1, %r12d</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// jmp 95</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">// mov %r12d, %ebx</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 65</span>        val <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token operator">*</span>input_copy<span class="token punctuation">)</span>            <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>a2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>a2<span class="token operator">&lt;=</span> <span class="token number">5</span> <span class="token punctuation">)</span> <span class="token comment">// 87</span>    <span class="token operator">++</span>input_copy<span class="token punctuation">;</span> <span class="token comment">// add $0x4, %r13</span><span class="token punctuation">&#125;</span> <span class="token comment">// 93</span><span class="token comment">/*两个信息：(已验证)1. 输入字符串中所有元素不大于62. 输入字符串中所有元素互不相等 */</span> <span class="token number">0</span><span class="token operator">~</span><span class="token number">6</span><span class="token keyword">int</span><span class="token operator">*</span> sentry <span class="token operator">=</span> input<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// mov 0x18(%rsp), %rsi   95</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy_2 <span class="token operator">=</span> input<span class="token punctuation">;</span> <span class="token comment">// %rax</span><span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// %edx, %ecx</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>input_copy_2<span class="token punctuation">)</span> <span class="token operator">=</span> a3 <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span>input_copy_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>input_copy_2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>input_copy_2 <span class="token operator">!=</span> sentry<span class="token punctuation">)</span><span class="token comment">/* 更新输入字符串所有值为：7-初始值(已证实), 结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */</span> <span class="token keyword">int</span> a4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 123 %esi  -- index</span><span class="token keyword">int</span> a5<span class="token punctuation">;</span> <span class="token comment">// %edx</span><span class="token keyword">int</span> a6<span class="token punctuation">;</span> <span class="token comment">// %eax  -- index</span>offset_166<span class="token operator">:</span><span class="token keyword">if</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>a4<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 166  %ecx</span><span class="token punctuation">&#123;</span>    a5 <span class="token operator">=</span> <span class="token number">0x6032d0</span><span class="token punctuation">;</span> <span class="token comment">// 143</span>    offset_148<span class="token operator">:</span>    <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">0x20</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>a4<span class="token punctuation">)</span> <span class="token operator">=</span> a5<span class="token punctuation">;</span> <span class="token comment">// 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48</span>                             <span class="token comment">//   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   </span>    a4 <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// add $0x4, %rsi </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a4 <span class="token operator">==</span>  <span class="token number">24</span> <span class="token punctuation">)</span>        <span class="token keyword">goto</span> offset_183<span class="token punctuation">;</span> <span class="token comment">// 161 </span>    <span class="token keyword">else</span>         <span class="token keyword">goto</span> offset_166<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>  <span class="token comment">// 均要走这个else， 可能有一个不走这个else -->肯定有一个不走</span><span class="token punctuation">&#123;</span>    a6 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 171  </span>    <span class="token operator">&amp;</span>a5 <span class="token operator">=</span> <span class="token number">0x6032d0</span><span class="token punctuation">;</span> <span class="token comment">// 176  这个地址+0x8能多次跳转</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span> <span class="token comment">// 130</span>        a5 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a5 <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// mov 0x8(%rdx),%rdx  链表?</span>        <span class="token operator">++</span>a6<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>a6 <span class="token operator">!=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span>a4<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)</span>    <span class="token keyword">goto</span> offset_148<span class="token punctuation">;</span>         <span class="token comment">// recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5</span><span class="token punctuation">&#125;</span> <span class="token comment">// 181</span>offset_183：    function<span class="token operator">:</span> link node in order<span class="token keyword">int</span> a7 <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy_3 <span class="token operator">=</span> input<span class="token operator">+</span><span class="token number">10</span> <span class="token comment">// %rax  0x28(%rsp)</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy_4 <span class="token operator">=</span> input<span class="token operator">+</span><span class="token number">20</span> <span class="token comment">// %rsi  0x50(%rsp)</span>a3 <span class="token operator">=</span> a7<span class="token punctuation">;</span> <span class="token comment">// a3:%rcx</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 201</span>    a5 <span class="token operator">=</span> <span class="token operator">*</span>input_copy_3<span class="token punctuation">;</span> <span class="token comment">//a5:%rdx [10][12]...[18][20] 6</span>    <span class="token operator">*</span><span class="token punctuation">(</span>a3<span class="token operator">+</span><span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> a5<span class="token punctuation">;</span> <span class="token comment">// 0x8(%rcx)</span>    input_copy_3 <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 0x8 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>input_copy_3 <span class="token operator">==</span> input_copy_4<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 215 </span>    a3 <span class="token operator">=</span> a5<span class="token punctuation">;</span> <span class="token comment">// mov %rdx, %rcx</span><span class="token punctuation">&#125;</span>    <span class="token comment">//   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)</span><span class="token comment">// 结束时 %rdx = * (input + 18)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 222   set last node's pointer to nullptr</span><span class="token keyword">int</span> a8 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// %ebp</span><span class="token keyword">int</span> a9 <span class="token comment">// %rax </span><span class="token keyword">do</span><span class="token punctuation">&#123;</span> <span class="token operator">&amp;</span>a9 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>a7<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// %rax   initial a7 = input[8]</span>  a9 <span class="token operator">=</span> <span class="token operator">*</span>a9<span class="token punctuation">;</span> <span class="token comment">// mov (%rax), %eax</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> a9<span class="token punctuation">)</span> <span class="token comment">// cmp %eax, (%rbx) </span>    <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 验证是否降序</span>a7 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mov 0x8(%rbx), %rbx 更新%rbx  </span><span class="token operator">--</span>a8<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>a8<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// over</span>    <span class="token comment">/*inital:0x14c(0): 332;0x0a8(1): 168;0x39c(2): 924;0x2b3(3): 6910x1dd(4): 4770x1bb(5): 4432->3->4->5->0->1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是<code>0x6032d0</code>这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使<code>0x6032d0</code>这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/acd690b3b50691d1f6e3f12a5cbd3c85.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/40edff8d78bfb0c20b5b843703546e03.png" class=""><h2 id="secret_phase"><a class="markdownIt-Anchor" href="#secret_phase"></a> secret_phase</h2><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/532ab5bef0f2b1fbcb4e3a75616980cc.png" class=""><ol><li>发现彩蛋</li></ol><p>以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用<code>objdump -t bomb</code>查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/022618c6c2df7c53f1385e093b46d9bf.png" class=""><ol start="2"><li>怎么触发</li></ol><p>1)谁调用了secret_phase：<code>secret_phase</code>既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在<code>main</code>函数中寻找可能调用<code>secret_base</code>的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在<code>phase_defused</code>函数中，反汇编<code>phase_defused</code>函数，果然发现了调用<code>secret_phase</code>的指令</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/d198271aa8a29539467dd82ee47ef6ad.png" class=""><p>2）在phase_defused中如何触发：从<code>main</code>函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次<code>phase_defused</code>。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/02e77af27b1c4e865e36db8907ca7b63.png" class=""><p>接着从地址<code>0x603870</code>处读取两个数字，一个字符串</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/840754c4bede736bec5534802d03b4c2.png" class=""><p>经过验证，地址<code>0x603870</code>为phase_4阶段输入字符串的开始地址<br /><img src="attachment/a660c4c01c2033e2876e3574083862bd.png" alt="" /><img src="attachment/42cd427d395bd0887302dfbe5f3a095f.png" alt="" /><br />根据后续逻辑，只要在phase_4阶段时输入<code>&quot;7 0 DrEvil&quot;</code>即可触发<code>secret_bomb</code></p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/172349e0413d8582ce691ac2f1abecf3.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/6275de0a9feabb7b06a305b4e04ba190.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a7dc7f4a3fb6f6a4c1c13204acce6c2e.png" class=""><ol start="3"><li>终章：拆解secret_phase</li></ol><p>1）反编译secret_base</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">secret_phase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> input_2<span class="token punctuation">;</span><span class="token comment">// (%rdi)</span>    <span class="token operator">&amp;</span>input_2 <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  %rdi</span>        <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">0xa</span><span class="token punctuation">;</span> <span class="token comment">// %edx</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span> <span class="token comment">// %esi</span>    <span class="token keyword">long</span> <span class="token keyword">int</span> input_num_1 <span class="token operator">=</span> <span class="token function">strtol</span><span class="token punctuation">(</span>input_2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// %rax</span>    <span class="token keyword">long</span> <span class="token keyword">int</span> input_num_2 <span class="token operator">=</span> input_num_1 <span class="token comment">// %rbx</span>    input_num_1 <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>input_num_1 <span class="token operator">></span> <span class="token number">0x3e8</span> <span class="token comment">/*1000*/</span><span class="token punctuation">)</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输入的数字字符串 值小于 1001</span>    a2 <span class="token operator">=</span> input_num_2<span class="token punctuation">;</span><span class="token comment">// mov %ebx, %esi  </span>    <span class="token operator">&amp;</span>input_2 <span class="token operator">=</span> <span class="token number">0x6030f0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span>a2<span class="token punctuation">,</span>input_num_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ret_value: %rax</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0x2</span><span class="token punctuation">)</span>        <span class="token function">defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> input_num_1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2 <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// avoid endless recursion</span>    <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 9 %edx   initial a3 = 24</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a3 <span class="token operator">&lt;=</span> a2<span class="token punctuation">)</span> <span class="token keyword">goto</span> offset_28<span class="token punctuation">;</span> <span class="token comment">// 13  a2是输入值 </span>    <span class="token comment">// a3 > a2</span>    input_2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2 <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// +2  turn left</span>    input_num_1 <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> input_num_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 19</span>    input_num_1 <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// input_num_q is 1 here</span>    <span class="token keyword">return</span> input_num_1<span class="token punctuation">;</span>    offset_28<span class="token operator">:</span>    input_num_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a3 <span class="token operator">==</span> a2<span class="token punctuation">)</span> <span class="token keyword">return</span> input_num_1<span class="token punctuation">;</span>    <span class="token comment">// a3 &lt; a2</span>    input_2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2 <span class="token operator">+</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// +4   turn right</span>    input_num_1 <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> input_num_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>    input_num_1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>input_num_1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>    <span class="token keyword">return</span> input_num_1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）有了phase_6的经验，我在查看了特殊地址<code>0x6030f0</code>的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址<code>0x6030f0</code>为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合<code>secret_phase</code>的逻辑，在子函数<code>fun7</code>返回值为2时defuse，经过分析，<code>fun7</code>这个递归函数，在最后三次递归时为turn left(<code>&amp;input_2 + 0x8</code>）-&gt;turn right(<code>&amp;input_2 + 0x10</code>) -&gt; return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a05e697174deb4b8d970e125f4076696.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/d198271aa8a29539467dd82ee47ef6ad.png" class=""><ol start="3"><li>至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/022618c6c2df7c53f1385e093b46d9bf.png" class=""><hr /><h1 id="lab3-attacklab"><a class="markdownIt-Anchor" href="#lab3-attacklab"></a> lab3 attacklab</h1><h2 id="前提-2"><a class="markdownIt-Anchor" href="#前提-2"></a> 前提</h2><ol><li>注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04</li></ol><p>博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题</p><ol start="2"><li>exploit string用工具<code>hex/2raw</code>构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。</li></ol><p>writeup的附录A介绍了多种<code>hex/2raw</code>接受输入字符串并传递给ctarget的多种方式，我习惯用：<br /><code>./hex2raw &lt; exploit_string.txt | ./ctarget -q</code><br />这条命令将<code>exploit_string.txt</code>作为<code>hex2raw</code>的输入，并建立管道将<code>hex2raw</code>的输出传输到<code>./ctarget</code>中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行<code>./hex2raw</code>那么将无法中止输入</p><h2 id="phase_1-2"><a class="markdownIt-Anchor" href="#phase_1-2"></a> phase_1</h2><ol><li>反汇编<code>ctarget</code>：可用<code>objdump -d ctarget</code>获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/5e39b3abb1bc5e7f4330d928004e1682.png" class=""><p>这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了</p><ol start="2"><li><code>vim dis_ctarget.asm</code>查看<code>getbuf</code>函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者<code>test</code>函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看<code>touch1</code>函数，它的地址在<code>0x004017c0</code>处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/77ee6da89546a4114df2d33fbf821a72.png" class=""><ol start="3"><li><code>vim phase_1.txt</code>输入</li></ol><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>0</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>40</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\  &amp;00 &amp;00  &amp; 00 &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;c0 &amp;17  &amp;40  &amp;00  &amp;00  &amp;00  &amp;00\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.200000000000001em;vertical-align:-3.35em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-5.8500000000000005em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.650000000000001em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.05em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:0.1500000000000002em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span><br />最后留了一个字节以供gets放入’ \n ’ (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/77ee6da89546a4114df2d33fbf821a72.png" class=""><h2 id="phase_2-2"><a class="markdownIt-Anchor" href="#phase_2-2"></a> phase_2</h2><ol><li>编写汇编代码，转化为字节码：<code>vim asb.s</code>，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/97bcb18bfbfeb7e9317be7ad13681c7d.png" class=""><p>line1将<code>cookie</code>值赋给<code>%rdi</code>传参给<code>touch2</code>；ine2将2<code>touch2</code>的地址压入栈中，目的在于在<code>ret</code>指令执行后，从栈中弹出并赋值给<code>%rip</code>的返回地址是<code>touch2</code>的地址</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/aeea8b6bce1c1c133dbdb9f1a3d99fc5.png" class=""><p>writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br /><code>gcc -c asb.s</code><br /><code>objdump -d asb.o &gt; asb.d</code><br />这样我们就得到了指令序列的字节码，可用于构造exploit_string</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/545f6b671736fb44dfde1345b0c75cff.png" class=""><ol start="2"><li>构造<code>phase_2.txt</code>，因为<code>asb.o</code>中的代码本身就已经逆序，所以直接输入即可；用于覆盖<code>test</code>栈帧中返回地址的值可由<code>%rsp</code>的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是<code>%rsp</code>的值</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/7ff73ffc1bf9e9611f1cd79ae7de1f2c.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/6a17fd900e3467ceb030942fd0334f13.png" class=""><ol start="3"><li>攻击生效</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/0cf71efb20d9854b0a1e6e1cfb8a3252.png" class=""><h2 id="phase_3-2"><a class="markdownIt-Anchor" href="#phase_3-2"></a> phase_3</h2><ol><li>与<code>phase_2</code>很像，但这次要传递的参数是字符串形式的<code>cookie</code>。因为<code>getbuf</code>的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串<code>cookie</code>放在<code>test</code>函数的栈帧中，地址<code>0x5561dca8</code>；获取<code>touch3</code>函数的地址，编写攻击代码</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/7210c3d6fbde68b1e7705b12b56e6d38.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/75eb7fac02ee199b822f199e5e69d09f.png" class=""><ol start="2"><li><code>ascii -ax</code>查看十六进制形式的ascii-table，得出<code>&quot;59b997fa&quot;</code>的ascii形式为<code>35 39 62 39 39 37 66 61</code></li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a05e697174deb4b8d970e125f4076696.png" class=""><ol start="3"><li>覆盖返回地址和test栈帧，写入攻击代码的地址和字符串<code>cookie</code></li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a05e697174deb4b8d970e125f4076696.png" class=""><ol start="4"><li>攻击生效</li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a85afbd69b690948359583ead1d13729.png" class=""><h2 id="phase_4-2"><a class="markdownIt-Anchor" href="#phase_4-2"></a> phase_4</h2><p>确定攻击方案：<code>rtarget</code>由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用<code>ctarget</code>自身的代码实现攻击，具体做法是通过地址跳转，截取<code>ctarget</code>的部分代码用作攻击代码；<code>gadget</code>指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串<code>gadget</code>的地址，那么一旦执行其中一个<code>gadget</code>，<code>ret</code>指令就会不断的从栈中弹出新的<code>gadget</code>的地址赋给<code>%rip</code>,由此引发多个<code>gadget</code>的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）</p><ol><li><code>cookie</code>的值不可能从<code>rgadget</code>中找到，需要我们自己放到栈中，如同<code>phase_3</code>一样，放的位置不能是<code>getbuf</code>的缓冲区，因此我们将其放到<code>test</code>的栈帧中；接着要实现<code>mov $0x59b997fa,%rdi</code>，需执行<code>popq %rdi</code>，根据writeup的参照表，先在<code>start_farm</code>和<code>end_farm</code>之间寻找<code>5f</code>，结果没有，但是找到了<code>58 90</code>,地址为<code>0x004019ab</code>，这代表<code>popq %rax  nop</code>，因此我们需要用<code>%rax</code>作介质传递<code>cookie</code>给<code>%rdi</code>，而在farm中我们也确实找到了<code>movq %rax, %rdi：48 89 c7</code>，地址为<code>0x004019c5</code>，一共用到了两个<code>gadget</code></li></ol><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/bbea916ea56dfc9a947de21da0b02567.png" class=""><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/a85afbd69b690948359583ead1d13729.png" class=""><ol start="2"><li>按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒</li></ol><p><img src="attachment/db45ead78f5aca153cab1156d508daef.png" alt="" /><img src="attachment/50bc769c1e6db59af741f48d8624ac96.png" alt="" /></p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/7c0c3e8a239918e820904293bd7101c2.png" class=""><hr /><h1 id="lab4-cachelab"><a class="markdownIt-Anchor" href="#lab4-cachelab"></a> lab4 cachelab</h1><h2 id="parta"><a class="markdownIt-Anchor" href="#parta"></a> PartA</h2><h3 id="1-要做什么"><a class="markdownIt-Anchor" href="#1-要做什么"></a> 1. 要做什么：</h3><p><a href="https://www.yuque.com/attachments/yuque/0/2023/pdf/29536731/1679034059665-5dc8f6ef-14b4-44d3-b7d7-86d86787439b.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F29536731%2F1679034059665-5dc8f6ef-14b4-44d3-b7d7-86d86787439b.pdf%22%2C%22name%22%3A%22cachelab.pdf%22%2C%22size%22%3A61287%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ucfed49fb-dba4-4b45-976d-96d9752defc%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22iZZyy%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">cachelab.pdf</a> <a href="https://www.yuque.com/attachments/yuque/0/2023/pdf/29536731/1679034059905-2f06047b-ba4e-4abb-b642-f43a20552896.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F29536731%2F1679034059905-2f06047b-ba4e-4abb-b642-f43a20552896.pdf%22%2C%22name%22%3A%22rec07.pdf%22%2C%22size%22%3A373293%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u3bcb76bc-9a98-45cd-a08f-c450961f38a%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22M2QOk%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">rec07.pdf</a><br />partA 中提到的<code>.trace</code>文件是一个可执行文件的内存访问记录，由Linux程序<code>valgrind</code>产生。partA要求我们构造一个模拟cache行为的<code>cache simulator</code>，将<code>.trace</code>文件作为输入(实际上就是一条条内存访问记录，模拟内存访问过程)，并伴有三个输入参数：</p><ol><li>组索引位数 -s  （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">S = 2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span>为高速缓存组的组数）</li><li>高速缓存行数 -E</li><li>块偏移位数 -b （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B = 2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>为高速缓存块的大小）</li></ol><p>根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用<code>printSummary(hit_count, miss_count, eviction_count)</code>函数完成，输出结果应当与作者提供给我们的<code>reference cache simulator</code>相同，运行<code>make</code>+<code>./test-csim</code>获取评分</p><h3 id="2-getopt函数的用法"><a class="markdownIt-Anchor" href="#2-getopt函数的用法"></a> 2. getopt函数的用法</h3><p>由于三个参数通过命令行输入，因此我们需要通过C语言库中的<code>getopt</code>函数，结合switch语句从命令行中获取参数值<br />C语言中的<code>main</code>函数是程序的入口函数，它包含两个参数：<code>argc</code>和<code>argv</code>。它们的作用如下：</p><ol><li>argc参数</li></ol><p>argc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。</p><ol><li>argv参数</li></ol><p>argv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br />通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br />C语言中的<code>getopt</code>函数可以帮助程序解析命令行参数。<code>getopt</code>函数通常与<code>argc</code>和<code>argv</code>参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是<code>getopt</code>函数的一般用法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> opt<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"abc:d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -a\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'b'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'c'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -c with value '%s'\n"</span><span class="token punctuation">,</span> optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -d\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'?'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unknown option: %c\n"</span><span class="token punctuation">,</span> optopt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，<code>getopt</code>函数的第一个参数是<code>argc</code>，第二个参数是<code>argv</code>，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，<code>&quot;abc:d&quot;</code>表示可接受的选项有<code>-a</code>、<code>-b</code>、<code>-c</code>和<code>-d</code>，其中<code>-c</code>选项需要接受一个参数。<br /><code>getopt</code>函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用<code>switch</code>语句根据选项进行相应的操作。如果<code>getopt</code>函数发现了一个未知的选项，它会返回<code>?</code>,并将这个选项保存在<code>optopt</code>变量中。<br />以下是一些示例命令行及其对应的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./a.out <span class="token parameter variable">-a</span> <span class="token parameter variable">-b</span> <span class="token parameter variable">-c</span> filename <span class="token parameter variable">-d</span>Option <span class="token parameter variable">-a</span>Option <span class="token parameter variable">-b</span>Option <span class="token parameter variable">-c</span> with value <span class="token string">'filename'</span>Option <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./a.out <span class="token parameter variable">-a</span> <span class="token parameter variable">-b</span> <span class="token parameter variable">-c</span>Option <span class="token parameter variable">-a</span>Option <span class="token parameter variable">-b</span>Unknown option: c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在使用<code>getopt</code>函数时，需要注意以下几点：</p><ol><li>在循环中，<code>optarg</code>变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过<code>atoi</code>函数转化为整型。</li><li>如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，<code>getopt</code>函数会返回<code>?</code>，并将这个选项保存在<code>optopt</code>变量</li><li>如果一个选项在可接受的选项字符串中没有指定，<code>getopt</code>函数会返回<code>-1</code>，并结束循环</li></ol><p><code>getopt</code>函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br />虽然<code>getopt</code>函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，<code>getopt</code>函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br />可接受选项字符串可以告诉<code>getopt</code>函数哪些选项是合法的，以及它们是否需要参数，从而使<code>getopt</code>函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串<code>&quot;ab:c&quot;</code>表示程序支持三个选项<code>-a</code>、<code>-b</code>和<code>-c</code>, 其中<code>-c</code>选项需要一个参数。</p><h3 id="3-fscanf的用法"><a class="markdownIt-Anchor" href="#3-fscanf的用法"></a> 3. fscanf的用法</h3><p><code>fscanf</code>是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。<code>fscanf</code>函数的基本格式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，第一个参数<code>stream</code>是指向要读取数据的文件的指针；第二个参数<code>format</code>是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br />例如，如果你有一个文件<code>data.txt</code>，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量<code>a</code>、<code>b</code>、<code>c</code>中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>    <span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d, b = %d, c = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，<code>fscanf</code>函数的第一个参数是文件指针<code>fp</code>，第二个参数是格式化字符串<code>&quot;%d %d %d&quot;</code>，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量<code>a</code>、<code>b</code>、<code>c</code>的地址，<code>fscanf</code>函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。</p><h3 id="4-编写程序"><a class="markdownIt-Anchor" href="#4-编写程序"></a> 4. 编写程序</h3><p>这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量</p><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/ea760dfad84e022b238df1bf264916b5.png" class=""><ol><li>cache结构声明</li></ol><p>cache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cache_line</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> valid_bit<span class="token punctuation">;</span><span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> time_stamp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cache_line<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cache</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> S<span class="token punctuation">;</span><span class="token keyword">int</span> E<span class="token punctuation">;</span><span class="token keyword">int</span> B<span class="token punctuation">;</span>cache_line<span class="token operator">*</span><span class="token operator">*</span> Cache<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>cache<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>main</li></ol><p>主要在于正确解析命令行参数，会用<code>getopt</code>就行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span>hit_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> miss_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> eviction_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s<span class="token punctuation">,</span> E<span class="token punctuation">,</span> b<span class="token punctuation">,</span>opt<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> trace_name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token operator">*</span> my_cache<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"s:E:b:t:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'s'</span><span class="token operator">:</span>   s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'E'</span><span class="token operator">:</span>   E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'b'</span><span class="token operator">:</span>   b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'t'</span><span class="token operator">:</span>   <span class="token function">strcpy</span><span class="token punctuation">(</span>trace_name<span class="token punctuation">,</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'?'</span><span class="token operator">:</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unknown option: %c\n"</span><span class="token punctuation">,</span>optopt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     my_cache <span class="token operator">=</span> <span class="token function">construct_cache</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>E<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> s<span class="token punctuation">,</span> b<span class="token punctuation">,</span> trace_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hit_count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>miss_count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>eviction_count<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">free_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printSummary</span><span class="token punctuation">(</span>hit_count<span class="token punctuation">,</span> miss_count<span class="token punctuation">,</span> eviction_count<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>construct_cache</li></ol><p>根据输入的命令行参数<code>s</code>,<code>E</code>,<code>b</code>构造cache，并初始化每一个高速缓存行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cache<span class="token operator">*</span> <span class="token function">construct_cache</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> E<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cache<span class="token operator">*</span> my_cache <span class="token operator">=</span><span class="token punctuation">(</span>cache<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// construct Cache</span> my_cache<span class="token operator">-></span>S <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span> my_cache<span class="token operator">-></span>B <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">;</span> my_cache<span class="token operator">-></span>E <span class="token operator">=</span> E<span class="token punctuation">;</span> my_cache<span class="token operator">-></span>Cache <span class="token operator">=</span> <span class="token punctuation">(</span>cache_line<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>S <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cache_line<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>my_cache<span class="token operator">-></span>S<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>cache_line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>E <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cache_line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token comment">// initialize</span><span class="token punctuation">&#123;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> my_cache<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>update_LRU</li></ol><p>我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">update_LRU</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_tag<span class="token punctuation">,</span> <span class="token keyword">int</span> line_index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit<span class="token punctuation">)</span> <span class="token operator">++</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>line_index<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>line_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>line_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> ad_tag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>get_line_index</li></ol><p>每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">get_line_index</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_tag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit <span class="token operator">&amp;&amp;</span> my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> ad_tag<span class="token punctuation">)</span><span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token comment">// hit</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// miss</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>is_not_full</li></ol><p>。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">is_not_full</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit<span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>find_LRU</li></ol><p>对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find_LRU</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> max_stamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> evict_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>temp <span class="token operator">=</span> my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">></span> max_stamp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>max_stamp <span class="token operator">=</span> temp<span class="token punctuation">;</span>evict_line <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> evict_line<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="8"><li>access_cache</li></ol><p>我们需要用<code>fscanf</code>对数据访问操作进行解析，注意此处的<code>&quot; %c %x,%d&quot;</code>,<code>%c</code>前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数<code>real_access_cache</code>。M等于L+S，因此需要两次更新。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">access_cache</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> trace_name<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> hit_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> miss_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> eviction_count_ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  FILE<span class="token operator">*</span> pFile<span class="token punctuation">;</span>   <span class="token comment">// receive access</span>     pFile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>trace_name<span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pFile<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">char</span> identifier<span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> address<span class="token punctuation">;</span>     <span class="token keyword">int</span> size<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">fscanf</span><span class="token punctuation">(</span>pFile<span class="token punctuation">,</span><span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>identifier<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token operator">&amp;</span>size<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> mask <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">64</span><span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ad_set <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span><span class="token keyword">int</span> ad_tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>s<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>identifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'M'</span><span class="token operator">:</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'L'</span><span class="token operator">:</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'S'</span><span class="token operator">:</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>pFile<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">real_access_cache</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_tag<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> hit_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> miss_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> eviction_count_ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> line_index<span class="token punctuation">,</span>free_line<span class="token punctuation">,</span> evict_line<span class="token punctuation">;</span>line_index <span class="token operator">=</span> <span class="token function">get_line_index</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>line_index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>hit_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">update_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> line_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>free_line <span class="token operator">=</span> <span class="token function">is_not_full</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>free_line <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>miss_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">update_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> free_line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>miss_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>evict_line <span class="token operator">=</span> <span class="token function">find_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span>ad_set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">update_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> evict_line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-结果"><a class="markdownIt-Anchor" href="#5-结果"></a> 5. 结果</h3><img src="/2023/03/06/CSAPP-Lab/CSAPP-LAB/f79658fdbb805322f1a6a578ef030add.png" class="">]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言【王爽】实验流程</title>
      <link href="/2023/02/04/CSAPP-Lab/assembly/"/>
      <url>/2023/02/04/CSAPP-Lab/assembly/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h1><p>前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了</p><hr /><h1 id="实验1-查看cpu和内存用机器指令和汇编指令编程"><a class="markdownIt-Anchor" href="#实验1-查看cpu和内存用机器指令和汇编指令编程"></a> 实验1 查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="debug环境搭建参考此文"><a class="markdownIt-Anchor" href="#debug环境搭建参考此文"></a> debug环境搭建：<a href="https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506">参考此文</a></h2><h2 id="assignment-1"><a class="markdownIt-Anchor" href="#assignment-1"></a> assignment 1</h2><ol><li>用A命令向内存中写入汇编指令，用U命令查看</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/be45e9be004d61829c5b03272132030c.png" class=""><ol start="2"><li>用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><h2 id="assignment-2"><a class="markdownIt-Anchor" href="#assignment-2"></a> assignment 2</h2><ol><li>写入并查看指令</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/3433e861e5085ced9ca3c7be18ad26e6.png" class=""><ol start="2"><li>修改_CS:IP_指向</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/be45e9be004d61829c5b03272132030c.png" class=""><ol start="3"><li>执行指令，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，结果为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>X</mi><mo>=</mo><mn>0100</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">AX = 0100H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><h2 id="assignment-3"><a class="markdownIt-Anchor" href="#assignment-3"></a> assignment 3</h2><ol><li>用D命令查找，最终在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mn>5</mn><mi>H</mi><mo>→</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>C</mi><mi>H</mi><mtext>（</mtext><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>:</mo><mn>0005</mn><mo>→</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>:</mo><mn>000</mn><mi>C</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">FFFF5H \to FFFFCH（FFFF:0005 \to FFFF:000C）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">）</span></span></span></span>发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>d</mi><mi mathvariant="normal">/</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>y</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">dd/mm/yy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>字样的生产日期</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><ol start="2"><li>尝试用E命令修改，该操作失效，因为这是ROM</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/5fd1fddb244160f8985c8162d69751f1.png" class=""><h2 id="assignment-4"><a class="markdownIt-Anchor" href="#assignment-4"></a> assignment 4</h2><p>1.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>0000</mn><mi>H</mi><mo>→</mo><mi>B</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">A0000H \to BFFFFH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石</p><img src="/2023/02/04/CSAPP-Lab/assembly/3433e861e5085ced9ca3c7be18ad26e6.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><hr /><h1 id="实验2-用机器指令和汇编指令编程"><a class="markdownIt-Anchor" href="#实验2-用机器指令和汇编指令编程"></a> 实验2 用机器指令和汇编指令编程</h1><h2 id="assignment-1-2"><a class="markdownIt-Anchor" href="#assignment-1-2"></a> assignment 1</h2><ol><li>用A指令向内存中写入汇编指令，用U指令查看</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/69e55d7cd42de97dab21bb828f85738e.png" class=""><ol start="2"><li>修改CS:IP使其指向代码段</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/9f2dfda5f53b12dff0c5b678c0230fe1.png" class="">、<ol start="3"><li>t命令逐步执行指令后查看AX、BX、SP寄存器内容</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><h2 id="assignment-2-2"><a class="markdownIt-Anchor" href="#assignment-2-2"></a> assignment 2</h2><p>在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）</p><hr /><h1 id="实验3-编程-编译-链接-跟踪"><a class="markdownIt-Anchor" href="#实验3-编程-编译-链接-跟踪"></a> 实验3 编程、编译、链接、跟踪</h1><h2 id="assignment-1-3"><a class="markdownIt-Anchor" href="#assignment-1-3"></a> assignment 1</h2><ol><li>编译链接生成可执行文件</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/9a986e22ba33aa2f07fb537819658b5d.png" class=""><h2 id="assignment-2-3"><a class="markdownIt-Anchor" href="#assignment-2-3"></a> assignment 2</h2><ol><li>debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mo>=</mo><mn>075</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">DS=075C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，则PSP的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>075</mn><mi>C</mi><mo>:</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">075C:0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，程序的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>0</mn><mtext>  </mtext><mo stretchy="false">(</mo><mn>075</mn><mi>C</mi><mo>+</mo><mn>10</mn><mo>:</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">076C:0\;(075C+10:0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi><mo>:</mo><mi>I</mi><mi>P</mi><mo>=</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0000</mn></mrow><annotation encoding="application/x-tex">CS:IP = 076C:0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/9f2dfda5f53b12dff0c5b678c0230fe1.png" class=""><ol start="2"><li>跟踪程序执行过程</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/4558f12f037760ce42478fc1c563f99a.png" class=""><p>用P命令执行<code>INT 21</code></p><img src="/2023/02/04/CSAPP-Lab/assembly/55386b9183e912238f4ef08482495438.png" class=""><h2 id="assignment-3-2"><a class="markdownIt-Anchor" href="#assignment-3-2"></a> assignment 3</h2><ol><li>查看PSP的内容</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><hr /><h1 id="实验4-bx和loop的使用"><a class="markdownIt-Anchor" href="#实验4-bx和loop的使用"></a> 实验4 [bx]和loop的使用</h1><h2 id="assignment-1-4"><a class="markdownIt-Anchor" href="#assignment-1-4"></a> assignment 1</h2><ol><li>编写源程序</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentmov ax, 0020Hmov ds, axmov bx, 0mov dx, 0mov cx, 64s: mov [bx],dxinc bxinc dxloop smov ax, 4c00h int 21hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>编译，链接生成可执行文件</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/9a986e22ba33aa2f07fb537819658b5d.png" class=""><ol start="3"><li>查看载入内存的程序，可以看见标签s已被替换为地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>000</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076C:000E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><ol start="4"><li>执行程序，验证结果，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/69e55d7cd42de97dab21bb828f85738e.png" class=""><h2 id="assignment-2-4"><a class="markdownIt-Anchor" href="#assignment-2-4"></a> assignment 2</h2><ol><li>编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentmov ax, 0020Hmov ds, axmov bx, 0mov cx, 64s: mov [bx],bxinc bxloop smov ax, 4c00h int 21hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>其它步骤与assigment 1一致，验证结果，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><h2 id="assignment-3-3"><a class="markdownIt-Anchor" href="#assignment-3-3"></a> assignment 3</h2><ol><li>复制的是什么：复制程序的第一条指令<code>mov ax,cs</code>到 <code>loop s</code> 指令至内存地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0020</mn><mo>:</mo><mn>0000</mn></mrow><annotation encoding="application/x-tex">0020:0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>处</li><li>如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在<code>mov cx,_____</code> 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>0000</mn><mo>→</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0015</mn></mrow><annotation encoding="application/x-tex">076C:0000 \to 076C:0015</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">5</span></span></span></span>，共<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>H</mi><mtext> </mtext><mo stretchy="false">(</mo><mn>23</mn><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">16H\,(23D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>个字节,因此第二个空应该填入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">16H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><hr /><h1 id="实验5-编写-调试具有多个段的程序"><a class="markdownIt-Anchor" href="#实验5-编写-调试具有多个段的程序"></a> 实验5 编写、调试具有多个段的程序</h1><h2 id="assignment-1-5"><a class="markdownIt-Anchor" href="#assignment-1-5"></a> assignment 1</h2><ol><li>将程序载入内存后查看，可知data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/d589f866c98c4ea05c31a837ae10ba82.png" class=""><ol start="2"><li>Q1：<code>G 001D</code>执行程序至程序返回前，用U命令查看data段内容: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0123</mn><mi>H</mi><mo separator="true">,</mo><mn>0456</mn><mi>H</mi><mo separator="true">,</mo><mn>0789</mn><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>A</mi><mi>B</mi><mi>C</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>D</mi><mi>E</mi><mi>F</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>F</mi><mi>E</mi><mi>D</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>C</mi><mi>B</mi><mi>A</mi><mi>H</mi><mo separator="true">,</mo><mn>0987</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">8</span><span class="mord">9</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">9</span><span class="mord">8</span><span class="mord">7</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><ol start="3"><li>Q2：R命令查看各个段寄存器的值  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo><mtext>  </mtext><mi>C</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">\to \;CS:076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">DS:076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">SS:076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/4558f12f037760ce42478fc1c563f99a.png" class=""><ol start="4"><li>Q3：data段和stack段分别占16个字节，因此设code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mn>1</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X-1H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mn>2</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X-2H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>（做了assignment2后可以发现这里说法并不准确）</li></ol><h2 id="assignment-2-5"><a class="markdownIt-Anchor" href="#assignment-2-5"></a> assignment 2</h2><ol><li>步骤与assigment1 完全一致</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/2a60b33897c958a72dcac6c90c6195cf.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/74a158dbaf8f30c5bda7baeaf9e299e7.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/e32c2fe4dd55436bc2d3d5814bd82eec.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/b61143a70bf02c04d76e0e636905efe6.png" class=""><ol start="2"><li>得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍</li></ol><h2 id="assignment-3-4"><a class="markdownIt-Anchor" href="#assignment-3-4"></a> assignment 3</h2><ol><li>步骤与assignment1完全一致</li></ol><p>2， 设code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>+</mo><mn>3</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X+3H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>+</mo><mn>4</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X+4H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></p><h2 id="assignment-4-2"><a class="markdownIt-Anchor" href="#assignment-4-2"></a> assignment 4</h2><p>如果去掉通知编译器程序的入口的<code>end start </code>语句，那么唯一可正确运行的是起始段为code段的程序3</p><h2 id="assignment-5"><a class="markdownIt-Anchor" href="#assignment-5"></a> assignment 5</h2><ol><li>编写源程序，注意在将段地址写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>时，要借助一个寄存器充当介质，因为立即数无法直接写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codea segment db 1,2,3,4,5,6,7,8a endsb segmentdb 1,2,3,4,5,6,7,8b endsc segment db 0,0,0,0,0,0,0,0c endscode segmentstart:mov bx, 0mov cx, 8s:mov dx, amov ds,dxmov ax, [bx]mov dx, bmov ds,dxadd ax, [bx]mov dx, cmov ds,dxmov [bx], axinc bxloop smov ax,4c00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>用debug跟踪程序，可以看到a段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、b段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>、c段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><ol start="3"><li>执行程序，查看c段内容，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/1902be5182e1e33b83c2ed1578768ca2.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/7e5d09d22bc0f75cb757fda650a9b4eb.png" class=""><h2 id="assignment-6"><a class="markdownIt-Anchor" href="#assignment-6"></a> assignment 6</h2><ol><li>编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codea segmentdw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffha endsb segment dw 0,0,0,0,0,0,0,0b endscode segment start:mov ax, amov ds, axmov ax, b mov ss, axmov sp, 0010Hmov bx, 0mov cx, 8s:push [bx]add bx, 2loop smov ax, 4c00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>用debug跟踪程序，可以看到a段段地址： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 、 b段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>、code段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>F</mi></mrow><annotation encoding="application/x-tex">076F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><ol start="3"><li>执行程序，查看b段内容，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><hr /><h1 id="实验6-实践课程中的程序"><a class="markdownIt-Anchor" href="#实验6-实践课程中的程序"></a> 实验6 实践课程中的程序</h1><h2 id="assignment-1-6"><a class="markdownIt-Anchor" href="#assignment-1-6"></a> assignment 1</h2><ol><li>这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesg, ds:datasg, ss:stacksgdatasg segment db &#39;ibm             &#39;db &#39;dec             &#39;db &#39;dos             &#39;db &#39;vax             &#39;datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscodesg segmentstart:mov ax, stacksgmov ss, axmov sp, 10Hmov ax, datasgmov ds, axmov bx, 0mov cx, 4s0:push cxmov si, 0mov cx, 3s:mov al, [bx+si]and al, 11011111Bmov [bx+si], alinc siloop s pop cxadd bx, 10Hloop s0mov ax, 4c00Hint 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>跟踪程序，查看data段内容</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><ol start="3"><li>执行程序后，查看data段内容，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><h2 id="assignment-2-6"><a class="markdownIt-Anchor" href="#assignment-2-6"></a> assignment 2</h2><ol><li>编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesg, ds:datasg, ss:stacksgstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endsdatasg segment db &#39;1. display      &#39;db &#39;2. brows        &#39;db &#39;3. replace      &#39;db &#39;4. modify       &#39;datasg endscodesg segmentstart:mov ax, stacksgmov ss, axmov sp, 10H mov ax, datasgmov ds, axmov bx, 0mov cx, 4s0:push cxmov cx, 4mov si, 0s: mov al, [bx+3+si]and al, 11011111Bmov [bx+3+si], alinc siloop spop cxadd bx, 10Hloop s0mov ax, 4c00Hint 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>跟踪程序，查看data段内容</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><ol start="3"><li>执行程序，查看data段内容，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><hr /><h1 id="实验7-寻址方式在结构化数据访问中的应用"><a class="markdownIt-Anchor" href="#实验7-寻址方式在结构化数据访问中的应用"></a> 实验7 寻址方式在结构化数据访问中的应用</h1><ol><li>编写源程序，用<code>word ptr / byte ptr</code>指定内存单元大小主要应用在<code>div</code>指令或用于向内存写入立即数</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgstack segmentdw 0,0,0,0,0,0,0,0stack endsdata segmentdb &#39;1975&#39;,&#39;1976&#39;, &#39;1977&#39;, &#39;1978&#39;, &#39;1979&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;,&#39;1983&#39;db &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;db &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;dd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514dd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226dw 11542,14430,15257,17800data endstable segmentdb 21 dup (&#39;year summ ne ?? &#39;)table endscodesg segmentstart:mov ax, stack ;0776Cmov ss, axmov sp, 10Hmov ax, data ; 076Dmov es, axmov ax, table ; 077bmov ds, axmov bx,0mov si,0mov cx,21year:push cxmov cx, 4mov di, 0char:mov al, es:[si]mov [bx+di], alinc diinc siloop charpop cxadd bx, 10Hloop yearmov cx, 21mov bx, 0income:push cxmov cx, 2mov di, 0dwInt:mov ax, es:[si]mov [bx].5[di], axadd si, 2add di, 2loop dwIntpop cxadd bx, 10Hloop incomemov cx, 21mov bx, 0staff:mov ax, es:[si]mov [10+bx], axadd si, 2;add bx, 10Hloop staffmov cx, 21mov bx, 0average:mov dx, [bx+7]mov ax, [bx+5]div word ptr [bx+0AH]mov [bx+0Dh], axadd bx, 10Hloop averagemov ax, 4C00Hint 21Hcodesg endsend start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>查看原始table段的内容</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/9bc6319e4399ae16eed295b023956965.png" class=""><ol start="3"><li>执行程序后，查看table段的内容，正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><h1 id="实验8-分析一个奇怪的程序"><a class="markdownIt-Anchor" href="#实验8-分析一个奇怪的程序"></a> 实验8 分析一个奇怪的程序</h1><ol><li>程序从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span></span></span></span>入口处开始执行，一个<code>nop</code>指令占一个字节并表示No operation，此处用了两个<code>nop</code>指令的目的是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处预留两个字节的空间，程序执行<code>mov cs:[di], ax</code>之后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的两个字节被试图写入<code>jmp short s1</code>，接着程序向下执行<code>jmp short s</code>使得程序跳转回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处开始执行。</li><li><code>jmp short s1</code>到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>跳转到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span>，即从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>处的jmp指令的下一指令<code>nop</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0022</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(076C:0022)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>跳转到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span>处的<code>mov ax, 0</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0018</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(076C:0018)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>，因为<code>jmp short 标号</code>是依据位移进行转移的指令，而此处位移大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0022</mn><mi>H</mi><mo>−</mo><mn>0018</mn><mi>H</mi><mo>=</mo><mo>−</mo><mn>10</mn><mi>D</mi><mo stretchy="false">(</mo><mi>F</mi><mn>6</mn><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0022H-0018H =-10D(F6H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的<code>jmp short s</code>指令的机器码为<code>EBF6</code>（刚好占两个字节，因此可以被正确写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处）</li><li>执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的跳转指令，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mo>=</mo><mi>I</mi><mi>P</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IP = IP+(-10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为<code>mov ax, 4c00H</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>000</mn><mi>A</mi><mi>H</mi><mo>−</mo><mn>0010</mn><mi>H</mi><mo>=</mo><mn>0000</mn><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(000AH-0010H=0000H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，程序从此处开始向下执行，最终可以正确退出</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><h1 id="实验9-根据材料编程"><a class="markdownIt-Anchor" href="#实验9-根据材料编程"></a> 实验9 根据材料编程</h1><ol><li>编写源程序：最开始我试图用<code>mov address，data</code>的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据<code>welcome to masm!</code>，利用寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">ax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgdata segmentdb &#39;welcome to masm!&#39;data endscodesg segmentstart: mov ax, datamov ds, axmov ax, 0B800Hmov es, axmov bx, 0mov si, 1824mov cx, 10Hs0:mov ah, 82Hmov al, [bx]mov es:[si], axinc bxadd si, 2loop s0mov bx, 0 mov si, 1984mov cx, 10Hs1:mov ah, 0A4Hmov al, [bx]mov es:[si], axinc bxadd si, 2loop s1mov bx, 0 mov si, 2144mov cx, 10Hs2:mov ah, 11110001Bmov al, [bx]mov es:[si], axinc bxadd si, 2loop s2mov ax, 4c00Hint 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>最终效果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><h1 id="实验10-编写子程序"><a class="markdownIt-Anchor" href="#实验10-编写子程序"></a> 实验10 编写子程序</h1><h2 id="assignment-1-7"><a class="markdownIt-Anchor" href="#assignment-1-7"></a> assignment 1</h2><ol><li>编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（<strong>注意入栈顺序与出栈顺序相反</strong>）</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segmentdb &quot;welcome to masm!&quot;, 0data endsstack segmentdw 16 dup (0)stack endscode segmentstart:mov dh, 8mov dl, 3mov cl, 2mov ax, datamov ds, axmov ax, stackmov sp, 20Hmov si, 0call show_strmov ax, 4C00Hint 21Hshow_str:push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复push bxpush cxpush dxpush espush simov ax, 0B800H; 80×25彩色模式显示缓冲区mov es, axmov al, 160 ; 设置指定打印位置inc dh ; 行数从0开始mul dh ; 8位乘法，结果存储在ax中mov bx, axmov al, 2mul dladd bx, axmov ah, clprint:mov cl, [si] ; 设置cxmov ch, 0jcxz ok ;判断字符串是否结束mov al, cl ; 设置字符属性和值mov es:[bx],axinc siadd bx, 2jmp printok:pop sipop espop dxpop cxpop bxpop axret code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><h2 id="assignment-2-7"><a class="markdownIt-Anchor" href="#assignment-2-7"></a> assignment 2</h2><ol><li><p>编写源程序，利用除法溢出公式</p><pre><code>            $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$</code></pre></li></ol><p>该公式的基本思想是将可能发生除法溢出的32位除法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">X/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span>，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>+</mo><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(H/n)*65536 + (L/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br /><strong>商（32位）：</strong><br />高十六位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">int(H/2)*65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span>,低十六为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>r</mi><mi>e</mi><mi>m</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>+</mo><mi>L</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">int([rem(H/n)*65536+L]/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br /><strong>余数（16位）：</strong><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>m</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>r</mi><mi>e</mi><mi>m</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>+</mo><mi>L</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rem([rem(H/n)*65536+L]/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br />（注：对这个公式的理解有限）</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codestack segmentdw 16 dup (0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 4240Hmov dx, 000FHmov cx, 0AHcall divdwmov ax, 4C00Hint 21Hdivdw:push bxmov bx, ax ; 暂存Lmov ax, dx ; H&#x2F;Nmov dx, 0div cx ; int(H&#x2F;N)在ax中，rem(H&#x2F;N)在dx中push ax ; 暂存int(H&#x2F;N)，除数mov ax, bx; dx and ax constitute rem(H&#x2F;N)*65535+Ldiv cx ; ax store the resultmov cx, dxpop dx ; int(H&#x2F;N)pop bxretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果正确</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/3e62cb394c3e34f04693136b17ab094f.png" class=""><h2 id="assignment-3-5"><a class="markdownIt-Anchor" href="#assignment-3-5"></a> assignment 3</h2><ol><li>编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segmentdb 10 dup(0)data endsstack segmentdw 16 dup(0)stack endscode segmentstart:mov ax, 12666mov bx, datamov ds, bxmov si, 0mov bx, stackmov ss, bxmov sp, 20Hcall dtocmov dh, 8mov dl, 3mov cl, 2call show_strmov ax, 4C00Hint 21Hdtoc:push axpush bxpush cxpush dxpush sipush dimov dx, 0 ; 被除数高16位 置0mov bx, 10mov di, 0 ; 字符计数divide:mov cx, ax jcxz overinc didiv bx ; 32位除法，商在ax，余数在dxadd dx, 30Hpush dxmov dx, 0jmp divideover:mov cx, dimove: pop bxmov [si], blinc siloop movepop dipop sipop dxpop cxpop bxpop axretshow_str:push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复push bxpush cxpush dxpush espush simov ax, 0B800H; 80×25彩色模式显示缓冲区mov es, axmov al, 160 ; 设置指定打印位置inc dh ; 行数从0开始mul dh ; 8位乘法，结果存储在ax中mov bx, axmov dh, 0mov al, 2mul dladd bx, axmov ah, clprint:mov cl, [si] ; 设置cxmov ch, 0jcxz ok ;判断字符串是否结束mov al, cl ; 设置字符属性和值mov es:[bx],axinc siadd bx, 2jmp printok:pop sipop espop dxpop cxpop bxpop axret code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/4a2d01950618f1bd82fc3ef321645928.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/641df2d303642523f5b106137fff3bf6.png" class=""><h1 id="实验11-编写子程序"><a class="markdownIt-Anchor" href="#实验11-编写子程序"></a> 实验11 编写子程序</h1><ol><li>编写源程序：主要用到了<code>cmp</code>指令和条件转移指令组合形成的if逻辑</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgdatasg segmentdb &quot;Beginner&#39;s All-purpose Symbolic Instruction Code.&quot;,0datasg endscodesg segmentbegin:mov ax, datasgmov ds, axmov si, 0call lettercmov ax, 4C00Hint 21Hletterc:push axpush cxCapital:mov al, [si]mov cl, almov ch, 0jcxz OKcmp al, 97jb NOcmp al, 122ja NOand al, 11011111Bmov [si], alNO:inc sijmp short CapitalOK:pop cxpop axretcodesg endsend begin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/ae00e48f345b630c03e516d571016343.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/fcb4683184a6c0d79d2699bc79186aa3.png" class=""><h1 id="实验12-编写0号中断的处理程序"><a class="markdownIt-Anchor" href="#实验12-编写0号中断的处理程序"></a> 实验12 编写0号中断的处理程序</h1><ol><li>编写源程序</li></ol><p>总体来说就3个任务：</p><ul><li>编写中断处理程序</li><li>复制中断处理程序至内存空闲区域(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn><mo>:</mo><mn>0200</mn><mi>H</mi><mo>→</mo><mn>0000</mn><mo>:</mo><mn>02</mn><mi>F</mi><mi>F</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">0000:0200H\to0000:02FFH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>)</li><li>修改中断向量表（中断处理程序地址入口表）</li></ul><p>注意在用<code>jcxz</code>条件转移指令时，要<code>jmp short</code>回程序开头</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset do0 ; 076C:0028mov ax, 0mov es, axmov di, 0200Hmov cx, offset do0end- offset do0; 0034Hcldrep movsb ; 复制程序到0:200mov word ptr es:[0], 0200Hmov word ptr es:[0+2], 0 ; 修改中断向量表mov ax, 4C00Hint 21Hdo0:jmp short do0startdb &quot;divide error&quot;,0 do0start:mov ax, 0B800Hmov es, axmov di, 160*12+34*2mov ax, csmov ds, axmov si, 202Hprint:mov cL, [si]mov ch, 0jcxz okmov ah, 04h ;redmov al, clmov es:[di], axinc siadd di, 2 jmp short printok:mov ax, 4C00Hint 21Hdo0end: ;005Cnopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/3e62cb394c3e34f04693136b17ab094f.png" class=""><h1 id="实验13-编写-应用中断例程"><a class="markdownIt-Anchor" href="#实验13-编写-应用中断例程"></a> 实验13 编写、应用中断例程</h1><h2 id="assignment-1-8"><a class="markdownIt-Anchor" href="#assignment-1-8"></a> assignment 1</h2><ol><li>编写源程序：与lab10-1的show_str基本一致，只需将<code>call-ret</code>更改为 <code>int 7cH - iret</code></li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset printmov ax, 0mov es, axmov di, 0200Hmov cx, offset printed - offset printcldrep  movsbmov word ptr es:[7cH*4], 0200Hmov word ptr es:[7cH*4+2], 0 mov ax, 4C00Hint 21Hprint:push bxpush cxpush espush sipush axpush dxmov ax, 0B800Hmov es, axmov al, 160inc dhmul dh ; 160*(10+1) in axmov bx, axmov al, 2mul dl ; 10*2 in axadd bx, axmov ah, clstPrint:mov ch, 0mov cl, [si]jcxz okmov al, clmov es:[bx], axadd bx, 2inc sijmp short stPrintok:pop dxpop axpop sipop espop cxpop bxiretprinted:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><h2 id="assignment-2-8"><a class="markdownIt-Anchor" href="#assignment-2-8"></a> assignment 2</h2><ol><li>编写源程序</li></ol><p>用中断例程实现loop指令，主要需要解决三个问题</p><ul><li>怎么取得标号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的段地址和偏移地址？</li></ul><p>有一对段地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>和偏移地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>在中断过程时被压入栈，标号的段地址就是该CS，标号       的偏移地址可由该IP加上转移地址(<code>offset s - offset se</code>)得到</p><ul><li>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的段地址和偏移地址后，如何设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi><mo>:</mo><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">CS:IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></li></ul><p>用<code>iret</code>指令：<code>pop IP , pop CS ,  popf</code></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset lpmov ax, 0mov es, axmov di, 0200Hmov cx, offset lped - offset lpcldrep  movsbmov word ptr es:[7cH*4], 0200Hmov word ptr es:[7cH*4+2], 0 mov ax, 4C00Hint 21Hlp:dec cxjcxz lpretpush bpmov bp, spadd [bp+2], bxlpret:pop bpiretlped:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/3e62cb394c3e34f04693136b17ab094f.png" class=""><h2 id="assignment-3-6"><a class="markdownIt-Anchor" href="#assignment-3-6"></a> assignment 3</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segments1: db &#39;Good,better,best,&#39;,&#39;$&#39;s2: db &#39;Never let it rest,&#39;,&#39;$&#39; s3: db &#39;Till good is better,&#39;,&#39;$&#39;s4: db &#39;And better,best.&#39;, &#39;$&#39;s: dw offset s1, offset s2, offset s3, offset s4 row: db 2,4,6,8start:mov ax, cs mov ds, axmov bx, offset smov si, offset rowmov cx, 4ok:mov bh, 0 mov dh, [si]mov dl, 0mov ah, 2 ; BIOS中断例程--设置光标int 10h mov dx, [bx]                                           mov ah, 9 ; DOS中断例程--打印字符串int 21hinc siadd bx, 2loop okmov ax, 4C00H; DOS中断例程--程序返回，返回值在alint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验14-访问-cmos-ram"><a class="markdownIt-Anchor" href="#实验14-访问-cmos-ram"></a> 实验14 访问 CMOS RAM</h1><ol><li>编写源程序</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codestack segmentdw 16 dup (0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 0B800Hmov ds, axmov al, 9mov bx, 160*12+36*2call GetAscillmov byte ptr [bx+4], &#39;&#x2F;&#39;mov al, 8add bx, 6call GetAscillmov byte ptr [bx+4], &#39;&#x2F;&#39;mov al, 7add bx, 6call GetAscillmov byte ptr [bx+4], &#39; &#39;mov al, 4add bx, 6call GetAscillmov byte ptr [bx+4], &#39;:&#39;mov al, 2add bx, 6call GetAscillmov byte ptr [bx+4], &#39;:&#39;mov al, 0add bx, 6call GetAscillmov ax, 4C00Hint 21HGetAscill:push axpush bxpush cxpush dxout 70H, alin al, 71Hmov ah, almov cl, 4shr ah, cland al, 00001111Badd ah, 30Hadd al, 30Hmov dx, 0B800Hmov es, dxmov es:[bx], ah mov byte ptr es:[bx+1], 02H ; greenmov es:[bx+2], almov byte ptr es:[bx+3], 02Hpop dxpop cxpop bxpop axretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><h1 id="实验15-安装新的int-9-中断例程"><a class="markdownIt-Anchor" href="#实验15-安装新的int-9-中断例程"></a> 实验15 安装新的int 9 中断例程</h1><h2 id="前置练习1"><a class="markdownIt-Anchor" href="#前置练习1"></a> 前置练习1</h2><p>在屏幕中间依次显示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a\to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>,按Esc键后改变与颜色</p><ol><li>编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把<code>call dword ptr ds:[0]</code>写成了<code>call word ptr ds:[0]</code>，导致整个系统没有正确的int 9中断例程，因此出现了错误。</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codestack segmentdb 64 dup(0)stack endsdata segmentdw 0,0data endscode segmentstart:mov ax, stackmov ss, axmov sp, 40Hmov ax, datamov ds, axmov ax, 0mov es, axpush es:[9*4]pop ds:[0]push es:[9*4+2]pop ds:[2] ; 保存原int 9中断例程的入口地址climov word ptr es:[9*4], offset int9mov es:[9*4+2], cs;设置新的入口地址stimov ax, 0B800Hmov es,axmov dh, &#39;a&#39;s:mov es:[160*12+40*2], dhcall delayinc dhcmp dh, &#39;z&#39;jna s ; 依次打印a~zmov ax, 0 mov es, axclipush ds:[0]pop es:[9*4]push ds:[2]pop es:[9*4+2] ;恢复原int 9中断例程的入口地址stimov ax, 4C00hint 21Hdelay:push axpush dxmov ax, 0mov dx, 10Hse:sub ax, 1 ; 不能用decsbb dx, 0cmp ax, 0jne secmp dx, 0jne sepop dxpop axret ; 延时int9:push axpush esin al, 60Hpushfcall dword ptr ds:[0]cmp al, 01Hjne int9retmov ax, 0B800Hmov es, axinc byte ptr es:[160*12+40*2+1] ; 修改字符属性int9ret:pop espop axiretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/cc6fd8aa713248d3063b863655b4b1eb.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/175b1d630705c9664b4ee1403d07af35.png" class=""><h2 id="前置练习2"><a class="markdownIt-Anchor" href="#前置练习2"></a> 前置练习2</h2><p>在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理</p><ol><li>编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>:</mo><mn>0200</mn><mo>→</mo><mn>0</mn><mo>:</mo><mn>0203</mn></mrow><annotation encoding="application/x-tex">0:0200 \to 0:0203</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">3</span></span></span></span>,可在新int 9中断例程中通过<code>cs:[200H]</code>访问</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ss:stackstack segmentdb 32 dup(0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 0mov es, axmov di, 0204Hmov ax, csmov ds, axmov si, offset int9mov cx, offset int9ed - offset int9cldrep movsb; 安装push es:[9*4]pop es:[200H]push es:[9*4+2]pop es:[202H] ; 保存原int 9入口地址climov word ptr es:[9*4], 204Hmov word ptr es:[9*4+2], 0 ; 修改中断向量表stimov ax, 4C00Hint 21Hint9:push axpush cxpush espush diin al, 60Hpushfcall dword ptr cs:[200H] ; 调用原int 9cmp al, 3BHjne int9retmov ax, 0B800Hmov es, axmov di, 1mov cx, 2000s:inc byte ptr es:[di]add di, 2loop sint9ret:pop dipop espop cxpop axiretint9ed:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/877445709c8ed9e5d56a7314e57f8ea3.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/030425252bf3048fb11aa73425e64b26.png" class=""><h2 id="assignment-1-9"><a class="markdownIt-Anchor" href="#assignment-1-9"></a> assignment 1</h2><ol><li>编写源程序</li></ol><p>与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码<code>cmp aL, 1EH+80H</code></p><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ss:stackstack segmentdb 32 dup(0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 0mov es, axmov di, 0204Hmov ax, csmov ds, axmov si, offset int9mov cx, offset int9ed - offset int9cldrep movsb; 安装push es:[9*4]pop es:[200H]push es:[9*4+2]pop es:[202H] ; 保存原int 9入口地址climov word ptr es:[9*4], 204Hmov word ptr es:[9*4+2], 0 ; 修改中断向量表stimov ax, 4C00Hint 21Hint9:push axpush cxpush espush diin aL,60hpushfcall dword ptr cs:[200H]cmp aL, 1EH+80Hjne int9retmov cx, 2000mov ax, 0B800Hmov es, axmov di, 0s:mov byte ptr es:[di], &#39;A&#39;mov byte ptr es:[di+1], 02Hadd di, 2loop sint9ret:pop dipop espop cxpop axiretint9ed:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/ef86dd4e7df68488abe8bf379be285f3.png" class=""><h1 id="实验16-编写包含多个功能子程序的中断例程"><a class="markdownIt-Anchor" href="#实验16-编写包含多个功能子程序的中断例程"></a> 实验16 编写包含多个功能子程序的中断例程</h1><ol><li>编写源程序</li></ol><p>注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset int7chmov ax, 0mov es, axmov di, 0200Hmov cx, offset int7ched - offset int7chcldrep  movsbmov word ptr es:[7cH*4], 0200Hmov word ptr es:[7cH*4+2], 0 mov ax, 4C00Hint 21Hint7ch:jmp short int7chStarttable dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200Hint7chStart:push axpush bxcmp ah, 3ja int7chRetmov bl, ahmov bh, 0add bx, bxcall word ptr cs:(table-int7ch+200H)[bx]int7chRet:pop bxpop axiretSub1:push axpush bxpush cxpush dsmov ax, 0B800Hmov ds, axmov cx, 2000mov bx, 0s1:mov byte ptr [bx], &#39; &#39;add bx, 2loop s1pop dspop cxpop bxpop axretSub2:push axpush bxpush cxpush dsmov bx, 0B800Hmov ds, bxmov cx, 2000mov bx, 1s2:and byte ptr [bx], 11111000B ; 只设置最后3位or byte ptr [bx], aladd bx, 2loop s2pop dspop cxpop bxpop axretSub3:push axpush bxpush cxpush dsmov bx, 0B800Hmov ds, bxmov cl, 4shl al, clmov cx, 2000mov bx, 1s3:and byte ptr [bx], 10001111Bor [bx], aladd bx, 2loop s3pop dspop cxpop bxpop axretSub4:push axpush bxpush cxpush dspush espush sipush dimov bx, 08B00Hmov es, bxmov ds, bxmov si, 160mov di, 0cldmov cx, 24s4:push cxmov cx, 160rep movsbpop cxloop s4mov cx, 80mov si, 0s41:mov byte ptr [160*24+si], &#39; &#39;add si ,2loop s41pop dipop sipop espop dspop cxpop bxpop axretint7ched:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ah,1 ; 0 2 3mov al,2int 7CHmov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/4c1ca28437ff3c577a43f65b910fda7a.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/e142cd676fd54b10899408183ed6cb5a.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/11cdf681ec8c986a3cde650b18515366.png" class=""><h1 id="实验17-编写包含多个功能子程序的中断例程"><a class="markdownIt-Anchor" href="#实验17-编写包含多个功能子程序的中断例程"></a> 实验17 编写包含多个功能子程序的中断例程</h1><p>第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了</p><h2 id="练习17-1"><a class="markdownIt-Anchor" href="#练习17-1"></a> 练习17-1</h2><p>接受用户的键盘输入，输入&quot;r&quot;，“g”,“b”分别将屏幕上的字符设置为红色，绿色，蓝色</p><ol><li>编写源程序</li></ol><p>用功能号为0的int 16H中断例程读取键盘输入即可</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:show:push axpush espush dimov ah, 0int 16Hmov bl, 1cmp al,&#39;b&#39;je showstshl bl, 1cmp al, &#39;g&#39;je showstshl bl, 1cmp al, &#39;r&#39;je showstjmp short FRetshowst:mov ax, 0B800Hmov es, axmov di, 1mov cx, 2000s:and byte ptr es:[di], 11111000Bor es:[di], bladd di, 2loop sFRet:mov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP-Lab/assembly/3ac9ffcac28dbfa0df02e9ddeb39586e.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/d94e14d3995f026c2ff6eae5847929ca.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/1902559d0ee1576594f6400ef5ea21dc.png" class=""><h1 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h1><h2 id="1-理解assume伪指令的作用"><a class="markdownIt-Anchor" href="#1-理解assume伪指令的作用"></a> 1. 理解assume伪指令的作用</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datadata segmenta db 1,2,3,4,5,6,7,8b dw 0data endscode segmentstart:mov ax, datamov ds, axmov si, 0mov cx, 8s:mov ah, 0mov al, a[si]add b, axinc siloop smov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>assume ds:data ss:stack</code></li></ol><ul><li>assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mtext>、</mtext><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS、SS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:<code>mov ax, data ``mov ds, ax</code></li><li>assume是伪指令，用于指示编译器将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mtext>、</mtext><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS、SS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>分别与data段和stack段关联。①关联是什么意思呢？就是<strong>在编译时默认data段中的数据标号a、b的段地址在</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><strong>中</strong>，因此如果要正确访问到a、b的内容，必须用指令将data填入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此<code>mov ax, data</code>在编译器看来是<code>mov ax, data段段地址</code>，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax</li></ul><p>如果在程序中省略<code>assume ds:data</code>，则会出现_不能用段寄存器寻址_的错误</p><img src="/2023/02/04/CSAPP-Lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><ol start="2"><li><code>assume cs:codesg</code></li></ol><p>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>与代码段关联，在程序加载时将代码段(codesg)的段地址放入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中. 如果去掉该语句，则程序编译不通过，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的值不确定</p><img src="/2023/02/04/CSAPP-Lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><h2 id="2-理解数据标号"><a class="markdownIt-Anchor" href="#2-理解数据标号"></a> 2. 理解数据标号</h2><ol><li>数据标号与地址标号的不同</li></ol><p>地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）</p><pre class="line-numbers language-none"><code class="language-none">assume cs:code, es:datadata segmenta db 1,2,3,4,5,6,7,8b dw 0data endscode segmentstart:mov ax, datamov es, axmov si, 0mov cx, 8s:mov ah, 0mov al, a[si]add b, axinc siloop smov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的a和b分别指代了</p><ul><li><strong>地址为</strong><code>**seg data:0**</code><strong>, 长度为byte的字节单元</strong></li><li><strong>地址为</strong><code>**seg data:8**</code><strong>, 长度为word的字单元</strong></li></ul><ol start="2"><li>如何用数据标号以简洁形式访问内存中的数据</li></ol><p>在上一个程序中，我们用<code>mov al, a[si]</code> <code>add b, ax</code>访问了data段的内容，在编译器看来，这两条语句是这样的: <code>mov al, es:0[si]``add es:[8], ax</code></p><img src="/2023/02/04/CSAPP-Lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><p>我们现在用更熟悉的<code>mov al, [si+a]</code> <code>add b[0], ax</code>形式，从编译器角度来看，这两种形式没有区别<br />这说明了在指令中<strong>a等价于</strong><code>**byte ptr [0]**</code><strong>，b等价于</strong><code>**word ptr [8]**</code>（仅含偏移地址信息，默认段地址在es中，因为<code>assume es:data</code>）</p><img src="/2023/02/04/CSAPP-Lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><ol start="3"><li>将标号当作数据定义</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datadata segmenta db 1,2,3,4,5,6,7,8b dw 0c dw a, bdata endscode segmentstart:mov ax, datamov ds, axmov dx, 2mov dx, cmov ax, c[1]mov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>c dw a, b</code>将数据标号当作数据定义，c指代地址为<code>seg data:000A</code>的字单元，<strong>该字单元的内容是a的偏移地址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn></mrow><annotation encoding="application/x-tex">0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，下面是验证</p><img src="/2023/02/04/CSAPP-Lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><img src="/2023/02/04/CSAPP-Lab/assembly/00b606854598c5ba4b5d5647c190adcf.png" class="">]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> assembly language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
