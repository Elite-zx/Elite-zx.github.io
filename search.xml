<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[操作系统真象还原] 从0开始自制操作系统</title>
      <link href="/2023/12/15/elephont_os/build_os_from_scratch/"/>
      <url>/2023/12/15/elephont_os/build_os_from_scratch/</url>
      
        <content type="html"><![CDATA[<p>获取源码：<a href="https://github.com/Elite-zx/XUN-OS">XUN-OS</a></p><h1 id="1-部署工作环境安装并配置bochs"><a class="markdownIt-Anchor" href="#1-部署工作环境安装并配置bochs"></a> 1. 部署工作环境，安装并配置bochs</h1><p>我的系统为ubuntu22.04</p><h2 id="11-安装bochs"><a class="markdownIt-Anchor" href="#11-安装bochs"></a> 1.1. 安装bochs</h2><ol><li>在<a href="https://sourceforge.net/projects/bochs/files/bochs/2.7/">这里</a>下载好bochs的源码包，我使用的版本是boch-2.7</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/d1ab714337199458a28667211f191d72.png" class=""><ol start="2"><li>构建安装</li></ol><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">.&#x2F;configure \--prefix&#x3D;&#x2F;home&#x2F;elite-zx&#x2F;bochs \--enable-debugger \--enable-disasm \--enable-iodebug \ --enable-x86-debugger \--with-x \--with-x11make -j $(nproc) &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装汇编器NASM</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">sudo apt update &amp;&amp; sudo apt -y install nasm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="12-配置bochs"><a class="markdownIt-Anchor" href="#12-配置bochs"></a> 1.2. 配置bochs</h2><p>根据书在bochsrc.disk中写入以下内容</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt"># bochs configuration file# bochsrc.disk# memory size: 32MBmegs: 32# BIOS and VGA BIOSromimage: file=/path/to/bochs/share/bochs/BIOS-bochs-latestvgaromimage: file=/path/to/bochs/share/bochs/VGABIOS-lgpl-latest# boot from hard disk (rather than floppy disk)boot: disk# log filelog: bochs.out# disable mouse, enable keyboardmouse: enabled=0keyboard_mapping: enable=1,map=/path/to/bochs/share/bochs/keymaps/x11-pc-us.map# hard disk settingata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14# gdb part setting#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后运行（为了方便，我把/bin/bochs这个路径加入了环境变量PATH中）</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">&#x2F;bin&#x2F;bochs -f bochsrc.disk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/12/15/elephont_os/build_os_from_scratch/f2544200a88c0d93613f35ab61d8a59d.png" class=""><p>以上输出说明keyboard_mapping的写法已经被淘汰了，于是换成keyboard后再次运行上述命令</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/37b098d4862d7a43add0bec5b06a1517.png" class=""><p>这说明我们有关键盘配置的格式出现了问题，书上的配置已经有些过时了。样本文件中有关keyboard的内容如下，我们以此为依据做修改：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9163ff3c499522d0f0936ee287f27e33.png" class=""><p>我们将修改后的以下内容写入bochsrc.disk即可</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt"># bochs configuration file# bochsrc.disk# memory size: 32MBmegs: 32# BIOS and VGA BIOSromimage: file=/home/elite-zx/bochs/share/bochs/BIOS-bochs-latestvgaromimage: file=/home/elite-zx/bochs/share/bochs/VGABIOS-lgpl-latest# boot from hard disk (rather than floppy disk)boot: disk# log filelog: bochs.out# disable mouse, enable keyboardmouse: enabled=0keyboard:keymap=/home/elite-zx/bochs/share/bochs/keymaps/x11-pc-us.map# hard disk settingata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14# gdb part setting#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后启动bochs，提示我们缺少启动盘（could not read the boot disk），所以接下来的任务就是创建启动盘(同时在bochs配置文件中指定磁盘映象文件)</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2ddc5157ba9f54c0372047c4eb1e1179.png" class=""><p>工具链配置 (这段内容只面向vim-er)：<br />这部分是我写到第8章的位图的时候补充的，我发现随着文件越来越多，clangd的静态分析总是会出现找不到头文件的错误。解决办法是利用<a href="https://github.com/rizsotto/Bear">bear</a>工具从makefile文件中提取出编译信息，生成compile_commands.json文件，clangd可以从这个文件中提取出头文件路径 (来源：<a href="https://clangd.llvm.org/installation.html#:~:text=Other%20build%20systems%2C%20using%20Bear">Other build systems, using Bear</a>)</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">make clean &amp;&amp; bear -- make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-主引导记录mbr"><a class="markdownIt-Anchor" href="#2-主引导记录mbr"></a> 2. 主引导记录MBR</h1><p>当计算机加电后，CPU的CS:IP寄存器被强制初始化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mi>F</mi><mn>000</mn><mo>:</mo><mn>0</mn><mi>x</mi><mi>F</mi><mi>F</mi><mi>F</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">0xF000:0xFFF0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">0</span></span></span></span>, 这是为了让<strong>CPU先执行BIOS程序</strong>，该程序检测并初始化硬件（通过硬件自己提供的初始化功能调用）。在这个过程中，CPU确实处于实模式（Real Mode），这是一种兼容早期8086处理器的运行模式。<strong>在实模式下，CPU能直接访问的内存空间是1MB，地址空间从0x00000到0xFFFFF。</strong> 这个1MB的内存空间被划分为多个区域 (详见P.53 表2-1)，具体如下：</p><ol><li>BIOS ROM: 通常位于地址空间的高端(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mi>F</mi><mn>0000</mn><mo>→</mo><mn>0</mn><mi>x</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">0xF0000\to0xFFFFF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>)，共64KB，包括基本输入输出系统（BIOS）代码。BIOS是存储在主板上的固件，负责初始化硬件并提供操作系统与硬件之间的通信接口。</li><li>RAM: 实际的随机存取存储器（RAM）占据了大部分的1MB地址空间。</li><li>其他固定映射硬件: 有些特定的内存区域可能被映射到其他硬件设备。</li></ol><p>为什么计算机一开始要进入实模式呢？ 这又是历史遗留问题了，是8086处理器遗传下来的</p><p>地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mi>F</mi><mn>000</mn><mo>:</mo><mn>0</mn><mi>x</mi><mi>F</mi><mi>F</mi><mi>F</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">0xF000:0xFFF0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">0</span></span></span></span>的内存中存放了一条跳转指令</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/747f653a526543439dfb66bb055cf902.png" class=""><p>BIOS的主体代码在这个位置：$$0xf000&lt;&lt;4+0xe05b=0xfe05b$$<br />这才是BIOS真正开始执行的地方</p><p>于是CPU开始执行BIOS的代码，完成硬件检测和硬件的初始化，<strong>建立中断向量表</strong>以便后续可以通过<code>int 中断号</code>来实现相关的硬件调用，最后BIOS检测启动盘的0号盘面0号磁道1号扇面（扇面从1开始编号）的内容，如果此扇区的末尾2个字节是魔数0x55和0xaa，那BIOS就认为此扇区有可执行程序 (即MBR)，接着BIOS就会把该扇区的内容加载到物理地址0x7c00处，接着CPU跳转到0x7c00处执行MBR</p><h2 id="21-创建一个假的启动盘试试"><a class="markdownIt-Anchor" href="#21-创建一个假的启动盘试试"></a> 2.1. 创建一个假的启动盘试试</h2><p>在编写MBR以创建我们自己真正的启动盘之前，我们可以先用bochs自带的工具创建一个启动盘，如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/097e7aff3618649eebf5f81e0d7e9ced.png" class=""><blockquote><p>.img 文件通常是一个磁盘映像文件，它包含了一个磁盘驱动器或分区的完整内容，包括文件系统、文件、程序和操作系统。</p></blockquote><p>接着我们把最后的提示信息添加到bochs的配置文件bochsrc.disk中</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ata0-master: type=disk, path="hd60M.img", mode=flat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个配置语句用于将一个磁盘映像文件连接到 Bochs 的虚拟机中，因为我们在配置文件中设置了 <code>boot: disk</code>，即在启动顺序中只指定了硬盘，因此Bochs将会尝试从这个指定的磁盘映像启动操作系统(即hd60M.img是启动盘)，样本文件中关于启动顺序的说明如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/45b6c2304dcca12c52c58d947b01ca3c.png" class=""><p>那么现在的配置文件bochsrc.disk的完整内容是：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt"># bochs configuration file# bochsrc.disk# memory size: 32MBmegs: 32# BIOS and VGA BIOSromimage: file=/path/to/bochs/share/bochs/BIOS-bochs-latestvgaromimage: file=/path/to/bochs/share/bochs/VGABIOS-lgpl-latest# boot from hard disk (rather than floppy disk)boot: disk# log filelog: bochs.out# disable mouse, enable keyboardmouse: enabled=0keyboard:keymap=/path/to/bochs/share/bochs/keymaps/x11-pc-us.map# hard disk settingata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=disk, path="hd60M.img", mode=flat# gdb part setting#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再次启动bochs</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e2d7c6c0e3c71c7454445146b6548696.png" class=""><p>此时提示not a bootable disk的错误，这说明使用bochs创建的盘不是一个真正的启动盘</p><h2 id="22-编写mbr创建真正的启动盘"><a class="markdownIt-Anchor" href="#22-编写mbr创建真正的启动盘"></a> 2.2. 编写MBR创建真正的启动盘</h2><p>下面我们用汇编语言写一个MBR，并用nasm汇编器生成bin格式（纯二进制）的文件</p><p>上面这段代码主要完成了清屏，在光标处打印一个字符串，最后的代码确保了该MBR文件汇编之后(<code>nasm -o mbr.bin mbr.S</code>)是512个字节，最后的2个魔数确保了BIOS会加载这个程序 (56)</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/12c4417b8b6621f67f81f75b3898f4cd.png" class=""><p>因为BIOS最后一个项工作是加载启动盘的0号盘面0号磁道1号扇区（扇区从1开始编号，而非0）中的内容到物理地址0x7c00中，因此我们要把我们的mbr.bin文件加载到该扇区中，通过dd命令：</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">dd if&#x3D;&#x2F;path&#x2F;to&#x2F;mbr.bin of&#x3D;&#x2F;path&#x2F;to&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行结果如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/8637557a2059c45f59d472223101f523.png" class=""><blockquote><p>dd 命令会读取 .img 文件中的每个字节，并将其直接写入目标磁盘。这意味着文件系统、引导记录和所有其他数据都会被完整地复制到目标磁盘上。</p></blockquote><p>以上过程，我们先是用汇编语言编写了一个汇编程序，描述MBR要做的事情，接着用nasm汇编器生成了对应的可执行文件，然后用命令<code>dd</code> 将文件mbr.bin的内容写入到磁盘映像文件hd60M.img的第一个扇区（这里没有用dd的seek选项，因此没有跳过任何512字节大小的块，即没有跳过任何扇区，因此写入的是第1个扇区）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/47cf66d2f009b1e0f45a2fa2dcb78d76.png" class=""><p>最后我们启动bochs：</p><p>MBR被BIOS成功加载并执行</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e4c00511fc4f9dc678ea13df9e0766f1.png" class=""><h1 id="3-操纵显示器初探内核加载器"><a class="markdownIt-Anchor" href="#3-操纵显示器初探内核加载器"></a> 3. 操纵显示器，初探内核加载器</h1><p>这一节先是花了一些篇幅来讲解汇编的知识，然后描述CPU如何操纵外设。CPU主要通过I/O接口来操纵外设，I/O接口就是CPU与外设之间的中间件。I/O接口通过寄存器（称之为端口）的方式同CPU通信</p><p>前一节我们用BIOS的中断调用操纵了显示器的输出，这一节我们通过I/O端口操纵显示器的输出</p><p>显卡 (显示适配器) 是显示器的I/O端口，显存是显卡内部的一块内存，显卡就是读取这段内存并把内容发送到显示器上。通过往显存上写入数据，同时遵循ASCII标准，就可以操纵显示器显示我们想要的内容</p><h2 id="31-mbr-v2"><a class="markdownIt-Anchor" href="#31-mbr-v2"></a> 3.1. MBR V2</h2><p>先用一个附加段寄存器gs保存显存中用于文本模式的地址以作为段基址，段内每2个字节为一个字符</p><p>在bochs上的运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9f17c9fdd145275b0c5904baf690418b.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/01fd7b870a8d3fddc73df683797b60fd.png" class=""><h2 id="32-读写硬盘载入kernel-loader"><a class="markdownIt-Anchor" href="#32-读写硬盘载入kernel-loader"></a> 3.2. 读写硬盘，载入kernel loader</h2><p>这一节先是介绍了磁盘 (主要指磁盘，另外还有固态硬盘SSD) 的工作原理，再介绍了硬盘对应的I/O接口硬盘控制器中的端口寄存器。我们正是通过读写这些寄存器间接完成CPU与磁盘的交互</p><p>计算机加电之后，先执行BIOS，接着BIOS把CPU指挥棒交给了MBR，这是我们之前完成的流程。接下来，MBR要传递CPU指挥棒，传递给谁呢？内核加载器！</p><p>那么我们MBR要做的事情，就是把硬盘上的内核加载器读取到实模式的1MB内存的空闲位置中，并跳转到内核加载器去执行</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">nasm -I include&#x2F; -o mbr.bin mbr-v3.Sdd if&#x3D;mbr.bin of&#x3D;..&#x2F;..&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">nasm -I include&#x2F; -o loader.bin loader.Sdd if&#x3D;loader.bin of&#x3D;..&#x2F;..&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 seek&#x3D;2 conv&#x3D;notrunc # seek&#x3D;2 means that the file is placed in the 3rd sector of the boot disk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里我们简单的实现了一个内核加载器，它只是简单的向屏幕上打印&quot;2 loader&quot;</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/4bd16a974fe4cafdde798e3edde9c2cd.png" class=""><h1 id="4-从实模式到保护模式"><a class="markdownIt-Anchor" href="#4-从实模式到保护模式"></a> 4. 从实模式到保护模式</h1><h2 id="41-由多段模型到平坦模型"><a class="markdownIt-Anchor" href="#41-由多段模型到平坦模型"></a> 4.1. 由多段模型到平坦模型</h2><p>这一节主要是修改内核加载器Loader.S的功能，让它能将把CPU从实模式切换为保护模式，要完成这个切换，主要进行以下3个步骤</p><ol><li>打开A20（157）</li><li>加载gdt (155)</li><li>将控制寄存器CR0的pe位置1 (158)</li></ol><p>为什么把段基址设为0 :<br />无论是在实模式还是在保护模式，x86访问内存的机制都是段基址：偏移地址的形式。现在CPU进入保护模式了，寄存器（除段寄存器，现在段寄存器是选择子而非段基址了）和地址总线都拓展到了32位，所以无需设置段基址就可以访问到整块内存（4GB），内存变成了平坦模型（单段），无需再像实模式哪样通过切换段基址来访问整个地址空间，因此我们对段寄存器采取简单的做法：把段基址设为0，<s>所以这里还没有实现对不同段的保护。</s> 而段的长度单位（粒度）我们选择的是4k，所以段界限(limit)为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>G</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>0</mn><mi>x</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">4GB/4KB = 2^{20} = 0xFFFFF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></p><p>进入保护模式前为什么有一个jmp指令：<br />这样做的目的有2个</p><ol><li>更新段描述符缓冲寄存器的值</li><li>清空流水线<br />以上两点在P.172有详细的解释</li></ol><p>书上boot.inc部分的代码是有问题的，显卡的段基址的低位不应该是和代码段和数据段一样的0x00，而是应该为0x0b，这样才能和段描述符的低位4字节组成段基址0xb800</p><p>此外，因为此时的Loader.bin的大小已经超过一个扇区的512字节：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d6c7b98827b3e12b8febd778a445222a.png" class=""><p>因此我们要修改之前的MBR-V3.S，让它读取loader起始地址开始的4个扇区（其实2个就足以，不过为了避免将来再过来修改，就多读点咯）</p><p>相应的，在用dd命令把loader.bin加载到磁盘映象文件时，count参数要指定为4</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">dd if&#x3D;loader.bin of&#x3D;..&#x2F;..&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;4 seek&#x3D;2 conv&#x3D;notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们的文件大小 (这里是623B) 小于 dd命令指定读取到磁盘映象文件的大小(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mo>×</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>512</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>2</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">block \times count =512 \times 4 = 2KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>)，那么dd只会复制实际文件大小的数据 (623B)</p><p>运行结果：<br />因为loader.S中没有清屏操作了，因此运行结果中保留了MBR模块的字符输出。打印的PM表示现在CPU处于protected mode</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5d2b63e4f8b5cd2d12ca6e67859ca414.png" class=""><p>现在我们来看看此时的全局符号表GDT：<br />这与我们在源文件中定义的3个段描述符号一致，此外，bochs调试器获取段描述符条数的方式是读取GDTR寄存器的低位2个字节所表示的GDT界限。这里虽然代码段描述符和数据段描述符对应了同一个段（基址为0, 大小为4GB, 即整个内存空间）, 但是当CPU通过不同的段描述符获取该段的信息时，该段就有不同的性质（如代码段 只可执行， 数据段只可读 ）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b095a420671212006e159bb9739c867d.png" class=""><p>此时的控制寄存器CR0：<br />PE大写意味着该位已经被置1</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ac61cad9642cb555793972f4e554c21f.png" class=""><p>为了进一步验证这是我们的内核加载器loader完成的置位，我们可以在loader的入口地址设置断点，并查看此时的CR0</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9e204327c041de2c7c91ddb3784a1bba.png" class=""><p>pe小写，说明此时的位pe的值是0，也就意味着此时CPU还是实模式。看样子我们的loader确实正确执行了</p><h2 id="42-多次切换从何而来"><a class="markdownIt-Anchor" href="#42-多次切换从何而来"></a> 4.2. 多次切换从何而来</h2><p>因为bochs调试器中支持用命令<code>show mode</code>指定bochs在实模式和保护模式之间的切换打印提示信息。出于好奇，我在这一节中使用了这个命令，但是结果出人意料，本该只有一个real mode到protected mode的提示语句，但是实际上却出现了多条：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/14003e5af4dfea4865f170fbb9b89c4b.png" class=""><p>我以为是我的代码有问题，于是开始断点检查，在MBR的入口地址0x7c00设置段点并重新启动OS：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/601d4625a3c6baf8aecd6822e94e90cc.png" class=""><p>可见除了最后的实模式到保护模式的提示信息是由我的实现造成的以外，之前的提示信息均发生在BIOS执行期间，这可能是BIOS执行硬件检测和初始化导致的。</p><h1 id="5-在保护模式中开辟天地"><a class="markdownIt-Anchor" href="#5-在保护模式中开辟天地"></a> 5. 在保护模式中开辟天地</h1><h2 id="51-获取物理内存容量"><a class="markdownIt-Anchor" href="#51-获取物理内存容量"></a> 5.1. 获取物理内存容量</h2><p>这一节通过BIOS的0x15中断的3个子功能完成对物理内存容量的获取，主要是通过0xE820号中断，我们通过计算该中断获取的内存段中最高的内存上限值作为物理内存容量信息，所以我们的汇编代码中还有一个遍历内存段取最大内存上限值的过程。</p><p>此外，为了内存对齐，进而使得指令执行效率更高，我们想要把数据部分放在内核加载器loader的前0x300个字节，这意味这loader的指令真正开始的位置是物理地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>900</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>300</mn><mo>=</mo><mn>0</mn><mi>x</mi><mi>b</mi><mn>00</mn></mrow><annotation encoding="application/x-tex">0x900+0x300=0xb00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">9</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal">b</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 处。之前我们在loader的开头加了一句jmp语句，这是因为mbr跳转到loader后，loader的开头是一堆数据定义，而不是指令，所以加上这条jmp是有必要的。但是现在，既然我们能知道loader的指令起始地址是0xb00，那么我们直接在修改MBR中的跳转指令<code>jmp LOADER_BASE_ADDR </code>为<code>jmp LOADER_BASE_ADDR + 0x300</code>，这样就可以省略到loader开头的jmp指令（占3个字节），从而使得在它之后定义的数据的地址均对齐到偶数（具体可见P.183）。</p><p>这里我其实产生过疑惑，为什么汇编就可以指定数据在指令之前，即我在一堆指令之前用dd,dw指令定义了一堆数据，就可以保证在该程序执行时，数据是在指令之前的。此时就要搬出我们伟大的工具chatgpt来问问了: 这主要是因为汇编语言提供了对计算机硬件的直接控制能力，包括内存地址的直接访问和操作。当你在汇编程序中使用伪指令如 <code>db</code>, <code>dw</code>, <code>dd</code> 等定义数据，它们会按照出现的顺序在生成的机器代码（或对象文件）中占据空间。当你在源代码中书写这些伪指令时，汇编器会按照你的指示将对应的数据字节、字、双字放置在生成的代码中。而类似C语言这样的高级语言，数据（例如全局变量、静态变量和局部变量）和代码（函数）是被编译器和链接器管理的。编译器和链接器会根据操作系统的规范将程序的不同部分放置在不同的内存区域中。</p><p>查看物理地址为0xb00的变量total_mem_bytes的值是否为我们bochs配置文件bochs.disk中定义是32MB (0x200 0000):</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d5b995560753dcd2d2811fbe9534470e.png" class=""><p>可见检测物理内存容量的结果正确。</p><h2 id="52-开启虚拟地址"><a class="markdownIt-Anchor" href="#52-开启虚拟地址"></a> 5.2. 开启虚拟地址</h2><p>本节主要通过3个步骤完成了CPU分页机制的启动：</p><ol><li>准备好分页机制所需要的数据结构—页目录表（PDT）和页表（PT）</li><li>将页目录地址写入控制寄存器cr，这样CPU的页部件就可以启动页查找</li><li>把寄存器cr0的PG位置1，这是让CPU进入内存分页运行机制</li></ol><p>要了解分页机制，咱们得先把分段机制搞透。分段机制的地址处理由CPU的段部件负责，在分页机制开启之前，段部分输出的线性地址就是物理地址，即线性地址和物理地址是一一对应的关系，就像我们的显存段基址是0xb800，它对应的物理地址就是0xb800。当然了，这里的线性地址，以段基址：段内偏移形式计算出的，但是因为保护模式下寄存器和地址总线都为32位，所以段基址是0。这样一一对应的关系导致内存利用效率低，无法充分利用内存，因为此时线性地址和物理地址都必须是连续的，导致进程必须用一整块物理内存装下。<strong>我们想要的是线性地址连续而物理地址不连续，这样就可以用离散的物理内存装载进程。当我们用离散的物理内存装载了进程后，为了让CPU可以正确寻址，就要记录下线性地址和物理地址的映射关系。</strong> 此时线性地址和物理地址就不是一一对应的关系了，而是线性地址可以映射到任意一个物理地址。此时的线性地址有了新的名称，叫做虚拟地址</p><p>我们要创建页目录表(PDT)和页表(PT)来记录下映射关系。在我们保护模式下，是32位的地址空间，也就是4GB，这也就是说进程可以用的地址空间最大为4GB。在分页机制下，每个进程都有4GB的虚拟内存，但是不具有真正的4GB物理内存，每个进程都有自己的页表。</p><p>分页机制下，以4kb为分配单位（即页框/标准页），一个页目录有1KB个页目录项（PDE），一个PDE占4个字节，也就是说一个页目录表的大小是4KB，这正好是一个标准页的大小。页目录项保存着页表的地址，一个页表内含义1KB个页表项（PTE），一个PTE也是4个字节，一个页表页正好是一个标准页4KB的大小。总得算下来，一个填满的页目录和页表所代表的地址为：$$1KB\times1KB\times4KB=32GB$$<br />这也是32位下的地址空间大小，所以任何一个虚拟地址都可以通过PDT和PT找到对应的物理地址。</p><p>其实我不想在这种书上有着详细解释的问题上留下太多额外的描述，上面的内容就当作是我稍微看懂一点之后的足迹吧，不一定准确。</p><p><strong>虚拟地址为什么高10位是PDE的索引，中间10位是PTE的索引，最后10位是页内偏移呢？</strong><br />我认为P.190的地址滑块模型是一个很好说明， 在地址中放一个滑块，滑块左边就是内存块数据，滑块右边就是内存块大小。而且PDT和PT都是含义1KB个项，所以均用10位来确定索引值</p><p><strong>创建页目录表时，为什么第768个PDE保存与第1个PDE相同页表地址？</strong><br />第768个PDE，对应着虚拟地址 3GB (0xc0000001)~3GB+4MB (0xc03fffff)，这部分在进程的虚拟地址空间中是OS内核所在的区域(3GB~4GB, 0xc0000000~0xffffffff)，而第一个PDE对应的物理地址是物理内存的从0开始的4MB。所以这样做本质上是把进程的高1GB虚拟地址空间中的4MB映射到OS内核所在的物理地址，这样就能实现操作系统在用户进程间的共享（实际上我们的内核大小还不到1MB）。不只是这4MB，我们实际上需要把进程虚拟地址空间中的整个高端1GB都映射到OS内核所在的从0开始的物理地址空间。</p><p><strong>如何通过虚拟地址访问到页表本身？</strong><br />让页目录表的最后一项保存页目录表的起始地址PAGE_DIR_TABLE_POS，详见P.204。这个实现方式十分的巧妙，让我看了连连摇头赞叹，竖起大拇指。简单来说，就是欺骗CPU，让CPU以为它访问到的是页表地址，其实是页目录地址; CPU以为访问的是物理页的物理地址，实际上是页表的物理地址。</p><p><strong>为什么要移动GDT到内核空间？为什么要修改视频段的段描述符？</strong><br />这2者都是因为在分页机制下，内核在虚拟地址空间的高端1GB中，而这2者都属于内核。<br />GDT是内核空间的东西，而内核空间现在在虚拟地址空间中处于高端1GB，因此要调整之前的GDT地址，把它放入这1GB中。而修改视频段的段描述符中的段基址是因为显存也要在内核中，不能让用户直接控制显存这个硬件，必须通过OS。</p><p>在创建页表时，把PDT放在了物理地址0x10000处 (这也是后续填入控制寄存器CR3的值)，并将页表紧随其后。因为PDT的大小是4KB，因此第一个页表的地址是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>100000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>101000</mn></mrow><annotation encoding="application/x-tex">0x100000+0x1000=0x101000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。在页目录项中填入页表的地址，这样页表就创建好了。同样的，在页表项中填入物理页框的地址（不同页框地址相隔4KB，这也是为什么有edx+4096），这样页表项就创建好了</p><p>运行结果：<br />打印V表示OS已经开启分页机制，进程开始使用虚拟（Virtual）地址</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/f220cfb82f4de5fa7652d7724e1b89c1.png" class=""><p>查看GDT起始地址和视频段基址：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/4e43ab4ad4a18f0dcf955d0f2b925fb9.png" class=""><p>查看当前的页表信息：<br />前2项是PDE第1项和第768项的结果，我们为这2个PDE对应的页表分配了实际的物理内存 (即创建页表项)，后3项是为了实现通过虚拟地址访问到页表的结果，书上有着详细的分析 (P.205)，我就不多说了</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/57cb3f91e69e3c355803c55c0ed039a1.png" class=""><p>查看cr3的值：<br />这正是我们放置GDT的物理地址</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/75bb143a17225a2d6ecf86cc65568a40.png" class=""><h2 id="53-传递第3棒进入内核"><a class="markdownIt-Anchor" href="#53-传递第3棒进入内核"></a> 5.3. 传递第3棒，进入内核</h2><p>这一节主要在loader.S中完成2件事情：</p><ol><li>把内核文件kernel.bin（elf格式的二进制可执行文件，同样含有文件头）加载到内存 （<a href="https://stackoverflow.com/a/2427229/19705477">elf vs bin</a>, 总的来说就是bin可以直接放入内存执行，而elf需要被解析之后才能执行，我们的第2步就是编写解析elf的程序）</li><li>根据kernel.bin文件头和segment header table（段头表）中的信息，把kernel.bin中的各个段（segment）拷贝到被编译的目标虚拟地址处（这一坨称为内核映象，即内核的内存映像）</li></ol><blockquote><p>当ELF文件中的segments被加载到内存时，它们形成了程序的内存映像，这个内存映像可以由操作系统或者执行环境来执行</p></blockquote><p>我把内核放在了物理地址的低1MB处，没错，就是BIOS所在的那1MB。这1MB中不仅还有空闲的区域（见P.223图5-43），并且MBR已经完成它的使命了，内核可以覆盖它。所以这1MB中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>500</mn><mo>→</mo><mn>0</mn><mi>x</mi><mn>9</mn><mi>f</mi><mi>b</mi><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x500\to 0x9fbff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">9</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>  可以用来放我的内核（最终的内核大小不会超过1MB）。 在我的实现中，把内核文件kernel.bin放在了0x7000的位置，把内核的内存映像放在了0x1500（即虚拟地址0xc001500, 由链接器ld的-Ttext选项指定，分配虚拟内存地址是链接器的任务。这个物理地址到虚拟地址的转换是我在前一节完成的）的位置。之所以这做，是因为内核的内存映像可能随着执行会变大，需要预留更多的空间，放在低地址处更好。而内核文件kernel.bin是固定的，只需要能放下即可。</p><p>关于栈的处理，见P.226图5-44，我们要保证处理内核时用到的栈在内核空间中（即虚拟地址0xc0000000~0xc03fffff，我们在上一节中把物理内存0～4MB映射到了这块虚拟地址，够用）。栈在内存中既然是从高地址向低地址增长的，并且栈底永远不会被访问到(如果对这一点不理解，可见P.226)，那么内核的栈最合适的放置位置就应该是内核可用空间的最高地址的下一个地址，即$$0x9fbff+0x1 = 0x9fc00$$<br />对应到虚拟地址就是$$ 0x9fc00 + 0xc0000000=0xc009fc00$$<br />但是这里选择了物理地址为0x9f000的地址作为了栈底，这就意味着还有0xc00个字节的位置没用。为什么这么做呢，这里我就不再重复P.228刚哥说的话了，而是提一嘴：P.384讲内存位图基址的时候进一步解释了这个地址的由来，可以结合起来看。归根结底，就是让main线程的PCB占有一个完整的页框</p><p>再谈对kernel.bin的解析，这里需要对elf文件的格式比较熟悉，因为我看过程序员的自我修养这本书，所以刚哥讲elf格式的部分我是直接跳过了。主要来看，就是先从头文件中提取出程序头表(program header table)的信息（条目大小，表的起始位置，条目数），并根据这些信息遍历程序头表中每一项，并从这些项中提取出原虚拟地址，目标虚拟地址，大小信息，最后实现一个memcpy函数（这里涉及传递memcpy所需要的3个参数src, dst和size）完成内存映射。</p><p>文件头如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/84d05334ef38af79b55fc74f2ced4c3d.png" class=""><p>程序头表：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d98572826027a229b5816230d3ba996d.png" class=""><p>下面说一下我踩的坑，我在参照着书上的代码写好程序后，程序并没有进入理想的无限循环中，而是重新回到了BIOS，这样出人意料的结果肯定是在哪里发生了什么错误。于是我开始断点单步执行，这时候一个困扰了好一会的问题冒出来了，那就是我怎么知道我汇编程序中指定指令的物理地址/虚拟地址呢，因为只有知道这些地址我才能设置断点（bin文件不含有调试信息，因此不能用符号名），最后我探索出一个方法，那就是<strong>在我想要设置断点的汇编语句前加一个<code>jmp $</code>语句，这样bochs执行到这里的时候就会停下，并显示地址，于是我就得到需要的地址信息啦</strong>。经过调试，我发现我的数据复制小团队出现了问题，即我的<code>rep movsb</code>并不能正常的完成数据复制。<br />如下，圈出来的指令在程序中是<code>cmp byte [ebx+0], PT_NULL</code>, 按道理说该语句之后继续continues应该会回到这个指令，但是之后的执行就开始乱七八糟了，居然有回到了BIOS。不仅如此我在函数mem_cpy的最后加了jmp $语句，该语句居然也没被成功执行，说明我的数据搬运小团队出现了问题，但是代码和目标磁盘区域是对的，那么就只有一种可能—磁盘内的数据有问题。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5d5cb5984af3d32cefeece4ae37dbde0.png" class=""><p>于是我查看kernel.bin的格式，居然是ELF64！问题果然出在这里😦，因为我是64位机器，所以gcc和ld默认以64位方式进行编译和链接。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9d1f20583e15d4ce19f177fddd98e2b6.png" class=""><p>以下面这个方式（写成了一个脚本）生成ELF32格式的kernel.bin之后，程序正常执行。内核文件放在磁盘的第9个扇区 (LHS计数中，以0开始计数)，并把划分出200个扇区用来存放内核文件，因为内核文件不会超过100KB，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn><mo>×</mo><mn>200</mn><mo>=</mo><mn>100</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">512\times200 =100KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>是足够的</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d33f9a570c358a46764727d4f71260a3.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/820db50ca1253b8635b82cadf28033c1.png" class=""><p>顺便贴一下我用于生成mbr.bin和loader.bin的脚本</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b7b9640b1c1670fcf77c01ec56644d7f.png" class=""><p>运行结果分析：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/6d1bf4170cd1a1622af76a6e8ce56d99.png" class=""><p>打印K字符，说明我们已经进入内核模式，这个打印语句是我自己在进入内核的相关代码中加的。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/873c22390f65ac254f2c5d9418ea399c.png" class=""><p>查看当前执行的指令，是指令<code>jmp $</code>，一个死循环，而且地址在我们的内核映象的起始地址0x1500附近，说明正在执行的就是内核中的语句<code>while(1)</code></p><h2 id="54-特权级前瞻"><a class="markdownIt-Anchor" href="#54-特权级前瞻"></a> 5.4. 特权级前瞻</h2><p>这一节的内容写了很多，也花了我挺长时间看完。日后拾起来的话主要看看最好先看看P.247的例子。<br />主要的关键内容如下：<br />CPL(current privilege level)可以就理解为当前(current)CPU所执行的代码段的DPL (descriptor privilege level)。RPL具体指的是选择子的RPL位，它代表了真正的资源请求者的特权。操作系统正是通过RPL才避免了用户程序企图通过内核提供的服务进而恶意访问/修改内核的企图，因为无论用户如何伪造它的特权级，RPL永远代表用户真正的特权级（从用户的CS寄存器中取出，由操作系统修改）。</p><p>接下来好好说说特权级检查，CPU执行特权检查的时间点在更新段寄存器的时候，即加载选择子的时候。进一步说，是发生在访问的时候，之所以要加载选择子是因为程序要访问代码/数据了。</p><p>先不涉及调用门，当我们访问数据段和代码段（下面称为资源）的时候执行特权级检查，此时会涉及RPL的检查，当我们在请求这些资源的时候，访问者的RPL和CPL与受访者的DPL需要满足下面这个条件：$$CPL\le {DPL}<em>{target};&amp;&amp;;RPL\le{DPL}</em>{target}$$<br />即访问者的特权级要高于受访者（实际上这对数据段资源成立，对代码段来说，只能平级访问，也就是说要求是相等）。</p><p>接下来涉及调用门，用户程序可以通过调用门让CPU进入高特权级。门的作用用P.237的蹦床原理来形容就很形象。这时候的特权级检查就发生变化了，一共有2步检查，第一步与门槛比较，即门描述符，第二步与门框比较，即门描述符对应的内核代码。</p><h1 id="6-从一个简单的print开始完善我的内核"><a class="markdownIt-Anchor" href="#6-从一个简单的print开始完善我的内核"></a> 6. 从一个简单的print开始，完善我的内核</h1><h2 id="61-打印单个字符的print"><a class="markdownIt-Anchor" href="#61-打印单个字符的print"></a> 6.1. 打印单个字符的print</h2><p>这一节主要是完成一个print函数。要完成这个函数光会往显存上mov数据是不够的，还得学会如何操作显卡的端口(即寄存器)以控制光标的位置，以及处理控制字符，打印的字符超出屏幕时实现滚屏等。显卡的寄存器是目前遇到过的端口中比较特殊的，需要通过类似索引数组的方式完成对指定端口的读写，具体来说就先在Address Register中写好我们需要哪个索引下的端口，然后再通过Data Register完成对索引下寄存器的读写操作。</p><p>除此之外，这里实现滚屏的方式也很巧妙，具体体现在处理光标的移动上。这里的滚屏，具体指的就是把当前内容向上滚动一屏，滚动之后的光标应该出现在最后一行（即第24行，行数从0开始）的首位，而这个移动光标的操作正好可以与处理回车符的操作放在一起，也就是说我们可以把这个操作看作是在当前光标下处理一个回车符。在处理回车符时，我们先把bx（该寄存器被我们原来代表光标地址）对80取余，再在bx上减去这个余数，于是bx就指向了行首的位置，接着再<code>add bx, 80</code>那么bx就到了下一行的行首了。</p><p>在处理控制字符时，我们只处理了下面这3个控制字符 (<a href="https://stackoverflow.com/a/12747850/19705477">line feed and carriage return</a>)</p><ul><li><code>\r</code> — carriage return, ascii值为0xd，含义是把光标移动到当前行首</li><li><code>\n</code> — line feed，ascii值为0xa，含义是把光标移动到下一行的行首， 即回车符 （这在linux上才成立，回车符在windows上为<code>\r\n</code>）</li><li><code>\b</code> — backspace, ascii值为0x8， 含义是删除当前光标下的字符<br />具体实现中，把<code>\r</code>和<code>\n</code>统一当作了回车符号处理。处理<code>\b</code>时，先把光标往前移动一个位置，接着在光标原来的指向的字符位置处填上空格，注意这里的字符位置，是通过光标位置乘2之后得到的。</li></ul><p>此外，print的实现定义在汇编文件print.S中，调用在C文件main.c中，是高级语言和汇编语言之间的调用。main函数中向print函数传递参数的方式就是把参数压入栈中，这由编译器帮我们完成（即编译器生成相关的机器码），而汇编函数print从栈中拿到对应的参数，这个步骤由我们自己编写。</p><p>运行结果：<br />这里的数字我就没有按照书上输出啦，我换成了我完成这个函数的日期。运行结果与预期一致，backspace被正确的处理了。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/1c3dc981f2a51ae9120487a02fbc5934.png" class=""><h2 id="62-打印字符串的print"><a class="markdownIt-Anchor" href="#62-打印字符串的print"></a> 6.2. 打印字符串的print</h2><p>本质上就是多次调用put_char, 通过判断当前字符的ASCII值是否为<code>0</code>(对应字符<code>\0</code>)进而判断字符串是否结束。</p><p>运行结果：<br />加个感叹号让我的内核宝宝看起来更有气势😃</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/66ba0e19c0baeee118bcd0e060288f17.png" class=""><h2 id="63-打印整数的print"><a class="markdownIt-Anchor" href="#63-打印整数的print"></a> 6.3. 打印整数的print</h2><p>我们同样可以借用put_char完成对整数的打印。关键的步骤就是完成整数到字符的转换。</p><p>先说结果，<strong>对于每个输入的整数，最终的打印形式都是其对应的16位进制数</strong>，比如我输入十进制数数字<code>15</code>到print中，打印的会是十六进制数<code>F</code>。具体的转换怎么实现的呢？参数是一个32位整数，不管我们是传递十六进制的数字还是十进制的数字，在CPU开始都是1和0组成的二进制数字，所以<strong>实际上我们要处理的就是这一个32位长的二进制串，把每4位转换为一个十六进制数，一共就是8个十六进制数，接着再把这8个十六进制数转换位对应的字符(即ASCII值)，比如十六进制数<code>F</code>就转换为字符<code>F</code></strong>。这里要注意的一点就是，在转换位字符之前，每个十六进制数用4位就可以存下了，但是转为字符之后，此时的值是一个ASCII码了，至少需要7位，因此拿一个字节来存放这个字节结果，这也是为什么在函数开头要申请8个字节的用于存储转换结果的缓冲区put_int_buffer。最后我们还要去除数字高字节中的0，使得打印结果更精简<br />eg:<br /><span class='katex-error' title='ParseError: KaTeX parse error: Double superscript at position 82: …its) \to&#039;1&#039;&#039;2&#039; &#039;̲3&#039; &#039;4&#039;'>0x00001234 \to 0000\_0000\_0000\_0000\_0001\_0002\_0003\_0004 (32bits) \to&#039;1&#039;&#039;2&#039; &#039;3&#039; &#039;4&#039;</span></p><p>运行结果：<br />今年（2023年）快结束了,那么就打印2023吧！</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/28cf6d86a5f377a1d626ce20bf055a1a.png" class=""><p>可以在进入put_int时设置断点，查看此时栈的内容</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e66f2de4d200fddca3660c8d48d4bad0.png" class=""><p>可以看到，函数main传递过来的参数在从栈顶数下来的第9个项的位置 (从0开始计数)，前9项是指令<code>pushad</code>压入是8个4字节的通用寄存器和main函数的返回地址，说明代码中从<code>[ebp+4*9]</code>取出参数是正确的</p><h1 id="7-让中断驱动操作系统内核"><a class="markdownIt-Anchor" href="#7-让中断驱动操作系统内核"></a> 7. 让中断驱动操作系统内核</h1><h2 id="71-初步建立33个中断内联汇编开始发挥功效"><a class="markdownIt-Anchor" href="#71-初步建立33个中断内联汇编开始发挥功效"></a> 7.1. 初步建立33个中断，内联汇编开始发挥功效</h2><p>这一节呢用了比较长的时间，大概有个3天吧。主要是上个周末，休息了一天，也不是完全休息，但是也没搞OS，而是去重新配置了一下vimrc, 加了几个好用的插件，比如vim-surround, vim-which-key等，我就喜欢这种高度自定义并且可扩展的软件 (另一个就是obsidian)，只要vim还能满足我的需求，我宁愿花时间去配置它，也不会转去vscode</p><p>那么就简单的谈谈这一节吧。 这节我们要做好的事情主要就2件：</p><ol><li>构造好IDT</li><li>提供中断向量号</li></ol><p>对于第1点，那就是写好中断处理程序并把记录着中断处理程序的地址表（说是表，本质上还是个数组）的地址加载到寄存器IDTR中，这样CPU才知道中断处理程序在哪里</p><p>对于第2点，那么就要学习可编程中断控制器8259A芯片，也叫中断代理。我们要初始化好它，并通过它设置好中断向量号的起始值。在实现中，中断向量号的起始值被设置为0x20,也就是32，从0开始计数的话就是第33个项。之所以是这个值是因为，中断向量号的前32个值（0～31）是被CPU保留的（详见P.303 表7-1），提供给CPU内部中断使用的。8259A主片上的第一个引脚被底层电路设计为接受来自时钟的中断信号，为了简单的检测程序是否成功，这一节只让CPU响应这一个外部中断。</p><p>这一节的实现中，值得说道的一点是IDTR寄存器的装载，相关代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">uint64_t</span> idt_operand <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>idt<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>idt <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"lidt %0"</span> <span class="token double-colon punctuation">::</span><span class="token string">"m"</span><span class="token punctuation">(</span>idt_operand<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中idt是关于中断处理程序的地址数组的数组名，数组名在C语言中同时也是指向数组首元素的指针（在32位系统上，大小为32个bits）这个简单的知识点大家应该都知道。因为IDTR和GDTR一样，都是48位，高32存储table的基地址，后16表示表的界限。所以要完成IDTR寄存器的装载，就是通过这32位指针得到正确的48位的数据</p><p>首先是表界限，因为地址从0开始编址，而表界限要代表表的最后一个字节，所以这里的sizeof(idt) (sizeof运算符得到字节数)值要减去一个字节。CPU通过对比访问的地址是否超过这个表界限值来判断是否越界。例如，如果 IDT 总共有 256 个条目（实际上，在这一节我们创建了33个条目），每个条目 8 字节，那么 <code>sizeof(idt)</code> 将是 <code>256 * 8 = 2048</code> 字节。然而，由于从 0 开始计数，IDT 的最后一个字节实际上是第 2047 个字节（从 0 开始数到 2047 总共有 2048 个字节）。因此，段界限应该是 <code>2048 - 1 = 2047</code>。</p><p>其次是对32位指针的处理，因为要左移，有高位数据丢失的风险，所以要先扩容为64位。问题是为什么不直接扩展为64位而是先转为32位无符号数再扩展呢？主要还是因为符号扩展问题，当你直接将一个较小的数据类型（如 32 位指针）转换为一个较大的数据类型（如 64 位整数）时，关键问题在于如何处理额外的位。在某些系统或编译器中，如果源类型是带符号的（如 <code>int32_t</code>），直接转换可能会导致符号扩展 (保持了数值的符号（正或负）)，这意味着原始值的符号位（最高位）会被复制到新值的所有额外位上。对于指针来说，这通常不是期望的行为。指针通常应该被视为无符号值，因为它们表示内存地址，不应该有符号扩展的行为。但是由于<strong>指针在语义上不是有符号还是无符号，因此编译器可能不会自动将它们视为无符号数进行扩展。所以我们在扩展之前要先把32位指针idt明确的转换为32位无符号数，再进行扩展</strong>。因为这部分书上是一笔带过的，可能刚哥认为读者C语言知识都很扎实吧。所以我在这里添上一笔。</p><p>还有一个值得说道的一点就是中断程序地址数组的建立，这是在kernel.S中完成的。主要利用的就是编译器（这里说汇编器nasm应该更准确才是）会把属性相同的数据（数据/代码）当在一起，而不会理会程序中的section关键字。具体来说，编译后的目标文件中的段是根据它们的类型和属性（而非在源代码中的物理布局）来组织的。因此，所有的 .data 段都会被合并到目标文件的一个 .data 部分，所有的 .text 段被合并到一个 .text 部分，即使它们在源代码中是交错排列的。所以，在每个中断程序中定义的4字节地址数据intr_%1_entry才能被合并在一起，形成地址连续的数组结构。</p><p>从这一节开始，我将在我的代码注释中尽可能的遵循linux内核的注释风格，准则参考：<a href="https://www.kernel.org/doc/html/latest/doc-guide/kernel-doc.html">Writing kernel-doc comments</a></p><p>下面来谈谈我踩的坑，这个坑各位大概率不会踩，所以赶时间的各位看官可以跳过。</p><p>我在运行启动bochs之后，并没有看见时钟中断被正确的触发（即不停的打印interrupt occur），屏幕上只有几个初始化过程中的提示语句。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/64c353023f8b6a01d66b4ae0d918cca9.png" class=""><p>而且系统也因为某些错误而被迫重启，又回到了跳转到BIOS的入口地址的jmp语句</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/3448153089dd19f7e0eb670e69bec8bc.png" class=""><p>于是我开始了我的调试过程，仿造之前在汇编程序中加入<code>jmp $</code>语句以获取指令地址进而设置断点的思路，我首先在main函数中加入while(1)，如下：<br />（这里提一句，clang-format格式化工具哪都好，就是这个单句while的分号它非的给你换行，还不允许你通过配置.clang-format单独修改这个行为😄）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/f62d245cd4d4b6273964ac8869e0cd77.png" class=""><p>然后运行内核，结果如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ea958103cd6e43fe54c2f826065f0bfd.png" class=""><p>这说明内联汇编语句sti语句的物理地址为<code>0x00001531</code>，虚拟地址为<code>0xc0001531</code>。 下面去掉sti前的while语句，在0x00001531处设置断点，如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/8b0752e4076c37128fc9e986b4c5eec9.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/2ab8b9f08b9dbcb21d1cafdb2d9a40e8.png" class=""><p>可以看到的是，中断描述符表确实是如预期的建立起来了，LDTR中的内容也与IDT的起始地址一致，但道理来说中断处理程序应该是被能够被正确调用的。在确认了我的中断代理设置无误之后（即只放行时钟中断），我确定出问题的地址在中断处理程序本身！</p><p>于是我来到kernel.S, 在中断处理程序中加上了<code>jmp $</code>，结果如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/27e4e49d6d8bcc32d79f1f6aaed46acd.png" class=""><p>上图可见，通过对比jmp指令后续的的指令和定义的中断程序，可以发现现在就是在执行中断程序，因此中断程序确实是被正确的调用了。那么最终的错误一定就是中断处理程序本身的错误。</p><p>因为我把<code>jmp $</code>放在的时<code>call put_str</code>指令之后， 但此时屏幕上并没有正确的打印一条<code>interrupt occur</code>信息，这让我确信了错误出现在上一节完成的put_str函数中。经过对print.S的排查，发现原来是在完成put_char函数的roll_screen操作时，没有正确定义edi的值 (🥲)，导致我的数据搬运小团队把数据搬去了一个未知的内存区域。这也可以解释为什么系统被bochs重启了：在多次运行时钟中断的中断处理程序之后，数据搬运小团队移动了一大堆数据到未知的内存区域，最终覆盖了某些关键指令或数据，导致系统被bochs重启。</p><p>这也让我认为，今后每次在进入下一章之前，一定就充分的测试当前章节完成的功能点。在上一节中对print.S的检测中就没有检测滚屏操作是否能正常执行，才让我花费了不少时间在这一章找到这个错误。</p><p>最终的运行结果:<br />时钟中断一直在发生，因此不断的打印interrupt occur</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/76591f10265aa296d3dabcfbb111d6ca.png" class=""><p>查看中断描述符表：<br />一共建立了33个中断，最后一个中断为类型是外部中断的时钟中断</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e739bc3f1c18db0be8f67e559efcdc3c.png" class=""><p>查看标志寄存器eflags的IF位：<br />sti指令把IF置1, 对CPU执行开中断，使得CPU可以响应中断代理8259A发来的INTR信号和中断向量号信息</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/a9ed68083a6dd6c95da3a0b98a6a88fb.png" class=""><h2 id="72-移动中断处理函数到c程序中"><a class="markdownIt-Anchor" href="#72-移动中断处理函数到c程序中"></a> 7.2. 移动中断处理函数到C程序中</h2><p>上一小节在汇编程序中完成了中断处理程序，这一节把中断处理程序移到c程序中，毕竟C程序更简洁也更容易编写和维护，而在汇编程序定义中断程序的入口地址。</p><h2 id="73-深入探究中断时的栈"><a class="markdownIt-Anchor" href="#73-深入探究中断时的栈"></a> 7.3. 深入探究中断时的栈</h2><ol><li>通过bochs调试命令（主要是<code>show int</code>）找到中断入口点</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/b20f8d8de36bc20c03f62922ce2f1674.png" class=""><p>因此可以通过调试命令<code>sba</code>在中断入口点的前一个指令处设置断点，即第17581237条指令。执行<code>print-stack</code>查看此时的栈（也就是即将进入中断前的栈），在上方的是低地址处的栈顶。执行<code>r</code>或<code>reg</code>查看此时的标志寄存器，可见IF位是置1状态，CPU可以响应可屏蔽中断（即响应来自中断代理8259A的INTR信号）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/3259b5c3e592e2b0d400bdfa380f63a8.png" class=""><p>执行<code>s</code>进入中断，下一个指令正是中断处理程序的<code>push ds</code>指令</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/09b5015dc34ec4de3a1972873e89c0f3.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/f25ade9724394173f85374fb47eed0f9.png" class=""><p>CPU为了避免嵌套中断，进入中断后会把标志寄存器的IF位置0，我们来验证一下：还是用<code>r</code>命令查看标志寄存器，可见其IF位确实被置0了</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2aff30e45eefe6ad64baec5bdbcf14a5.png" class=""><p>现在查看刚进入中断后的栈：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5814cd347178d2582dea2beb011bb474.png" class=""><p>从栈顶的0x0是中断程序的第一条指令push 0执行的结果，依次往下应该是EIP, CS, 标志寄存器eflags, <s>ESP_old, SS_old</s>，还是来验证一下：</p><ul><li>CS : EIP — sba执行完毕后显示的指令地址为</li></ul><img src="/2023/12/15/elephont_os/build_os_from_scratch/4f71f217b3c5a538dbb26fd4b6a67caf.png" class=""><p>符合✔️</p><ul><li>eflags — 还记得我们刚刚进入中断前查看的标志寄存器：</li></ul><img src="/2023/12/15/elephont_os/build_os_from_scratch/3a4f0e4c48d6af0e68bdcde460cf4438.png" class=""><p>符合✔️</p><ul><li>SS_old : ESP_old —  对比栈中相应的值和进入中断前的ss和esp的值，发现对不上，我想不应该啊，咋回事呢？原来在我们的实现中发生中断时，CPU是从内核的main函数跳转到中断程序去执行，属于特权级的平级转移，CPU会把这种转移当作普通的直接远转移（即使CS前后一致，还是会压入在栈中CS），因此不会有栈的切换，也就没有在栈中压入ESP_old和SS_old</li></ul><h2 id="74-让时钟中断来的更加猛烈些吧"><a class="markdownIt-Anchor" href="#74-让时钟中断来的更加猛烈些吧"></a> 7.4. 让时钟中断来的更加猛烈些吧</h2><p>这一节通过设置可编程计时器Intel 8253完成了对时钟信号产生频率的提速<br />运行结果：<br />感觉不出来有什么提速，毕竟窗口就这么个大小，奇怪的是这里额外还触发了CPU内部的0xD号中断（General protection fault）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b27febf27caf090175448db7b09a1278.png" class=""><h1 id="8-让位图大放光彩实现内存管理"><a class="markdownIt-Anchor" href="#8-让位图大放光彩实现内存管理"></a> 8. 让位图大放光彩，实现内存管理</h1><h2 id="81-磨刀不误砍柴工学习makefile-实现assert断言和字符串操作函数"><a class="markdownIt-Anchor" href="#81-磨刀不误砍柴工学习makefile-实现assert断言和字符串操作函数"></a> 8.1. 磨刀不误砍柴工—学习makefile, 实现assert断言和字符串操作函数</h2><p>这一节讲解makefile的部分让我收益颇深，之前学cmake的时候，make和makefile对我来说就是个黑盒子，不知道里面具体是什么东西，只会拿来就用。现在要开始自己手写makefile了之后，也算是看见了makefile的真面目了。在我看来，makefile归根到底还是个脚本文件嘛。</p><p>为了后续方便调试程序，这里要求自己实现一个给内核用的ASSERT断言，其中用到的宏函数的可变参数我倒是第一次用，看样子C语言还有很多东西我不知道呢。这里提一嘴makefile的内容，书上要求给gcc指定选项<code>-Wstrict-prototypes</code>和<code>-Wmissing-prototypes</code>，目的是要求项目中的函数都有函数声明并且函数声明中必须带有参数类型，这意味着没有参数的函数也要加上一个void类型说明, 我没这个习惯，而且参照linux内核的代码风格上也没要求这两点，于是这2个选项我是去掉了的。</p><p>用刚刚学到的make—gcc—ld工具链生成程序，目标文件和内核文件kernel.bin确实都正确生成在了build目录中，但是我遇到的问题是伪目标hd对应的dd命令看起来是正确执行了，但是实际上bochs下的hd60M.img并没有更新，必须在终端手动执行dd命令才会更新🥲，搜索了一顿没找出原因，暂时还不清楚为什么。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d42302c5d9fee2dd10f457f413e7e232.png" class=""><p>btw，用gpt4给这些功能用途明显的函数生成注释真的很方便，这工具真的极大的减少了我在google搜索的时间，虽然有时候确实会牛头不对马嘴，但是大部分时间还是很可靠呢。有些问题这玩意不能解决的时候，我就只有在google上 do english searching了，找找stackoverflow上的回答或者官方文档什么的</p><h2 id="82-管理内存的工具位图bitmap的实现"><a class="markdownIt-Anchor" href="#82-管理内存的工具位图bitmap的实现"></a> 8.2. 管理内存的工具—位图bitmap的实现</h2><p>刚哥人是真好啊，不像教科书那般给你生涩的下一个位图的定义，而是给你扯了一页的内容告诉你怎么理解这玩意，中国大学的教材但凡能有点这种风格，也不至于那么误人子弟😅。</p><p>实现方式上没什么可说的，书上都有，倒是bitmap_scan方法上我自己尝试写了一下，但是博主我怕后续这里出问题，还是按照书上的内容实现了。</p><h2 id="83-开始砍柴了实现内存管理系统"><a class="markdownIt-Anchor" href="#83-开始砍柴了实现内存管理系统"></a> 8.3. 开始砍柴了！实现内存管理系统</h2><h3 id="831-饭要一口一口吃先初始化内存池"><a class="markdownIt-Anchor" href="#831-饭要一口一口吃先初始化内存池"></a> 8.3.1. 饭要一口一口吃，先初始化内存池</h3><p>内存管理系统要管理2块，一个是用户的，一个是内核的，这两者不能相互干涉，毕竟特权级都不一样。在这一小节中，建立数据结构内存池以规划内存，把物理内存分成了2部分，内核和用户各一半，作为各自的内存池，各用各的。同时建立好内核物理内存池和用户物理内存池，分别管理内核和用户的物理内存分配请求。内存池的结构用到了上一节定义的位图，这是内存池管理内存的关键。</p><p>此外，不仅需要物理内存池，还需要虚拟内存池。<br />为什么需要虚拟内存池，我还是简单总结一下，系统运行在分页机制下，不管是内核还是用户程序都是用的虚拟地址。当它们需要申请内存的时候，内存管理系统先是从他们各自的虚拟内存池中分配出一块空闲的虚拟地址，然后再转去物理内存池找到块空闲的物理内存来完成映射，此外还有别的好处，遇到了再提。</p><p>在初始化内存池的过程中我是遇到了点小问题的，在这里记录一下，那就是系统运行之后，一直触发0xE号中断，也就是缺页中断，因为之前把这些中断的处理程序都指定为了一个简单的打印中断号的程序，所以运行后的屏幕全是0xE：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/406577233e43f6acdd8584a1a2e9f15e.png" class=""><p>我在mem_pool_init中加了几次while(1)之后，发现用于管理内核的可用内存的位图的存放位置MEM_BITMAP_BASE少打了个0，本该是<code>0xc009a000</code>，而我写成了<code>0xc009a00</code>，而这个虚拟地址所在的虚拟页面是没有映射到物理页框的（目前只映射了虚拟内存的0~4MB和3G～3G+4B，这是在开启页表机制的时候完成的），当CPU访问这个地址的时候（执行bitmap_init函数的时候），必然要触发缺页中断啦，而我们的临时的中断处理程序又不能解决这个问题，所以只能一直不断被触发啦。</p><p>解决掉这个问题之后，运行程序，结果如下：<br />可用物理内存的起始位置kernel_pool_phy_start是0x200000, 这个值是除去了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0</mn><mo>→</mo><mn>0</mn><mi>x</mi><mn>1</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x0\to0x1fffff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>这2MB的已用内存的结果，这2MB中的低1MB拿来放BIOS和内核，另外1MB用来放PDT和PTs</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/c5f699919d7ff020a6871e85b72bb3ba.png" class=""><p>再多说一句，因为是在编写操作系统内核嘛，所以C语言的系统库肯定是用不了了，而定义在系统库里的关键字bool, NULL, true, false又得在内核程序中用到，所以得在一个头文件中自己定义这些关键字，我选的global.h：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/972c2df56b58e7b111cdc032a97dac9d.png" class=""><p>不知道有没有人跟我有一样的问题，这个问题也有点傻傻的，那就是为什么可以用int, unsigned这些关键词呢？答案是：关键字如 if, else, int, double, unsigned 等是 C 语言的一部分，它们是由编译器（如 GCC）本身直接提供和识别的，而不依赖于任何外部库。这些基本的语言结构和类型是编程语言的核心组成部分，编译器在解析和编译代码时直接处理这些元素。因此，即使在不包含标准库的情况下（如在裸机或内核编程环境中），这些基本关键字依然可用。我之所以有这样的问题，还是对编译器不够了解，哪天一定得看看编译原理这本书呢</p><h3 id="832-路要一步一步走先支持分配页大小的内存"><a class="markdownIt-Anchor" href="#832-路要一步一步走先支持分配页大小的内存"></a> 8.3.2. 路要一步一步走，先支持分配页大小的内存</h3><p>这一节先实现对页大小的内存的分配，对任意字节尺寸的内存分配在后续实现。</p><p>要实现这一点，需要对分页机制了解的比较透彻，我在这里还是简单总结一下。首先吧，现在地址对CPU来说都是虚拟地址了，操作系统总不能直接把物理页拿给进程吧，它也用不了，因为cpu看到的都是虚拟地址，此时已经开启分页机制了，如果进程用物理地址，那cpu也会用页表机制给它一顿转换，变成另外一个物理地址。那么对进程中提出的页分配请求呢，操作系统首先得分配给进程虚拟页，这样一进程才晓得能用的地址是什么，但是这个地址是否真正有效呢？还取决于这虚拟页到底是否跟物理页对上了，进程总不能拿着个虚无的虚拟页往里面倒腾数据吧，如果确实存在它的本体—物理页，那这个虚拟页就可以被进程拿去用，于是乎，操作系统要完成的关键2步已经显现出来了： <strong>1. 分配虚拟页 ，2. 分配物理页。</strong> 别急别急，还有第3步，别忘了我们现在是在分页机制下呢，所以还得 <strong>3. 建立PDE和PT以完成虚拟页和物理页的映射</strong>。</p><p>这一节的难点就是下面这2个函数：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2c2a29d6a00aec1da9b24c9657d5fb2b.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/67781f0bc6b5ffe50bdce18826570965.png" class=""><p>这2个函数都接受一个虚拟地址vaddr，并返回一个新的虚拟地址new_addr, 这个new_addr可不是一个普通的虚拟地址了，经过分页机制下的CPU的一顿转换 (其实就3个)，new_addr最终能变成vaddr对应的页目录项PDE/页表项PTE的物理地址。这部分得把分页机制玩的明明白白的才能彻底理解呢，简单说一下核心思想就是利用虚拟地址的高10位是虚拟地址对应的pde在页目录表的索引，中间十位是pte在页表中的索引，靠着CPU对虚拟地址的3步转换，凑出一个目标虚拟地址。书上P.391~P.393刚哥已经说的很清楚了，这里就不在赘述，</p><p>还有一点就是用bitmap_scan函数查找位图以确定可用的页面数量时，对物理页来说，一次查找一个，如果需要多个物理页，那么就循环的调用bitmap_scan; 对虚拟页，调用一次bitmao_scan分配多个虚拟页就行。原因是<strong>虚拟页是连续的，而物理页不是</strong>，物理页是可以分散在内存中的，这也是页表机制能提供内存利用效率的原因，如果我们在向物理页申请物理页时要求连续，即给bitmap_scan的pg_cnt参数传递大于1的值，那么分页机制的意义不就没了吗。</p><p>在第5章，我们把虚拟地址0x00000000~0x000fffff 和虚拟地址 0xc0000000~0xc00fffff (即低位1MB和3GB~3GB+4MB) 映射到了物理地址 0x00000000~0x000fffff， 对内核来说呢，它存在与虚拟地址空间的高1GB（3GB～4GB）中，那么从0xc0100000开始的内核虚拟地址 (内核虚拟内存池的起点是0xc0100000)也要映射到0x00010000开始的物理地址吗 ？不行哦，在0x00010000开始的物理地址中，0x00100000~0x001fffff （共1MB）已经被拿来放最初的页目录表和页表了，咱们得保证这部分物理内存不能被占用，所以在实现中是把这部分物理内存归为了used_mem的，物理内存池管理的物理地址的起点在0x00200000。</p><p>下面来测试一下，在内核的main函数申请3个页面，运行结果如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/06d2d8e658e22c7b504e7245865cca53.png" class=""><p>嗯，很好，分配的虚拟页面的起始地址正好是虚拟物理池中第一个空闲虚拟页的地址，看样子我们的位图管理内存机制是正确运行了的。</p><p>再用看看页表，验证一下这3个虚拟页是不是虚无的，内核可不需要虚无的东西呢</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/3585cd850ec7ce607fb521140080c4b9.png" class=""><p>看样子这3个虚拟页已经成功映射到从0x200000开始的物理内存了,  不确定的话可以用page命令单独查看下这3个虚拟页的映射情况：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0a3d686af9cdb39431197d9f9d5c80d8.png" class=""><p>最后查看物理内存的位图，位图的起始虚拟地址被设置为0xc009a000, 因此用命令<code>x 0xc009a000</code>查看该虚拟地址处的内容即可查看位图</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/4e769d0d34573ec4a9d8d2782cefcef6.png" class=""><p>开头的2个字节内容是0x00000007, 即0x0111, 也就是说位图的低3位被置1了，表示3个物理页被分配出去了，符合预期。</p><h1 id="9-单线程进程的光荣进化多线程机制的建立"><a class="markdownIt-Anchor" href="#9-单线程进程的光荣进化多线程机制的建立"></a> 9. 单线程进程的光荣进化—多线程机制的建立</h1><p>这一节呢，先是花了不少的篇幅来说清楚进程和线程的关系，刚哥是真贴心啊。归根结底，进程=线程+资源，CPU执行的就是线程。如果你要说你压根不晓得线程啊，难道我写的hello world程序执行的时候也叫线程？那么我要说如果进程中没有创建线程，那么这个进程就视为单线程的进程。哈哈哈，所以说概念这种东西真没必要隔那咬文嚼字的，没啥意义，在我看来能自圆其说，又符合实现的方式即可。</p><p>说到这里，在讲述这一章内容之前，我想反思一下过去的学习方式。各位看官不感兴趣的可以移步到下一个段落哈。过去的我呢，其实也没有多旧，就在我看这本书之前吧，我看书总习惯写点什么，比如我看程序员的自我修养这本书的时候，硬是闲的蛋疼的非要把每一章讲的知识点总结下来，好像不用自己的话说一遍就不爽似的，现在我觉得这样的做法极其的浪费时间，而且效益也不好。我为什么会有这样的思想改观呢？因为我有一天意识到，我又不是要出书，我干嘛要费心思把这些东西重新写一遍，我理解力又没那么差，而且这种行为真的无异于中学时代靠记笔记安慰自己的做法，真的没意义。从另一个角度出发，作为一个初学者，刚学习完某一章，你又能写出个什么东西呢？表达上绝对是有失偏颇的。不得不说，这样的学习方式，是我上大学以来学什么东西都很慢，学什么东西效果都不好，学完了还没有任何成品的根本原因。 现在我认为学某个科目，某个领域，最好的做法就是快速过一遍知识点，千万别搁那咬文嚼字的，看懂个七七八八就行了，然后立马实践，实践才能让你真正记住知识，自己折腾过的过程，绝对比那枯燥的文字更能在你脑中留下印象，最后实践完了，既能收获个成品，并且还可以带着实践的经验重新审视这些知识，总结出一些领悟和心得，这样的领域和心得才是唯一有价值记下来的。这里贴一个<a href="https://kuizuo.cn/blog/why-i-dont-write-notes">博客链接</a>，讨论的就是学计算机科学是否要记笔记，我认为博主说的就很好，还留下了评论。这部分就写到这。</p><hr /><p>这一节算是比较有难度的了，整体我都来来回回看了很多遍才开始实现。其实本章围绕的一个核心问题就是：执行中的线程cur_thread遇到时钟中断(陷入内核)，并在时钟中断中发现该线程时间片到期了（即<code>cur_thread.ticks==0</code>），那么该线程就要被内核中的调度器schedule函数和切换器switch_to换下，并让CPU执行新的线程。要怎么保证线程还能恢复！ 是的，我认为最关键的问题就是，怎么让线程恢复执行。这主要依靠一个switch_to中的ret指令和中断入口程序(kernel.S)中的一个iret指令，操作系统要组织好栈使得这2个指令的运行后能够恢复线程。</p><p>简单用drawio（btw：向开源软件的作者们respect🫡）画了个草图以描述PCB/TCB的结构 ，其中intr_stack栈用来存储中断时任务的上下文，thread_stack原来存储在中断处理程序中任务切换时 (switch_to)的上下文。（ ps: 看到11章的时候发现关于这部分P.509有更好的的图示）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d8d1812933c9234ec0f1015104fb63a0.png" class=""><p>PCB和TCB这里没有各自单独定义，而是统一定义成task_struct, 其中包含pgdir成员用以表示进程的页表信息，所以当task_struct表示线程的时候，pgdir是置为NULL值的。因为PCB/TCB是严格按照页大小分配的，所以PCB/TCB的起始地址一定是<code>0x*****000</code>的形式，即低12位一定为0，基于这一点我们就能通过esp的高20位获取当前的线程的PCB起始地址，这也是函数running_thread实现的逻辑</p><p>线程被切出去之后，线程栈的地址即esp, 被保存在PCB的self_kstack成员中，该成员位于PCB结构体的开头，即第一个成员，所以可以用PCB的起始地址 (即running_thread的返回值) 作为self_kstack的地址。</p><p>下面好好说道说道switch_to函数栈的ret指令：</p><p>在switch_to函数中，完成PCB的切换之后， 在函数末尾执行ret指令的时候，会把当前线程的内核栈(即<code>thread_stack</code>)的栈顶元素填入<code>eip</code> (见P.85 )。如果这个线程是首次执行，那么栈顶的值就是线程对应的函数<code>kernel_thread</code>。该函数实际上调用了我们在thread_state中传入的参数function。为什么它在栈顶？这是我们在thread_create函数中初始化内核栈时设计的：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b5595576fac960f74380cab8a914559c.png" class=""><p>于是cpu接着就开始执行这个函数，也就意味着CPU转到新的线程开始执行。如果线程不是首次执行，那么栈顶的值就是函数schedule (该函数调用的switch_to，当然它的返回地址就在栈顶) 的返回地址，ret指令之后回返回schedule，schedule再返回到时钟中断的处理函数intr_timer_handler (schedule的主调函数)，接着再从这个中断函数中退出，回到kernel.S的intr_exit (intr_time_handler的主调函数)，在Intr_exit中完全退出中断并完成线程的寄存器环境的恢复。（写完这部分才发现刚哥在P.434中说了同样的话，不过没事， 我自己分析出来也不错🧐）</p><p>别的就不多说了，这一章确实比较杂，如果不把代码整体拉出来分析，是看不出怎么实现的。我建议看到这章的看官，先快速过一遍，把代码组合起来，再跟着代码的逻辑看懂实现过程。</p><p>线程的创建部分的运行结果：<br />线程a创建并运行成功，此时还没实现调度机制，因此线程a不停的运行</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/146431a13cfb7bc958a497f5f97d379f.png" class=""><p>任务调度机制部分的运行结果：<br />我给主线程main，线程a和线程b的优先级分别设置的是：36, 32 , 4，即9:8:1。 下面的显示的比例也差不多是这个值, 打印的值有空格且有的值不完整，这是因为线程的put_str还没执行完就被调度，以及多个线程在没有锁的情况下访问公共资源—光标寄存器导致的，下一章将解决这个问题</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/f74015c5c6a6a7828ec92007c0d08e75.png" class=""><p>这里我遇到了一件奇怪的事情，就是如果我把main的优先级改为32，即跟线程a一样的值的时候，运行结果会变成下面这个样子</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/c7db0be8fbb84309e080bb7371649c5b.png" class=""><p>目前不是很清楚为什么打印的语句变少了，GP中断似乎也没有被提前触发了，下一章锁机制学完了再回来看看。</p><p>把主线程main和线程a的priority换成跟书上一样的31, 输出就符合了</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/a9d0f836b71138dd21bbdb15ca69baa6.png" class=""><p>运行结果的顶部显示的一般保护性中断是由于显存段内的偏移量bx超出了段界限，验证如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/1cd219d8be6f8a3be901634d1c54a2d7.png" class=""><h1 id="10-让终端不再静态建立输入输出系统"><a class="markdownIt-Anchor" href="#10-让终端不再静态建立输入输出系统"></a> 10. 让终端不再静态，建立输入输出系统</h1><h2 id="101-引入锁机制修复破碎的终端"><a class="markdownIt-Anchor" href="#101-引入锁机制修复破碎的终端"></a> 10.1. 引入锁机制，修复破碎的终端</h2><p>上一节中破碎的终端主要源自于多个线程对公共资源—显卡和光标寄存器的访问冲突了，解决这个问题的办法就是给终端上锁，上锁啥意思？就是一个线程进入临界区的时候，意味着它要访问某个公共资源了，它把门锁上，其他线程看见门锁了，就把自发的把状态转为blocked并加入等待队列waiter中。等进去的线程出来的时候，就会把锁打开，其他线程（在等待队列writer中的线程）就可以进去了。</p><p>信号量和锁是什么联系？我觉得吧，信号量拿来就是实现锁的。在我们的实现中，锁是封装了信号量的，锁的结构体中除了信号量，还有表示锁的当前持有者的信息holder。所以锁是包含信号量的，锁机制的实现是靠信号量实现的。</p><p>当我们把终端视为一个公共资源console的时候，把对它的操作都用锁机制限制起来，即每个线程要操作终端的时候都得看看通往终端的大门上有没有上锁，如果有锁，就说明正有线程在里面挥斥方遒呢，得自个先在门口（等待队列writer）等着。</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/aa27a8f140e41f6f08ab9a75b2a42046.png" class=""><h2 id="102-让字符处理函数支配键盘输入"><a class="markdownIt-Anchor" href="#102-让字符处理函数支配键盘输入"></a> 10.2. 让字符处理函数支配键盘输入</h2><p>这一节完成外部设备—键盘的中断处理函数，即标题中的字符处理函数，键盘把用户按下的按键的通码和断码传递到键盘控制器（8024芯片）的寄存器中，然后处理器去读取这个字符，怎么处理这个字符完全取决于字符处理函数的具体实现。</p><p>对所有按键都只是简单的打印k：<br />按下单个字符打印2个k，因为按下和弹起分别发送了通码和断码</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/200b03a18a9170a24f696ee903a05a13.png" class=""><p>按下右alt打印4个k,因为键盘控制器的寄存器是8位寄存器，处理器一次只能读取一个字节，而右alt的通码和断码分别是2个字节</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/217366aba0bf4c3458f0dcc832163850.png" class=""><p>打印字符的字符编码：<br />按下字符k, 打印了<code>25A5</code>, 这与字符k对应的通码和断码相符合。 这里为什么是A而不是小写a呢，因为在put_int的实现中，十六进制中出现的A～F用的是大写</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/a8392d8137bfa199628a2bf9edcc1fcc.png" class=""><h2 id="103-更完善的字符处理函数键盘驱动程序"><a class="markdownIt-Anchor" href="#103-更完善的字符处理函数键盘驱动程序"></a> 10.3. 更完善的字符处理函数—键盘驱动程序</h2><p>这一节我们要实现所见即所得的键盘输入了，难点在于处理shift, alt, ctrl， caps-lock等控制字符，当按下这些控制字符的时候，按键对应的ascii码是不一样的，比如<code>1</code>会变成<code>！</code>， <code>a</code>会变成<code>A</code></p><p>因为键盘驱动程序从键盘控制器的8位寄存器中读取的是按键的编码 （通码/编码），要想用put_char打印字符，得先把这个字符编码转换为ASCII码，做法是把通码当作二维数组keymap的索引，keymap中的每一个元素都是一个表示按键本身的ASCII值和shift之后该按键对应的ASCII值的一维数组。</p><p>难点在于如何处理shift和cap_locks之间的关系，这里采取的做法是统一用一个bool变量shift来表示接下来的按键是采用一维数组中的第0个元素还是第1个元素，控制按键shift和cap_locks对驱动程序的影响就体现在这个shift变量上，比如当这2个控制按键都按下去的时候，两者效果抵消，此时置布尔变量shift为0，打印第0个元素。</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/bc251dacd4e0f46751269474e736dff4.png" class=""><h2 id="104-管理输入的字符建立环形输入缓冲区"><a class="markdownIt-Anchor" href="#104-管理输入的字符建立环形输入缓冲区"></a> 10.4. 管理输入的字符—建立环形输入缓冲区</h2><p>之前我们键入的字符是直接用put_char写入显卡去了，现在我们要保留键入的信息到一个暂存地，并让其他线程来读取这个数据，这样我们就能通过键盘和线程交流交互啦。</p><p>这一节涉及到了一个经典的消费者和生产者的问题，要注意的一点是线程进入阻塞的那个条件判断语句，得用while语句而不是if语句，这和之前实现信号量机制的sema_down思想一致，就是让线程被唤醒之后，立马再次进入条件判断，原因很简单，就是线程被唤醒之后，并不是立马就调度到它执行的，可能在它之前，它所要求的资源又被其他线程给拿走了，哈哈哈，可怜的线程，因此这个被唤醒的线程不能想当然的就以为自己被唤醒了那么资源就一定在那，得再判断一句才是🥳。</p><p>既然是环形缓冲区，怎么判断它是空的还是满的呢？ 首先，缓冲区为空的时候，也就是ioq_init刚执行完的时候，此时head和tail都指向第一个位置，所以似乎判断<code>head==tail</code>就可以知道是不是空的。但是！如果我们塞满缓冲区，此时head回绕加1之后指向下一个可写入的位置，那它将不得不跟tail一样指向第一个元素，也就是说head和tail此时也满足<code>head==tail</code>的关系，在这种情况下，我们将不能简单的通过<code>head==tail</code>来判断缓冲区是满的还是空的，这跟我之前学数据结构实现环形链表遇见的问题一样。 因此，我们妥协一下，在缓冲区中留出最后一个位置，这样当head指向tail的前一个元素的时候(即<code>return next_pos(ioq-&gt;head) == ioq-&gt;tail</code>)，就认为缓冲区满了，不再写入了</p><p>只有生成者的运行结果：<br />缓冲区大小为63, 写满之后在调用消费者之前生成着将无法继续写入，所以屏幕上最多显示63个字符，之后无论怎么按都不会再输出字符：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/369422ae8648f0bf48775273e6fed198.png" class=""><p>添加了2个线程（a和b）作为消费者读取环形缓冲区中的数据，运行结果：<br />初始时缓冲区为空，按住k键往环形缓冲区中写入字符k，消费者a和b轮流从中读取出字符k并打印，因为在函数<code>ioq_getchar</code> (消费者取出数据)和函数<code>ioq_putchar</code>（生产者写入数据）的实现中，确保了是在关中断的进行的原子操作，因此不会造成多个线程对缓冲区的访问冲突。不仅如此，在添加数据和取出数据时用了<code>ioq_is_full</code>和<code>ioq_is_empty</code>作为前提条件，避免了对缓冲区的越界访问</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/19506d2c0b7fb06073ee3f19b04f46bb.png" class=""><h1 id="11-task的另一块拼图用户进程的实现"><a class="markdownIt-Anchor" href="#11-task的另一块拼图用户进程的实现"></a> 11. task的另一块拼图—用户进程的实现</h1><h2 id="111-不得不用的tss"><a class="markdownIt-Anchor" href="#111-不得不用的tss"></a> 11.1. 不得不用的TSS</h2><p>刚哥已经反复强调过，一个完整的进程(即一个任务task)，不仅包括我们自己编写的用户应用程序，还包括底层的操作系统内核，P.197的图5-18就很好的阐述了这个事实。因此我们的用户进程运行期间只要涉及到操作系统提供的服务，那么它就得进入内核。一如你需要洗车店的服务你就得进入洗车店一样。然后呢，因为内核态程序的栈与用户态程序的栈不一样，所以CPU在用户陷入内核的时候就得把ss:esp切换，使其指向内核态下的栈。这个内核栈的地址在哪呢？就在任务的tss中。</p><p>为什么我取得标题是不得不用呢？因为linux是不太想用tss的，因为用这玩意实现任务切换很慢，但cpu获取内核栈这个过程还是得依靠tss, 所以我们还是得让操作系统初始化好tss，具体是指初始化好tss中的esp0和ss0字段。所有任务共享这一个tss, 切换任务时得更新这个tss中的esp0和ss0</p><p>这节多少有点繁琐，得照着P.151的GDT描述符格式，几乎是一个bit一个bit的写好描述符的属性🙃。</p><p>运行结果：</p><p>查看gdt表，已经成功建立好了tss段，用户代码段和用户数据段</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/fa537a202ff1950e8cbf9442f660b790.png" class=""><h2 id="112-特权级为3的用户进程"><a class="markdownIt-Anchor" href="#112-特权级为3的用户进程"></a> 11.2. 特权级为3的用户进程</h2><p>这一节花了我不少时间来完成，准确的来说是耽搁了不少时间。因为最近我的状态有些不好，前几天整夜整夜的睡不着，好像是有入睡障碍一样，主要原因还是自己多少有些焦虑，没学的东西还有点多，等着把这OS搓完了，就去把<code>C++</code>拾起来，做个<code>C++</code>的项目。这几天换了个记忆棉的人体工学枕头，稍微缓解了一下失眠。</p><hr /><p>用户进程的实现分为创建用户进程和执行用户进程，第一个核心问题是如何从当前正在运行的OS内核主进程跳转到用户进程执行。这是高特权级向低特权级的转移，要实现这种转移，只有一种办法，那就是通过中断返回，再具体点就是iret指令。我们要把用户进程的入口（具体实现中为start_process函数）作为中断程序的返回地址，就能实现这种转移。第二个核心问题就是，用户进程自己得有一套页表，从而实现进程间虚拟地址空间的分隔，还要有一套位图，这样它才能管理自己的内存。此外，实现用户进程还得给用户进程创建一个特权级为3的栈空间（栈底为0xc0000000），拿给用户态下执行的函数用。第三个核心问题就是如何让用户进程之间共享操作系统内核，做法是把操作系统内核所在的地址空间，映射到用户地址空间的高1GB中，相当于在用户进程中创建了一个通向内核的入口。</p><p>这一节踩了坑，花了5,6个的时间来debug，首先第一个错误是在内核的main函数中执行process_execute之后，会出现pagefault，通过之前设置的中断处理函数打印的提示信息，发现cr2寄存器中保存的触发pagefault的虚拟地址是0xf000ff57。我想不应该啊，怎么会访问到内核的这个高地址去。通过在main函数和prcess_execute中添加while(1)语句，发现process_execute能够完整的执行，但是却无法正确返回到main函数。找了很久都没找出原因， 最后对着代码一行一行的看，才发现在process_execute中把进程加入到all_list队列中的时候，加入的是进程的general_tag而不是all_tag，这会导致就绪队列中已经加入的general_tag被破坏，从而破坏了整个就绪队列。至于为什么这个错误会导致无法正确返回到main函数，还不是太清楚。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/8053df9fa2200a6e1c83cb50949e5591.png" class=""><p>第二个错误发生在第一个错误修复之后，进程切换到第一个用户进程u_prog_a的时候，无法再切换到别的进程，导致内核主进程中的打印线程kthread_a和kthread_b无法执行，从下图可以看出，目标内存的变量的值已经被进程u_prog_a不断的增1了，但是屏幕没有反应，而且进程b对应的变量一直为0,也就是进程b完全没有得到执行。如下图：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e145ebf8aa190cfe1c9660bd40ce957c.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/e4ce92dc8f9c265eab7cdfe0cc6f2150.png" class=""><p>我也是调试了很久，把用户进程的建立和执行翻了个底朝天，甚至还跑去复查了第一遍第8章写的线程切换的相关代码。这样下来之后我意识到，我的时钟中断跑哪去了？要是有时钟中断，并且正确执行了的话，进程a没道理会一直占据CPU。于是我用nm命令查看了内核elf文件的符号表，获取到符号u_prog_a的虚拟地址，</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2606ffbdb245cc3f169d505c855abce3.png" class=""><p>在bochs中设置此虚拟地址的断点，然后用<code>show extint</code>命令开启bochs对外部中断的提示，惊奇的发现我的时钟中断居然没了！毛提示信息也没有。于是乎，我又去复查了一边时钟中断的相关代码，没发现什么问题。那么时钟中断消失的原因只有一个，那就没能成功开启中断，即eflags的IF位没有被置1，我在bochs中一看，IF位果然为0！</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/afaf892391da95cc1ddf72d93356f2af.png" class=""><p>我猜测这可能是intr_enable或intr_disable等调用没做好，于是去查了一下这些函数调用，没发现问题。最后我发现在start_process中初始化用户进程上下文中的eflags时，把或运算写成了与运算，导致eflags的IF位为0，所以才会有切换到用户进程的时候，标志寄存器从用户的上下文中恢复时，其IF位被置0</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/64220d92297c5bc534ddb34f150c21e8.png" class=""><p>上面的坑，都是自己写代码的时候没能好好理清楚实现的逻辑进而自己想当然的写出来而造成的错误 。博主我是不爱直接对着书抄的，基本上都是理解完代码和机制之后才开始动手写，所以有时候会加入一些自己的想法而没去认真看书上的代码。踩这样的坑固然是有些“耽搁”的，但是不踩这样的坑，不犯这样的&quot;笨&quot;错误，我也不会去好好的把这几个文件翻来覆去的看，把机制彻底搞懂，也算是一个加深体会的过程吧。</p><p>运行结果：<br />内核线程kthread_a和内核线程kthread_b不断的打印被用户进程递增的2个变量。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/dd36fbb3d0ebff89059a1c7bec359c2d.png" class=""><p>当调度到用户进程执行时，查看此时的选择子cs：<br />cs的值此时是<code>0x002b</code>,即<code>0000_0010_1011</code>，低2位为rpl位，表示的特权级为3，这说明当前确实执行在3特权级下。高13位表示GDT中的索引，值为5 (00101)，正好索引到GDT中的用户代码段描述符</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0ec1fd2d1b9359a188a832cb51deb3d0.png" class=""><h1 id="12-进一步完善我的内核"><a class="markdownIt-Anchor" href="#12-进一步完善我的内核"></a> 12. 进一步完善我的内核</h1><h2 id="121-用户进程找操作系统办事系统调用的实现"><a class="markdownIt-Anchor" href="#121-用户进程找操作系统办事系统调用的实现"></a> 12.1. 用户进程找操作系统办事—系统调用的实现</h2><p>用户进程找操作系统办事，那么执行流程就得转到内核态的操作系统执行，这样操作系统才能办事。这样陷入内核的方式就是类型为软中断的指令—int+8位立即数， 更具体点就是<code>int 0x80</code>指令。</p><p>我们提供给用户进程一个能让它陷入内核态的接口<code>_syscall</code>，这个syscall中封装了<code>int 0x80</code>指令。既然是软中断，我们得有相应的中断处理程序，所以咱们得为中断向量号0x80写一个对应的中断处理程序。这个处理程序做些什么呢？那就是把eax中保存的NUMBER，也就是子功能号当作索引，遍历一个系统调用处理程序的数组，叫做syscall_table，找到相应的系统调用处理函数sys_xxx，然后跳转到这个函数执行，这个时候操作系统才开始真正为用户办事了。</p><p>值得注意的一点是，为0x80号中断写好中断处理程序后， 还要在中断向量表中注册这个程序，也就是说添加描述符，这里的描述符的权限是用户级别的，也是说对应的中断处理程序的特权级为3， CPU在执行 int 指令时会检查当前特权级别（CPL）是否满足中断描述符的 DPL 要求，这样用户进程就可以通过 <code>int 0x80</code> 发起系统调用，而不需要具备执行内核代码的权限。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b4cf68dbff4eb497a4eb19a16b457670.png" class=""><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b3d74a86b6abaeb8c38467ccf997bfad.png" class=""><h2 id="122-让用户进程说话实现printf函数"><a class="markdownIt-Anchor" href="#122-让用户进程说话实现printf函数"></a> 12.2. 让用户进程说话—实现printf函数</h2><p>有人看到这个标题可能会问，为啥还要实现printf函数？这不是C语言自带的吗？其实这个问题的答案跟我之前不理解还要另外自己定义bool类型一样，因为这些函数和类型是在C语言库里面的，而操作系统本身肯定是没法借助C语言库—外部库的，毕竟操作系统就是硬件之上的一层。而且从另一个角度看，C语言系统库不就是封装了操作系统接口的，便于用户调用的共享库嘛，比如C语言库里面的printf封装了操作系统提供的系统调用write，而我现在就是在搓操作系统，自然用不了封装了操作系统接口的C语言库</p><p>总之，我们的操作系统不能借助C语言库这种外部库，一切行为都得自己实现。</p><p>这一节值得额外讲讲的是那3个宏的实现，也就是下面这三个宏：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d1d58731f891bf2e41a9cbf967d294c5.png" class=""><p>这3个宏实现了函数的可变参数机制，具体来说，函数中就是通过这3个宏函数来操作可变参数列表的。</p><p>va_list是类型<code>char*</code>的别名，而v在printf中传入的实参是format。format本身是一个类型为<code>char*</code>的指针，所以va_start就是让二级指针ap指向由v表示的一级指针format。因为按照C语言函数调用规定，参数是从右到左依次压入函数的栈中的，因此此时ap指向的就是位于刚好返回地址之上的format参数。而va_arg函数把ap向上移动4个字节，4个字节就32位计算机栈中一项的大小，因此va_arg就是让ap指向下一个栈中的参数，这个参数一定是可变参数列表中的参数。</p><p>刚哥在书上说va_start指向的是可变参数的第一个参数，我认为这个说法不太对，format是最后一个固定参数，如果要让va_start指向第一个可变参数，那么它应该是这样做才对：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">va_start</span><span class="token expression"><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> v<span class="token punctuation">)</span> ap <span class="token operator">=</span> <span class="token punctuation">(</span>va_list<span class="token punctuation">)</span><span class="token operator">&amp;</span>v<span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果这样做，那么后续获取可变参数的时候，就先返回值，再递增ap指针，也就是要改变va_arg的实现了。</p><p>我们这里的va_arg是先递增ap,再返回值，因此也可以正确的获得可变参数列表中的值。</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d5fc8efbff3b9030dda23b483d5e5a78.png" class=""><h2 id="123-完善堆内存管理"><a class="markdownIt-Anchor" href="#123-完善堆内存管理"></a> 12.3. 完善堆内存管理</h2><h3 id="1231-更细粒度的内存分配"><a class="markdownIt-Anchor" href="#1231-更细粒度的内存分配"></a> 12.3.1. 更细粒度的内存分配</h3><p>之前在第8章实现内存管理的时候，我们只是简单的以页作为分配单位，这一节要实现更细粒度的内存分配，实现malloc对应的系统调用处理函数sys_malloc。总共建立了7种大小内存块—16, 32, 64, 128, 256, 512, 1024。<br />P.548的图12-16已经把整个内存分配的数据结构讲的很清楚了。值得注意的一点就是，在实现sys_malloc时，用<code>struct arena*</code>类型声明的指针a接受了malloc_page的返回值，从本质上来说，a就是个存储了值为指针的普通变量，struct arena不过是告诉编译器，用<code>*a</code>取地址的时，取出<code>struct arena</code>大小的内容。所以用a来接受malloc_page返回的页的起始地址是没问题的。</p><p>这里采取的数据块分配策略是从低容量的内存块向上找，找到最接近目标大小的数据块进行分配，这玩意在教科书上应该叫最佳适配算法吧🧐？</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/866fd15807bf8f27f77a7d60f4f92ca1.png" class=""><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9e0aac0b35e8f9f107f4ab2f7602de98.png" class=""><h3 id="1232-用好老朋友位图实现内存的释放"><a class="markdownIt-Anchor" href="#1232-用好老朋友位图实现内存的释放"></a> 12.3.2. 用好老朋友位图，实现内存的释放</h3><p>无论是内存的分配还是释放，无非就是操作3个玩意，一是虚拟内存池的位图，二是物理内存池的位图，三是页表。要分配内存，那么就在位图上找个为0的位，把它置1，并建立虚拟地址和物理地址的联系。要释放内存，那么就去把之前置1的位变成0，再修改页表就完事了。</p><p>测试sys_free的运行结果：<br />运行了挺长时间的（可能有一分钟），我还以为我的逻辑有问题，又跑回去过了一遍，没发现什么问题， 最后运行的结果也是正确的，在每次循环中进行了多次内存分配和释放，这本身就是一个相当大的操作量。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0e02d82e8bbe29470d52a141a4b23820.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/d8f81a7061da1b32ec2f3572d10f55f2.png" class=""><p>malloc和free的测试结果：<br />在sys_malloc和sys_free上建立2个系统调用接口而已，很快就写好了。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b1437d5d6e38abf210eb245f11e3c13b.png" class=""><h1 id="13-硬盘驱动程序"><a class="markdownIt-Anchor" href="#13-硬盘驱动程序"></a> 13. 硬盘驱动程序</h1><h2 id="131-给文件系统安个窝创建一个从盘"><a class="markdownIt-Anchor" href="#131-给文件系统安个窝创建一个从盘"></a> 13.1. 给文件系统安个窝，创建一个从盘</h2><img src="/2023/12/15/elephont_os/build_os_from_scratch/6f55b26498682f710d9494e04a5b3102.png" class=""><p>在配置文件bochsrc.disk中写入：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/3ba2c15e6d49de2da4dc37ee7b6aaaa5.png" class=""><p>启动bochs,查看此时的磁盘数量</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9c48056c56e7af02e3e49d0413e18850.png" class=""><p>用fdisk创建分区：</p><ol><li>设置柱面数和磁头数</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/126b3db764c44dd2365c4af0241e6a6c.png" class=""><ol start="2"><li>建立主分区，扩展分区，扩展分区中的逻辑分区<br />这部分的fdisk流程跟书上的不一样，估计是bochs版本的原因。书上是设置起始和终止的柱面数，而我这是设置起始和终止的扇区号(sector)，但本质上来说，就是在填充分区表中的描述符嘛，描述符指定了这些分区的起止界限，只不过单位从柱面变成扇区号了而已。在网上试着找了下前人关于这部分的内容，填了下面的值：</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/bc35c664767624d47dde6ab9e70a116a.png" class=""><p>用t命令设置分区id之后（设置了一个不存在于已知文件系统id集合的值，因此显示unknown。分区id表示文件系统类型，也就是说这些分区上的文件类型是未知的）：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/680e3da3eb0d8160856abfb243d182ff.png" class=""><ol start="3"><li>列出分区表</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/6f239d7586a739f212d6746dbb3e4db9.png" class=""><p>分区后的硬盘大小：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/96dd1f00829a8e8e53e20e70d9c62f00.png" class=""><p>强烈建议：把创建好的盘弄个备份，后续建立文件系统的时候会很需要有一块只划分了分区的磁盘来验证结果。</p><h2 id="132-磁盘与分区"><a class="markdownIt-Anchor" href="#132-磁盘与分区"></a> 13.2. 磁盘与分区</h2><p>硬盘分区是指将硬盘的存储空间分割成独立部分的过程。每个分区表现为一个独立的“区域”，可以单独进行格式化和管理。<strong>在操作系统眼中，每个分区都像是一个独立的硬盘</strong>。<br />主分区：最多可有 4 个。这些是最基本的分区类型，可以直接包含文件系统。<br />扩展分区：最多只能有 1 个，用于绕过 4 个主分区的限制。扩展分区本身不包含文件系统，而是包含多个逻辑分区。<br />逻辑分区：存在于扩展分区内，数量可以超过 4 个。它们在扩展分区的框架内表现得就像主分区。</p><p>网上找了张图，我觉得说的很清楚(PBR改名为OBR更合适)：</p><p>总扩展分区被拆为多个子扩展分区, 子扩展分区又被拆为EBR引导扇区+空闲扇区+逻辑分区, 逻辑分区中有包含OBR引导扇区,也就是操作系统引导记录, 也即操作系统内核加载器</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/8e3d2af656f1ac44a4151bd7d536eecc.png" class=""><h2 id="133-抽丝剥茧深入探究硬盘驱动程序"><a class="markdownIt-Anchor" href="#133-抽丝剥茧深入探究硬盘驱动程序"></a> 13.3. 抽丝剥茧，深入探究硬盘驱动程序</h2><p>这一节真的花了我接近一天来debug， 不过也还好， 正好借着我遇到的这个问题， 把硬盘驱动程序的实现细节理清楚了一遍。</p><p>我遇见的问题是，在identify_task函数获取第2块硬盘（即slave disk）的信息的时候，sema_down函数会抛出当前进程已在就绪队列中的错误。我加入了几条printk语句以获取更多信息</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/de6ddfff0c22e9f37c10c773dffdd451.png" class=""><p>运行结果如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/7bbcf77f609644a7ba19992d942e5e53.png" class=""><p>输出有些乱，各位看官也没必要看懂上面的输出，总之通过这几条printk语句的执行结果我可以得出的信息就是：第一次identify_task是完美执行的，在ide_init中第二次调用identify_task的时候，进入sema_down函数之前，信号量hd-&gt;which_channl-&gt;disk_done的等待队列是为空的，说明identify_task函数本身是没问题的，问题一定是出在了sema_down函数内部。</p><p>于是我开始排查sema_down，根据sema_down中的printk语句运行结果可知，第二次idenfify_task函数进入sema_down的时候，首次执行是成功的，也就是说，是成功调用了thread_block阻塞了当前进程的 (其实问题的根源就是在这里假阻塞了)。因为此时在内核初始化init_all过程中，所以还没有开启用户进程和其他线程，因此此时执行环境中只有一个内核main进程和能够让CPU挂起的idle线程。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ac5176371e5a4f47e98bb8b9b1c3ce21.png" class=""><p>于是我就开始对进程/线程的切换抽丝剥茧。一步一步的看，当main进程在sema_down中用thread_block函数阻塞自己之后，thread_block函数会把main进程的状态设置会TASK_BLOCKED，然后调用schedule函数</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/bf45eaf8d9877d8b39bd1a4ee9b3b237.png" class=""><p>在schedule函数中，存在这样一条语句：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/7a890cbd3bc49091ee19afdc7951988c.png" class=""><p>要理解这条语句，那么我要好好说道说道idle线程。这个线程的实现如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/119ef9306475386ce71dc756953d44d0.png" class=""><p>并且该线程在内核刚启动的时候就在thread_init函数中随着内核main主线程的建立而建立。因此在第一次调用identify_task，接着执行到schedule函数的时候，此时thread_ready_list并不为空，此时里面还有一个刚建立的idle线程，因此就pop出来执行。那么现在CPU就要执行idle线程了，该线程先阻塞调用thread_block阻塞自己，接着就又要调用schdule函数，因为内核中的main主线程是调用的thread_block主动阻塞的自己，所以main主线程此时不在thread_ready_list里面，因此上面的这个if语句（<code>if(list_empty(&amp;thread_ready_list))</code>）就成立了，此时就应该对idle线程执行thread_unblock。也就是说，首次执行idle线程的时候，它自己阻塞了自己，结果马上又回到自己了（注意我的论述的前提是，此时的执行环境下只有内核main主线程和idle线程），于是idle线程再次开始执行，halt CPU。既然hlt指令在遇到外部中断的时候会继续执行，那么当时钟中断来临的时候 (并且idle时间片到期)，又要切换idle线程了，但是！现在的thread_ready_list还是空，所以又调度到idle线程，接着就是thread_block <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> schedule<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>队列为空<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>调度回idle执行hlt指令，这样不断的循环，直到产生磁盘中断。</p><p>当然啦，上面所说的发生在只有内核main主线程和idle线程的情况下。此时可能有其他进程/线程存在吗？ 不可能，因为ide_init存在在init_all中被调用，这属于内核初始化的一个过程，因此不存在其他的进程/线程（进程就是线程+资源，既然我强调的是执行序列，以后就叫线程了，省的多打字）。idle老哥的存在，是为了让CPU大哥休息休息，好在内核初始化之后投入到多线程的战斗中。</p><p>说了这么久的idle线程，那么它和sema_down函数有什么关系呢？是这样的，当磁盘中断来临的时候，CPU从hlt中苏醒过来，开始执行磁盘中断处理程序intr_hd_handler，</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/00f0460e686b213fa5bf4a396d997ed4.png" class=""><p>这个中断处理程序会调用sema_up函数，并在这个函数中把main主线程重新加入就绪队列thread_ready_list中。那么在下一次从idle中调度出来的时候，CPU就可以重新回到identify_task中的sema_down函数中继续执行。sema_down被唤醒之后，因为存在while循环，于是又去判断信号量disk_done的值value是否为0, 因为disk_done.value已经在中断处理函数中+1了，所以该判断为false, sema_down执行信号量值递减操作后退出。所以说，磁盘驱动程序是被磁盘中断处理程序唤醒的。</p><p>既然正常的流程搞清楚了，是时候看看上面的程序错在哪了。从printk的输出可以看出，在第二次调用identify_task进入sema_down的时候，首次执行的没问题的，因为打印了<code>sema_down success</code>的语句，此时内核main主线程被block，等待中断处理程序唤醒它。按正常流程走，此时CPU应该切换到idle线程执行去了。</p><p>然后挂起CPU等待外部中断，具体来说是等待磁盘中断来唤醒main进程。</p><p>问题一定是出在上面这个“按正常流程走”部分，CPU指定是没这么走，才会导致在内核main主线程被唤醒之后，信号量的值0，继续进入while，等待队列里面居然还有内核main主线程，于是进入if语句中，从而触发PANIC。</p><p>于是我一行代码一行代码的审查，甚至还去把老早就实现的list.c文件重新检查了一遍。 最终发现在schedule中，不是要添加一个if语句在队列为空的时候唤醒idle线程吗？我想当然的就在后面加了个else 😩，导致我schedule函数可以说是毛也没干，只是把idle线程加入了就绪队列，也没执行list_pop切换到它。schedule函数执行完thread_unblock后直接返回，这sema_down压根就没让main睡着，更别谈唤醒了，更没有等到磁盘中断处理程序把信号量加1，就接着立马进入sema_down函数的while语句了，因为此时磁盘中断处理程序都没执行，所以信号量肯定还是为0，也没有sema_up操作把main主线程从disk_done的等待队列中取出。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/69d704dfbf4dad646c152f854100a2b6.png" class=""><p>修改之后，去掉用的printk语句，运行程序，结果如下：<br />分区表中的内容正好对应了用fdisk工具为从盘hd80M.img划分分区之后，用<code>fdisk -l hd80M.img</code>查看分区输出的信息</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/8a8efd8d404dd26511ab5ff1f60b659e.png" class=""><p>顺便提一句busy_wait函数，这个函数被多次用到，目的是就是判断此时磁盘到底是不是可以操作的状态，如果不是，那么就是调用thread_yield交出CPU。按道理来说，磁盘发出中断（其实是磁盘控制器发出的中断），就说明此时磁盘已经准备好了，没必要在加个busy_wait。所以这里的busy_wait更多的是一种保险措施，具体来说，在busy_wait中判断磁盘控制器中的寄存器的位是否是预期的，这样加上一层保险。只要磁盘本身没什么大毛病，busy_wait都不会进入else分支（已添加printk语句验证过了）</p><p>这一章费了我不少精力啊，我以为能很快搞完然后马上搞文件系统呢，没想到还是花了很多时间，大概有3天呢。主要原因还是本身对磁盘不了解，这一章开头讲磁盘和分区的时候，MBR, EBR, OBR把我旋晕了快。而且也没写过什么驱动程序，现在看来，这些硬件驱动程序，无非就是把硬盘抽象为一个一个数据结构，比如我们定义在ide.h中的结构体。然后把对I/O端口的操作封装为一个个函数就完事了。</p><p>写到这里，从10.31号开始有第一次git提交起算，XUN-OS已经用了一个月的时间了，具体来说是34天，现在还剩文件系统和终端的实现。我所做的一切，是我热爱的，是我觉得有成就感的事情。这些事情对于我的目标，对于明年的愿望，肯定也是有好处的，但是我不愿意想太多未来的事情，这会令当下处于特殊阶段的我倍感焦虑，我所能做的，就是向着正确的方向 (心之所向)，一个脚步一个脚步的走好，不在浮沙上建立高楼。总之，但行好事，莫问前程。</p><h1 id="14-创建文件系统"><a class="markdownIt-Anchor" href="#14-创建文件系统"></a> 14. 创建文件系统</h1><h2 id="141-站在磁盘驱动程序的肩膀上建立超级块inode-目录项"><a class="markdownIt-Anchor" href="#141-站在磁盘驱动程序的肩膀上建立超级块inode-目录项"></a> 14.1. 站在磁盘驱动程序的肩膀上，建立超级块，inode, 目录项</h2><p>这一节呢是在分区上创建文件系统，是个怎么回事呢？本质上就是在每个分区（主分区+扩展分区中的逻辑分区）中建立好超级块，空闲块位图，inode位图和inode数组这4样东西就行了。怎么个建立法呢？就是先在filesys_init中遍历这几个分区（1个主分区，5个逻辑分区），检查看看有没有这4个玩意。没有的话就调用partition_format给分区中加这4样东西。既然要加进去，那么就是把内存里面的东西放到磁盘里面，上一节定义的ide_write在这就能发挥作用了。因为这4样东西还是挺大的，毕竟个个至少都要占有一个扇区的大小，所以先在程序中定义并初始化好这4个东西肯定是不行的，栈直接给你溢出PCB了。因此用的是堆空间，而且只用了一个buf缓冲区，用强制类型转换让这个缓冲区分别存储super_block, inode bitmap, inode table和目录项，存一个写一个，写完换下一个 QvQ 。</p><p>运行结果如下：<br />跟分区的实际情况对得上，说明程序正确</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d0249bbfeb8c3127aea31d0dcf445159.png" class=""><p>再次运行：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ce9592913845dee9b062c7c7ae971431.png" class=""><h2 id="142-挂载分区"><a class="markdownIt-Anchor" href="#142-挂载分区"></a> 14.2. 挂载分区</h2><p>本质上就是把磁盘分区上的文件系统的信息（超级块，inode位图，空闲块位图）读入到内存中，这样我们的操作系统就可以通过这些信息使用这个分区中的数据块。这里又是一个ide_read大显身手的场合</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/3c0e1baed5fb6d9397c41fddfcde7a8f.png" class=""><p>我在moun_partition函数中额外加入了2条printk语句用来获取当前挂载的分区的数据区起始扇区地址，也即根目录的起始扇区。这样做的原因呢，是方便用刚哥给的xxd.sh脚本插件检查硬盘hd80M.img的内容是否符合预期。</p><p>上面的输出显示挂载的是主盘sdb1, 起始扇区为0xA67，换算为起始字节地址为<code>1363456</code>，用xxd查看该地址处起始512字节的内容：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/50928b0174bca57fbe4a73953ea1d8fc.png" class=""><p>咱们目录项的定义是下面这个样子，其中filename占16个字节，enum 类型的f_type可以理解为int类型，占4个字节，所以一个目录项的大小是24个字节。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5b5f9bb9820d1dc46d77600b88eba49a.png" class=""><p>因此，我们看起始字节地址开始的48个字节，如果表示页目录项<code>.</code>和<code>..</code>，那么就对了， 这2个目录是在函数partition_format中为根目录创建的。那我们来验证一下：因为我的CPU是小端序列，那么打印的前16字节的值为0x0000…02E, 代表了第一个目录项的file_name。字符<code>.</code>的ASCII是2E， 因此filename为<code>.</code>，紧接着的8个字节分别表示根目录的inode编号，为0，和文件类型，值为2，文件类型定义在fs.h中，如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/170404db5f8ff0a09c8cdd2f302f26be.png" class=""><p>因此2对应到文件类型—目录文件类型。后面的24个字节就不分析了，一样的道理。可见，咱们的程序的正确运行的了。</p><h2 id="143-打开和创建文件sys_open的实现"><a class="markdownIt-Anchor" href="#143-打开和创建文件sys_open的实现"></a> 14.3. 打开和创建文件，sys_open的实现</h2><p>这一节的内容相当的多，我建议是把14.3，14.4和14.5一口气看完再说，不然14.3的函数你就不是很清楚有什么用。</p><p>基于sys_open的实现所要求的东西，我来理一理这些函数的组织形式。</p><p>要实现文件打开指定路径 (pathname)下的文件，首先得先找到文件吧，于是就有了<code>file.c</code>中的<code>search_file</code>函数。这个函数是怎么做到搜索的呢？答案是在pathname中顶层目录所代表的目录项中寻找次顶层目录的目录项 (别忘啦，目录文件中数据内容是目录项)，找到了就更新顶层目录为次顶层目录。</p><p>举个例子，对于路径<code>/home/elite-zx/build-OS-from-scratch</code>，search_file函数先在根目录<code>/</code>下寻找文件名为home的目录项，哈哈哈，就是遍历目录项嘛，这正是<code>dir.c</code>中的函数<code>search_dir_entry</code>做的事情。在搜索过程中，既然要遍历当前顶层目录中目录项，咱们得把这顶层目录的数据块读入内存吧，嘿嘿，这就是<code>dir_open</code>做的事情，仔细想想，要读取一个文件的数据块，得先把这个文件的inode读进来吧，CPU得在inode中获取数据块的地址，于是就有了<code>inode_open</code>函数。要读入inode, 得知道inode在分区中的位置吧，咱们定义了一个结构体<code>inode_postion</code>来表示inode的位置，并通过调用inode_locate把inode位置信息填入到这个结构体中。所以光是打开对应的目录文件就有<code>dir_open</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><code>inode_open</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><code>inode_locate</code>这样的调用链。有打开就有关闭，不然把路径中每一层的目录文件都加载到内存，那也太多啦，于是就有了<code>dir_close</code>和<code>inode_close</code>。</p><p>sys_open可以在目标文件不存在的时候创建文件（仅限最后一个目录下不存在目标我文件，对中间目录不存在的情况不成立），所以咱们有一个创建文件的需求，这是由函数<code>file_create</code>做到的。创建文件，总的指定在哪个父目录下创建吧，于是file_create肯定有一个<code>parent_dir</code>参数。创建文件还需要什么呢？我想P.614的图14-16已经说的很清楚了。我们就按照这个图的指示来创建文件。</p><p>咱们创建文件的第一步是创建文件的inode, 这是每个文件必需的，由函数<code>inode_bitmap_alloc</code>和函数<code>inode_init</code>来完成。第二步是在父目录下创建一个目录项，不然CPU上哪找到我们的文件QVQ，这个需求是由函数<code>sync_dir_entry</code>和函数<code>create_dir_entry</code>来完成的。第三步是在全局文件表中创建一个目录，第4步是在进程内部的文件描述符表中创建一个目录，这2步的目的是让CPU能通过用户进程提供的文件描述符来找到对应的文件，分别由函数<code>get_free_slot_in_global_FT</code>和函数<code>pcb_fd_install</code>完成。</p><p>最后，咱们在内存中把从磁盘读取的分区数据修修改改的，必然得同步到磁盘，因此有了一堆磁盘同步的函数<code>inode_sync</code>, <code>bitmap_sync</code>。 函数的实现细节都在仓库的源码里啦，我注释写的还是蛮详细的。</p><p>首次运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/a10f9363ba70008eac801d318d0446dd.png" class=""><p>咱们在main函数中调用sys_open在根目录下创建了文件file1。查看挂载的主盘sdb1中的根目录的数据扇区内容，可见file1的目录项已经建立。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/493f2b6ff5dd9c019ae291bd969ca772.png" class=""><p>再次运行，显示文件已存在，符合预期🥳</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/6ca0d0d7a10104e3e1b20fae3f050de0.png" class=""><h2 id="144-关闭文件sys_close的实现"><a class="markdownIt-Anchor" href="#144-关闭文件sys_close的实现"></a> 14.4. 关闭文件，sys_close的实现</h2><p>关闭文件，就是把打开文件所建立的访问链条（即 fd<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> file table entry <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> inode）一一关闭。具体来说，sys_close函数收到主调函数传来的文件描述符fd， 然后调用fd_local_2_global函数把fd转为全局文件表的下标global_fd，通过global_fd咱们就可以得到文件对应的inode了，调用inode_close去掉这个inode，并把global_fd对应的文件表项的fd_inode指针置为NULL，这样才能使得函数get_free_slot_in_global_FT认为这个global_fd有效，可以重新拿来用。</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/54209d878d7bf28669a2cecf0a3859b1.png" class=""><h2 id="145-写入文件sys_write的实现"><a class="markdownIt-Anchor" href="#145-写入文件sys_write的实现"></a> 14.5. 写入文件，sys_write的实现</h2><p>这一节2百行的函数file_write可真长啊，不过逻辑还算清晰易懂的。因为咱们是需要时再分配磁盘上的数据块，而不是一股脑的就塞给每个文件一堆数据块，因此在写入文件时，得看看现在文件拥有的数据块够不够你写的，不够的话还得再分配点数据块给文件。分配数据块也不是个简单的事情，还得考虑是分配是直接数据块还是间接数据块，如果是后者，那么得把一级间接块索引表读进来。sys_write中的核心函数file_write的大致思路就是先把可写入的数据块给确定了，放在<code>all_blocks_addr</code>这个数组里面，再开始写。写的时候还要注意因为咱们是以块为单位进行读写（ide_read和ide_write就是这么实现的），所以写入第一个数据块的时候不要把原来的数据给覆盖了，</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/7fe64c9f921b0bdef2c039b84a1e3991.png" class=""><p>下面来验证一下正确性：</p><p>从上面的输出结果可以看出，我又给mount_partition函数加了个printk😁, 打印inode_table的地址，因为咱得看看根目录文件和file1文件的inode是不是都写入正确的值了。</p><p>先看看file1此刻的内容吧：</p><p>确实是万物起源<code>hello,world</code>, 没问题。这个<code>hello，world</code> 应该是我学习计算机科学以来，难度和水平最高的一个了吧🤓</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0238178fb16e869d18df6318bd38629d.png" class=""><p>再执行一次试试：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/6f424bf951d4cf1988be8dd701931560.png" class=""><p>再检查下inode_table:</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/df3b3f6ba58373665673175898c6a771.png" class=""><p>上面这串数字是个啥呢？ 听我慢慢道来：</p><p>咱们的inode结构定义如下：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2b0788a7ea2e139c8e875e01001cec2e.png" class=""><p>list_elem结构体中内含2个指针prev和next，这意味着一整个inode占用的大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>13</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>76</mn></mrow><annotation encoding="application/x-tex">6\times4+13\times4=76</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">6</span></span></span></span> 个字节，因此上面xxd的输出中前76个字节是根目录的inode，与刚哥给的结果相同，刚哥已经分析过这部分了，那我就说说后面的第2个inode吧，第一个双字内容为1，说明该文件的编号是1，check✅。第2个双字内容为0x18，即24字节，因为该文件是普通文件（咱们在file_create给函数create_dir_entry传递是文件类型参数是FT_REGULAR，因为我们的sys_open不支持创建目录文件），所以这24个字节表示file1文件本身的大小，正好对应了2个<code>hello,world\n</code>的大小，check✅。再看第5个双字内容，为0xA68，表示<code>i_blocks[0]</code>，与我们打印的地址相同 (此时空闲数据块中只分配出去了一个根目录占有的数据块和file1占有的数据块)，check✅。按照file_write函数的逻辑，在首次写入文件时要先分配一个数据块：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0ce4e53c4572a0735b9aeb3655b47e3f.png" class=""><p>而且写入是<code>hello,world</code>远不足以写满这个数据块，因此此时file1文件只占有一个数据块，所以<code>i_blocks[1~12]</code>的值为0，check✅</p><p>在分析上面的内容的过程中，我算是切身体会到这个inode索引结构的好用了。要分配一个数据块，能在空闲块位图中找到一个空位就行了，然后返回该位对应的空闲数据块 (函数block_bitmap_alloc的实现逻辑)，也不用管这个数据块与文件已有的数据块连不连续，充分利用了空闲数据块。在做到这一点的同时，还不用维护链表结构，没有链表结构本身的缺点，既能做到快速访问，而位图本身占有的空间还小的很，确实是精彩的设计。我相信做完这个操作系统，&quot;纸上得来终觉浅，绝知此事要躬行&quot;绝对会成为我学习要遵循的真理。</p><h2 id="146-读取文件sys_read的实现"><a class="markdownIt-Anchor" href="#146-读取文件sys_read的实现"></a> 14.6. 读取文件，sys_read的实现</h2><p>与sys_write的实现过程大差不差</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5befaf34f38738b0413ec6e090a4c47a.png" class=""><h2 id="147-移动文件读写指针sys_lseek的实现"><a class="markdownIt-Anchor" href="#147-移动文件读写指针sys_lseek的实现"></a> 14.7. 移动文件读写指针，sys_lseek的实现</h2><p>本质上就是修改文件结构(<code>struct file</code>)中的<code>fd_pos</code>成员</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ffdc21957fde4ad43e7918aa1a61fea1.png" class=""><h2 id="148-删除文件sys_unlink的实现"><a class="markdownIt-Anchor" href="#148-删除文件sys_unlink的实现"></a> 14.8. 删除文件，sys_unlink的实现</h2><p>本质上就是去除/回收这几样东西：</p><ol><li>文件占用的数据块和块位图中的位</li><li>inode和inode位图中的位</li><li>父目录中的相关目录项</li></ol><p>前2个由函数<code>inode_release</code>做到，第3个由函数<code>delete_dir_entry</code>完成</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2606772b39d210ffec64a9c2e1bfeccf.png" class=""><p>下面分别查看块位图，inode位图，inode表，根目录的内容：</p><ol><li>块位图<br />仅分配出一个块，这个块是给根目录用的，符合预期</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/27e0be5f32a1bd7405c3ba6939a809c2.png" class=""><ol start="2"><li>inode位图<br />仅分配出一个inode, 说明咱们确实是把file1的inode给回收了</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/ff49c9b2a6e4ee6bdd9ff1254b4ec45c.png" class=""><ol start="3"><li>inode表<br /><code>/file1</code>的inode被抹去，并且根目录的i_size更新为2个目录项大小，即0x30 (48个字节)</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/15fa48731e32d1870b3f332035ddcf0d.png" class=""><ol start="4"><li>根目录<br />file1的目录项已被抹去，现在根目录中仅剩最初的<code>.</code>和<code>..</code>目录</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/a789d25c556b3662c942425ffbd22fa5.png" class=""><h2 id="149-创建目录-sys_mkdir的实现"><a class="markdownIt-Anchor" href="#149-创建目录-sys_mkdir的实现"></a> 14.9. 创建目录， sys_mkdir的实现</h2><img src="/2023/12/15/elephont_os/build_os_from_scratch/dae0df55c061a0284d7010c9a06aae1b.png" class=""><p>根目录：</p><p>dir1对应的在根目录中的目录项显示，dir1的inode编号为<code>02</code>，文件类型为FT_DIRECTORY (表现为值<code>02</code>)</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/4681413d93b549c1e3c51e7feb5008fe.png" class=""><p>inode表：<br />根据一个inode占用76个字节大小这一信息 (咱们自个定义的)，可以在inode表中找出4个inode，dir1的inode在第2个竖线处。该inode中<code>i_blocks[0]</code>的值为0xA69，说明了目录文件dir1的第一个数据块的LBA为0xA69，转换为字节地址就是<code>1364480</code>。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d2bf4b3470629311cc0ff8f143c42451.png" class=""><p>下面我们查看这个地址的内容：</p><p>可见目录文件dir1的数据块中存在3目录项：<code>.</code> , <code>..</code>和<code>subdir1</code> , 符合预期 QVQ。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0cbea9d21366cd316848262b4709a1bc.png" class=""><p>根据上图中subdir1目录项中的信息，可以得出该文件也为目录文件（FT_DIRECTORY，值为<code>02</code>），inode编号为<code>03</code>，从inode表中第3个inode中可以知道subdir1的第一个数据块的LBA为<code>0xA6A</code>, 换算为字节地址就是<code>1364992</code>。文件大小为0x48，也就是72个字节，正好对应了subdir1目录下的3个目录项：<code>.</code> , <code>..</code>和<code>file2</code></p><p>咱们查看subdir1的数据块的内容：<br />存在3个目录项，即<code>.</code> , <code>..</code>和<code>file2</code>的目录项。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0e3428e4a2b69a559391d7ef4d8afcc8.png" class=""><p>再根据inode表中的内容，查看file2的内容：<br />这里的字符串内容是向我最喜欢的美剧之一《硅谷》致敬 <code>^_^</code>，话说最近OpenAi的董事会开除创始人CEO又马上重新应聘回来的行为真的是跟《硅谷》里面如出一辙啊🤨。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e406b5dab9598c470e3d5d93c0d6951f.png" class=""><h2 id="1410-打开和关闭目录sys_opendir和sys_closedir的实现"><a class="markdownIt-Anchor" href="#1410-打开和关闭目录sys_opendir和sys_closedir的实现"></a> 14.10. 打开和关闭目录，sys_opendir和sys_closedir的实现</h2><img src="/2023/12/15/elephont_os/build_os_from_scratch/ec07045da26f1114a575ef02b4a9f6dd.png" class=""><h2 id="1411-遍历目录sys_readdir和sys_rewinddir的实现"><a class="markdownIt-Anchor" href="#1411-遍历目录sys_readdir和sys_rewinddir的实现"></a> 14.11. 遍历目录，sys_readdir和sys_rewinddir的实现</h2><img src="/2023/12/15/elephont_os/build_os_from_scratch/40d3dba8042cbef91306978bbeab28db.png" class=""><h2 id="1412-删除空目录sys_rmdir的实现"><a class="markdownIt-Anchor" href="#1412-删除空目录sys_rmdir的实现"></a> 14.12. 删除空目录，sys_rmdir的实现</h2><img src="/2023/12/15/elephont_os/build_os_from_scratch/f45956d551bb3e3dbc2b056c36e85b9d.png" class=""><h2 id="1413-目录项展现锋芒-sys_getpwd与sys_chdir的实现"><a class="markdownIt-Anchor" href="#1413-目录项展现锋芒-sys_getpwd与sys_chdir的实现"></a> 14.13. 目录项&quot;…&quot;展现锋芒， sys_getpwd与sys_chdir的实现</h2><p>每个目录中存在的目录项<code>..</code>终于发挥了它的作用，咱们从当前目录，从下而上的顺藤摸瓜到根目录，就能获取到工作目录的路径啦。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9f5979df5eef713cb375bc0c1b3519f1.png" class=""><h2 id="1414-探索sys_stat函数获取文件属性"><a class="markdownIt-Anchor" href="#1414-探索sys_stat函数获取文件属性"></a> 14.14. 探索sys_stat函数，获取文件属性</h2><img src="/2023/12/15/elephont_os/build_os_from_scratch/2157b95ac191fe426d6945403dfa9d09.png" class=""><p>文件系统的内容是出乎意料的多，我认为这一章起码顶之前3章的内容。本来我预计是12/10之前读完这本书并写完这个操作系统，但这个文件系统的内容确实太多了🙃，以至于12/10才把文件系统写完，现在还剩最后一章系统交互。从做这个操作系统到现在，每一行代码都是我自己写的，而且百分之99.99的代码我都是理解了的，只有函数和结构开头的注释是让GPT4帮我生成的。对于这本书，如果真的只是想赶个项目出来，而甘愿当而coper而不thinker，那么这个过程会是痛苦的，毕竟这是一本700多页的书和几千行代码。但如果当一名thinker，尽管要投入大量的时间，但也确实是能看见操作系统的“真象”的。</p><p>自从来到宁波，开始居家修炼起，我感觉是一天好觉也没睡过，那怕有的晚上确实很累了很困了，也会躺下去就开始焦虑，经常性的闭眼了1,2个小时还是清醒的。直到昨晚我实在受不了这种恶性循环了（晚上睡不着，早上又起不来），就直接干脆不睡了，起来把这个文件系统写完了，<code>git log</code>都显示我凌晨3点提交的commit。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/da49684abe7c8c380e9c6382c153cd4b.png" class=""><p>但今天早上起来身体又浑身难受，我大概是受不了这种日夜颠倒的作息，真心希望后面能睡个好觉啊，现在最想拥有的能力就是到点倒头就睡的能力🥱。</p><h1 id="15-迎来终章系统交互"><a class="markdownIt-Anchor" href="#15-迎来终章系统交互"></a> 15. 迎来终章，系统交互</h1><h2 id="151-回顾第9章实现fork"><a class="markdownIt-Anchor" href="#151-回顾第9章实现fork"></a> 15.1. 回顾第9章，实现fork</h2><p>这一节用到了很多第9章线程切换的知识，我确实有点忘记了，于是我又翻回到第九章大致看了看。因为这一节涉及到进程切换的难点，所以这一节我要好好说道说道。</p><p>要实现fork，也就是说要从一个进程中创建一个一模一样的进程出来。要创建进程，那么咱们就看看一个进程需要什么呢？回顾第9章可以知道，一个进程得需要一个PCB，这个PCB里面有用于中断的<code>intr_stack</code>和线程自己的内核栈<code>thread_stack</code>。要创建一模一样的进程？那咱们就直接把父进程的PCB复制过来不就行了嘛，当然啦，也不是全部拿过来用了，还是得个性化的修改一下呢。在我们的实现中，第一步就是创建子进程的PCB，这就是函数<code>copy_PCB_and_vaddr_bitmap</code>做的事情：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d326e14a83ef8be61fdddf321e76e41a.png" class=""><p>注意哈，这里子进程调用函数<code>block_desc_init</code>重新初始化了自己的用于堆内存管理的内存块描述符，而不是使用父进程的内存块描述符。这是因为进程之间的堆内存管理应该隔离。如果不隔离的话，如果父进程修改了堆（如分配或释放内存块），这将影响共享的内存块描述符，进而影响到另一个进程。当子进程使用从父进程继承的内存块描述符来分配内存时，它可能会基于不正确或过时的信息进行操作。因为描述符中的信息可能已经由父进程修改过。</p><p>现在咱们的进程宝宝已经有了自己的PCB了，但在PCB中要根据子进程个性化修改的可不止上面这几个赋值语句呢。子进程管理虚拟内存池用到的位图 (进程有自己独立的地址空间，2个进程总不可能用一个位图来管理自己的虚拟内存吧)，内核栈<code>thread_stack</code>都得独立于父进程。于是就有了为子进程分别创建位图和内核栈的过程：</p><p>创建位图</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/47a5db8ced87e7dc01333df7638e2370.png" class=""><p>创建内核栈：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b41165a55da34924a923b6e1653ee9eb.png" class=""><p>这个内核栈的创建过程是真得好好说说，这里涉及了第9章进程切换的知识。从P.509的图11-13表示的栈布局可以看出，ebp位于内核栈的顶部，它的地址就是内核栈<code>thread_stack</code>的地址，咱们得把它的地址保存在PCB的<code>self_stack</code>中，因为进程调度时执行的<code>switch_to</code>函数在切换PCB时，就是通过PCB的第一个成员<code>self_stack</code>来获取的内核栈的地址的（这部分可以见P.433刚哥对<code>switch_to</code>函数的讨论）。ret_addr位于内核栈的顶部，从switch_to函数退出的时候，就是返回到这个地址中继续执行，我们把它设置成了intr_exit，目的是它子进程直接从中断返回。注意这里哈，和第9章不一样，第9章是从switch_to函数返回到schedule再返回到中断处理函数再返回到intr_exit()。</p><p>进程可不能只有个PCB啊，这玩意只是被操作系统调度模块所需要，进程自个还得有血有肉才是，也就是说进程得有自己的进程体（代码段数据段等），这部分直接把父进程的copy过来就行了，反正父子进程执行的是独立且相同的代码。这里要注意的是，子进程被重新调度之后，是接着fork()函数之后的流程开始执行，所以呢，它拥有的用户栈得和父进程一样。这是由函数<code>copy_body_and_userstack</code>完成的。</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9b95df32c63ffed1e5284f11a51650f6.png" class=""><h2 id="152-打造我的shell"><a class="markdownIt-Anchor" href="#152-打造我的shell"></a> 15.2. 打造我的Shell</h2><h3 id="1521-先搓个shell雏形"><a class="markdownIt-Anchor" href="#1521-先搓个shell雏形"></a> 15.2.1. 先搓个Shell雏形</h3><p>这一节在sys_read，putchar和键盘驱动程序的基础上初步建立了一个shell。有趣的是刚哥取得用户名是rabbit，不知道各位看书的时候是否注意到，在第7章开头刚哥提到了他女朋友叫王小兔，这正好对应上了，可见刚哥也是很有风趣的😜。</p><p>这一节也不是那么一帆风顺，我在readline的实现中，错把下面的1写成了count，导致这个shell进程一直卡在sys_read的ioq_getchar处，进而导致我的终端对键盘输入毫无反应（输入不满count个字符）。排查了一番才找到错误。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/45f9eab41105200874d150a188a0b356.png" class=""><p>这里我取的用户名是Peach，也是对应了我最重要的人之一。</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/6660cb6343807b248af502a9ed7c717c.png" class=""><h3 id="1522-让雏形稍微动起来实现ctrll清除屏幕和ctrlu清除当前行"><a class="markdownIt-Anchor" href="#1522-让雏形稍微动起来实现ctrll清除屏幕和ctrlu清除当前行"></a> 15.2.2. 让雏形稍微动起来，实现Ctrl+l清除屏幕和Ctrl+u清除当前行</h3><p>本质上就是在键盘中断程序中，把<code>Ctrl+l</code>和<code>Ctrl+u</code>通过<code>cur_char-='a'</code>的形式映射到某个控制字符，然后对这个控制字符在<code>readline</code>中专门处理，还是第10章那句话，什么字符表现为什么形式是由我们说了算😎</p><p>运行结果：<br />这种动态的运行结果，用ubuntu自带的录屏软件 (用<code>ctrl+shift+alt+r</code>启动) + ffmpeg生成gif (<code>ffmpeg -i videofile output.gif</code>)，很方便</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/15d0187723549ad1bee964f4589c4a6b.gif" class=""><h3 id="1523-解析命令"><a class="markdownIt-Anchor" href="#1523-解析命令"></a> 15.2.3. 解析命令</h3><p>本质上就是提取出命令行中以空格分隔的参数</p><p>运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9e65c3959bc3e215922dd5ca70ec9a6e.gif" class=""><h3 id="1524-shell中的路径解析"><a class="markdownIt-Anchor" href="#1524-shell中的路径解析"></a> 15.2.4. Shell中的路径解析</h3><p>这节还是有点难度的，咱们的任务是把用户输入的不规整的路径转换为规整的路径格式，比如说把<code>/a/b/../c</code>转变为<code>/a/c</code>，这样的规整路径交给<code>cd</code>, <code>ls</code>等命令，才好处理</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/20549e368af0766fe7089535df8e0d15.png" class=""><h3 id="1525-让shell更名副其实实现ls-cd-mkdir-ps-rm等命令"><a class="markdownIt-Anchor" href="#1525-让shell更名副其实实现ls-cd-mkdir-ps-rm等命令"></a> 15.2.5. 让shell更名副其实！实现ls, cd, mkdir, ps, rm等命令</h3><p>这一节仅在ls的实现上稍微复杂一点，而且还没有注释，不过仔细看看还是看得懂。我的<code>ls</code>支持选项<code>-l</code>和<code>--help</code>，因为<code>-h</code>对linux上的ls命令来说是–human-readable的意思，所以我改成了<code>--help</code>，此外各种输出提示我也是照着linux上实现的。之前一直没用到的all_list_tag总算在实现ps的时候派上了用场。</p><p>部分命令运行结果：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d73f4fc97e17a51e5bf9da56d48a25bc.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/29a1c8717fccd15a7fe5cd3ccb4344ba.png" class=""><h2 id="153-加载用户进程"><a class="markdownIt-Anchor" href="#153-加载用户进程"></a> 15.3. 加载用户进程</h2><p>先谈谈处理用户程序这部分。需要额外再写一个assert.c，实现逻辑与debug.c一样，之前写shell的时候遇到过<code>assert</code>，我都是直接在debug.c中加了句<code>#define assert ASSERT</code>解决的，现在用户程序prog_no_arg需要assert.c，就必须得写一个了。此外编译出的prog_no_arg的实际大小远大于刚哥所说的4777，我估计是页对齐的原因。加载用户可执行文件的逻辑本质上是这样的：把可执行文件先写入裸盘hd60M.img，再在内核中通过ide_read把文件的数据从hd60M.img中读到位于内核的堆空间的缓冲区，接着在通过文件系统接口sys_write把缓冲区的数据写入文件系统所在的硬盘hd80M.img（更准确的说是第一个分区sdb1）</p><p>最后便是execv的实现，这个函数本质上就是做了这样一件事情：读取用户的ELF文件的文件头和程序头表，并根据这2个表的信息完成ELF文件的加载，具体来说是类型为LOAD的segment的加载。关于这部分，我强烈建议各位看官先去看看程序员的自我修改—链接，装载与库这本书，直接看第三章就够了。ELF文件加载完了之后，就开始进程体的替换了，用刚加载的用户程序的进程体换掉老进程的进程体，关键的步骤就是修改老进程的eip为用户程序的入口地址entry_point，然后假装从中断返回。各位看看代码就知道了。</p><p>这一节做的相当久，原因是我遇到了下面这样的页错误：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/b12f29b0a452ce9a7473c1e81eee1bbf.png" class=""><p>上面的hello，success之类的语句是我为了调试定位加的，大家可以忽略。经过定位，我发现load函数在加载ELF文件的第2个segment的时候触发了页错误。我一直以来都是用bochs原生的调试功能，但在这一节就显得太捉襟见肘，连查看变量的值都是那么麻烦，对C语言太不友好了，之前的C程序调试基本都是靠加打印语句和审查代码能查出来，这下我不得不换成gdb调试（结果发现异常好用！）。</p><p>因此现在补充一下<strong>如何配置bochs+gdb</strong> （<a href="https://bochs.sourceforge.io/doc/docbook/user/debugging-with-gdb.html">Using Bochs and the remote GDB stub</a>）</p><ol><li>重新编译bochs，使其支持gdb远程调试</li></ol><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">.&#x2F;configure \--prefix&#x3D;&#x2F;home&#x2F;elite-zx&#x2F;bochs \--enable-gdb-stub \--enable-iodebug \--enable-x86-debugger \--with-x \--with-x11make -j $(nproc) &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改bochs配置信息，追加下面的内容</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt"># gdb part settinggdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>让ELF文件包含调试信息<br />修改makefile, 在gcc的选项中加入<code>-g</code>， 我查了下gcc的man手册，顺手把这个选项的含义贴在这里：</li></ol><img src="/2023/12/15/elephont_os/build_os_from_scratch/87abea38b80ec867e8c0d30047737d1f.png" class=""><ol start="3"><li>使用gdb远程调试<br />接着用<code>bochs -f bochsrc.disk</code>启动bochs，再启动gdb（推荐用<code>gdb -tui</code>的形式启动gdb，更直观），最后在gdb中输入下面的命令，sysmbol-file后面跟着的是内核文件的路径</li></ol><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">target remote localhost:1234symbol-file &#x2F;home&#x2F;elite-zx&#x2F;build-OS-from-scratch&#x2F;build&#x2F;kernel.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>效果如下， 之后咱们就可以用gdb调试啦</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d94653838e10729b33d04bf00df07cab.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/a7dc26009e3b132c5ef6489acc5c11d4.png" class=""><p>这里各位看官可能有跟我一样的疑惑？这里为什么要用gdb的命令sysmbol-file手动的加载内核文件的调试信息呢 ，实际上经过我的实践，这里如果不手动加载调试信息的话，gdb是找不到的。我问了下GPT-4, 把它的回答贴在这里：</p><blockquote><p>当您在 GDB 中调试内核或类似于内核的低级程序时，可能需要手动加载符号表。这主要是因为这类程序通常以一种与常规用户空间程序不同的方式加载和运行。在用户空间程序的情况下，操作系统加载器（如 Linux 上的 exec）负责加载程序并准备执行环境，其中包括设置用于调试的必要信息。GDB 依赖于这些信息来自动加载符号表。</p><p>然而，对于内核或其他低级系统程序，这些程序通常由引导加载程序（bootloader）在没有操作系统加载器的帮助下加载。例如，在引导一个操作系统时，内核是由引导加载程序直接加载的，没有标准的加载器来设置调试信息。因此，GDB 无法自动加载内核的符号表，需要您手动指定。</p><p>使用 symbol-file 命令手动加载符号表是在这种情况下获取调试信息的标准做法。您提供给 symbol-file 命令的路径应该指向包含调试符号的内核文件。</p></blockquote><p>gdb的用法，可以参考<a href="https://beej.us/guide/bggdb/">Beej’s Quick Guide to GDB</a>，网站虽然很老，但是内容很实用。此外，提醒各位，按住shift可以在gdb中选中内容，然后进行复制，这样会方便许多。</p><p>下面开始我的调试之路，我是怎么找出错误点的。</p><p>查看prog_no_arg的程序头表中的segment信息</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d31bd9e08651e4933cedc9b2f88d6f98.png" class=""><p>在开始加载segment之前，查看文件头中关于程序头表的信息:</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/6327d5dd909657656027d9ce79164fb4.png" class=""><p><code>prog_header_entry_count</code>显示程序头表中有5个项，即一共有5个segment, 这与上图中<code>readelf -l</code>的输出结果相符合。此时的文件指针偏移量为52，这是因为在load函数的前半部分，咱们先把用户文件<code>prog_no_arg</code>的文件头读进来了，不信的话各位看官可以看看用户文件<code>prog_no_arg</code>的文件头大小：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/dbeee7e0d7be83e4a0889aa4a4da666b.png" class=""><p>正是52个字节的大小，而且 上图中的<code>size of program headers</code>字段为32, 表明程序头表的每一个项为32个字节，这与上述的prog_header_entry_size的值相符合 QvQ</p><p>下面开始加载segment1：</p><p>进入<code>segment_load</code>函数之后，打印segment的大小：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/c078758771e6cbd12dcd78e47b6eb3ac.png" class=""><p>这与<code>readelf -l</code>的输出中FileSize字段的值吻合。</p><p>接着看看这个segment所处的虚拟页和在虚拟页中的偏移（无偏移）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/327f592aa6ebacb78c64001e7d699101.png" class=""><p><code>readelf -l</code>输出中的Align字段表示了segment的对齐属性，因此即使segment本身的大小不超过<code>0x1000</code>个字节，链接器还是会给它分配<code>0x1000</code>大小的虚拟内存空间，所以第一个segment的大小在这里显示的是<code>0x1000</code>，此处的<code>804800</code>也符合在函数<code>create_user_vaddr_bitmap</code>中设置的用户进程起始虚拟地址（vaddr_start）。</p><p>看样子刚哥在P.719所说的<code>文件的第一个段的起始地址都不是自然页</code>有些过时了，链接器确保了文件的segment是页对齐的。现在我应该能猜到为什么我的prog_no_arg文件的大小远大于刚哥所说的4777个字节了，因为我的prog_no_arg遵循页对齐。</p><p>不得不说，这一节用到了大量的有关ELF文件格式，链接，加载运行方面的知识，要不是之前读过这方面的书，我可能是真的一脸懵（虽然读过但好像也不是特别清楚 QAQ）</p><p>segment1的页目录项和页表项对应的虚拟地址，前者高20位是均为1以索引页目录表，后者高10位均为1以索引页表。查看页目录项和页表项的实际内容，可以发现其present位都为1</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/3eacc173ae386e0de96c00510af7aa7b.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/d4a184b0ca3105b66540ca3fa35a70c3.png" class=""><p>segment1看样子是成功加载了，下面看看segment2：</p><p>读取一个32字节的程序头表项之后，此时的文件指针偏移量变成84</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/179cf558b65a62fc85572ed6c98c61cc.png" class=""><p>查看segment2所处的虚拟页信息，依旧是页对齐的形式，实际大小<code>b66</code>与<code>readelf -l</code>的输出相符</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/199ea69a188b639fe04aa50a6a640782.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/683eb72f08692531d13959741e03bb87.png" class=""><p>页目录项和页表项，页表项在segment1的基础上加了一个项的大小（4个字节），这意味着segment2所处的虚拟页紧跟在segment1的虚拟页之后</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/e42f578cf31a875477b37f3a26f41156.png" class=""><p>下面就是调用sys_read读取这个segment, 具体来说，就是读取从虚拟地址<code>0x804900</code>开始的一个页，进入sys_read，再跳转到file_read，从文件prog_no_arg中偏移量为4096的位置开始读取<code>0xb66</code>个字节。这里的4096是怎么回事？其实这是segment2中由prog_header.p_offset指示的偏移量，从之前的<code>readelf -l</code>的输出就可以看出。而且在segment2之前已经有一个4KB的segment1了，所以偏移量是4096</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/d19f329c04a426cf1f778531b29631db.png" class=""><p>一共分配了6个数据块（编号8~13）, 这个数字怎么来的呢？因为咱实际读取的字节数是<code>0xb66</code>，换算为十进制就是2918，一个数据块大小为512个字节，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2918</mn><mi mathvariant="normal">/</mi><mn>512</mn></mrow><annotation encoding="application/x-tex">2918/512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">9</span><span class="mord">1</span><span class="mord">8</span><span class="mord">/</span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 向上取整，得到所需数据块数量为6。为了保险，我还是打印了<code>blocks_required_read</code>的值，该值表示待读取的数据块数量，！！！这里居然是一个巨大的值，原因很简单，就是无符号数的回绕，因为我用一个小的值<code>block_read_start_idx</code>减去了一个大的值<code>block_read_end_idx</code>。但其实这里<code>blocks_required_read</code>的值对流程的影响并不大，后续分支只是判断它是不是0而已。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/531bad7c9536075971a8803fb18a11a1.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/1b9685ac52b4cdebcdb18108d585d56e.png" class=""><p>下面开始读入。因为是页对齐的，所以不存在第一个数据块存在旧数据的情况（数据块被完全覆盖），因此第一次读入也是以块为单位</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/f14d8c4b9960a1bc86ed4ca11c344357.png" class=""><p>4次循环后查看还未读取的数据量，确实是刚读了2048个字节（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2918</mn><mo>−</mo><mn>870</mn><mo>=</mo><mn>2048</mn></mrow><annotation encoding="application/x-tex">2918-870=2048</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">9</span><span class="mord">1</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span></span></span></span>）</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/8889c350a8c0bcf2115eaed1e2ddda3c.png" class=""><p>读取完size个字节后，进入释放<code>all_blocks_addr</code>和<code>io_buf</code>的内存阶段。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/37b2fee3ccc62e403421a93d71a57405.png" class=""><p>这2个变量在用户内存池中占有的大小分别是512个字节和560个字节</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9c1628c8d8fda13ae55e2f98bd5d3921.png" class=""><p>先看<code>sys_free(all_blocks_addr)</code>，因为是用户进程，所以从用户内存池中释放</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/a9cce02842372a40c5cc17bd65c1b691.png" class=""><p>先看看对<code>all_blocks_addr</code>的释放过程，按照<code>sys_mallo</code>c的逻辑，应该分配给了它一个1024大小的内存块，咱们在<code>sys_free</code>中查看它占有的块对应的描述符中的信息，块大小果然是1024，该类型的arena中的数据块一共是3个，因为4KB的页其中元数据要占有一小部分，因此剩余的空间，平均分成1024的块的话，只能分成3份，初始化描述符是在函数<code>block_desc_init</code>中实现的，从这里确实可以看出，我们的<code>sys_malloc</code>实现是真没啥问题，问题一定是出在<code>sys_free</code>这里。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/267779e9ca1c702ec7f650da869e9b7e.png" class=""><p>因为在1024类型的arena中只分配了一个数据块给<code>all_blocks_addr</code>，因此回收这个数据块的时候会导致把整个arena回收（回顾一下第12章，在<code>sys_free</code>中如果arena中全是空闲数据块，那么就回收整个arena）。还是验证一下，查看当前arena的元信息（该元信息在文件memory.c中声明为结构体 <code>struct arena</code>）中的cnt字段</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5377a8ff484ee7e3e091e2433dd512a5.png" class=""><p>因此现在<code>sys_free</code>进入了回收arena的代码块</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/43c0510bf2d97461ede8daac5541e15b.png" class=""><p>对<code>all_blocks_addr</code>的释放没有触发页错误，接着我们看对<code>sys_free(io_buf)</code>。</p><p>执行到这里的时候发生了页错误：</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/776f3e58261cf6d06883c4dc4a76d8d9.png" class=""><p>此处应该是512字节大小类型的arena，但其描述符中的信息是乱码</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/2226d5873e05fbb4ee5e80bf828c765d.png" class=""><p>回到给io_buf分配内存的sys_malloc语句，进去看看</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/5fbef48df79c7e7b68160a5b38dbbeef.png" class=""><p>分配的确实是类型为512字节的arena</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/9a751bc22e0ee42651c4ea6aac7d8eb9.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/f7144965f58cf8b809ef2e359b58a410.png" class=""><p>执行流程没有进入list_empty分支</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ca385eb0144e1d98b8fab0c07355a15b.png" class=""><p>查看free_list的值，head和tail确实不符合list_empty的<code>plist-&gt;head.next == &amp;plist-&gt;tail</code>的条件，但是这个free_list的值明显是不对的 (😢)。 下面的打印的指针值明显是不正确的，next指针的值成了<code>0x804960c</code>，该地址下的内容又是head的地址，等于说head的next成员成了head的二级指针，看样子必须回到前一次segment的加载过程，看看512类型的arena怎么出错了。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/47f05e8d1504ddbec3c718ddbc719719.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/b2cc389e67ee5b9ee0a38e26a70d2f99.png" class=""><p>回到加载segment1的过程中，进入给io_buf分配内存的sys_malloc，分配给io_buf一个数据块之后，还有5个512字节块。</p><p>这里应该是有问题的啊，首先吧，现在我们执行的进程是由Shell进程fork而来的，然后在调用execv用 用户进程的进程体取代当前进程的进程体。所以目前这个进程的块描述符应该是才初始化过的，我检查了下，虽然在进入segment_load函数之前，该进程中调用过几次sys_malloc，但都在函数末尾释放了的，这意味着现在的块文件描述符对应的arena应该是空的才对，这里为什么会有一个被分配出去的512数据块呢？</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/49ac435e5b8d4f99b6185b623e9673a4.png" class=""><p>为了搞清楚这个问题，我决定回到fork结束之后，刚进入子进程的时间点，查看此时子进程的块描述符数组<code>u_mb_desc_arr</code>。怎么进程PCB的内容全部变成0了😅</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/10c65bb08a6d1615f23c107cc74b975c.png" class=""><p>子进程pid居然也为0…, 我现在的情绪是这样的😫。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/c2f7d07dd0cf93d91d9de81da8cdec86.png" class=""><p>那么回顾下内核启动以来调用fork的地方，先是在init进程中调用fork创建了子进程shell，通过ps命令就可以知道，这个fork到没啥问题。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ce67fee9286f5e498370123d7a07c727.png" class=""><p>。。。我现在的情绪依旧是这样的😫， 因为我查看了其他几个进程的pid，除了main以外，包括init进程在内，只要是用running_thread()-&gt;pid打印pid的值，结果都是0，真是抽风啊！！！。 ps命令能正确运行是因为它是通过all_list_tag获取的进程PCB，而不是running_thread，但是running_thread的实现也没什么问题😥。此外，fork的返回值也是正确的pid值。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/bd698297e378a4107dcdca764cd17bf2.png" class=""><p>在函数block_desc_init中检查512类型的arena的描述符的初始化过程：</p><p>对于512大小的arena, 一个arena（一页）中可以放7个数据块</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/ff473a4afaabd08b5386406aa704e932.png" class=""><p>刚初始化的描述符free_list为空，head指向tail，说明函数block_desc_init初始化的过程没什么问题</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/0dd41d42586945912754b27bf182373b.png" class=""><p>行吧，这个running_thread()获取的PCB打印为0的事情就先不管了。既然段错误发生的核心原因是因为进入segment_load之前，进程的块描述符的free_list不是为空的状态。那么我就在进入segment_load函数的前一步再调用一次block_desc_init重新初始化进程的块描述符，这样就能保证free_list为0了，这样做也确实能正确的让用户进程加载并执行。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/25f7a7c5ce3bf58beec4c099ccfd3c8f.png" class=""><img src="/2023/12/15/elephont_os/build_os_from_scratch/e68540e2e56051cc576505fe26e3588a.png" class=""><p>但是这样的话，在重新初始化之前记录在块描述符的free_list中的空闲数据块就丢失了，造成了内存泄露了。因此这个办法还是有问题的🙃。</p><hr /><h1 id="16-结语"><a class="markdownIt-Anchor" href="#16-结语"></a> 16. 结语</h1><p>这个execv内触发的page fault， 我从前天晚上调试到今天晚上，一共是用了2天。我几乎把堆内存管理的代码又过了一遍，也没能发现哪里导致了512大小类型的arena的异常，最终只能在进入segment_load之前强制重新初始化块描述符并以内存泄露的代价勉强完成用户进程的加载。其实我内心还是很失落的，我确实是想从0开始手搓一个操作系统内核的，这个内核当然是功能越完整越好。因为现在已经出现了我解决不了的问题，因此后续系统调用wait,exit和管道的内容哪怕我把代码敲上去也看不到运行结果，所以我就不准备是实现了。</p><p>从<code>git log</code>记录来看，我的OS kernel的首次提交是在10.31号，到今天（12.15号）有了差不多快一百次提交，如果之前的CS144和实习期间做的一个grpc后端服务不算的话，这应该算是我第一个完成大型的个人项目。我本来给自己定的完成的时间就是12.15号（本来是12.10号，但没想到文件系统的内容这么多），除去11月的几个出去散步了的周末和几个晚上严重失眠的疲惫的天数之外，从实现MBR开始一直到实现系统调用execv一共用了差不多40天的时间。我也不是一个特别自律的人，而且我还是居家学习，不是在像图书馆那样的有氛围的地方， 所以我基本上最多连着学一个小时就会开始坐不住了，最开始下了个番茄钟来培养固定学习时间段，后来我发现不用这玩意我学的更好更久，就没用了。因此这40天内，我大概平均每天花了5个小时在这个项目上面，看书，写代码和写博客记录，时间跨度大概就是这样，供大家参考。</p><p>写到这，我也想回顾一下我自大学以来走过的路。我想先分析一点，那就是从进入大学到现在，我是怎么一步一步落到今天这副局面的。我认为我主要犯了2个错误。一是刚上大学的时候，意识不到位。不去涉及CS专业相关的信息，不去关心怎么学，重点学什么，专业前景是什么，加上没能认清大学的本质（关于这一点，我强烈推荐每个有个人规划的大学生都去看看：<a href="https://survivesjtu.gitbook.io/survivesjtumanual/">上交大生存手册</a>），再加上没有利用好假期，导致自己做了一年半的无用功。我现在都记得，在大二下开设操作系统课程的时候，在第一节课上，老师指着ubuntu的图标问我们是什么，我当时是见都没见过。课后让我们写一个shell脚本，我费力安装好ubuntu之后，完全不晓得怎么操作，更别说写shell脚本了，那时候连ls命令都不知道。二是过去一年大部分时间的学习是比较低效率的，学习方法上脱离实践，太专注于纸面上的理解。我记得大二下册的五月的一个晚上，我受到了一个与我同名的，极有自驱力，目标极其清晰的人的影响（现在他已经去了微信部门），这里就称他为X吧，我现在还记得在那天晚上我看他的博客看到了凌晨2点，深有感触。于是我开始纠正过去一年半的错误，着手学习专业相关的技能了，但是我毕竟之前从未认真学习过CS方面的知识和技能，我可以这么说，在大二结束的时候，我只会C语言基础和一点<code>C++</code>皮毛，操作系统，数据库和计算机组成原理能把考试考过，别的就没了，而且我也没有去搜集过怎么学习计算机知识的经验之谈，所以那时我学习计算机知识的方法是相当差的，首当其冲的就是大二暑假留校学习数据结构的时候，当时看的是数据结构与算法<code>C++</code>描述这本书，我居然耗时耗力的去把章节后面的30多道习题做了，而不是选择去刷一些leetcode。这个数据结构的学习花了我很久的时间，而且效果绝对还没有每天刷leetcode的人学到的多。学完了数据结构之后，我就开始看CSAPP了，这里也是犯了一个大忌，我居然在英语水平并不是那么高的情况下， 牺牲效率去看英文原版，这样的行为的结果就是一个月才能看完一章并做完对应的实验。之后我看计算机网络自顶向下的时候也看了英文原版，加上没接触过计算机网络，抓不住重点，第一章就看了大半个月。听起来很好笑对吧，我现在回想起来也觉得很好笑。直到今年年初跟X打了个视频，才意识到这样看英文原版的行为非常不适合我，学到的不仅不比看中文版的多，而且效率还很低。接着就是大三下开学了，那时候身边的人都开始准备考研和实习了，我既不准备考研，也没能力找实习，所以我就开始蹲在图书馆补基础。把CSAPP的bomblab和这之后的2个lab做完了之后，我就开始学习重新操作系统了，花了一个半月的时间把哈工大李志军的OS课程听完了，并完成了所有实验。这其中其实也做了无用功，那就是我每看一章就写一章的笔记，哪怕不是搞的很清楚，也要写，现在看来写这些笔记确实没什么用。OS学完了之后，我就开始重新看计算机网络自顶向下，一路看到了网络层，把前三章的所有课后实验完成了，最后还去把CS144给写了，当然啦，因为自个没怎么学过<code>C++</code>，完成CS144的时候还是遇到了一些麻烦的。学计网的时候也是，爱记笔记，虽然也重视实践了，但是总的来说记笔记还是拉低了效率。计网学了之后，我就开始学习网络编程了，开始看起了TCP/IP网络编程这本书，这样大三上就过去了。在六月份的时候自己还是很想找一个暑期实习，于是我还是凭着上半年学过的知识和写的小玩具在我们学院院长开设的小公司里面获得了实习岗位，在大三暑假我就开始实习生涯了。实习期间，我去把grpc的框架学了，搭建了一个简单的grpc后端服务，这期间确实是意识到自己<code>C++</code>知识太欠缺了，于是八月份把<code>C++ Primer</code>过了一遍，网络编程的学习也在继续，暑假七八月份把TCP/IP网络编程看完了并完成了所有实践和把linux高性能编程这本书看了个七七八八，实例也大部分都写了。九月份看了程序员的自我修养—链接装载与库这本书，也正是在看这本书的中途，我彻底意识到了这样边看书，边在笔记中重述书的内容的方式是极其偏离实践的，从那时候开始我便认定了learning by doing这个学习方法。然后到了十月份，其实在九月份的时候我就意识到这份实习给我带来是提升和体验十分有限，而且还占据了我的学习时间，于是十月份我就准备抓紧搞完交代的项目后办理离职，最后也是在十月底的时候离职了，离开了待了七八年的重庆来到了浙江宁波，开始了闭关修炼之路，这个小型操作系统也是我闭关修炼完成的第一个项目。</p><p>如果有看官看到这，肯定有疑问，我现在一个本该是大四的人了，还在这样一个阶段，不就是一个基本完蛋吗。确实是这样的，所以我才会在段落开头写“这副局面”，为了挽救这看似不可逆转的局面，我做了很多人不会做的事情，那就是休学一年。我先是在八月份留校实习期间找到辅导员探讨这件事的可行性，获得辅导员的同意之后，于九月初向学院提出了休学申请。当然，作为一个已经大四的人，我预想办理休学应该不是一件顺利的事情，但是很幸运的是我们的学院书记是一个很理解学生的人，在我给她交流了自己的想法之后，她还是同意了。之后学院院长也来找我谈过话，毕竟我是在他那实习，在交流之后，他也理解了我的做法，值得一提的是，他在谈话的第二天居然把我叫去跟客户谈话，现在我也不知道为什么。</p><p>实话说，我这一路走来是极其曲折的，现在总算是走上了正轨，今年这个小公司实习的经历也让我彻底认清自己是不会太愿意在一个小地方从事一份特别不起眼的工作的。在宁波呆的这些日子也让我确定我将来想定居的地方就是经济发达的地区，最好就是沿海这一带。但是，我也知道现在的我离自己的目标还差的很远很远，与那些真正厉害的人也差的很远很远，还要很努力很努力才能追上人家的脚步。</p><p>最后，贴一张刚写完文件系统时的桌面照片吧。</p><img src="/2023/12/15/elephont_os/build_os_from_scratch/c6a0d86144246c1256a4977e9c9e24c5.png" class="">]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Stanford CS144 Spring 2023] 手搓一个TCP</title>
      <link href="/2023/05/31/computer_network/CS144/"/>
      <url>/2023/05/31/computer_network/CS144/</url>
      
        <content type="html"><![CDATA[<h1 id="1-lab0-networking-warmup"><a class="markdownIt-Anchor" href="#1-lab0-networking-warmup"></a> 1.  lab0 networking warmup</h1><h2 id="11-set-up-gnulinux-on-your-computer"><a class="markdownIt-Anchor" href="#11-set-up-gnulinux-on-your-computer"></a> 1.1. Set up GNU/Linux on your computer</h2><p>ubuntu22.04LTS下执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> cmake gdb build-essential clang <span class="token punctuation">\</span>clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装g++12.3.0</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/ppa<span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> g++-12 <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer_network/CS144/d6f4cf3e9c0ddf6dfec8cf56cdbf46a7.png" class=""><p>将minnow仓库上传到自己的仓库，参考<a href="https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private">这个方法</a><br />如果你做的是2023年之前的版本，需要用到sponge仓库，那么我<a href="https://github.com/Elite-zx/CS144-sponge">这里</a>有一份未被修改过的版本</p><h2 id="12-networking-by-hand"><a class="markdownIt-Anchor" href="#12-networking-by-hand"></a> 1.2. Networking by hand</h2><h3 id="121-fetch-a-web-page"><a class="markdownIt-Anchor" href="#121-fetch-a-web-page"></a> 1.2.1. Fetch a Web page</h3><p>先提前准备好这3行首部信息，连接成功后快速复制进去，避免连接断开(<code>Connection closed by foreign host.</code>)</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/hello</span> <span class="token http-version property">HTTP/1.1</span></span><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">cs144.keithw.org</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">close</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer_network/CS144/c115d6890f5fd5aa7520dc617a5b121e.png" class=""><p>(Pretend to be a student at Stanford✌️)</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/lab0/elitezx</span> <span class="token http-version property">HTTP/1.1</span></span><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">cs144.keithw.org</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">close</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer_network/CS144/dfd50d27a92f6fa60d1b2f2a923902a8.png" class=""><h3 id="122-send-yourself-an-email"><a class="markdownIt-Anchor" href="#122-send-yourself-an-email"></a> 1.2.2. Send yourself an email</h3><p>这个实现在 <em>自顶向下</em> 的实验中已经完成过了，就不再重复了</p><img src="/2023/05/31/computer_network/CS144/d23d0311f3b4833f4d77f9aba232d1a2.png" class=""><h3 id="123-listening-and-connecting"><a class="markdownIt-Anchor" href="#123-listening-and-connecting"></a> 1.2.3. Listening and connecting</h3><p>netcat监听一个端口， telnet 连接到一个端口使用telnet连接到一个端口，该端口必须处于监听状态</p><img src="/2023/05/31/computer_network/CS144/254604b0f9b24b1052e329f52117eb1f.png" class=""><img src="/2023/05/31/computer_network/CS144/6da45053969b61df7a75cfb36704fc13.png" class=""><h2 id="13-writing-a-network-program-using-an-os-stream-socket"><a class="markdownIt-Anchor" href="#13-writing-a-network-program-using-an-os-stream-socket"></a> 1.3. Writing a network program using an OS stream socket</h2><h3 id="131-lets-get-startedfetching-and-building-the-starter-code"><a class="markdownIt-Anchor" href="#131-lets-get-startedfetching-and-building-the-starter-code"></a> 1.3.1. Let’s get started—fetching and building the starter code</h3><p>安装最新版的cmake，ubuntu22.04  follow <a href="https://askubuntu.com/a/1157132/1681772">here</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> minnowcmake <span class="token parameter variable">-S</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-B</span> buildcmake <span class="token parameter variable">--build</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/31/computer_network/CS144/bc74865004fa7f18defa1fe09d61f59f.png" class=""><h3 id="132-modern-c-mostly-safe-but-still-fast-and-low-level"><a class="markdownIt-Anchor" href="#132-modern-c-mostly-safe-but-still-fast-and-low-level"></a> 1.3.2. Modern C++: mostly safe but still fast and low-level</h3><p>代码规范</p><h3 id="133-reading-the-minnow-support-code"><a class="markdownIt-Anchor" href="#133-reading-the-minnow-support-code"></a> 1.3.3. Reading the Minnow support code</h3><p>Adress</p><img src="/2023/05/31/computer_network/CS144/7f7a17c918370d5a53fff8f0624c401c.png" class=""><p>file_descriptor</p><img src="/2023/05/31/computer_network/CS144/399585efdc594c98c39eee207e8cb94f.png" class=""><p>socket</p><img src="/2023/05/31/computer_network/CS144/a9b1e0847665ded2b05c50e9ede31e7d.png" class=""><p>TCPSocket</p><img src="/2023/05/31/computer_network/CS144/51aa482e91ac4069a40b0a3ef6a6f84d.png" class=""><h3 id="134-writing-webget"><a class="markdownIt-Anchor" href="#134-writing-webget"></a> 1.3.4. Writing webget</h3><p>根据提供的类，可以很轻松的写出来（10行够了，但完整和规范）。注意write接受string_view的对象，但是该类不能使用’+'运算符，因此用string代替。string_view和string的区别在于string_view只能被访问而不能被修改( refer to a constant contiguous sequence),，而string可以追加、删除和修改字符</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_URL</span><span class="token punctuation">(</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> host<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> path <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// cerr &lt;&lt; "Function called: get_URL(" &lt;&lt; host &lt;&lt; ", " &lt;&lt; path &lt;&lt; ")\n";</span>  <span class="token comment">// cerr &lt;&lt; "Warning: get_URL() has not been implemented yet.\n";</span>  TCPSocket tcp_socket <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Address <span class="token function">target_addr</span><span class="token punctuation">(</span> host<span class="token punctuation">,</span> <span class="token string">"http"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span> target_addr <span class="token punctuation">)</span><span class="token punctuation">;</span>  string request <span class="token punctuation">&#123;</span> <span class="token string">"GET "</span> <span class="token operator">+</span> path <span class="token operator">+</span> <span class="token string">" HTTP/1.1\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// can not use '+' in string_view object</span>  cout <span class="token operator">&lt;&lt;</span> request<span class="token punctuation">;</span>  string header0 <span class="token punctuation">&#123;</span> <span class="token string">"Host: "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> header0<span class="token punctuation">;</span>  string_view header1 <span class="token punctuation">&#123;</span> <span class="token string">"Connection: close\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> header1<span class="token punctuation">;</span>  string_view empty_line <span class="token punctuation">&#123;</span> <span class="token string">"\r\n"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> empty_line<span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> request <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> header0 <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> header1 <span class="token punctuation">)</span><span class="token punctuation">;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> empty_line <span class="token punctuation">)</span><span class="token punctuation">;</span>  string rcv_buffer<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>tcp_socket<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    tcp_socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span> rcv_buffer <span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> rcv_buffer<span class="token punctuation">;</span>    rcv_buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  tcp_socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// destructor</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./apps/webget cs144.keithw.org /hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/31/computer_network/CS144/87b796b15c232a403d24ed3180cd473e.png" class=""><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token parameter variable">--build</span> build <span class="token parameter variable">--target</span> check_webget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/31/computer_network/CS144/70352ffb130b6bf7fbd2bad02b119435.png" class=""><h2 id="14-an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#14-an-in-memory-reliable-byte-stream"></a> 1.4. An in-memory reliable byte stream</h2><h3 id="141-target"><a class="markdownIt-Anchor" href="#141-target"></a> 1.4.1. target</h3><p>在 “An in-memory reliable byte stream” 这一小节中，文档要求你<strong>实现一个可靠的字节流</strong>。这个字节流需要满足以下几个条件：</p><ul><li>字节流是有限的：写入者可以结束输入，然后就不能再写入更多的字节。当读取者读到流的末尾时，它将到达“EOF”（文件结束），并且不能再读取更多的字节。</li><li>字节流也需要进行流量控制，以限制其在任何给定时间的内存消耗。对象在初始化时会有一个特定的_capacity：它在任何给定点愿意在自己的内存中存储的最大字节数。字节流将限制写入者在任何给定时刻可以写入的量，以确保流不会超过其存储容量。当读取者读取字节并从流中排出它们时，写入者被允许写入更多。</li><li>字节流的使用是在单线程中，你不需要担心并发的写入者/读取者、锁定或竞争条件。</li></ul><p>你需要实现以下的接口：<br />对于写入者：</p><ul><li>void push( std::string data ); // 将数据推送到流中，但只能推送可用容量允许的量。</li><li>void close(); // 表示流已经结束。不会再有更多的写入。</li><li>void set_error(); // 表示流出现了错误。</li><li>bool is_closed() const; // 流是否已经关闭？</li><li>uint64_t available_capacity() const; // 现在可以推送到流中的字节数是多少？</li><li>uint64_t bytes_pushed() const; // 累计推送到流中的总字节数。</li></ul><p>对于读取者：</p><ul><li>std::string_view peek() const; // 查看缓冲区中的下一个字节</li><li>void pop( uint64_t len ); // 从缓冲区中移除 <code>len</code> 个字节</li><li>bool is_finished() const; // 流是否已经结束（已关闭并完全弹出）？</li><li>bool has_error() const; // 流是否出现过错误？</li><li>uint64_t bytes_buffered() const; // 当前缓冲的字节数（已推送但未弹出）</li><li>uint64_t bytes_popped() const; // 累计从流中弹出的总字节数。</li></ul><p>你需要打开 src/byte_stream.hh 和 src/byte_stream.cc 文件，并实现提供这个接口的对象。在你开发字节流实现的过程中，你可以使用 cmake --build build --target check0 运行自动化测试。如果所有测试都通过，check0 测试将会运行你的实现的速度基准测试。</p><h3 id="142-source-code"><a class="markdownIt-Anchor" href="#142-source-code"></a> 1.4.2. source code</h3><p>byte_stream.hh</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ByteStream</span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">uint64_t</span> capacity_<span class="token punctuation">;</span>  <span class="token comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span>  std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> mem_buf<span class="token punctuation">;</span>  size_t bytes_pushed_cnt<span class="token punctuation">;</span>  size_t bytes_poped_cnt<span class="token punctuation">;</span>  <span class="token keyword">bool</span> is_end<span class="token punctuation">;</span>  <span class="token keyword">bool</span> is_err<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>byte_stream.cc</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">ByteStream</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> capacity <span class="token punctuation">)</span>  <span class="token operator">:</span> capacity_ <span class="token punctuation">&#123;</span> capacity <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> mem_buf <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> bytes_pushed_cnt <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> bytes_poped_cnt <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> is_end <span class="token punctuation">&#123;</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> is_err <span class="token punctuation">&#123;</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span> string data <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  size_t allowed_size <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  allowed_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> capacity_ <span class="token operator">-</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// flow-controlled</span>  data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> allowed_size <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> data <span class="token punctuation">)</span>    mem_buf<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>  bytes_pushed_cnt <span class="token operator">+=</span> allowed_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  is_end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">set_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  is_err <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">is_closed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> is_end<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">available_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> capacity_ <span class="token operator">-</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Writer</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> bytes_pushed_cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>string_view <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> string_view <span class="token punctuation">&#123;</span> <span class="token operator">&amp;</span>mem_buf<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// const char*</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">is_finished</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> is_end <span class="token operator">&amp;&amp;</span> mem_buf<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">has_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> is_err<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">pop</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> len <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span> len<span class="token punctuation">,</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// avoid illegal len</span>  <span class="token keyword">int</span> _size <span class="token operator">=</span> len<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> _size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>    mem_buf<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bytes_poped_cnt <span class="token operator">+=</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_buffered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> mem_buf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Reader</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_popped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> bytes_poped_cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="143-result"><a class="markdownIt-Anchor" href="#143-result"></a> 1.4.3. result</h3><img src="/2023/05/31/computer_network/CS144/a8993a0ccdbc79fc8603e6126bdda791.png" class=""><h1 id="2-lab1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#2-lab1-stitching-substrings-into-a-byte-stream"></a> 2. lab1 stitching substrings into a byte stream</h1><h2 id="21-target"><a class="markdownIt-Anchor" href="#21-target"></a> 2.1. target</h2><p>将远程仓库的 <code>check1-startercode</code> 分支的更改合并到当前所在的main分支，重新cmake</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> merge origin/check1-startercodecmake <span class="token parameter variable">-S</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-B</span> buildcmake <span class="token parameter variable">--build</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这个实验和下一个实验中，你将实现一个TCP接收器：这个模块接收数据报，并将它们转换成一个可靠的字节流，以便应用程序从套接字中读取——就像你在Checkpoint 0中的webget程序从webserver中读取字节流一样。</p><p>TCP发送器将其字节流分割成短的段（子字符串，每个不超过约1460字节），以便它们每个都能装入一个数据报。但是，网络可能会重新排序这些数据报，或者丢弃它们，或者多次传送它们。接收器必须将这些段重新组装成它们开始时的连续字节流。</p><p>在这个实验中，你将编写一个负责这种重组的数据结构：<strong>一个Reassembler</strong>。它将接收子字符串，由一串字节和该字符串在更大流中的第一个字节的索引组成。流的每一个字节都有它自己的唯一索引，从零开始并向上计数。</p><img src="/2023/05/31/computer_network/CS144/b93603f9efe81d5ff6627cb41ccc715c.png" class=""><h2 id="22-analyze"><a class="markdownIt-Anchor" href="#22-analyze"></a> 2.2. analyze</h2><img src="/2023/05/31/computer_network/CS144/b9d0adf15b770596e7b145e3d3f2df50.png" class=""><p>首先理解内存限制的要求。ByteStream对象的capacity分为了两个部分，一个是用于字节流的buffer，用于存储重组好的有序字节流，这是对writer对象和reader对象而言的。一个是用于未重组的字节流的缓冲，可通过available_capacity()方法获取，这是reassembler对象而言的。因为capacity是固定的，意味着如果pop的频率太小，那么capacity被有序字节流填满，此时重组器reassembler会停止工作，因为它的存储空间available_capacity为0。</p><p>其次，实现这个reassembler最大的难点在于：如何<strong>处理重叠的子串</strong>。比如first_unassemble_index(期望接受的第一个有序字节)是’a’，但是先后来了子串’bc’，‘c’，这两个子串就要缓存在reassembler的内存空间中(大小为available capacity, 如果该值大于2的话)。我们需要在将c加入子串的时候，执行remove_overlapping操作，将这两个重叠子串合并为’bc’，这样确保reassembler中缓存空间中不存在重叠子串。换句话说，就是在新的子串要缓存时，在加入前先与缓存中重叠的子串执行合并操作，以确保加入后缓存中不存在重复子串，合并后bytes_pending（<code>unordered_bytes_size</code>）减去相应子串的大小。这样的目的是节省内存空间，并且在期望的有序字节达到<code>last_index + 1 == begin_index</code>时，也能快速的与缓存中的相邻子串合并然后通过writer的push函数push到reader的buffer中。</p><p>不仅如此，我们对新来的子串，在合并操作前，我们还要<strong>确保该子串是合法的</strong>，即该子串是在first_unassembled_index（<code>output.bytes_pushed()</code>）和first_unacceptable_index-1（<code>output.bytes_pushed()+output.available_capacity() - 1</code>）之间的，也就是说该子串的字节即不是已经被pop的，也不是到了buffer中的，更不是capacity之外的(否则会超出容量)，这个可以通过判断边界值做到。</p><p>在选择数据结果的问题上，我一开始为了效率（<code>string next_substring = unordered_bytes_buffer[first_index]</code>更快一点），选择了unordered_map,但是后来在test阶段，发现遍历reassembler的缓存unordered_bytes_buffer时，必须按first_index从小到大遍历，否则合并操作会出现遗漏，而unordered_map无法指定遍历顺序，因为哈希值我是不知道的，于是换成了能自动根据key值排序(默认从小到大)的map</p><p>在判断是否Finish的问题上，除了要满足达到接受方的流is_last_substring为true，还要满足reassembler已经通过writer的push函数将所有有序字节push到了buffer中，即<code>output.bytes_pushed() = first_index + data.size()</code></p><p>完成这个实验是不容易的，说实话我看把文档看懂让我究竟干什么都花了1个小时，花了一上午写好初始代码，结果一开始只能通过8个test用例，调试了一下午，逐步通过cap,dup…。这期间加入了很多cout语句（很管用），因为我对gdb还不咋熟悉，而且这文件也太多了。 最后测试到win又报错了，这个时候分析打印结果不太可行了，于是我硬着头皮又重新过了一遍自己的代码，发现是合并操作计算边界时+1,-1问题，最后成功通过test！</p><h2 id="23-source-code"><a class="markdownIt-Anchor" href="#23-source-code"></a> 2.3. source code</h2><h3 id="231-reassemblerhh"><a class="markdownIt-Anchor" href="#231-reassemblerhh"></a> 2.3.1 reassembler.hh</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Reassembler</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>  size_t next_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// the next ordered index,which will push to bytestream by writer</span>  size_t unordered_bytes_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> unordered_bytes_buffer <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// store unordered bytes</span>  <span class="token keyword">bool</span> byte_stream_end <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  size_t eof_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// function:let string legal</span>  <span class="token keyword">void</span> <span class="token function">process_substr</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> output <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// make sure no overlapping in reassembler buffer</span>  <span class="token keyword">void</span> <span class="token function">remove_overlap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="232-reassemblercc"><a class="markdownIt-Anchor" href="#232-reassemblercc"></a> 2.3.2 <a href="http://reassembler.cc">reassembler.cc</a></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"reassembler.hh"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"byte_stream.hh"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> first_index<span class="token punctuation">,</span> string data<span class="token punctuation">,</span> <span class="token keyword">bool</span> is_last_substring<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> output <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token function">process_substr</span><span class="token punctuation">(</span> first_index<span class="token punctuation">,</span> data<span class="token punctuation">,</span> output <span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"next_index: "</span> <span class="token operator">&lt;&lt;</span> next_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">==</span> next_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string next_substring <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"push to buffer!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> next_substring <span class="token punctuation">)</span><span class="token punctuation">;</span>    unordered_bytes_size <span class="token operator">-=</span> next_substring<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> first_index <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// key_type</span>  <span class="token punctuation">&#125;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_bytes_size: "</span> <span class="token operator">&lt;&lt;</span> unordered_bytes_size <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> is_last_substring <span class="token punctuation">)</span> <span class="token comment">// all bytes arrived</span>  <span class="token punctuation">&#123;</span>    byte_stream_end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    eof_index <span class="token operator">=</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> byte_stream_end <span class="token operator">&amp;&amp;</span> output<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> eof_index <span class="token punctuation">)</span> <span class="token comment">// all bytes pushed</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"All done!"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    output<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">process_substr</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> output <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* within the stream’s available capacity():   * [first_unassembled index,first unacceptable index]*/</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// empty input , will make last_index invalid (unsigned int -> -1 -> max int)</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"empty input!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  size_t begin_of_storage <span class="token operator">=</span> output<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// first_unassembled index</span>  size_t end_of_storage <span class="token operator">=</span> begin_of_storage <span class="token operator">+</span> output<span class="token punctuation">.</span><span class="token function">available_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// first unacceptable index -1</span>  size_t last_index <span class="token operator">=</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  next_index <span class="token operator">=</span> begin_of_storage<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"begin of storage: "</span> <span class="token operator">&lt;&lt;</span> begin_of_storage <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end_of_storage: "</span> <span class="token operator">&lt;&lt;</span> end_of_storage <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"last_index: "</span> <span class="token operator">&lt;&lt;</span> last_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> begin_of_storage <span class="token operator">></span> end_of_storage <span class="token punctuation">)</span> <span class="token comment">// buffer is full, waiting for ReadAll</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buffer is full and storage of reassembler is empty!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">></span> end_of_storage <span class="token operator">||</span> last_index <span class="token operator">&lt;</span> begin_of_storage <span class="token punctuation">)</span> <span class="token comment">// out of range</span>  <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index out of range!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">&lt;</span> begin_of_storage <span class="token operator">&amp;&amp;</span> last_index <span class="token operator">>=</span> begin_of_storage <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"keep tail!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> begin_of_storage <span class="token operator">-</span> first_index <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep tail</span>    first_index <span class="token operator">=</span> begin_of_storage<span class="token punctuation">;</span>                       <span class="token comment">// update first_index</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">>=</span> begin_of_storage <span class="token operator">&amp;&amp;</span> last_index <span class="token operator">></span> end_of_storage <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"keep head!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> end_of_storage <span class="token operator">-</span> first_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep head</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// cout &lt;&lt; "string process is done!" &lt;&lt; endl;</span>  <span class="token comment">// cout &lt;&lt; data &lt;&lt; endl;</span>  <span class="token function">remove_overlap</span><span class="token punctuation">(</span> first_index<span class="token punctuation">,</span> data <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cout &lt;&lt; "is not  overlap error" &lt;&lt; endl;</span>  unordered_bytes_buffer<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>  unordered_bytes_size <span class="token operator">+=</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">remove_overlap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span><span class="token operator">&amp;</span> first_index<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span> iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    size_t last_index <span class="token operator">=</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    size_t begin_index <span class="token operator">=</span> iter<span class="token operator">-></span>first<span class="token punctuation">;</span>    size_t end_index <span class="token operator">=</span> iter<span class="token operator">-></span>first <span class="token operator">+</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"begin_index: "</span> <span class="token operator">&lt;&lt;</span> begin_index <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">"end_index: "</span> <span class="token operator">&lt;&lt;</span> end_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">"last_index: "</span> <span class="token operator">&lt;&lt;</span> last_index <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> last_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> begin_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exactly append!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      data <span class="token operator">+=</span> iter<span class="token operator">-></span>second<span class="token punctuation">;</span>      unordered_bytes_size <span class="token operator">-=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not use erase(key), it will casue iterator invalid</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Overlap between head and tail.</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> first_index <span class="token operator">&lt;=</span> begin_index <span class="token operator">&amp;&amp;</span> begin_index <span class="token operator">&lt;=</span> last_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// = reason : "bc" "b"</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"append tail!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> end_index <span class="token operator">&lt;=</span> last_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// completely covered</span>        unordered_bytes_size <span class="token operator">-=</span> unordered_bytes_buffer<span class="token punctuation">[</span>begin_index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        data <span class="token operator">+=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> last_index <span class="token operator">-</span> begin_index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        unordered_bytes_size <span class="token operator">-=</span> unordered_bytes_buffer<span class="token punctuation">[</span>begin_index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> begin_index <span class="token operator">&lt;=</span> first_index <span class="token operator">&amp;&amp;</span> first_index <span class="token operator">&lt;=</span> end_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// = reason: "bc" "c"</span>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"append head!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> last_index <span class="token operator">&lt;=</span> end_index <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        first_index <span class="token operator">=</span> begin_index<span class="token punctuation">;</span>        data <span class="token operator">=</span> iter<span class="token operator">-></span>second<span class="token punctuation">;</span>        unordered_bytes_size <span class="token operator">-=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        data <span class="token operator">=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> first_index <span class="token operator">-</span> begin_index <span class="token punctuation">)</span> <span class="token operator">+</span> data<span class="token punctuation">;</span>        unordered_bytes_size <span class="token operator">-=</span> iter<span class="token operator">-></span>second<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iter <span class="token operator">=</span> unordered_bytes_buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        first_index <span class="token operator">=</span> begin_index<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token operator">++</span>iter<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after removing overlapping---"</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">"first_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">&lt;&lt;</span> <span class="token string">" last_index: "</span> <span class="token operator">&lt;&lt;</span> first_index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint64_t</span> <span class="token class-name">Reassembler</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">return</span> unordered_bytes_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="24-result"><a class="markdownIt-Anchor" href="#24-result"></a> 2.4. result</h2><img src="/2023/05/31/computer_network/CS144/61b17337a7d88a508fbce358e642c62e.png" class=""><h1 id="3-lab2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#3-lab2-the-tcp-receiver"></a> 3. lab2 the TCP receiver</h1><h2 id="31-translating-between-64-bit-indexes-and-32-bit-seqnos"><a class="markdownIt-Anchor" href="#31-translating-between-64-bit-indexes-and-32-bit-seqnos"></a> 3.1. Translating between 64-bit indexes and 32-bit seqnos</h2><img src="/2023/05/31/computer_network/CS144/0c490d98cf317a4773f7a4451f66c0c0.png" class=""><p>首先要解决的问题是，TCP有限的字节序列字段造成的有限字节序列范围进而导致的回绕问题，我们需要在永不会溢出的64位绝对序号和会发生回绕的32位相对序号之间实现转换，因为对重组器来说，字节流是从0开始的不会回绕的序列。此外，TCP随机的初始字节序号(ISN)为这个问题增加了难度</p><img src="/2023/05/31/computer_network/CS144/9f709e9806e18ae85d29faacc9785481.png" class=""><h3 id="311-wrapabsolute-seqno-to-seqno"><a class="markdownIt-Anchor" href="#311-wrapabsolute-seqno-to-seqno"></a> 3.1.1 wrap—absolute seqno to seqno</h3><p>把绝对序号转换为相对序号的wrap函数很简单，n的高32位表示绕了多少圈然后从0计数，带入这部分计算没有意义。因此截去n的高32位而将n的低32位与ISN相加即可得到目标相对序列（注释中有取余数的版本）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Wrap32 <span class="token class-name">Wrap32</span><span class="token double-colon punctuation">::</span><span class="token function">wrap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> n<span class="token punctuation">,</span> Wrap32 zero_point <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token comment">// return Wrap32 &#123; static_cast&lt;uint32_t>( ( n + zero_point.raw_value_ ) % ( 1ul &lt;&lt; 32 ) ) &#125;;</span>  <span class="token keyword">return</span> zero_point <span class="token operator">+</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="312-unwrap-seqno-to-absolute-seqno"><a class="markdownIt-Anchor" href="#312-unwrap-seqno-to-absolute-seqno"></a> 3.1.2 unwrap— seqno to absolute seqno</h3><p>这个函数给我干沉默了，我连别人的答案和解释都看不懂，说句惭愧的，我拿这玩意起码问了chatgpt几个小时，想了好几个小时，我都没整明白这个if语句是怎么来的，什么回绕之后ans要减去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，搞不懂。我说我在这个函数上磨了一天的时间都不夸张，还是理解不了，不管它了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">uint64_t</span> <span class="token class-name">Wrap32</span><span class="token double-colon punctuation">::</span><span class="token function">unwrap</span><span class="token punctuation">(</span> Wrap32 zero_point<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> checkpoint <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token keyword">uint64_t</span> uint32_range <span class="token operator">=</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span>  <span class="token keyword">uint32_t</span> offset <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>raw_value_ <span class="token operator">-</span> <span class="token function">wrap</span><span class="token punctuation">(</span> checkpoint<span class="token punctuation">,</span> zero_point <span class="token punctuation">)</span><span class="token punctuation">.</span>raw_value_<span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> ans <span class="token operator">=</span> checkpoint <span class="token operator">+</span> offset<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> offset <span class="token operator">>=</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token operator">&amp;&amp;</span> ans <span class="token operator">>=</span> uint32_range <span class="token punctuation">)</span> <span class="token comment">// ?</span>    ans <span class="token operator">-=</span> uint32_range<span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  <span class="token comment">// Your code here.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-implementing-the-tcp-receiver"><a class="markdownIt-Anchor" href="#32-implementing-the-tcp-receiver"></a> 3.2. Implementing the TCP receiver</h2><h3 id="321-receive"><a class="markdownIt-Anchor" href="#321-receive"></a> 3.2.1 receive</h3><p>对收到的message,首先要判断是否是SYN握手信息，并在收到此信息之后进入数据交换阶段（tcp连接已建立），因此要有一个bool变量<code>after_handshaking</code>标志现在是否处于三次握手之后的状态。在收到SYN后，因为SYN被置1的包的序号是发送端的随机初始序号ISN，因此将zero_point置为该值以便后续将相对序号<code>seqno</code>转变为绝对序号<code>absolute_seqno</code>。（为了声明和赋值zero_point成员变量，要在Wrap32类中添加指定的默认构造函数(= default)，复制构造函数和重载赋值运算符（这两个必须同时实现））</p><img src="/2023/05/31/computer_network/CS144/9818e9d7cdd833e176a6dd96ca42a339.png" class=""><p>因为重组器对收到的字节流，从0编号，因此传递给reassembler的first_index要去除SYN所占的序号(如果存在SYN)，用<code>first_index = absolute_seqno + message.SYN + -1</code>就可以一步解决（boolean类型为true时，本质是为1，反正false为0）<br />因此receive的实现如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">receive</span><span class="token punctuation">(</span> TCPSenderMessage message<span class="token punctuation">,</span> Reassembler<span class="token operator">&amp;</span> reassembler<span class="token punctuation">,</span> Writer<span class="token operator">&amp;</span> inbound_stream <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>after_handshaking <span class="token punctuation">)</span> <span class="token comment">// no handshaking</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> message<span class="token punctuation">.</span>SYN <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      after_handshaking <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// after handshaking</span>      zero_point <span class="token operator">=</span> Wrap32 <span class="token punctuation">&#123;</span> message<span class="token punctuation">.</span>seqno <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">uint64_t</span> checkpoint <span class="token operator">=</span> inbound_stream<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// first unassembled index</span>  <span class="token keyword">uint64_t</span> absolute_seqno <span class="token operator">=</span> <span class="token function">Wrap32</span><span class="token punctuation">(</span> message<span class="token punctuation">.</span>seqno <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span> zero_point<span class="token punctuation">,</span> checkpoint <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">uint64_t</span> first_index <span class="token operator">=</span> absolute_seqno <span class="token operator">+</span> message<span class="token punctuation">.</span>SYN <span class="token operator">+</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// since zero, remove SYN if exist</span>  reassembler<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> first_index<span class="token punctuation">,</span> message<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> message<span class="token punctuation">.</span>FIN<span class="token punctuation">,</span> inbound_stream <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="322-send"><a class="markdownIt-Anchor" href="#322-send"></a> 3.2.2 send</h3><p>TCP的接受端要向发送端反馈信息，实验的要求比实际情况是简化了的（不用为接受端的包生成随机初始序号），包括确认信息ackno和用于流量控制的窗口大小信息（rwnd, receiver window）window_size</p><ul><li>ackno：期望收到的下一个字节的序号（相对序号）</li><li>window_size：结合lab1和下图，可以看出window_size就是重组器用于排序的存储空间(storage)，可直接通过writer的available_capacity函数获得</li></ul><img src="/2023/05/31/computer_network/CS144/a77e7e0ef331e6368c1bc5ff65569cd9.png" class=""><p>因此send函数的实现如下：<br />根据文档描述</p><blockquote><p>in TCP the SYN (beginning-of-stream) and FIN (end-of-stream) control flags are assigned sequence numbers. Each of these occupies one sequence number. (The sequence number occupied by the SYN flag is the ISN.) Each byte of data in the stream also occupies one sequence number.</p></blockquote><p>如果接受方收到一个message后流结束了(<code>inbound_stream.is_closed()</code> )则说明该流包含FIN，而标志流结束的FIN还会占用一个序列号，所以此时next_expected_seq需要额外再加1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TCPReceiverMessage <span class="token class-name">TCPReceiver</span><span class="token double-colon punctuation">::</span><span class="token function">send</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Writer<span class="token operator">&amp;</span> inbound_stream <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// Your code here.</span>  TCPReceiverMessage msg<span class="token punctuation">;</span>  <span class="token comment">/*window_size*/</span>  <span class="token keyword">uint64_t</span> _available_capacity <span class="token operator">=</span> inbound_stream<span class="token punctuation">.</span><span class="token function">available_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  msg<span class="token punctuation">.</span>window_size <span class="token operator">=</span> _available_capacity <span class="token operator">></span> UINT16_MAX <span class="token operator">?</span> UINT16_MAX <span class="token operator">:</span> _available_capacity<span class="token punctuation">;</span>  <span class="token comment">/*ackno*/</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>after_handshaking <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    msg<span class="token punctuation">.</span>ackno <span class="token operator">=</span> nullopt<span class="token punctuation">;</span> <span class="token comment">// or &#123;&#125; instead</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint64_t</span> next_expected_seq <span class="token operator">=</span> inbound_stream<span class="token punctuation">.</span><span class="token function">bytes_pushed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> inbound_stream<span class="token punctuation">.</span><span class="token function">is_closed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// FIN</span>      <span class="token operator">++</span>next_expected_seq<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>ackno <span class="token operator">=</span> zero_point <span class="token operator">+</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span> next_expected_seq <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wrap</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> msg<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-result"><a class="markdownIt-Anchor" href="#33-result"></a> 3.3. result</h2><img src="/2023/05/31/computer_network/CS144/4ca2b48b339cd80c6d86e1d24d06da1e.png" class=""><h1 id="4-lab3-the-tcp-sender"><a class="markdownIt-Anchor" href="#4-lab3-the-tcp-sender"></a> 4. lab3 the TCP sender</h1><img src="/2023/05/31/computer_network/CS144/0c490d98cf317a4773f7a4451f66c0c0.png" class=""><p>下面讲讲实现过程中遇到的难点和debug过程</p><h2 id="41tcp_senderhh"><a class="markdownIt-Anchor" href="#41tcp_senderhh"></a> 4.1tcp_sender.hh</h2><p><a href="https://github.com/Elite-zx/CS144/blob/main/src/tcp_sender.hh">tcp_sender.hh</a><br />在<code>tcp_sender.hh</code>实现一个Timer类，注意rest_time使用int64_t类型， 我一开始顺手写成uint64_t导致超时无法触发，debug后才发现。</p><p>发送端的payload类型是Buffer, 这是一个包含智能指针的类，这使得发送端缓存已发生但未确认的seg时，只是增加了对同一块内存的引用计数，而不会真的复制payload。这体现了文档中的这样一句话</p><blockquote><p>This turns out not to be very wasteful because the TCPSenderMessage’s payload is stored as a reference-counted read-only string (a Buffer object). So don’t  worry about it—it’s not actually copying the payload data.</p></blockquote><p>当你复制<code>TCPSenderMessage</code>对象时，<code>Buffer</code>对象的复制也将涉及到<code>std::shared_ptr&lt;std::string&gt;</code>的复制。在复制<code>std::shared_ptr</code>时，它不会创建一个新的字符串对象，而是创建一个新的智能指针，指向同一个字符串对象，并将该对象的引用计数加1。这就意味着新的<code>TCPSenderMessage</code>对象和原始的<code>TCPSenderMessage</code>对象共享相同的<code>payload</code>。当最后一个指向该字符串对象的<code>std::shared_ptr</code>被销毁（该seg被确认因此缓存被清除）时，<code>std::shared_ptr</code>将自动删除其管理的字符串对象，从而防止内存泄漏。</p><img src="/2023/05/31/computer_network/CS144/f7c52fe07e3728ab4b4d5b84f335d6ce.png" class=""><h2 id="42-tcp_sendercc"><a class="markdownIt-Anchor" href="#42-tcp_sendercc"></a> 4.2. tcp_sender.cc</h2><p><a href="https://github.com/Elite-zx/CS144/blob/main/src/tcp_sender.cc">tcp_sender.cc</a></p><h3 id="421-设置fin位"><a class="markdownIt-Anchor" href="#421-设置fin位"></a> 4.2.1 设置FIN位</h3><p>发送方向接受方发送FIN被置true的包以标志流的结尾(marked with the SYN flag at the beginning of the stream, and FIN flag at the end.)</p><p>包含的FIN的包有两种情况</p><ul><li>一个数据包，其中FIN flag被置为true<br />即<strong>有可用空间时在段中搭载 FIN</strong>（Piggyback FIN in segment when space is available）<br />当outbound_stream中的数据均打包到data_seg中，stream is finished, 而接受窗口应该至少有一个空余字节(space is available))，此时要将最后一个数据包的FIN置1 (这里要多占一个字节）<br />看下图的测试用例，窗口的大小为8,而剩下的数据大小仅为4 bytes, 因此足以让最后一个数据包设置FIN位</li></ul><img src="/2023/05/31/computer_network/CS144/d9d31cacab2e25fe8ec17789df9afc85.png" class=""><ul><li>单独的一个FIN flag 包，payload为0<br />这种情况出现中，流传输完毕后，接受窗口被填满，此时<strong>没有多余空间为最后一个数据包添加FIN位</strong>，因此发送方在接受方的接受窗口有空余时，再发送一个单独的FIN包<br />看下图的测试用例，数据包正好占用了7个空间，填满了当前窗口 rwnd = 0 ，因此此时不能设置FIN位。在后续收到新的rwnd= 1的后，接受方知道有空余位置了，发送一个单独的FIN包</li></ul><img src="/2023/05/31/computer_network/CS144/780242ece281a0ca811c9b4811ea69dc.png" class=""><h3 id="422-debug"><a class="markdownIt-Anchor" href="#422-debug"></a> 4.2.2 debug</h3><p>遇到了一个很奇怪的测试用例&quot;SYN+FIN&quot;，这个用例要求我们同时设置SYN位和FIN位。首先发送方收到来自接受方的一个握手之前的ackno为nullopt的数据包(可能原因：网络延迟，旧链接断开之前的包在新链接建立之前达到)，接着发送方流向reader的流就关闭了，没有传出任何数据就关闭了。此时要求我们设置SYN+FIN的flag包，不包含任何数据负载。我只能在设置syn时检测流是否关闭从而通过这个测试用例，因为确实不知道什么情况下会有这样的包。</p><img src="/2023/05/31/computer_network/CS144/fe364c4d14e753567f3b654f7ea523e5.png" class=""><h3 id="423-result"><a class="markdownIt-Anchor" href="#423-result"></a> 4.2.3 result</h3><img src="/2023/05/31/computer_network/CS144/f9b40071ddfcc3d470d363c88538b467.png" class="">]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络自顶向下] Socket Programming Assignment + Miscellaneous Labs </title>
      <link href="/2023/05/24/computer_network/socket-programming/"/>
      <url>/2023/05/24/computer_network/socket-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="programming-tasks-of-computer-networking-a-topdown-approach"><a class="markdownIt-Anchor" href="#programming-tasks-of-computer-networking-a-topdown-approach"></a> Programming Tasks Of Computer-Networking-A-TopDown-Approach</h1><ul><li><p><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">WebServer</label></p></li><li><p><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">UDPPing</label></p></li><li><p><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">SMTP-Client</label></p></li><li><p><input type="checkbox" id="checkbox3" checked="true" /><label for="checkbox3">Proxy-Server</label></p></li><li><p><input type="checkbox" id="checkbox4" checked="true" /><label for="checkbox4">ABP-RDT</label></p></li><li><p><input type="checkbox" id="checkbox5" checked="true" /><label for="checkbox5">GBN-RDT</label></p></li></ul><h1 id="1-lab0-warmup"><a class="markdownIt-Anchor" href="#1-lab0-warmup"></a> 1 lab0 WarmUp</h1><h2 id="11-udp"><a class="markdownIt-Anchor" href="#11-udp"></a> 1.1. UDP</h2><ol><li><a href="http://UDPClient.py">UDPClient.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span> <span class="token comment"># ip or hostname , if is hostname,automatically carry out DNS lookup to find correspond ip</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span> <span class="token comment"># designate destination port number</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># create client socket(ipv4,udp), clientPort is automatically allocated by OS</span>message <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Input lowercase sentence:'</span><span class="token punctuation">)</span><span class="token comment"># message content and destination address(server_ip,server_ port),the clientAddress automatically add to the message by OS     </span>clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>modifiedMessage<span class="token punctuation">,</span> serverAddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># receive from server, 2048 is cache length</span><span class="token keyword">print</span><span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><a href="http://UDPServer.py">UDPServer.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span> <span class="token comment"># allocate server port number manually</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span><span class="token comment"># create server Socket(ipv4,udp)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># bind socket and port number, one socket one port number</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The server is ready to receive"</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    message<span class="token punctuation">,</span>clientAddress <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span> <span class="token comment"># receive message from client</span>    modifiedMessage <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done!"</span><span class="token punctuation">)</span>    serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>clientAddress<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>result</li></ol><img src="/2023/05/24/computer_network/socket-programming/e93c1c9715ac60bb573dff2d805ff6c1.png" class=""><h2 id="12-tcp"><a class="markdownIt-Anchor" href="#12-tcp"></a> 1.2. TCP</h2><ol><li><a href="http://TCPClient.py">TCPClient.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span> <span class="token comment"># local host</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>   <span class="token comment"># welcoming socket</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#clientPort is automatically allocated by OS</span><span class="token comment"># knock at the welcoming door(welcomingsocket),this will initiate tcp three-way handshakes</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span> sentence<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Input lowercase sentence:'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># send message without server addree,since tcp connection is built</span>modifiedSentence <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>modifiedSentence<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><a href="http://TCPServer.py">TCPServer.py</a></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span> <span class="token comment"># welcoming socket</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># maximal connection number(at least 1)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The server is ready to receive'</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># create a new socket(connectionSocket) which is delicated to client</span>    sentence <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># receive message from connectionSocket</span>    capitalizedSentence <span class="token operator">=</span> sentence<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"done!"</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>capitalizedSentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>result</li></ol><img src="/2023/05/24/computer_network/socket-programming/c35cfd0227d5a85385ed4ec273af3c8e.png" class=""><img src="/2023/05/24/computer_network/socket-programming/9dbdab3fe3d049875c34e21b56a2bde3.png" class=""><h1 id="lab1-web-server"><a class="markdownIt-Anchor" href="#lab1-web-server"></a> lab1  Web-Server</h1><h2 id="21-web-serverpy"><a class="markdownIt-Anchor" href="#21-web-serverpy"></a> 2.1. <a href="http://Web-Server.py">Web-Server.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#import socket module</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> sys <span class="token comment"># In order to terminate the program</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#Prepare a sever socket</span><span class="token comment">#Fill in start</span>serverPort <span class="token operator">=</span> <span class="token number">80</span> <span class="token comment"># allocate server port number manually</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment"># maximal connection number</span><span class="token comment">#Fill in end</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment">#Establish the connection</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    <span class="token comment">#Fill in start</span>    connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## create a new socket(connectionSocket) which is delicated to client</span>    <span class="token comment">#Fill in end</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment">#Fill in start</span>        message <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># receive message from connectionSocket</span>        <span class="token comment">#Fill in end</span>        filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># get filename from string list message</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment">#Fill in start</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#Fill in end</span>        <span class="token comment">#Send one HTTP header line into socket</span>        <span class="token comment">#Fill in start</span>        header <span class="token operator">=</span> <span class="token string">'HTTP/1.1 200 OK\r\nConnection: close\r\nDate: Tue, 23 May 2023 11:14:01 GMT\r\nContent-Type: text/html\r\nContent-Length: %d\r\n\r\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># Comply with the HTTP response message format</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">#Fill in end</span>        <span class="token comment">#Send the content of the requested file to the client</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>        <span class="token comment">#Send response message for file not found</span>        <span class="token comment">#Fill in start</span>        header <span class="token operator">=</span> <span class="token string">'HTTP/1.1 404 Not Found'</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>header<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">#Fill in end</span>        <span class="token comment">#Close client socket</span>        <span class="token comment">#Fill in start</span>        <span class="token comment">#Fill in end</span>        serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#Fill in end</span>serverSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#Terminate the program after sending the corresponding data</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用以下命令可以检查端口号80是否被占用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-tuln</span> <span class="token operator">|</span> <span class="token function">grep</span> :8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>HelloWorld.html放在Web-Server.py同目录下，内容如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 36px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Hello,World! This is Elite-zx web server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="22-result"><a class="markdownIt-Anchor" href="#22-result"></a> 2.2. result</h2><img src="/2023/05/24/computer_network/socket-programming/413b22962afb7e0a05c99a6b2663139f.png" class=""><h1 id="lab3-udppinger"><a class="markdownIt-Anchor" href="#lab3-udppinger"></a> lab3 UDPPinger</h1><h2 id="31-udppingerclientpy"><a class="markdownIt-Anchor" href="#31-udppingerclientpy"></a> 3.1. <a href="http://UDPPingerClient.py">UDPPingerClient.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">import</span> time serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span><span class="token punctuation">;</span>clientSocket<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># timeout is 1 second </span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sendTime <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>     message <span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'Ping %d %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>sendTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>        modifiedMessage<span class="token punctuation">,</span> serverAddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>        rtt <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> sendTime        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Sequence %d: RTT = %.3fs  Reply from %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>rtt<span class="token punctuation">,</span>serverName<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception<span class="token punctuation">:</span> <span class="token comment"># time out Exception, socket.timeout is not from BaseException</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Sequence %d: Request timed out'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-udppingerserverpy"><a class="markdownIt-Anchor" href="#32-udppingerserverpy"></a> 3.2. <a href="http://UDPPingerServer.py">UDPPingerServer.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># We will need the following module to generate randomized lost packets</span><span class="token keyword">import</span> random<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># Create a UDP socket</span><span class="token comment"># Notice the use of SOCK_DGRAM for UDP packets</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token comment"># Assign IP address and port number to socket</span>serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># Generate random number in the range of 0 to 10</span>    rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token comment"># Receive the client packet along with the address it is coming from</span>    message<span class="token punctuation">,</span> address <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token comment"># Capitalize the message from the client</span>    message <span class="token operator">=</span> message<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># If rand is less is than 4, we consider the packet lost and do not respond</span>    <span class="token keyword">if</span> rand <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span>    <span class="token comment"># Otherwise, the server responds</span>    serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-result"><a class="markdownIt-Anchor" href="#33-result"></a> 3.3. result</h2><img src="/2023/05/24/computer_network/socket-programming/74e8a02e61f32df5efa4d22b1d92b233.png" class=""><h1 id="lab4-smtp-client"><a class="markdownIt-Anchor" href="#lab4-smtp-client"></a> lab4 SMTP-Client</h1><h2 id="41-smtp-mailclientpy"><a class="markdownIt-Anchor" href="#41-smtp-mailclientpy"></a> 4.1. <a href="http://SMTP-MailClient.py">SMTP-MailClient.py</a></h2><p>这里访问的是Gmail的服务器，因此多了2个额外的步骤</p><ul><li>建立TLS (Transport Layer Security) 连接，为了加密</li><li>在Google账户中开启双重验证，为Gmail设置单独的密码，直接用Google账户的密码AUTH LOGIN，Gmail服务器不认的，会返回<code>535-5.7.8 Username and Password not accepted</code>。如果账户密码正确，则返回<code>235 2.7.0 Accepted</code><br />注意账户密码使用base64编码，这可以通过<code>base64.b64encode</code>函数做到</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> base64<span class="token keyword">import</span> sslmsg <span class="token operator">=</span> <span class="token string">"\r\n Elite-ZX love computer networks!"</span>endmsg <span class="token operator">=</span> <span class="token string">"\r\n.\r\n"</span><span class="token comment"># Choose a mail server (e.g. Google mail server) and call it mailserver</span><span class="token comment">#Fill in start</span>mailServer <span class="token operator">=</span> <span class="token string">'smtp.gmail.com'</span>mailPort <span class="token operator">=</span> <span class="token number">587</span>fromAddress <span class="token operator">=</span> <span class="token string">'********@gmail.com'</span>toAddress <span class="token operator">=</span> <span class="token string">'********@qq.com'</span>username <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span><span class="token string">b'********@gmail.com'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>password <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span><span class="token string">b'********'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#Fill in end</span><span class="token comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span><span class="token comment">#Fill in start</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>mailServer<span class="token punctuation">,</span>mailPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#Fill in end</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'220 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Send HELO command and print server response.</span>heloCommand <span class="token operator">=</span> <span class="token string">'HELO Elite-zx\r\n'</span><span class="token keyword">print</span><span class="token punctuation">(</span>heloCommand<span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>heloCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv1 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv1<span class="token punctuation">)</span><span class="token keyword">if</span> recv1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Send STARTTLS command and print server response</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'STARTTLS\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'220'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'220 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Create TLS connection</span>context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>clientSocket <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>clientSocket<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span><span class="token string">'smtp.gmail.com'</span><span class="token punctuation">)</span><span class="token comment"># Send AUTH LOGIN command </span>authLoginCommand<span class="token operator">=</span><span class="token string">'AUTH LOGIN\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>authLoginCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'334'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'334 reply not received from server'</span><span class="token punctuation">)</span><span class="token comment"># Send username</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span>username<span class="token operator">+</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'334'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'334 reply not received from server'</span><span class="token punctuation">)</span><span class="token comment"># Send password </span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span>password<span class="token operator">+</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>recv<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'235'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'235 reply not received from server'</span><span class="token punctuation">)</span><span class="token comment"># Send MAIL FROM command and print server response.</span><span class="token comment"># Fill in start</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'MAIL FROM: &lt;'</span> <span class="token operator">+</span> fromAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'MAIL FROM: &lt;'</span> <span class="token operator">+</span> fromAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv2 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv2<span class="token punctuation">)</span><span class="token keyword">if</span> recv2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send RCPT TO command and print server response.</span><span class="token comment"># Fill in start</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'RCPT TO: &lt;'</span><span class="token operator">+</span> toAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'RCPT TO: &lt;'</span><span class="token operator">+</span> toAddress <span class="token operator">+</span> <span class="token string">'>\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv3 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv3<span class="token punctuation">)</span><span class="token keyword">if</span> recv3<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send DATA command and print server response.</span><span class="token comment"># Fill in start</span>DataCommand <span class="token operator">=</span> <span class="token string">'DATA\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>DataCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv4 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv4<span class="token punctuation">)</span><span class="token keyword">if</span> recv4<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'354'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'354 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send message data.</span><span class="token comment"># Fill in start</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Message ends with a single period.</span><span class="token comment"># Fill in start</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>endmsg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv5 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv5<span class="token punctuation">)</span><span class="token keyword">if</span> recv5<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'250'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'250 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span class="token comment"># Send QUIT command and get server response.</span><span class="token comment"># Fill in start</span>QuitCommand <span class="token operator">=</span> <span class="token string">'QUIT\r\n'</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>QuitCommand<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>recv6 <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>recv6<span class="token punctuation">)</span><span class="token keyword">if</span> recv6<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'221'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'221 reply not received from server.'</span><span class="token punctuation">)</span><span class="token comment"># Fill in end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="42-result"><a class="markdownIt-Anchor" href="#42-result"></a> 4.2. result</h2><img src="/2023/05/24/computer_network/socket-programming/d23d0311f3b4833f4d77f9aba232d1a2.png" class=""><img src="/2023/05/24/computer_network/socket-programming/b33d5322851ce8be0201013b6348a331.png" class=""><h1 id="lab5-proxyserver"><a class="markdownIt-Anchor" href="#lab5-proxyserver"></a> lab5 ProxyServer</h1><h2 id="51-setback-road"><a class="markdownIt-Anchor" href="#51-setback-road"></a> 5.1. setback road</h2><p>这个实验我踩了很多坑，一来是因为文档给出的源码与python3有很多不合的地方，二来网上没有很好的参考，包括<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES/blob/master/SocketProgrammingAssignment/%E4%BD%9C%E4%B8%9A4-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BD%9C%E4%B8%9A4-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%A7%A3%E7%AD%94.md">github上热度很高的那个参考</a>对我也不可行。因此我靠着添加try-except语句，stackoverflow以及chatgpt的分析，花了一个五六个小时总算是做出来了。<br />下面我将列举我踩的坑</p><ul><li>端口80默认绑定到http协议，因此访问https的网站将被拒绝连接。大多数网站即使你的URL是http还是会给你重定向到https，因此建议使用<a href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html%E8%BF%9B%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%96%87%E6%A1%A3%E9%87%8C%E6%8F%90%E5%88%B0%E7%9A%84www.google.com%E6%80%95%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A1%8C%E5%90%A7%F0%9F%A4%A8">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html进行结果测试，文档里提到的www.google.com怕是不可行吧🤨</a></li><li>关于split和partition的使用，目的是在URL中提取出源服务器gaia.cs.umass.edu和目标文件路径wireshark-labs/INTRO-wireshark-file1.html，要根据你访问的网站做调整</li><li>send函数内的参数均要加上用encode()处理，使参数从字符流变成字节流，否则会抛出<code>a bytes-like object is required, not 'str'</code>的异常</li><li><code>makefile()</code>函数返回一个与socket关联的文件对象，这里应该使用<code>fileobj = c.makefile('rw',None)</code>，则不是文档里的<code>fileobj = c.makefile('r', 0)</code>，首先参数0是python2中的，在python3已被替换为None, 而且如果用只读模式打开，后续write将会抛出不可写入的异常</li><li><code>fileobj.write(&quot;GET /&quot;.encode()+ filename.encode() + &quot; HTTP/1.0\r\n\r\n&quot;.encode())</code>的执行迟迟不结束，原来是发送的http请求先被放入了内部缓冲区等待发送，添加<code>fileobj.flush() </code>刷新缓冲区，立即发送请求</li><li>一开始参考了github上的代码直接转发message即<code>c.sendall(message.encode())</code>，可是浏览器总是会先发出先自动<code>GET /favicon.ico HTTP/1.1</code>的请求，查阅stackflow后，这个行为要修改html头部才能避免，因此只能采用文档提供的方法即自己构造HTTP请求（虽然浏览器在该请求之后还是会自动发出<code>GET /favicon.ico HTTP/1.1</code>请求😕）</li><li>因为目标路径文件包含一个子目录，因此要先在代理服务器下创建一个wireshark-labs的文件夹以避免<code>tmpFile = open(&quot;./&quot; + filename,&quot;wb&quot;)</code>抛出子目录不存在的异常）</li></ul><h2 id="52-proxyserverpy"><a class="markdownIt-Anchor" href="#52-proxyserverpy"></a> 5.2 <a href="http://ProxyServer.py">ProxyServer.py</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> sys<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment"># get listening port</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>'Usage <span class="token punctuation">:</span> <span class="token string">"python ProxyServer.py listening_port"</span>\n<span class="token punctuation">[</span>server_ip <span class="token punctuation">:</span> It <span class="token keyword">is</span> the listening\            port of Proxy Server'<span class="token punctuation">)</span>    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment"># Create a server socket, bind it to a port and start listening</span>tcpSerSock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token comment"># Fill in start.</span>tcpSerPort <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>tcpSerPort<span class="token punctuation">)</span><span class="token punctuation">)</span>tcpSerSock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment"># Fill in end.</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token comment"># Start receiving data from the client</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ready to serve...'</span><span class="token punctuation">)</span>    tcpCliSock<span class="token punctuation">,</span> addr <span class="token operator">=</span> tcpSerSock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received a connection from: '</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>    <span class="token comment"># Fill in start.</span>    message <span class="token operator">=</span> tcpCliSock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Fill in end.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"message content: "</span> <span class="token punctuation">,</span> message<span class="token punctuation">)</span>    <span class="token comment"># Extract the filename from the given message</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"URL: "</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    filename <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"filename: "</span> <span class="token punctuation">,</span> filename<span class="token punctuation">)</span>    fileExist <span class="token operator">=</span> <span class="token string">"false"</span>    <span class="token comment"># print(filetouse)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span><span class="token comment"># Check wether the file exist in the cache</span>        f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>        outputdata <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>        fileExist <span class="token operator">=</span> <span class="token string">"true"</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Target file exist!"</span><span class="token punctuation">)</span>        <span class="token comment"># ProxyServer finds a cache hit and generates a response message</span>        tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.0 200 OK\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"Content-Type:text/html\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Fill in start.</span>        <span class="token comment"># send file content</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputdata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>outputdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Fill in end.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Read from cache'</span><span class="token punctuation">)</span>    <span class="token comment"># Error handling for file not found in cache</span>    <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>        <span class="token keyword">if</span> fileExist <span class="token operator">==</span> <span class="token string">"false"</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Target file no exist!"</span><span class="token punctuation">)</span>            <span class="token comment"># Create a socket on the proxyserver</span>            <span class="token comment"># Fill in start.</span>            c <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>            <span class="token comment"># Fill in end.</span>            hostn <span class="token operator">=</span> message<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"www."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># remove www. get hostname</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"source server host: "</span> <span class="token punctuation">,</span> hostn <span class="token punctuation">)</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                <span class="token comment"># Connect to the socket to port 80</span>                <span class="token comment"># Fill in start.</span>                c<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>hostn<span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"proxy server's socket connected to source server!"</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in end.</span>                <span class="token comment"># Create a temporary file on this socket and ask port 80</span>                <span class="token comment"># for the file requested by the client</span>                <span class="token comment">#print("will open fileobj!")</span>                <span class="token comment">#try:</span>                fileobj <span class="token operator">=</span> c<span class="token punctuation">.</span>makefile<span class="token punctuation">(</span><span class="token string">'rw'</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">)</span>                <span class="token comment">#except Exception as e:</span>                <span class="token comment">#    print("Exception occurred while making file:", str(e))</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"open fileobj!"</span><span class="token punctuation">)</span>                <span class="token comment"># approach + url + version of http + empty line + empty header</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>                    number <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"GET "</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> filename<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" HTTP/1.0\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>                    fileobj<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># Send immediately, do not wait</span>                <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Exception occurred while writing file:"</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"requested sent to source server!"</span><span class="token punctuation">)</span>                <span class="token comment"># Read the response into buffer</span>                <span class="token comment"># Fill in start.</span>                <span class="token comment">#c.sendall(message.encode())</span>                <span class="token comment">#buff = c.recv(2048)</span>                <span class="token builtin">buffer</span> <span class="token operator">=</span> fileobj<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>                tcpCliSock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"buffer is ready!"</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in end.</span>                                <span class="token comment"># Create a new file in the cache for the requested file.</span>                tmpFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"./"</span> <span class="token operator">+</span> filename<span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in start.</span>                tmpFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">)</span>                tmpFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># Fill in end.</span>            <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Exception: "</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Illegal request"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># HTTP response message for file not found</span>            <span class="token comment"># Fill in start.</span>            tcpCliSock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"HTTP/1.1 404 Not Found\r\n\r\n"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'File Not Found'</span><span class="token punctuation">)</span>            <span class="token comment"># Fill in end.</span>    <span class="token comment"># Close the client and the server sockets</span>    tcpCliSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Fill in start.</span>tcpSerSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Fill in end.   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="53result"><a class="markdownIt-Anchor" href="#53result"></a> 5.3.result</h2><p>首次访问proxy server<br /><a href="http://localhost:8080/gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html">http://localhost:8080/gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html</a><br />代理服务器上没有目标文件，因此它向源服务器发出请求，在得到文件后转发给client并缓存目标文件在代理服务器本地</p><img src="/2023/05/24/computer_network/socket-programming/010ebfd181aef963fb5dc1ee0e4d6c8c.png" class=""><p>client端获取成功</p><img src="/2023/05/24/computer_network/socket-programming/b311d99e137e0737fee01f705f1f02a8.png" class=""><p>此时wireshark-labs目录下已经多了一个缓存文件</p><img src="/2023/05/24/computer_network/socket-programming/db6ca4c65166d4a1cda7e465689748eb.png" class=""><p>再次访问proxy server，可以看到代理服务器直接返回了已缓存的文件</p><img src="/2023/05/24/computer_network/socket-programming/51c4634ee69a357a132cb7d1c05dc65e.png" class=""><p>client端获取成功</p><img src="/2023/05/24/computer_network/socket-programming/b763c137d8a41fca75d9cbc4c7da7c1d.png" class=""><h1 id="reliable-transport-protocol"><a class="markdownIt-Anchor" href="#reliable-transport-protocol"></a> Reliable Transport Protocol</h1><p><em>Tell me and I forget. Show me and I remember. Involve me and I understand.</em></p><h2 id="1-stop-and-wait-alternating-bit"><a class="markdownIt-Anchor" href="#1-stop-and-wait-alternating-bit"></a> 1. Stop And Wait / Alternating-Bit</h2><p>我实现的版本更像是rdt3.0，没有使用NAK，而是通过为ACK编号让接受方判断是否收到了正确的反馈信息，只要在接受方B没有收到目标packet时在ack_packet的acknum字段填入上次收到的packet序号即可。因为B反馈的ack_packet没有要求装入数据，因此ack_packet的payload字段为空，那么相应的checksum字段也不需要加上payload了，ack_packet的seqnum在该协议中没有约束。</p><p>为网络模拟器版本纠错，把exit()改成exit(0)<br />实验开始前，阅读文档提供的<a href="http://gaia.cs.umass.edu/kurose/transport/programming_assignment_QA.htm">问答</a>可以解决一些你的疑惑</p><h3 id="11-analyze"><a class="markdownIt-Anchor" href="#11-analyze"></a> 1.1 analyze</h3><p>发送方FSM，用A_status的4个值表示4种状态</p><img src="/2023/05/24/computer_network/socket-programming/89b16b7b14b82b04ee59f46aab1a6b85.png" class=""><p>接受方的FSM，用B_status的2个值表示2种状态</p><img src="/2023/05/24/computer_network/socket-programming/c3563a3317ec4f89aa04e5d5b7b003d9.png" class=""><h3 id="12-source-code"><a class="markdownIt-Anchor" href="#12-source-code"></a> 1.2. source code</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">/* ****************************************************************** ALTERNATING BIT AND GO-BACK-N NETWORK EMULATOR: VERSION 1.1  J.F.Kurose   This code should be used for PA2, unidirectional or bidirectional   data transfer protocols (from A to B. Bidirectional transfer of data   is for extra credit and is not required).  Network properties:   - one way network delay averages five time units (longer if there     are other messages in the channel for GBN), but can be larger   - packets can be corrupted (either the header or the data portion)     or lost, according to user-defined probabilities   - packets will be delivered in the order in which they were sent     (although some can be lost).**********************************************************************/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIDIRECTIONAL</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">/* change to 1 if you're doing extra credit */</span></span>                        <span class="token comment">/* and write a routine called B_output */</span><span class="token keyword">int</span> sndPkt_seq<span class="token punctuation">;</span>  <span class="token comment">// 0,1,0,1...</span><span class="token keyword">int</span> A_status<span class="token punctuation">;</span>    <span class="token comment">// 4 status in FSM rdt3.0, 0 is iniital status</span><span class="token keyword">int</span> B_status<span class="token punctuation">;</span>    <span class="token comment">// 2 status in FSM rdt2.2, waiting for packet 0 or 1</span><span class="token comment">/* a "msg" is the data unit passed from layer 5 (teachers code) to layer  */</span><span class="token comment">/* 4 (students' code).  It contains the data (characters) to be delivered */</span><span class="token comment">/* to layer 5 via the students transport level protocol entities.         */</span><span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* a packet is the data unit passed from layer 4 (students code) to layer */</span><span class="token comment">/* 3 (teachers code).  Note the pre-defined packet structure, which all   */</span><span class="token comment">/* students must follow. */</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> seqnum<span class="token punctuation">;</span>    <span class="token keyword">int</span> acknum<span class="token punctuation">;</span>    <span class="token keyword">int</span> checksum<span class="token punctuation">;</span>    <span class="token keyword">char</span> payload<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> cachedPkt<span class="token punctuation">;</span><span class="token comment">/********* STUDENTS WRITE THE NEXT SEVEN ROUTINES *********/</span><span class="token comment">/* called from layer 5, passed the data to be sent to other side */</span><span class="token function">A_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>A_status <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> A_status <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sender A is waiting for ACK!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// waiting for ACK;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> sndPkt<span class="token punctuation">;</span>    <span class="token comment">/*make_Pkt*/</span>    sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> sndPkt_seq <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>acknum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// not a ACKnowledged package</span>    sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">=</span> sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> sndPkt<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">+=</span> message<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>sndPkt<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> message<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A is sending packet %d !\n"</span><span class="token punctuation">,</span> sndPkt<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*cache_pkt*/</span>    cachedPkt <span class="token operator">=</span> sndPkt<span class="token punctuation">;</span>    <span class="token comment">/*udt_send(sndPKt)*/</span>    <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> sndPkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*start timer*/</span>    <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*switch status of A*/</span>    <span class="token operator">++</span>A_status<span class="token punctuation">;</span>    <span class="token operator">++</span>sndPkt_seq<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">B_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment">/* need be completed only for extra credit */</span>    <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 */</span><span class="token function">A_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>A_status <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> A_status <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// incorrect status</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token comment">/*no payload of ack packet*/</span>    <span class="token comment">/* notcorrupt and is target ACK*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">==</span> packet<span class="token punctuation">.</span>checksum <span class="token operator">&amp;&amp;</span> cachedPkt<span class="token punctuation">.</span>seqnum <span class="token operator">==</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ACK %d packet  is not corrupt!\n"</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* stop timer*/</span>        <span class="token function">stoptimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        A_status <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>A_status<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"corrupt or not target ACK %d! will timeout and retransmit!\n"</span><span class="token punctuation">,</span>               cachedPkt<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// corrupt or is not target ack ,waiting for timeout</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when A's timer goes off */</span><span class="token function">A_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sender A is retransmiting packet %d !\n"</span><span class="token punctuation">,</span> cachedPkt<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*udt_send*/</span>    <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cachedPkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*start timer*/</span>    <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following routine will be called once (only) before any other */</span><span class="token comment">/* entity A routines are called. You can use it to do any initialization */</span><span class="token function">A_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sndPkt_seq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// initial status of sender A---waiting for message from layer5</span>    A_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* Note that with simplex transfer from a-to-B, there is no B_output() */</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 at B*/</span><span class="token function">B_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> ack_packet<span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> tmp_checksum <span class="token operator">+=</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* notcorrupt and is target packet*/</span>    ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">==</span> packet<span class="token punctuation">.</span>checksum <span class="token operator">&amp;&amp;</span> B_status <span class="token operator">==</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"notcorrupt and target packet %d! sending right ACK!\n"</span><span class="token punctuation">,</span>               packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*extract*/</span>        <span class="token keyword">struct</span> <span class="token class-name">msg</span> extract_msg<span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>extract_msg<span class="token punctuation">.</span>data<span class="token punctuation">,</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*deliver_data*/</span>        <span class="token function">tolayer5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> extract_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> B_status<span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span>            ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>  <span class="token comment">// no payload</span>        <span class="token comment">/*make_Pkt*/</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>        B_status <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>B_status<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// switch B status</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"corrupt or not target packet! sending last receiving ACK!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> <span class="token punctuation">(</span>B_status <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span>            ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>  <span class="token comment">// no payload</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when B's timer goes off */</span><span class="token function">B_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following rouytine will be called once (only) before any other */</span><span class="token comment">/* entity B routines are called. You can use it to do any initialization */</span><span class="token function">B_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> B_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-result"><a class="markdownIt-Anchor" href="#12-result"></a> 1.2. result</h3><h4 id="21-no-loss-and-corruption"><a class="markdownIt-Anchor" href="#21-no-loss-and-corruption"></a> 2.1. no loss and corruption</h4><p>一来一回，运行正常， packet 0与ack 0对应，packet 1与ack 1对应</p><img src="/2023/05/24/computer_network/socket-programming/ccfe78ace391eb03d86554132cc0c2a0.png" class=""><h4 id="22-loss-and-corruption"><a class="markdownIt-Anchor" href="#22-loss-and-corruption"></a> 2.2 loss and corruption</h4><p>虽然只设置了0.2的丢包率和损失率，但是实际上概率还是挺大的，可能是随机数生成器的问题，下面将分析部分输出来验证代码的正确性</p><p>A先发送packet0, B成功接受了packet0,但是反馈信息在layer3中被损坏，A收到损坏的ack信息后等待超时重传，重传2次的2个包都丢了，接着超时重传，发出的包又损坏了(这也太频繁了)，期间A收到来自上层layer5的数据包，但是由于这是stop and wait协议，在收到发出的包的确认之前不能发送新的包，因此A只打印它在等待ack的信息。B端收到A重传的数据包，发现这不是它想要的数据包，而是冗余的数据包，因此它丢弃该包（不上传到layer5），并重新对这个序号（最后一次成功收到的序号）的包发出确认，A端收到想要的确认后，发出packet 1</p><img src="/2023/05/24/computer_network/socket-programming/5b35c846e62834a821321e293a9e051d.png" class=""><img src="/2023/05/24/computer_network/socket-programming/37f5283f60325d87878bbd777a9bb644.png" class=""><img src="/2023/05/24/computer_network/socket-programming/d5f2639399ae272b158f370885f2fbaa.png" class=""><h2 id="2-go-back-n"><a class="markdownIt-Anchor" href="#2-go-back-n"></a> 2. Go-Back-N</h2><h3 id="21-analyze"><a class="markdownIt-Anchor" href="#21-analyze"></a> 2.1 analyze</h3><p>基于任务1, 完成GBN版本是比较轻松的，编写加调试只花了3个小时。接受方只需维护接受到<strong>最后有序packet的序号last_rcv_seq</strong>即可，在收到失序的重复的packet时发出包含last_rcv_seq的ACK即可告诉发送方自己可以确认了包含last_rcv_seq之前的所有包。因为存在ack到达之前，发送方超时重传的现象，因此发送方可能会收到冗余的ack信息，因此要设置一个acknum小于base的分支</p><p>发送方维护base和nextseq两个变量以表示window的发送边界，base表示窗口内最早发送但是未确认的序号（最右侧，窗口左移），nextseq表示下一个待发送的序号。因此当base = nextseq时，说明此时窗口内已经的packet均是待发送状态，此时只需要停止计时器，等待发送后启动计时器</p><p>注意这期间只有唯一的计时器，该计时器在窗口移动时重新记时<br />发送方FSM与接受方FSM：<br />纠正下图的&quot;如果下一个分组未发送&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> “如果窗口内的包均被确认<code>base == nextsequm</code>，则停止计时器，此时窗口内均是未发送的包，见下图 ，否则说明窗口内还有发送但未确认的包，重开计时器”</p><img src="/2023/05/24/computer_network/socket-programming/32d267d6b7b57841c28884749ca8b64b.png" class=""><h3 id="22-source-code"><a class="markdownIt-Anchor" href="#22-source-code"></a> 2.2 source code</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">/******************************************************************* ALTERNATING BIT AND GO-BACK-N NETWORK EMULATOR: VERSION 1.1  J.F.Kurose   This code should be used for PA2, unidirectional or bidirectional   data transfer protocols (from A to B. Bidirectional transfer of data   is for extra credit and is not required).  Network properties:   - one way network delay averages five time units (longer if there     are other messages in the channel for GBN), but can be larger   - packets can be corrupted (either the header or the data portion)     or lost, according to user-defined probabilities   - packets will be delivered in the order in which they were sent     (although some can be lost).**********************************************************************/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIDIRECTIONAL</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">/* change to 1 if you're doing extra credit */</span></span>                        <span class="token comment">/* and write a routine called B_output */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>   <span class="token comment">// window size of sliding-window protocol</span><span class="token keyword">int</span> last_rev_seq<span class="token punctuation">;</span>  <span class="token comment">// last receiving packet seq in receriver B</span><span class="token keyword">int</span> expected_seq<span class="token punctuation">;</span>  <span class="token comment">// expected packet sequence in receriver B</span><span class="token keyword">int</span> base<span class="token punctuation">;</span>          <span class="token comment">// start seq of sending window in sender A</span><span class="token keyword">int</span> nextseq<span class="token punctuation">;</span>       <span class="token comment">// next packet to be sent in the sending sliding window</span><span class="token comment">/* a "msg" is the data unit passed from layer 5 (teachers code) to layer  */</span><span class="token comment">/* 4 (students' code).  It contains the data (characters) to be delivered */</span><span class="token comment">/* to layer 5 via the students transport level protocol entities.         */</span><span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* a packet is the data unit passed from layer 4 (students code) to layer */</span><span class="token comment">/* 3 (teachers code).  Note the pre-defined packet structure, which all   */</span><span class="token comment">/* students must follow. */</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> seqnum<span class="token punctuation">;</span>    <span class="token keyword">int</span> acknum<span class="token punctuation">;</span>    <span class="token keyword">int</span> checksum<span class="token punctuation">;</span>    <span class="token keyword">char</span> payload<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pkt</span> buffer<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// buffer in sending A in order to retransmit</span><span class="token comment">/* called from layer 5, passed the data to be sent to other side */</span><span class="token function">A_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextseq <span class="token operator">>=</span> base <span class="token operator">+</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sending window is full now!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// window is full</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* make pkt*/</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> sndPkt<span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> nextseq<span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>acknum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// not a acknowledged packet</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>sndPkt<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> message<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">=</span> sndPkt<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> sndPkt<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> sndPkt<span class="token punctuation">.</span>checksum <span class="token operator">+=</span> sndPkt<span class="token punctuation">.</span>payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A is sending packet %d\n"</span><span class="token punctuation">,</span> nextseq<span class="token punctuation">)</span><span class="token punctuation">;</span>    buffer<span class="token punctuation">[</span>nextseq<span class="token punctuation">]</span> <span class="token operator">=</span> sndPkt<span class="token punctuation">;</span>    <span class="token comment">/*udt_send*/</span>    <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> sndPkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>base <span class="token operator">==</span> nextseq<span class="token punctuation">)</span>  <span class="token comment">// first packet of sending window, start timer</span>        <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>nextseq<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">B_output</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment">/* need be completed only for extra credit */</span>    <span class="token keyword">struct</span> <span class="token class-name">msg</span> message<span class="token punctuation">;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 */</span><span class="token function">A_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">!=</span> packet<span class="token punctuation">.</span>checksum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>            <span class="token string">"ACK %d packet  is  corrupt! will timeout and retransmit all "</span>            <span class="token string">"packets in the sliding window!\n"</span><span class="token punctuation">,</span>            packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>packet<span class="token punctuation">.</span>acknum <span class="token operator">&lt;</span> base<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"duplicated ACK %d"</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ACK %d packet is not corrupt or duplicated! \n"</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span>acknum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*base = getacknum(rcvpkt) + 1 */</span>    base <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>base <span class="token operator">==</span> nextseq<span class="token punctuation">)</span>  <span class="token comment">// no packets sent in sliding window</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"no packet sent in sliding window! stop timer! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stoptimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>  <span class="token comment">// exist unacknowledged packet in the window</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>            <span class="token string">"The earliest sent packet is acknowledged, restart timer and move "</span>            <span class="token string">"sliding window!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stoptimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when A's timer goes off */</span><span class="token function">A_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*Go Back N  */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Elite-zx: sender A GO BACK N, from packet %d to packet %d \n"</span><span class="token punctuation">,</span> base<span class="token punctuation">,</span>           nextseq <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> base<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextseq<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">starttimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following routine will be called once (only) before any other */</span><span class="token comment">/* entity A routines are called. You can use it to do any initialization */</span><span class="token function">A_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    nextseq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* Note that with simplex transfer from a-to-B, there is no B_output() */</span><span class="token comment">/* called from layer 3, when a packet arrives for layer 4 at B*/</span><span class="token function">B_input</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">pkt</span> packet<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">pkt</span> ack_packet<span class="token punctuation">;</span>    ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">=</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp_checksum <span class="token operator">=</span> packet<span class="token punctuation">.</span>acknum <span class="token operator">+</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> tmp_checksum <span class="token operator">+=</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp_checksum <span class="token operator">==</span> packet<span class="token punctuation">.</span>checksum <span class="token operator">&amp;&amp;</span> packet<span class="token punctuation">.</span>seqnum <span class="token operator">==</span> expected_seq<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        last_rev_seq <span class="token operator">=</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">;</span>        <span class="token operator">++</span>expected_seq<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"notcorrupt and expected packet %d! sending right ACK %d!\n"</span><span class="token punctuation">,</span>               packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">,</span> last_rev_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*extract*/</span>        <span class="token keyword">struct</span> <span class="token class-name">msg</span> extract_msg<span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>extract_msg<span class="token punctuation">.</span>data<span class="token punctuation">,</span> packet<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*deliver_data*/</span>        <span class="token function">tolayer5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> extract_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* make_pkt*/</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> last_rev_seq<span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span> ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>            <span class="token string">"corrupt or not expected packet %d (%d)! sending last receiving "</span>            <span class="token string">"ACK "</span>            <span class="token string">"%d!\n"</span><span class="token punctuation">,</span>            expected_seq<span class="token punctuation">,</span> packet<span class="token punctuation">.</span>seqnum<span class="token punctuation">,</span> last_rev_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>acknum <span class="token operator">=</span> last_rev_seq<span class="token punctuation">;</span>        ack_packet<span class="token punctuation">.</span>checksum <span class="token operator">=</span> ack_packet<span class="token punctuation">.</span>seqnum <span class="token operator">+</span> ack_packet<span class="token punctuation">.</span>acknum<span class="token punctuation">;</span>        <span class="token function">tolayer3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ack_packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* called when B's timer goes off */</span><span class="token function">B_timerinterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">/* the following rouytine will be called once (only) before any other */</span><span class="token comment">/* entity B routines are called. You can use it to do any initialization */</span><span class="token function">B_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    last_rev_seq <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    expected_seq <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23-result"><a class="markdownIt-Anchor" href="#23-result"></a> 2.3. result</h3><h4 id="21-no-loss-and-corruption-2"><a class="markdownIt-Anchor" href="#21-no-loss-and-corruption-2"></a> 2.1 no loss and corruption</h4><p>下面将分析部分输出来验证代码的正确性</p><p>A先发出两个packet，B对这两个packet进行了确认，A收到确认，窗口右移2次，此时窗口内没有已发送的包，因此暂停计时器。</p><img src="/2023/05/24/computer_network/socket-programming/276f5e6671463694fb72993989cb865e.png" class=""><p>接着A发出packet2,3,4，B对这3个包逐一确认，但A在收到packet2的确认之前超时，A重传packet 2 to 4。B对packet2,3,4的ack到达A后，A移动窗口。B会收到冗余的packet 2,3,4，那么B会回复3个同样的ack 4信息，因为packet 4 是它最后收到的有序pkt。之后A会到收到冗余的ack4，A会打印说明自己收到了重复的ack信息。接着A继续发送packet5…</p><img src="/2023/05/24/computer_network/socket-programming/e9228d9752502d65958cd87a1152e3c4.png" class=""><img src="/2023/05/24/computer_network/socket-programming/558c8c6a161ba3715fdf367a10d34721.png" class=""><p>…</p><img src="/2023/05/24/computer_network/socket-programming/1946975b88b4b65d58c88ded1a62c5b8.png" class=""><h4 id="22-loss-and-corruption-2"><a class="markdownIt-Anchor" href="#22-loss-and-corruption-2"></a> 2.2. loss and corruption</h4><p>下面将分析部分输出来验证代码的正确性</p><p>这里就简单说一下了。B对pkt 0的确认信息损失了，而此时A已经发出了0～2的pkt（其中pkt 1 丢失，pkt 2 损失）, 因此A要超时重传pkt 0～2（pkt 2 损失）, 因为B已经正确收到了pkt 0, 因此在收到冗余的pkt 0 时反馈ack 0, A成功收到ack 0 并移动窗口， 而B收到了重传的pkt1 而发送ack1信息…</p><img src="/2023/05/24/computer_network/socket-programming/f29d4e4a3d2c09fa475072d991d20b95.png" class=""><img src="/2023/05/24/computer_network/socket-programming/f70a5a55e0094826761fe3bdbcfc841b.png" class=""><p>…</p><img src="/2023/05/24/computer_network/socket-programming/6dff28c981d2c604e4bcbca86ed88d93.png" class=""><p><a href="https://zhuanlan.zhihu.com/p/35390933">reference</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络自顶向下] Wireshake Lab --- HTTP DNS UDP TCP</title>
      <link href="/2023/05/18/computer_network/Wireshark-Lab/"/>
      <url>/2023/05/18/computer_network/Wireshark-Lab/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1-getting-start"><a class="markdownIt-Anchor" href="#lab1-getting-start"></a> lab1 Getting Start</h1><hr /><p>用Wireshake捕获一个GET请求</p><ol><li><a href="https://gaia.cs.umass.edu/kurose_ross/wireshark.php">下载实验相关文件</a>， linux下执行<code>apt install wireshark</code>下载</li><li>参照指导书，<a href="http://www.wireshark.org/download.html">下载Wireshake软件</a>，这个软件可以捕获计算机发出或接受的数据包(package，其实主要是捕获链路层(link layer)的帧(frame)，因为该数据帧封装(encapsulate)了所有的上层协议)</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/3d5e07ff2b79d828f655330fc825c1aa.png" class=""><ol start="3"><li>选择Wlan接口(wireless local-area network,这里指wifi)，linux下选择wlp1s0接口，开启捕获</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/56d0df67832e9b065fa3bb5688434bce.png" class=""><ol start="5"><li>访问<a href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html">这个网站</a>以发出get请求，Wireshake会捕获这个HTTP信息</li></ol><p>注意：</p><ol><li>关闭VPN</li><li>访问目标网站后，清除浏览器缓存可再次抓包</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/f7a09801408174b57e47f37bd497536b.png" class="">从上图，我们得到以下信息：<ol><li>我在<code>21:02:28.468029</code>时发出了GET请求，在<code>21:02:28.735677</code>时收到了服务器的HTTP OK 回复</li><li>我电脑(source)是IP地址为192.168.0.105, 服务器(Destination)IP地址为128.119.245.12</li></ol><h1 id="lab2-http"><a class="markdownIt-Anchor" href="#lab2-http"></a> lab2 HTTP</h1><hr /><h2 id="21-the-basic-http-getresponse-interaction"><a class="markdownIt-Anchor" href="#21-the-basic-http-getresponse-interaction"></a> 2.1. The Basic HTTP GET/response interaction</h2><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/9666fb87f7a0dd831d9a7bca04892e8a.png" class=""><ol><li>Is your browser running HTTP version 1.0 or 1.1? What version of HTTP is the server running?<br /><strong>browser: HTTP1.1</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/74ff7bd33f836d0acfa4276f50feee09.png" class=""><p><strong>server:  HTTP1.1</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/fa49d3d6e62886ab35141cf7e7f3e5af.png" class=""><ol start="2"><li>What languages (if any) does your browser indicate that it can accept to the server?<br /><strong>chinese</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/842f4806947e906f83fd4acc50af9f51.png" class=""><ol start="3"><li>What is the IP address of your computer? Of the <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> server?<br /><strong>my computer:</strong> <code>10.20.102.167</code><br /><strong>server:</strong> <code>128.119.245.12</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/9a3242ad03c199e72f7d221c08994a6b.png" class=""><ol start="4"><li>What is the status code returned from the server to your browser?<br /><strong>status code: 200,  means successfully request , message is in the respond</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/1f07d403d9d7330c6c04465997fd798b.png" class=""><ol start="5"><li>When was the HTML file that you are retrieving last modified at the server?</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/b9f0939d8a0e33b59dade13167db4e4e.png" class=""><ol start="6"><li>How many bytes of content are being returned to your browser?<br /><strong>128 bytes</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/637e7b755bab8e8f5b71201efa82c9d3.png" class=""><ol start="7"><li>By inspecting the raw data in the packet content window, do you see any headers within the data that are not displayed in the packet-listing window? If so, name one.<br /><strong>no</strong></li></ol><h2 id="22-the-http-conditional-getresponse-interaction"><a class="markdownIt-Anchor" href="#22-the-http-conditional-getresponse-interaction"></a> 2.2. The HTTP CONDITIONAL GET/response interaction</h2><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/6bc81b701953085c84dd3d0cfcaf7adc.png" class=""><ol><li>Inspect the contents of the first HTTP GET request from your browser to the server. Do you see an “IF-MODIFIED-SINCE” line in the HTTP GET?<br /><strong>no</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/149774fceefd1466354244ddcd2e07bb.png" class=""><ol start="2"><li>Inspect the contents of the server response. Did the server explicitly return the contents of the file? How can you tell?<br /><strong>yes， there is a text data (entity body) behind headers</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/95ba9324691fcd33a45215c5013ca557.png" class=""><ol start="3"><li>Now inspect the contents of the second HTTP GET request from your browser to the server. Do you see an “IF-MODIFIED-SINCE:” line in the HTTP GET? If so, what information follows the “IF-MODIFIED-SINCE:” header?<br /><strong>yes, information as follows</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/2658e61ad8f0214c3c33410e804e9424.png" class=""><ol start="4"><li>What is the HTTP status code and phrase returned from the server in response to this second HTTP GET? Did the server explicitly return the contents of the file? Explain.<br /><strong>status code and phrase: 304 Not Modified<br />no contents behind headers, since proxy server not need to be updated</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/f5d69cafff5ca0c8d0402b00b8dc1711.png" class=""><h2 id="23-retrieving-long-documents"><a class="markdownIt-Anchor" href="#23-retrieving-long-documents"></a> 2.3. Retrieving Long Documents</h2><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/58b6db613551816ee63b829af32ba6dc.png" class=""><ol><li>How many HTTP GET request messages did your browser send? Which packet number in the trace contains the GET message for the Bill or Rights?<br /><strong>send 1 GET request messages in 10 seconds,  packet number is</strong> <code>76</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/ca6a50229ee3bc3d9426e57e5d6459a9.png" class=""><ol start="2"><li>Which packet number in the trace contains the status code and phrase associated with the response to the HTTP GET request?<br /><strong>still</strong> <code>76</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/43293ec4eb828ae71c6b6d63da7d3911.png" class=""><ol start="3"><li>What is the status code and phrase in the response?<br /><strong>200 OK</strong></li><li>How many data-containing TCP segments were needed to carry the single HTTP response and the text of the Bill of Rights?<br /><strong>1,  there is no</strong> <code>TCP segment of a reassembled PDU</code> **info display,  i reckon that it is a version problem of wireshark  **</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/e9209e0078dd14c5a5d023e87835a706.png" class=""><h2 id="24-html-documents-with-embedded-objects"><a class="markdownIt-Anchor" href="#24-html-documents-with-embedded-objects"></a> 2.4. HTML Documents with Embedded Objects</h2><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/c3a4468b8814c0953d31dd4fdac5d636.png" class=""><ol><li>How many HTTP GET request messages did your browser send? To which Internet addresses were these GET requests sent?<br />three<br /><code>128.119.245.12</code><br /><code>128.119.245.12</code><br /><code>178.79.137.164</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/9f268b8b2a79e7b190d5397e26452625.png" class=""><ol start="2"><li>Can you tell whether your browser downloaded the two images serially, or whether they were downloaded from the two web sites in parallel? Explain.<br /><strong>serially, since the GET request send after another GET request getting it’s response</strong></li></ol><h2 id="25-http-authentication"><a class="markdownIt-Anchor" href="#25-http-authentication"></a> 2.5. HTTP Authentication</h2><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/c0c297abba0275127407015d65925f9a.png" class=""><ol><li>What is the server’s response (status code and phrase) in response to the initial HTTP GET message from your browser?<br /><strong>401 Unauthorized</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/5a5a814fcc627d10d2c8e696ae987851.png" class=""><ol start="2"><li>When your browser’s sends the HTTP GET message for the second time, what new field is included in the HTTP GET message?<br /><strong>Authorization field</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/427ef940a795485dff92bf1917b75247.png" class=""><h1 id="lab3-dns"><a class="markdownIt-Anchor" href="#lab3-dns"></a> lab3 DNS</h1><hr /><h2 id="31-nslookup"><a class="markdownIt-Anchor" href="#31-nslookup"></a> 3.1. nslookup</h2><ol><li>Run nslookup to obtain the IP address of a Web server in Asia. What is the IP address of that server?<br /><strong>IPV4 address: <code>166.111.4.100</code> from DNS Cache</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/e62cbbd0a91c3a96402eb1f2569529e3.png" class=""><ol start="2"><li>Run nslookup to determine the authoritative DNS servers for a university in Europe.<br /><strong>four imperial college london nameservers</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/61a82f3a51e3c9b11b5c3189b9ec729f.png" class=""><h2 id="32-ifconfig"><a class="markdownIt-Anchor" href="#32-ifconfig"></a> 3.2. ifconfig</h2><p>Ubuntu上尽可能等效windows上的<code>ipconfig /displaydns</code> 的命令应该是<code>resolvectl statistics</code> ,这个命令会显示一些统计数据，包括当前缓存的条目数量、缓存命中次数、缓存未命中次数等。由于安全和隐私的考虑，<code>resolvectl</code> 并不提供直接查看全部DNS缓存条目的功能。</p><img src="/2023/05/18/computer_network/Wireshark-Lab/9358c4d071208b5800550371a9d012c6.png" class=""><p>使用<code>resolvectl flush-caches</code>清除本机的DNS缓存，再次用<code>resolvectl statistics</code>查看DNS缓存条目数量，此时变为0</p><img src="/2023/05/18/computer_network/Wireshark-Lab/cd4ed10ba0739b982bcdb68ba7fef486.png" class=""><blockquote><p><code>resolvectl</code> ,旧名<code>systemd-resolved</code> ，是一个由 systemd 提供的网络名称解析服务，它在 Ubuntu 和其他使用 systemd 的 Linux 发行版上运行。<strong>它负责 DNS 解析和缓存</strong>，mDNS（多播 DNS）解析，LLMNR（链接本地多播名称解析）和 DNSSEC（DNS 安全扩展）验证等功能。<br /><code>resolvectl</code> 将 DNS 查询结果存储在缓存中，以便在以后进行相同的查询时，可以直接从缓存中获取结果，而不必再次查询远程的 DNS 服务器。这可以显著提高 DNS 解析的速度，尤其是对于经常被查询的名称。<br />此外，<code>resolvectl</code> 还提供了其他一些功能，例如：</p><ul><li>它可以处理 /etc/hosts 文件和静态主机名解析。</li><li>它支持 DNS over TLS，这是一种加密 DNS 查询的方法，可以提高隐私和安全性。</li><li>它可以处理多个网络接口和多个 DNS 服务器，并可以为每个接口单独配置 DNS 服务器。<br />总的来说，<code>resolvectl</code> 是一个强大的网络名称解析服务，它提供了许多现代的和有用的功能。</li></ul><img src="/2023/05/18/computer_network/Wireshark-Lab/4d24df9ed9540e0dbf4cad215c7c49a7.png" class=""></blockquote><h2 id="33-tracing-dns-with-wireshark"><a class="markdownIt-Anchor" href="#33-tracing-dns-with-wireshark"></a> 3.3. Tracing DNS with Wireshark</h2><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/1270098e483482721bdf5c2970415ff4.png" class=""><ol><li>Locate the DNS query and response messages. Are then sent over UDP or TCP?<br /><strong>UDP， 这也符合教材所说的</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/18a7a3a7184a7217316f50aa2123a124.png" class=""><p><strong>DNS query:</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/ac534dc1568f877100b753268ef4a5de.png" class=""><p><strong>DNS response:</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/7715511eac6a247bee50665eea56c507.png" class=""><ol start="2"><li>What is the destination port for the DNS query message? What is the source port of DNS response message?<br /><strong>Dst Port of query: 53</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/c1cb87b6652765931391337df1908dee.png" class=""><p><strong>Src Port of response: 53</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/9b74161004a82931688b005e4b535e6c.png" class=""><ol start="3"><li>To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same?<br /><strong>linux下使用<code>resolvectl</code>获取当前的本地DNS服务器的IP地址</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/65fab6a2d77fcc66c7a34f5904812d30.png" class=""><p><strong>这与DNS query发送的目的地一致</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/1126bb1565533f880328c9c9147c73f9.png" class=""><ol start="4"><li>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?<br /><strong>type A , no answers in query message</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/9aa2c31c143fddc15f2a009098dd8235.png" class=""><ol start="5"><li>Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?<br /><strong>3个答案，分别是规范主机名，2条目的ip地址</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/36e84166025c5972a275f8fd9524a615.png" class=""><ol start="6"><li>Consider the subsequent TCP SYN packet sent by your host. Does the destination IP address of the SYN packet correspond to any of the IP addresses provided in the DNS response message?<br /><strong>yes，</strong><code>104.16.45.99</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/c37a042f10d88979fd8f0fa2ff0329ff.png" class=""><ol start="7"><li>This web page contains images. Before retrieving each image, does your host issue new DNS queries?<br /><strong>the images are all loaded from <a href="http://www.ietf.org">www.ietf.org</a>, no DNS queries after initial query, since the DNS have cached in host. Note that application layer protocol is https here, so no http message shown in wireshark list window instead of TLS message</strong></li></ol><blockquote><p>http not shown in wireshark<br />HTTPS代表着在TLS上的HTTP，因此除非您拥有将TLS解密为明文所需的数据，否则Wireshark无法分析加密内容，因此数据包中识别到的最高层协议（也就是显示在数据包列表中作为协议类型）仍然是TLS。</p></blockquote><h2 id="34-play-with-nslookup"><a class="markdownIt-Anchor" href="#34-play-with-nslookup"></a> 3.4. play with nslookup</h2><h3 id="341-nslookup-mitedu"><a class="markdownIt-Anchor" href="#341-nslookup-mitedu"></a> 3.4.1 nslookup <a href="http://mit.edu">mit.edu</a></h3><p>捕获成功<img src="/2023/05/18/computer_network/Wireshark-Lab/9dd3deb8326013386c8cc05127cb0744.png" class=""></p><img src="/2023/05/18/computer_network/Wireshark-Lab/9dd3deb8326013386c8cc05127cb0744.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/2fe4d6113c900392f724168b4a4ddb54.png" class=""><ol><li>What is the destination port for the DNS query message? What is the source port of DNS response message?<br /><strong>Dst port of query:</strong> <code>53</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/d246e10c4c912a73cbbcff353ff8ceff.png" class=""><p><strong>Src port of response:</strong><code>53</code></p><img src="/2023/05/18/computer_network/Wireshark-Lab/85c0a47000aaa941495f8b65d3232121.png" class=""><ol start="2"><li>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?<br /><strong>yes</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/68175fa176706e454785d1d995728f03.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/4de124ba3447e44694843e5e138e9495.png" class=""><ol start="3"><li>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?<br /><strong>A, no answer</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/feb20a80649c41636296dd228066dc01.png" class=""><ol start="4"><li>Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?<br /><strong>one,  an ip address, which is correspond to the answer of nslookup</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/6ba62f4eef87cc3093618c6611defb2c.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/4b504754eaef441797f928b55881e608.png" class=""><ol start="5"><li>Provide a screenshot.</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/50500f96b7771c4f99bd333520855246.png" class=""><h3 id="342-nslookup-typens-mitedu"><a class="markdownIt-Anchor" href="#342-nslookup-typens-mitedu"></a> 3.4.2 nslookup –type=NS <a href="http://mit.edu">mit.edu</a></h3><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/095d7009a83990429d8c1e2e4608f861.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/b4e2bdc07ef90ac60bd86dc27081ab1f.png" class=""><ol><li>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?<br /><strong>yes,</strong> <code>202.202.32.34</code></li><li>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?<br /><strong>NS， no answers</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/4988f28953c0e73d99679b2be88ced2a.png" class=""><ol start="3"><li>Examine the DNS response message. What MIT nameservers does the response message provide? Does this response message also provide the IP addresses of the MIT namesers?<br /><strong>Exactly as listed by nslookup, even in the same order. no IP address in response</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/a16d60d7adde4a2870e03d21bed54bbf.png" class=""><ol start="4"><li>Provide a screenshot.</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/d8b6c5a6326ae3de494e671ba7a43364.png" class=""><h1 id="lab4-udp"><a class="markdownIt-Anchor" href="#lab4-udp"></a> lab4 UDP</h1><ol><li>Select one UDP packet from your trace. From this packet, determine how many fields there are in the UDP header. (You shouldn’t look in the textbook! Answer these questions directly from what you observe in the packet trace.) Name these fields.<br /><strong>4 fields : 源端口号src port number，目标端口号dst port number，报文段长度 length，检验和 checkSum</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/0a9ca8f0fc91c09d8b35a6a4a3a5560f.png" class=""><ol start="2"><li>By consulting the displayed information in Wireshark’s packet content field for this packet, determine the length (in bytes) of each of the UDP header fields<br /><strong>Length - data part length (UDP payload)    = 8bytes, each of header fields have 2 bytes</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/482b48a820c86580578b0eac9084ee97.png" class=""><ol start="3"><li>The value in the Length field is the length of what? (You can consult the text for this answer). Verify your claim with your captured UDP packet.<br /><strong>header  + data part</strong></li><li>What is the maximum number of bytes that can be included in a UDP payload? (Hint: the answer to this question can be determined by your answer to 2. above)<br /><strong>the size of length field is 16bits, which means maximum value is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">2^{16}=65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span> , subtract header size(8 bytes) from the maximum, so the UDP payload maximum is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65536</mn><mo>−</mo><mn>8</mn><mo>=</mo><mn>65528</mn></mrow><annotation encoding="application/x-tex">65536 - 8 = 65528</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">2</span><span class="mord">8</span></span></span></span> bytes</strong></li><li>What is the largest possible source port number? (Hint: see the hint in 4.)<br /><strong>the source port number size is 16bytes as well as dst port number size, so the answer is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>65535</mn></mrow><annotation encoding="application/x-tex">2^{16}-1 = 65535</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">5</span></span></span></span></strong></li><li>What is the protocol number for UDP? Give your answer in both hexadecimal and decimal notation. To answer this question, you’ll need to look into the Protocol field of the IP datagram containing this UDP segment (see Figure 4.13 in the text, and the discussion of IP header fields).<br /><strong>17</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/8102ab429aaf7a1f6611f291fcc71c7b.png" class=""><ol start="7"><li>Examine a pair of UDP packets in which your host sends the first UDP packet and the second UDP packet is a reply to this first UDP packet. (Hint: for a second packet to be sent in response to a first packet, the sender of the first packet should be the destination of the second packet). Describe the relationship between the port numbers in the two packets.<br /><strong>the first UDP package of sender</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/30e8d3626c0befbb49d8d2d0b56ba8a0.png" class=""><p><strong>the second UDP package of  receiver</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/f759720a0f21cea84056024ae6a07738.png" class=""><p><strong>The sending port and receiving port of the sender and receiver are exactly the opposite</strong></p><h1 id="lab5-tcp"><a class="markdownIt-Anchor" href="#lab5-tcp"></a> lab5 TCP</h1><p>捕获成功</p><img src="/2023/05/18/computer_network/Wireshark-Lab/f7c02b9e59c5a0d2791952aa5b9fc365.png" class=""><h2 id="51-a-first-look-at-the-captured-trace"><a class="markdownIt-Anchor" href="#51-a-first-look-at-the-captured-trace"></a> 5.1 A first look at the captured trace</h2><ol><li>What is the IP address and TCP port number used by the client computer (source) that is transferring the file to <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a>?<br /><strong>src port: 45280,  dst port: 80</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/314920be8b5b765ccd96825ec1b747e5.png" class=""><ol start="2"><li>What is the IP address of <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a>? On what port number is it sending and receiving TCP segments for this connection?<br /><strong>ip address:</strong> <code>128.119.245.12</code><br /><strong>sending port number:</strong> <code>80</code><br /><strong>receiving port number:</strong> <code>80</code>, as well as sending port number</li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/60f15eea640ac29efe9e991e184d7ddd.png" class=""><h2 id="52-tcp-basics"><a class="markdownIt-Anchor" href="#52-tcp-basics"></a> 5.2 TCP Basics</h2><ol><li>What is the sequence number of the TCP SYN segment that is used to initiate the TCP connection between the client computer and <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a>? What is it in the segment that identifies the segment as a SYN segment?<br /><strong>sequence number: 0</strong><br /><strong>flag field of the segment identifies the segment is a SYN segment</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/94f0c60ba00e0a890b33bf10f57a3068.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/503f32fc757e7476c881954fc7faaf9c.png" class=""><ol start="2"><li>What is the sequence number of the SYNACK segment sent by <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> to the client computer in reply to the SYN? What is the value of the Acknowledgement field in the SYNACK segment? How did <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> determine that value? What is it in the segment that identifies the segment as a SYNACK segment?</li></ol><ul><li><strong>sequence number: 0</strong></li><li><strong>the value of ACKknowledgement field: 1</strong></li><li><strong>确认字段的值是主机期望从对方收到的下一个字节的序号，在没有双方没有发送任何数据之前，双方的确认字段只能填入对方的第一个字节的序号，因此我主机发出的SYN在确认字段填入的是0，而对方主机发送的SYNACK是1（已接受我主机发出的序号为0的字节）</strong></li><li><strong>flag field</strong></li></ul><img src="/2023/05/18/computer_network/Wireshark-Lab/eae8f329d5a6c5f67bcc5b9eb29bbeb3.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/2c53606f07fab98c6916bbba85377521.png" class=""><ol start="3"><li>What is the sequence number of the TCP segment containing the HTTP POST command? Note that in order to find the POST command, you’ll need to dig into the packet content field at the bottom of the Wireshark window, looking for a segment with a “POST” within its DATA field.1<br /><strong>sequence number:</strong> 1<br /><strong>此时从我主机发出的HTTP顺带第3次握手的ACK信息，因此是下一个字节1</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/3ea02b30cb660b4112d358a7e4f44504.png" class=""><ol start="4"><li>Consider the TCP segment containing the HTTP POST as the first segment in the TCP connection. What are the sequence numbers of the first six segments in the TCP connection (including the segment containing the HTTP POST)? At what time was each segment sent? When was the ACK for each segment received? Given the difference between when each TCP segment was sent, and when its acknowledgement was received, what is the RTT value for each of the six segments? What is the EstimatedRTT value (see Section 3.5.3, page 242 in text) after the receipt of each ACK? Assume that the value of the EstimatedRTT is equal to the measured RTT for the first segment, and then is computed using the EstimatedRTT equation on page 242 for all subsequent segments.<br /><strong>这是是重新捕获了，因此发送端口从</strong><code>45240</code><strong>变成了</strong><code>48774</code></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/8e43393a777274966c8cac1fa50519f7.png" class=""><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>α</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo stretchy="false">(</mo><mi>α</mi><mo>=</mo><mn>0.125</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EstimatedRTT = (1-\alpha)*EstimatedRTT +\alpha * RTT (\alpha = 0.125)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span></p><table><thead><tr><th>seq num</th><th>sent time</th><th>ack time</th><th>RTT</th><th>EstimatedRTT</th></tr></thead><tbody><tr><td>1</td><td>1.265422874</td><td>1.528751551</td><td>0.263328677</td><td>0.263329</td></tr><tr><td>708</td><td>1.265529027</td><td>1.528752932</td><td>0.263223905</td><td>0.263316</td></tr><tr><td>2156</td><td>1.265532825</td><td>1.529457711</td><td>0.263924886</td><td>0.263392</td></tr><tr><td>3604</td><td>1.272231437</td><td>1.529457932(lose)</td><td>0.257226495</td><td>0.262621</td></tr><tr><td>5052</td><td>1.272239774</td><td>1.529457932</td><td>0.257218158</td><td>0.261946</td></tr><tr><td>6500</td><td>1.274246481</td><td>1.537463133</td><td>0.263216652</td><td>0.262105</td></tr></tbody></table><p>这里只拿一对发送-响应的截图来说明：<br /><strong>发送segment1, 下一个字节序号为708, 因此接受方反馈的信息中确认字段应该填入708</strong></p><img src="/2023/05/18/computer_network/Wireshark-Lab/875283c601c34f76111ca7b635f008bb.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/b4571a214c8a775e27e11c06e9f1d708.png" class=""><ol start="6"><li>What is the length of each of the first six TCP segments?</li></ol><table><thead><tr><th>seq num</th><th>length</th></tr></thead><tbody><tr><td>1</td><td>707</td></tr><tr><td>708</td><td>1448</td></tr><tr><td>2156</td><td>1448</td></tr><tr><td>3604</td><td>1448</td></tr><tr><td>5052</td><td>1448</td></tr><tr><td>6500</td><td>1448</td></tr></tbody></table><ol start="7"><li>What is the minimum amount of available buffer space advertised at the received for the entire trace? Does the lack of receiver buffer space ever throttle the sender?<br /><strong>最小的接受窗口应该是在连接刚建立的时候，即包含在SYN ACK信息中，大小为</strong><code>28960</code></li></ol><blockquote><p>在一个 TCP 连接建立时，由于通信双方还未知道网络的具体情况，例如链路速度、延迟、丢包率等，因此需要从较小的窗口大小开始，以避免突然发送大量的数据导致网络拥塞。这就是为什么在 TCP 连接建立的时候，接收窗口的大小会被设置得相对较小。</p><p>当连接建立后，TCP 会通过观察网络的反馈（如接收端的 ACK，网络的延迟和丢包情况等）来动态调整窗口大小，这就是 TCP 的拥塞控制机制。如果网络条件良好，窗口会逐步增大，以提高传输效率。如果出现网络拥塞（如丢包），窗口会减小，以降低发送速率，避免拥塞的进一步发生。</p><p>所以，TCP 连接刚建立的时候，窗口大小被设置得较小，主要是为了避免对未知网络条件的盲目冒进，防止过早导致网络拥塞，同时也为后续的窗口动态调整留下空间。</p></blockquote><img src="/2023/05/18/computer_network/Wireshark-Lab/43efb35d73de5a049bcde442827ed4d3.png" class=""><p><strong>接受窗口的大小远大于单个segment(1448 bytes), 并且随着发送的进行还在不断变大， 因此发送方没有因为接受窗口大小而抑制发送速率</strong><br />9. Are there any retransmitted segments in the trace file? What did you check for (in the trace) in order to answer this question?<br /><strong>no retransimtted segments, the sequence of The sequence number of the segment sent by the sender is always incremented</strong>,<br /><strong>这里是重新捕获后的截图，端口变为</strong><code>45802</code></p><img src="/2023/05/18/computer_network/Wireshark-Lab/d8ef1ee754a2556fbce31f6bf8329a91.png" class=""><ol start="10"><li>How much data does the receiver typically acknowledge in an ACK? Can you identify cases where the receiver is ACKing every other received segment u(每隔一个收到的段)(see Table 3.2 on page 250 in the text).<br /><strong>两个连续的反馈信息中的ACK字段之差就表示了一个ACK确定的数据量，可以看到这里是</strong><code>1448</code><br /><strong>下图中也存在这样的情况<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9396</mn><mo>−</mo><mn>6500</mn><mo>=</mo><mn>2896</mn></mrow><annotation encoding="application/x-tex">9396 - 6500 = 2896</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord">3</span><span class="mord">9</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mord">9</span><span class="mord">6</span></span></span></span> , 这种就是间隔发送ACK的情况(case)</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/107b718dc0d1f7cc9f60dffd947e6e1c.png" class=""><ol start="11"><li>What is the throughput (bytes transferred per unit time) for the TCP connection? Explain how you calculated this value.<br /><strong>通过第一个TCP数据段的序列号和最后一个确认的序列号之间的差来计算发送的总数据量</strong></li></ol><img src="/2023/05/18/computer_network/Wireshark-Lab/e609d43b347ced7d0cd0c3e4a0a97c54.png" class=""><img src="/2023/05/18/computer_network/Wireshark-Lab/de7325161e37955a8f2d9bbf2cd4b5b7.png" class=""><p>**因此总数据量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1696891</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1696890</mn></mrow><annotation encoding="application/x-tex">1696891 - 1 = 1696890</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">9</span><span class="mord">6</span><span class="mord">8</span><span class="mord">9</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">9</span><span class="mord">6</span><span class="mord">8</span><span class="mord">9</span><span class="mord">0</span></span></span></span> （头部信息加上文件数据），这很符合文件的大小</p><img src="/2023/05/18/computer_network/Wireshark-Lab/2aeda677c398c1c2a738e9662a8fd7a7.png" class=""><p>除去这期间的时间就可得到单位时间**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14.24178</mn><mo>−</mo><mn>8.65656</mn><mo>=</mo><mn>5.58522</mn></mrow><annotation encoding="application/x-tex">14.24178 -8.65656 = 5.58522</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">.</span><span class="mord">2</span><span class="mord">4</span><span class="mord">1</span><span class="mord">7</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span><span class="mord">6</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">.</span><span class="mord">5</span><span class="mord">8</span><span class="mord">5</span><span class="mord">2</span><span class="mord">2</span></span></span></span><strong>的吞吐量</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1696890</mn><mi mathvariant="normal">/</mi><mn>5.58522</mn><mo>=</mo><mn>303</mn><mo separator="true">,</mo><mn>817.93376</mn></mrow><annotation encoding="application/x-tex">1696890/5.58522 = 303,817.93376</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">9</span><span class="mord">6</span><span class="mord">8</span><span class="mord">9</span><span class="mord">0</span><span class="mord">/</span><span class="mord">5</span><span class="mord">.</span><span class="mord">5</span><span class="mord">8</span><span class="mord">5</span><span class="mord">2</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mord">7</span><span class="mord">.</span><span class="mord">9</span><span class="mord">3</span><span class="mord">3</span><span class="mord">7</span><span class="mord">6</span></span></span></span> ， <strong>即303kB/s (not KB)</strong></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HIT-OS] 哈工大操作系统实验lab1~8</title>
      <link href="/2023/05/06/HIT_os/HIT-OS-Labs/"/>
      <url>/2023/05/06/HIT_os/HIT-OS-Labs/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><em>Learning operating system by coding it！</em></p><h1 id="实验0-实验环境搭建"><a class="markdownIt-Anchor" href="#实验0-实验环境搭建"></a> 实验0 实验环境搭建</h1><hr /><p><a href="https://hoverwinter.gitbooks.io/hit-oslab-manual/content/environment.html">reference1</a><br /><a href="https://blog.csdn.net/zy010101/article/details/108085192">reference2</a><br />遇到的问题：在编译linux0.11时，出现<code>fatal error：asm/ioctl.h: No such file or directory</code>，<code>loctl.h</code>这个文件是在库<code>linux-lib-dev</code>中的，而且我已经安装了这个库，但还是有这个错误</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/0fc97dc6618be181bcc508a1ae24096d.png" class=""><p>解决方法：使用i386版本的linux-libc-dev</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> linux-libc-dev:i386<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="实验1-操作系统的引导"><a class="markdownIt-Anchor" href="#实验1-操作系统的引导"></a> 实验1 操作系统的引导</h1><hr /><h2 id="1-改写bootsects"><a class="markdownIt-Anchor" href="#1-改写bootsects"></a> 1. 改写bootsect.s</h2><ol><li>我们只需要<code>bootsect.s</code>源码中打印字符串的部分，因为不涉及迁移<code>bootsect</code>从<code>0x07c00</code>到<code>0x90000</code>的操作，所以<code>bootsect.s</code>读入内存后还是在<code>0x07c00</code>的位置，因此要添加<code>mov es, #07c0</code>才能使<code>es:bp</code>指向正确的字符串起始位置。此外，<code>cx</code>参数的大小为字符串大小+6，这里的6是3个CR/LF (carriage return/line feed: 13 10)</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c8816d22b6b3d59ca96a5ac9155ffec9.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b3660aafb778e2e59f1b85d93bcfd830.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/1cfcbf9dea0e7cba56adf806615be13b.png" class=""><ol start="2"><li>改写<code>bootsect.s</code></li></ol><pre class="line-numbers language-none"><code class="language-none">entry _start_start:movah,#0x03! read cursor posxorbh,bhint0x10movcx,#34movbx,#0x0007! page 0, attribute 7 (normal)movbp,#msg1movax,#0x07c0moves,ax         ! set correct segment addressmovax,#0x1301! write string, move cursorint0x10inf_loop:        jmp inf_loop     ! keep not exitmsg1:.byte 13,10.ascii &quot;EliteX system is Loading ...&quot;.byte 13,10,13,10.org 510   ! jump over root_devboot_flag:.word 0xAA55         ! effective sign<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>要仅汇编<code>bootsect.s</code>得到<code>Image</code>，运行以下命令（在实模式下，as86工具用于汇编产生目标代码，ld86工具用于连接产生可执行文件）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">as86 <span class="token parameter variable">-0</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-o</span> bootsect.o bootsect.sld86 <span class="token parameter variable">-0</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-o</span> bootsect bootsect.o<span class="token function">dd</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>bootsect <span class="token assign-left variable">of</span><span class="token operator">=</span>Image <span class="token assign-left variable">skip</span><span class="token operator">=</span><span class="token number">32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>结果</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/0cdf798c3c7c3b0c98b5c22c198edb2b.png" class=""><h2 id="2-改写setups"><a class="markdownIt-Anchor" href="#2-改写setups"></a> 2. 改写setup.s</h2><h3 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> task1</h3><ol><li>在<code>setup.s</code>中写入<code>bootsect.s</code>的内容，对字符串信息作修改，修改<code>es</code>为<code>0x07e0</code>，因为<code>setup</code>在内存紧跟<code>bootsect</code>(0x07c00 + 0x200)之后 (这里将<code>cs</code>的值通过<code>ax</code>赋给<code>es</code>，因为此时<code>cs</code>的值就是<code>0x07e0</code>）)</li></ol><pre class="line-numbers language-none"><code class="language-none">entry _start_start:movah,#0x03! read cursor posxorbh,bhint0x10movcx,#25movbx,#0x0007! page 0, attribute 7 (normal)movbp,#msg1movax,csmoves,axmovax,#0x1301! write string, move cursorint0x10inf_loop:jmp inf_loop msg1:.byte 13,10.ascii &quot;Now we are in SETUP&quot;.byte 13,10,13,10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/aef3252bfb573b6b244bc26b131883fb.png" class=""><ol start="2"><li>在<code>bootsect.s</code>中添加源码中载入<code>setup</code>的部分，并修改<code>SETUPSEG</code>为<code>0x07e0</code>，原因还是在于我们没有移动<code>bootsect</code>**，**去掉循环并修改<code>SETUPLEN</code>为<code>2</code>，因为对我们的改写后的<code>setup</code>，仅需读入两个扇区就够了（其实一个扇区的大小也够了）</li></ol><pre class="line-numbers language-none"><code class="language-none">SETUPLEN &#x3D; 1SETUPSEG &#x3D; 0x07e0entry _start_start:movah,#0x03! read cursor posxorbh,bhint0x10movcx,#34movbx,#0x0007! page 0, attribute 7 (normal)movbp,#msg1movax,#0x07c0moves,axmovax,#0x1301! write string, move cursorint0x10load_setup:movdx,#0x0000! drive 0, head 0movcx,#0x0002! sector 2, track 0movbx,#0x0200! address &#x3D; 512, in INITSEGmovax,#0x0200+SETUPLEN! service 2, nr of sectorsint0x13! read itjncok_load_setup! ok - continuemovdx,#0x0000movax,#0x0000! reset the disketteint0x13jload_setupok_load_setup:jmpi0,SETUPSEG msg1:.byte 13,10.ascii &quot;EliteX system is Loading ...&quot;.byte 13,10,13,10.org 510   ! jump over root_devboot_flag:.word 0xAA55         ! effective sign<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>修改<code>linux-0.11/tool/build.c</code>注释掉最后部分，以便我们借助MakeFile编译<code>bootsect.s</code>与<code>setup.s</code>，而不用两个分别手动编译</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/631621eec969856642f202082e90dcae.png" class=""><ol start="4"><li>结果</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b3660aafb778e2e59f1b85d93bcfd830.png" class=""><h3 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> task2</h3><ol><li>我们需要<code>setup.s</code>源码中获取硬件信息的部分，需要解决的问题是将这些数据打印在屏幕上，利用了功能号为<code>0x0E</code>的<code>0x10</code>号中断，指导书写了一个<code>print_nl</code>来打印回车换行符，而我直接在打印的字符串中加入<code>13 10</code>实现回车换行</li></ol><pre class="line-numbers language-none"><code class="language-none">INITSEG  &#x3D; 0x9000entry _start_start:    mov ah,#0x03     ; read cursor pos    xor bh,bh    int 0x10    mov cx,#25       ; Print &quot;NOW we are in SETUP&quot;    mov bx,#0x0007    mov bp,#msg2     mov ax,cs        ; cs: 0x07e0    mov es,ax    mov ax,#0x1301    int 0x10; Get Cursor Pos    mov ax,#INITSEG    mov ds,ax    mov ah,#0x03    xor bh,bh    int 0x10    mov [0],dx  ; store in 9000:0; Get Memory Size    mov ah,#0x88    int 0x15    mov [2],ax      ; store in 9000:2; Get hd0 data    mov ax,#0x0000    mov ds,ax       ; modify ds    lds si,[4*0x41]    mov ax,#INITSEG    mov es,ax           mov di,#0x0004  ; store in 9000:4    mov cx,#0x10    rep    movsb! Be Ready to Print    mov ax,cs       ; 0x07e0    mov es,ax    mov ax,#INITSEG ; 9000    mov ds,ax; print Cursor Position    mov cx,#18    mov bx,#0x0007    mov bp,#msg_cursor    mov ax,#0x1301    int 0x10    mov dx,[0]  ; pass hex number through register dx to function print_hex    call    print_hex; print Memory Size    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#14    mov bx,#0x0007    mov bp,#msg_memory    mov ax,#0x1301    int 0x10    mov dx,[2]      call    print_hex; print KB    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#2    mov bx,#0x0007    mov bp,#msg_kb    mov ax,#0x1301    int 0x10; print Cyles    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#7    mov bx,#0x0007    mov bp,#msg_cyles    mov ax,#0x1301    int 0x10    mov dx,[4]    call    print_hex; print Heads    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#8    mov bx,#0x0007    mov bp,#msg_heads    mov ax,#0x1301    int 0x10    mov dx,[6]    call    print_hex; print Secotrs    mov ah,#0x03    xor bh,bh    int 0x10    mov cx,#10    mov bx,#0x0007    mov bp,#msg_sectors    mov ax,#0x1301    int 0x10    mov dx,[12]    call    print_hexinf_loop:    jmp inf_loopprint_hex:    mov    cx,#4print_digit:    rol    dx,#4   ; rotate left    mov    ax,#0xe0f     and    al,dl   ; fetch low 4 bits    add    al,#0x30    ; 0~9    cmp    al,#0x3a        jl     outp    add    al,#0x07    ; a~f , add more 0x07outp:    int    0x10    loop   print_digit    retmsg2:    .byte 13,10    .ascii &quot;NOW we are in SETUP&quot;    .byte 13,10,13,10msg_cursor:    .byte 13,10    .ascii &quot;Cursor position:&quot;msg_memory:    .byte 13,10    .ascii &quot;Memory Size:&quot;msg_cyles:    .byte 13,10    .ascii &quot;Cyls:&quot;msg_heads:    .byte 13,10    .ascii &quot;Heads:&quot;msg_sectors:    .byte 13,10    .ascii &quot;Sectors:&quot;msg_kb:    .ascii &quot;KB&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>结果</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/d83b172eeeb63114a561d5ea1e3942e7.png" class=""><h1 id="实验2-系统调用"><a class="markdownIt-Anchor" href="#实验2-系统调用"></a> 实验2 系统调用</h1><hr /><h2 id="1-编写接口函数iam-whoami"><a class="markdownIt-Anchor" href="#1-编写接口函数iam-whoami"></a> 1. 编写接口函数iam, whoami</h2><p>跟<code>write</code>一样，在接口函数文件内调用宏函数<code>_syscall1</code>或<code>_syscall2</code>（依参数个数而定），程序内包括后续用于测试系统调用的<code>main</code>函数。<br />iam.c</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span>   <span class="token comment">// 定义了这个宏，unistd.h中的一个条件编译块才会编译</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> iam<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">iam</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>whoami.c</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> whoami<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> username<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">whoami</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"username: %s\n"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-修改unistdh"><a class="markdownIt-Anchor" href="#2-修改unistdh"></a> 2. 修改unistd.h</h2><p>可以跳过这步，因为之后的编译过程所用到的<code>unistd.h</code>头文件并不在这个源码树下，而是在标准头文件<code>/usr/include</code>下。<br />在<code>linux-0.11/include/unistd.h</code>添加宏<code>_NR_whoami</code>、<code>_NR_iam</code>以在<code>_syscall*</code>函数中传递正确的参数给<code>0x80</code>号中断处理程序</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/825503e7b3bc733ec849543bef18bae4.png" class=""><h2 id="3-修改_sys_call_table函数表"><a class="markdownIt-Anchor" href="#3-修改_sys_call_table函数表"></a> 3. 修改_sys_call_table函数表</h2><p>在<code>linux-0.11/include/linux/sys.h</code>添加函数指针<code>sys_whoami</code>、<code>sys_iam</code>，函数在<code>sys_call_table</code>数组中的位置必须和在<code>&lt;unistd.h&gt;</code>文件中的<code>__NR_xxxxxx</code>的值对应上。在文件开头加上<code>extern</code>是让编译器在其它文件寻找这两个函数</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c5f54fc34542a48849bf640f523746c1.png" class=""><h2 id="4-实现函数sys_whoami-sys_iam"><a class="markdownIt-Anchor" href="#4-实现函数sys_whoami-sys_iam"></a> 4. 实现函数sys_whoami, sys_iam</h2><p>在<code>linux-0.11/kernel/iamwho.c</code>中编写最终的执行函数，执行这两个函数是系统调用的最后一步<br />在 Linux-0.11 内核中，<code>get_fs_byte</code> 和 <code>put_fs_byte</code> 函数用于在用户空间和内核空间之间传输数据。<br /><code>get_fs_byte</code> 函数从用户空间读取一个字节到内核空间。它接受一个指向用户空间内存地址的指针，并返回从该地址读取的字节。<br /><code>put_fs_byte</code> 函数则将一个字节从内核空间写入用户空间。它接受一个字节值和一个指向用户空间内存地址的指针。它将字节值写入指定的用户空间地址。<br />这两个函数在数据传输过程中起到了关键作用，使得内核可以与用户空间的应用程序进行安全地数据交换。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/segment.h></span>  <span class="token comment">// get_fs_byte, put_fs_byte</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;errno.h></span></span><span class="token keyword">char</span> str_pos<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sys_iam</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> c <span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        str_pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">23</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"elitezx lab2 string:  %s\n"</span><span class="token punctuation">,</span>str_pos <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_whoami</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">&lt;</span><span class="token function">strlen</span><span class="token punctuation">(</span>str_pos<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> str_pos<span class="token punctuation">[</span>ans<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">put_fs_byte</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>name<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-执行"><a class="markdownIt-Anchor" href="#5-执行"></a> 5. 执行</h2><p>关于这部分，指导书说的比较详细了，我这里再补充一些：挂载hdc目录到虚拟机操作系统上，实现hdc目录在linux-0.11与ubuntu22.04之间的文件共享，我们把用于系统调用的测试程序<code>iam.c</code>，<code>whoami.c</code>复制到hdc目录就可以在Bochs模拟器下的linux-0.11环境中编译执行这两个文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./mount-hdc <span class="token function">cp</span> iam.c whoami.c hdc/usr/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/e101da7028d27378793cef11f5352872.png" class=""><p>注意在<code>iam.c</code>,<code>whoami.c</code>程序内的头文件<code>&lt;unistd.h&gt;</code>是标准头文件，是由GCC编译器一同安装的，它们通常随着GCC一起打包并分发，通常位于<code>/usr/include</code>目录下，而不是在之前修过的源码树下的<code>include/unistd.h</code>, 因此我们要转入<code>hdc/usr/include</code>下修改<code>&lt;unistd.h&gt;</code>，加入两个宏<code>__NR_iam</code>,<code>__NR_whoami</code><br />编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> iam iam.cgcc <span class="token parameter variable">-o</span> <span class="token function">whoami</span> whoami.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-验证结果"><a class="markdownIt-Anchor" href="#6-验证结果"></a> 6. 验证结果</h2><img src="/2023/05/06/HIT_os/HIT-OS-Labs/821c28d5b04262d88ad0e48d4ad95bdf.png" class=""><h1 id="实验3-进程运行轨迹的跟踪与统计"><a class="markdownIt-Anchor" href="#实验3-进程运行轨迹的跟踪与统计"></a> 实验3 进程运行轨迹的跟踪与统计</h1><hr /><h2 id="1-前提"><a class="markdownIt-Anchor" href="#1-前提"></a> 1. 前提</h2><h3 id="11-系统调用times"><a class="markdownIt-Anchor" href="#11-系统调用times"></a> 1.1. 系统调用times</h3><p><code>times</code>系统调用接受一个<code>struct tms*</code>类型的参数，该结构体用于保存进程和其子进程的 CPU 时间信息，同时 times 系统调用会返回一个滴答数，即时钟周期数，该滴答数表示自OS启动以来经过的时钟周期数。<br /><code>struct tms</code>类型在<code>include/sys/times.h</code>中定义如下：</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/825503e7b3bc733ec849543bef18bae4.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c48cf07a034075a0d27348bf6dbac5e4.png" class=""><p><code>tms_stime</code>和<code>tms_utime</code>分别记录了进程在内核态和用户态下消耗的CPU时间总和，它们的和就是进程从开始执行到调用times系统调用所经过的时间。<code>tms_stime</code>和<code>tms_utime</code>并不包括进程在睡眠状态或等待I/O操作中所消耗的时间，因此它们的和也不等于进程的实际运行时间。<br />注意这里时间的单位是CPU的滴答时间（tick），一个滴答数表示两个时钟中断的间隔。在Linux系统中，时钟中断通常由硬件定时器产生，定时器会以固定的频率向CPU发送中断信号。**每当时钟中断发生时，内核会将当前进程的时间片计数器减 1，内核会检查当前进程的时间片（counter）是否已经用完，如果用完了，就将当前进程放到就绪队列中，然后调用调度函数 schedule 选择一个新的进程运行。**这个频率通常是100Hz，即一秒发生100次，也就是说时间中断的间隔为10ms（1/100s），每隔10ms就发生一次时钟中断，linux内核中的<code>jiffies</code>变量就记录了时间中断的个数，即滴答数。那么可以看出这里的时间单位既然是滴答数，而滴答数10ms产生一个，那么实际时间应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">ticks/100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> (秒)，100是常量<code>HZ</code>的值<br />由此，如果想获取一个进程从开始到结束的CPU使用时间，即用户态下CPU时间和内核态下CPU时间之和，可用如下函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/times.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">tms</span> t<span class="token punctuation">;</span>    clock_t clock_time<span class="token punctuation">;</span>    <span class="token comment">// 获取进程的CPU时间统计信息</span>    clock_time <span class="token operator">=</span> <span class="token function">times</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算进程的总的CPU时间</span>    <span class="token keyword">double</span> cpu_time <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>tms_utime <span class="token operator">+</span> t<span class="token punctuation">.</span>tms_stime<span class="token punctuation">)</span> <span class="token operator">/</span> HZ<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Total CPU time: %.2f seconds\n"</span><span class="token punctuation">,</span> cpu_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用到的<code>clock_t</code>在<code>include/time.h</code>中定义如下</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c48cf07a034075a0d27348bf6dbac5e4.png" class=""><h3 id="12-系统调用wait"><a class="markdownIt-Anchor" href="#12-系统调用wait"></a> 1.2. 系统调用wait</h3><p><code>wait</code> 函数是一个系统调用（位于<code>include/sys/wait.h</code>）。在Unix/Linux操作系统中，<code>wait</code>函数可以等待子进程结束，并获取子进程的退出状态。在使用<code>wait</code>函数时，如果子进程已经结束，<code>wait</code>函数会立即返回并返回子进程的退出状态；如果子进程还没有结束，<code>wait</code>函数会阻塞父进程，直到子进程结束并返回其退出状态。具体来说，<code>wait</code> 函数的作用如下：<br />1 如果当前进程没有子进程，<code>wait</code> 函数会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>ECHILD</code>，表示当前进程没有子进程需要等待。<br />2 如果当前进程有一个或多个子进程正在运行，调用 <code>wait</code> 函数会阻塞当前进程，直到其中一个子进程结束。当子进程结束时，<code>wait </code>函数会返回该子进程的进程 ID，并将该子进程的退出状态保存到一个整型变量<code>status</code>中。<br />3 如果当前进程有多个子进程正在运行，调用<code>wait</code>函数会等待其中任意一个子进程结束，并且无法指定要等待哪个子进程。如果需要等待特定的子进程，可以使用 <code>waitpid</code>函数代替<code>wait</code>函数。<br />需要注意的是，如果当前进程没有调用wait函数等待其子进程结束，那么当子进程结束时，其退出状态可能会一直保存在内核中，直到当前进程调用<code>wait</code>或<code>waitpid</code>函数获取该状态。如果当前进程没有获取子进程的退出状态，那么该子进程就会成为僵尸进程（Zombie Process），占用系统资源并且无法被正常清理。<br />因此，在编写多进程程序时，通常需要在父进程中调用<code>wait</code>或<code>waitpid</code>函数等待子进程结束，并获取其退出状态，以避免产生僵尸进程。</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/02fe9737164d08468c47ff985f1d6276.png" class=""><p>对linux0.11 wait函数必须接受一个<code>int</code>参数以保存子进程退出状态，如果你不想保存该信息，可传递<code>NULL</code>。而在现代linux中，该参数为可选参数。</p><h3 id="13-linux011中进程的state值"><a class="markdownIt-Anchor" href="#13-linux011中进程的state值"></a> 1.3. linux0.11中进程的state值</h3><p>在Linux 0.11中，进程状态可以被表示为以下几个值：</p><ol><li><code>TASK_RUNNING</code>：进程正在执行，也就是说CPU正在执行它的指令。但是，如果一个进程的状态为<code>TASK_RUNNING</code>，而它又没有占用CPU时间片运行，那么它就是处于就绪态。</li><li><code>TASK_INTERRUPTIBLE</code>：进程正在等待某个事件的发生（例如，等待用户输入、等待网络数据等），它已经睡眠，并且可以响应一个信号以退出等待状态。</li><li><code>TASK_UNINTERRUPTIBLE</code>：和<code>TASK_INTERRUPTIBLE</code>一样，进程也是正在等待某个事件的发生，但是进程在等待期间不会响应信号，直到事件发生后才会退出等待状态，比如I/O操作。</li><li><code>TASK_STOPPED</code>：进程已经被停止，通常是收到了一个SIGSTOP信号。</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/3d998177822f40110dc0de83e59313be.png" class=""><h2 id="2-processc"><a class="markdownIt-Anchor" href="#2-processc"></a> 2. process.c</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/times.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">void</span> <span class="token function">cpuio_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span> last<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu_time<span class="token punctuation">,</span> <span class="token keyword">int</span> io_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pid_t son_proc_pid<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token punctuation">(</span>son_proc_pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cpuio_bound</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child_process_pid: %d\n"</span><span class="token punctuation">,</span> son_proc_pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">cpuio_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span> last<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu_time<span class="token punctuation">,</span> <span class="token keyword">int</span> io_time<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">tms</span> start<span class="token punctuation">,</span> pre<span class="token punctuation">;</span>clock_t sum_cpu_time <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>clock_t accumulate <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">times</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>sum_cpu_time <span class="token operator">&lt;</span> cpu_time<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">times</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>sum_cpu_time <span class="token operator">=</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>tms_utime <span class="token operator">-</span> start<span class="token punctuation">.</span>tms_utime <span class="token operator">+</span> pre<span class="token punctuation">.</span>tms_stime <span class="token operator">-</span> pre<span class="token punctuation">.</span>tms_stime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sum_cpu_time<span class="token operator">>=</span>last<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token function">sleep</span><span class="token punctuation">(</span>io_time<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>accumulate<span class="token operator">+=</span> io_time <span class="token operator">+</span> cpu_time<span class="token punctuation">)</span><span class="token operator">>=</span>last<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/4ca217256a1b821d07cb20ec055b3152.png" class=""><h2 id="3-生成log的前置工作"><a class="markdownIt-Anchor" href="#3-生成log的前置工作"></a> 3. 生成log的前置工作</h2><ol><li>修改<code>linux-0.11/init/main.c</code>，将文件描述符<code>3</code>与<code>process.log</code>关联。文件描述符是一个非负整数，它是操作系统内部用来标识一个特定文件的引用。</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/6d2047abf1eabe1da394c52980b55800.png" class=""><ol start="2"><li>在内核中添加<code>fprintk</code>函数用于在程序中调用以写入log文件</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">static</span> <span class="token keyword">char</span> logbuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> file<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> inode<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token operator">=</span><span class="token function">vsprintf</span><span class="token punctuation">(</span>logbuf<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment">/* 如果输出到stdout或stderr，直接调用sys_write即可 */</span>    <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"push %%fs\n\t"</span>            <span class="token string">"push %%ds\n\t"</span>            <span class="token string">"pop %%fs\n\t"</span>            <span class="token string">"pushl %0\n\t"</span>            <span class="token string">"pushl $logbuf\n\t"</span> <span class="token comment">/* 注意对于Windows环境来说，是_logbuf,下同 */</span>            <span class="token string">"pushl %1\n\t"</span>            <span class="token string">"call sys_write\n\t"</span> <span class="token comment">/* 注意对于Windows环境来说，是_sys_write,下同 */</span>            <span class="token string">"addl $8,%%esp\n\t"</span>            <span class="token string">"popl %0\n\t"</span>            <span class="token string">"pop %%fs"</span>            <span class="token double-colon punctuation">::</span><span class="token string">"r"</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span> <span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"ax"</span><span class="token punctuation">,</span><span class="token string">"cx"</span><span class="token punctuation">,</span><span class="token string">"dx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token comment">/* 假定>=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>file<span class="token operator">=</span>task<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>filp<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">/* 从进程0的文件描述符表中得到文件句柄 */</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        inode<span class="token operator">=</span>file<span class="token operator">-></span>f_inode<span class="token punctuation">;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"push %%fs\n\t"</span>            <span class="token string">"push %%ds\n\t"</span>            <span class="token string">"pop %%fs\n\t"</span>            <span class="token string">"pushl %0\n\t"</span>            <span class="token string">"pushl $logbuf\n\t"</span>            <span class="token string">"pushl %1\n\t"</span>            <span class="token string">"pushl %2\n\t"</span>            <span class="token string">"call file_write\n\t"</span>            <span class="token string">"addl $12,%%esp\n\t"</span>            <span class="token string">"popl %0\n\t"</span>            <span class="token string">"pop %%fs"</span>            <span class="token double-colon punctuation">::</span><span class="token string">"r"</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span> <span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"r"</span> <span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"ax"</span><span class="token punctuation">,</span><span class="token string">"cx"</span><span class="token punctuation">,</span><span class="token string">"dx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>修改fork.c</li></ol><p>进程在创建后就立马被设置为就绪态<code>TASK_RUNNING</code></p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/79ff16fbb9eb2d35d267aa2017761a11.png" class=""><ol start="4"><li>修改sched.c</li></ol><p>在进程的状态切换点打印进程的状态信息</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* *  linux/kernel/sched.c * *  (C) 1991  Linus Torvalds */</span><span class="token comment">/* * 'sched.c' is the main kernel file. It contains scheduling primitives * (sleep_on, wakeup, schedule etc) as well as a number of simple system * call functions (type getpid(), which just extracts a field from * current-task */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sys.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fdreg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/system.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/io.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/segment.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_S</span><span class="token expression"><span class="token punctuation">(</span>nr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_BLOCKABLE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token function">_S</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">_S</span><span class="token punctuation">(</span>SIGSTOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">void</span> <span class="token function">show_task</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">4096</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%d: pid=%d, state=%d, "</span><span class="token punctuation">,</span>nr<span class="token punctuation">,</span>p<span class="token operator">-></span>pid<span class="token punctuation">,</span>p<span class="token operator">-></span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%d (of %d) chars free in kernel stack\n\r"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">show_stat</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>NR_TASKS<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">show_task</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LATCH</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1193180</span><span class="token operator">/</span>HZ<span class="token punctuation">)</span></span></span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">mem_use</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">timer_interrupt</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">system_call</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">union</span> task_union <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> task<span class="token punctuation">;</span>    <span class="token keyword">char</span> stack<span class="token punctuation">[</span>PAGE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">union</span> task_union init_task <span class="token operator">=</span> <span class="token punctuation">&#123;</span>INIT_TASK<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">volatile</span> jiffies<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">long</span> startup_time<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>current <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>last_task_used_math <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">long</span> user_stack <span class="token punctuation">[</span> PAGE_SIZE<span class="token operator">>></span><span class="token number">2</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token operator">*</span> a<span class="token punctuation">;</span>    <span class="token keyword">short</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> stack_start <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token operator">&amp;</span> user_stack <span class="token punctuation">[</span>PAGE_SIZE<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token number">0x10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* *  'math_state_restore()' saves the current math information in the * old math state array, and gets the new ones from the current task */</span><span class="token keyword">void</span> <span class="token function">math_state_restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math <span class="token operator">==</span> current<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"fwait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"fnsave %0"</span><span class="token operator">::</span><span class="token string">"m"</span> <span class="token punctuation">(</span>last_task_used_math<span class="token operator">-></span>tss<span class="token punctuation">.</span>i387<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    last_task_used_math<span class="token operator">=</span>current<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>used_math<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"frstor %0"</span><span class="token operator">::</span><span class="token string">"m"</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>tss<span class="token punctuation">.</span>i387<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"fninit"</span><span class="token operator">::</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current<span class="token operator">-></span>used_math<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* *  'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. */</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>next<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&lt;</span> jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGALRM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>_BLOCKABLE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>blocked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">==</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">=</span>TASK_RUNNING<span class="token punctuation">;</span>                <span class="token comment">/*可中断睡眠 => 就绪*/</span>                <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">/* this is the scheduler proper: */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> NR_TASKS<span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token operator">--</span>p<span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">></span> c<span class="token punctuation">)</span>                c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">,</span> next <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>priority<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*编号为next的进程 运行*/</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>pid <span class="token operator">!=</span> task<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">-></span>pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/*时间片到时程序 => 就绪*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING<span class="token punctuation">)</span>            <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tR\t%d\n"</span><span class="token punctuation">,</span>task<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">switch_to</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token comment">/**当前进程  运行 => 可中断睡眠*/</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tW\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> current<span class="token punctuation">;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token comment">/**当前进程进程 => 不可中断睡眠*/</span>    <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tW\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp<span class="token operator">-></span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**原等待队列 第一个进程 => 唤醒（就绪）*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span>tmp<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">interruptible_sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span>current<span class="token punctuation">;</span>    repeat<span class="token operator">:</span>current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span>    <span class="token comment">/**这一部分属于 唤醒队列中间进程，通过goto实现唤醒 队列头进程 过程中Wait*/</span>    <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tW\t%d\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**当前进程进程 => 可中断睡眠 同上*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp<span class="token operator">-></span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**原等待队列 第一个进程 => 唤醒（就绪）*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span>tmp<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**唤醒 最后进入等待序列的 进程*/</span>        <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%d\tJ\t%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * OK, here are some floppy things that shouldn't be in the kernel * proper. They are here because the floppy needs a timer, and this * was the easiest way of doing it. */</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> wait_motor<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span>  mon_timer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> moff_timer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> current_DOR <span class="token operator">=</span> <span class="token number">0x0C</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">ticks_to_floppy_on</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">extern</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> selected<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> mask <span class="token operator">=</span> <span class="token number">0x10</span> <span class="token operator">&lt;&lt;</span> nr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nr<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"floppy_on: nr>3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    moff_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span><span class="token comment">/* 100 s = very big :-) */</span>    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* use floppy_off to turn it off */</span>    mask <span class="token operator">|=</span> current_DOR<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>selected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mask <span class="token operator">&amp;=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span>        mask <span class="token operator">|=</span> nr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">!=</span> current_DOR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">outb</span><span class="token punctuation">(</span>mask<span class="token punctuation">,</span>FD_DOR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">^</span> current_DOR<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf0</span><span class="token punctuation">)</span>            mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">=</span> HZ<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>            mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        current_DOR <span class="token operator">=</span> mask<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mon_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">floppy_on</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">ticks_to_floppy_on</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">sleep_on</span><span class="token punctuation">(</span>nr<span class="token operator">+</span>wait_motor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">floppy_off</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    moff_timer<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token operator">*</span>HZ<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">do_floppy_timer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> mask <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span>mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> current_DOR<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mon_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>mon_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token function">wake_up</span><span class="token punctuation">(</span>i<span class="token operator">+</span>wait_motor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>moff_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            current_DOR <span class="token operator">&amp;=</span> <span class="token operator">~</span>mask<span class="token punctuation">;</span>            <span class="token function">outb</span><span class="token punctuation">(</span>current_DOR<span class="token punctuation">,</span>FD_DOR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>            moff_timer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIME_REQUESTS</span> <span class="token expression"><span class="token number">64</span></span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> jiffies<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> timer_list<span class="token punctuation">[</span>TIME_REQUESTS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span> next_timer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token keyword">long</span> jiffies<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jiffies <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> timer_list <span class="token punctuation">;</span> p <span class="token operator">&lt;</span> timer_list <span class="token operator">+</span> TIME_REQUESTS <span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>fn<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> timer_list <span class="token operator">+</span> TIME_REQUESTS<span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"No more time requests free"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>        p<span class="token operator">-></span>jiffies <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> next_timer<span class="token punctuation">;</span>        next_timer <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies <span class="token operator">&lt;</span> p<span class="token operator">-></span>jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p<span class="token operator">-></span>jiffies <span class="token operator">-=</span> p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies<span class="token punctuation">;</span>            fn <span class="token operator">=</span> p<span class="token operator">-></span>fn<span class="token punctuation">;</span>            p<span class="token operator">-></span>fn <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token operator">-></span>fn<span class="token punctuation">;</span>            p<span class="token operator">-></span>next<span class="token operator">-></span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>            jiffies <span class="token operator">=</span> p<span class="token operator">-></span>jiffies<span class="token punctuation">;</span>            p<span class="token operator">-></span>jiffies <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies<span class="token punctuation">;</span>            p<span class="token operator">-></span>next<span class="token operator">-></span>jiffies <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">do_timer</span><span class="token punctuation">(</span><span class="token keyword">long</span> cpl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> beepcount<span class="token punctuation">;</span>    <span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">sysbeepstop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beepcount<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>beepcount<span class="token punctuation">)</span>            <span class="token function">sysbeepstop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cpl<span class="token punctuation">)</span>        current<span class="token operator">-></span>utime<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        current<span class="token operator">-></span>stime<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next_timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        next_timer<span class="token operator">-></span>jiffies<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>next_timer <span class="token operator">&amp;&amp;</span> next_timer<span class="token operator">-></span>jiffies <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fn <span class="token operator">=</span> next_timer<span class="token operator">-></span>fn<span class="token punctuation">;</span>            next_timer<span class="token operator">-></span>fn <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            next_timer <span class="token operator">=</span> next_timer<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current_DOR <span class="token operator">&amp;</span> <span class="token number">0xf0</span><span class="token punctuation">)</span>        <span class="token function">do_floppy_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">--</span>current<span class="token operator">-></span>counter<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>counter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cpl<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_alarm</span><span class="token punctuation">(</span><span class="token keyword">long</span> seconds<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> old <span class="token operator">=</span> current<span class="token operator">-></span>alarm<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span>        old <span class="token operator">=</span> <span class="token punctuation">(</span>old <span class="token operator">-</span> jiffies<span class="token punctuation">)</span> <span class="token operator">/</span> HZ<span class="token punctuation">;</span>    current<span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token punctuation">(</span>seconds<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>jiffies<span class="token operator">+</span>HZ<span class="token operator">*</span>seconds<span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>pid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>father<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>uid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_geteuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>euid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getgid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>gid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_getegid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> current<span class="token operator">-></span>egid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_nice</span><span class="token punctuation">(</span><span class="token keyword">long</span> increment<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>priority<span class="token operator">-</span>increment<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        current<span class="token operator">-></span>priority <span class="token operator">-=</span> increment<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sched_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">desc_struct</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">16</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Struct sigaction MUST be 16 bytes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_tss_desc</span><span class="token punctuation">(</span>gdt<span class="token operator">+</span>FIRST_TSS_ENTRY<span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">.</span>tss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_ldt_desc</span><span class="token punctuation">(</span>gdt<span class="token operator">+</span>FIRST_LDT_ENTRY<span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">.</span>ldt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> gdt<span class="token operator">+</span><span class="token number">2</span><span class="token operator">+</span>FIRST_TSS_ENTRY<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>NR_TASKS<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        task<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>a<span class="token operator">=</span>p<span class="token operator">-></span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>a<span class="token operator">=</span>p<span class="token operator">-></span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Clear NT, so that we won't have troubles with that later on */</span>    <span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"pushfl ; andl $0xffffbfff,(%esp) ; popfl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ltr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lldt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb_p</span><span class="token punctuation">(</span><span class="token number">0x36</span><span class="token punctuation">,</span><span class="token number">0x43</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* binary, mode 3, LSB/MSB, ch 0 */</span>    <span class="token function">outb_p</span><span class="token punctuation">(</span>LATCH <span class="token operator">&amp;</span> <span class="token number">0xff</span> <span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* LSB */</span>    <span class="token function">outb</span><span class="token punctuation">(</span>LATCH <span class="token operator">>></span> <span class="token number">8</span> <span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* MSB */</span>    <span class="token function">set_intr_gate</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>timer_interrupt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">inb_p</span><span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">~</span><span class="token number">0x01</span><span class="token punctuation">,</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_system_gate</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>system_call<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sys_pause在Linux0.11中，<code>sys_pause()</code>系统调用的主要作用是让进程暂停执行，直到接收到一个信号。当进程调用<code>sys_pause()</code>系统调用时，它会将自己的状态设置为<code>TASK_INTERRUPTIBLE</code>，并且将其添加到等待信号队列中。然后，进程会进入睡眠状态，直到收到一个信号或者被其他进程显式地唤醒。<br />这个系统调用通常用于实现等待信号的操作，比如等待一个定时器信号或者等待一个IO操作完成的信号。在这种情况下，进程可以使用<code>sys_pause()</code>系统调用进入睡眠状态，而不必浪费CPU资源等待信号的到来。当信号到来时，内核会唤醒进程，并且将信号传递给进程的信号处理程序进行处理。<br />需要注意的是，在Linux 2.6以后的版本中，<code>sys_pause()</code>系统调用已经被废弃，被<code>sys_rt_sigsuspend()</code>系统调用所取代。<code>sys_rt_sigsuspend()</code>系统调用可以实现类似的等待信号的操作，并且提供更多的控制选项。</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/882778374b4a4e4e71d923210ac02fab.png" class=""><ol start="5"><li>修改exit.c</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_exit</span><span class="token punctuation">(</span><span class="token keyword">long</span> code<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">free_page_tables</span><span class="token punctuation">(</span><span class="token function">get_base</span><span class="token punctuation">(</span>current<span class="token operator">-></span>ldt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">get_limit</span><span class="token punctuation">(</span><span class="token number">0x0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free_page_tables</span><span class="token punctuation">(</span><span class="token function">get_base</span><span class="token punctuation">(</span>current<span class="token operator">-></span>ldt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">get_limit</span><span class="token punctuation">(</span><span class="token number">0x17</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_TASKS <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>father <span class="token operator">==</span> current<span class="token operator">-></span>pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>father <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_ZOMBIE<span class="token punctuation">)</span>                <span class="token comment">/* assumption task[1] is always init */</span>                <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">send_sig</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> task<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_OPEN <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>filp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">sys_close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iput</span><span class="token punctuation">(</span>current<span class="token operator">-></span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>pwd<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">iput</span><span class="token punctuation">(</span>current<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>root<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">iput</span><span class="token punctuation">(</span>current<span class="token operator">-></span>executable<span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>executable<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>leader <span class="token operator">&amp;&amp;</span> current<span class="token operator">-></span>tty <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        tty_table<span class="token punctuation">[</span>current<span class="token operator">-></span>tty<span class="token punctuation">]</span><span class="token punctuation">.</span>pgrp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math <span class="token operator">==</span> current<span class="token punctuation">)</span>        last_task_used_math <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>leader<span class="token punctuation">)</span>        <span class="token function">kill_session</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_ZOMBIE<span class="token punctuation">;</span>    current<span class="token operator">-></span>exit_code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token function">fprintk</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"%ld\tE\t%ld\n"</span><span class="token punctuation">,</span>current<span class="token operator">-></span>pid<span class="token punctuation">,</span>jiffies<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tell_father</span><span class="token punctuation">(</span>current<span class="token operator">-></span>father<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* just to suppress warnings */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>旁注：do_exit函数与sys_waitpid函数</strong></p><blockquote><p>在 Linux 0.11 中，<code>do_exit()</code> 函数负责终止一个进程。当一个进程调用 <code>do_exit()</code> 时，它会执行多个清理操作，包括释放进程持有的任何资源，如打开的文件和内存，并向父进程通知进程的退出状态。如果进程有任何子进程，则 <code>do_exit()</code> 也通过递归调用 <code>do_exit()</code> 终止它们。<br /><code>sys_waitpid() </code>函数用于等待子进程终止并检索其退出状态。当进程调用 <code>sys_waitpid()</code> 时，它会阻塞，直到其中一个子进程终止。如果子进程已经终止，<code>sys_waitpid() </code>将立即返回该子进程的退出状态。否则，它将继续阻塞，直到子进程终止。<br />除了等待特定的子进程外，<code>sys_waitpid() </code>还可以用于等待任何子进程终止，方法是通过传递<code> -1</code> 的 <code>pid</code> 参数。当一个进程有多个子进程并且想要等待第一个终止时，这很有用。</p></blockquote><h2 id="4-生成log"><a class="markdownIt-Anchor" href="#4-生成log"></a> 4. 生成log</h2><p>先共享文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mount-hdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>移动多进程程序<code>process.c</code>到linux-0.11目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> process.c hdc/usr/root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/02fe9737164d08468c47ff985f1d6276.png" class=""><p>编译运行, 最后执行一个<code>sync</code>命令，确保将文件系统中的所有缓存数据写入磁盘</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/79ff16fbb9eb2d35d267aa2017761a11.png" class=""><p><strong>旁注: sync命令</strong></p><blockquote><p>sync 命令是用于将文件系统中的所有缓存数据写入磁盘的命令。在 Linux 中，当一个进程修改了一个文件时，这个修改不会立即写入磁盘，而是会先被写入内存中的缓存，以提高文件系统的性能。然而，如果系统崩溃或出现其他问题，这些修改可能会丢失。因此，为了保证数据的完整性，我们需要将缓存数据定期地写入磁盘中。<br />sync 命令会将所有的缓存数据写入磁盘中，并将所有被修改的元数据（如 i-node、目录结构等）更新到磁盘中。这样可以保证所有的修改都被写入到磁盘中，从而避免了数据的丢失。通常在关机前执行 sync 命令，以确保所有数据都已被保存到磁盘中。<br />需要注意的是，执行 sync 命令并不能保证磁盘数据的完全一致性。在磁盘数据的写入过程中，如果发生了异常情况，可能会导致数据的损坏或丢失。因此，在执行 sync 命令后，建议再执行一次磁盘检查命令（如 fsck 命令）来确保文件系统的完整性。</p></blockquote><p>将生成的<code>process.log</code>移动到虚拟机下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mount-hdc<span class="token function">cp</span> hdc/var/process.log process.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看process.log，进程0在log关联文件描述符之前就已经在运行，因此未出现在log文件中<br /><img src="attachment/3e830a5c6e61ab255ee992dc5bac5593.png" alt="" /><img src="attachment/8e0524ec54ddb87b0a5e113d5fa1d7fa.png" alt="" /></p><h2 id="5-分析log"><a class="markdownIt-Anchor" href="#5-分析log"></a> 5. 分析log</h2><p>用指导书给的py脚本程序<code>stat_log.py</code>分析log文件，在分析之前将py脚本文件的第一行<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2</code>（已安装python2）以适配版本，否则在python3环境下<code>print</code>函数会出错<br />为该脚本文件分配可执行权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x stat_log.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行脚本，分析进程9、10、11、12的运行情况（多个指标：平均周转时间，平均等待时间）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./stat_log.py process.log <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token parameter variable">-g</span> <span class="token operator">|</span> <span class="token function">less</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/649840cfe743be95432ea8e447458260.png" class=""><h2 id="6-修改时间片重新分析log"><a class="markdownIt-Anchor" href="#6-修改时间片重新分析log"></a> 6. 修改时间片，重新分析log</h2><p>进程的时间片是进程的<code>counter</code>值，而counter在schedule函数中根据<code>priority</code>动态设置，因此进程的时间片受<code>counter</code>和<code>prioriy</code>两个变量的影响。进程的<code>priority</code>继承自父进程，进而所有进程的<code>priority</code>都来自于进程0 。<br />linux0.11中，<code>priority</code>和<code>counter</code>在<code>include/linux/sched.h</code>中定义</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/272c3457121ac25449d18a44519a3a56.png" class=""><p>我们修改这个值，然后重新执行process程序，分析log。</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/edf7c77ecdd9d23b77031b2b97969a17.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/edf7c77ecdd9d23b77031b2b97969a17.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/308e7fc00291185da771123b16b349b8.png" class=""><p>可以看到这里的时间平均周转时间变多了，有以下两种可能：</p><ol><li>当进程的执行时间很长时，增加时间片大小可能会导致进程在等待时间片结束时的等待时间变长，因为进程需要等待更长的时间才能获得 CPU</li><li>当进程的数量非常多时，增加时间片大小可能会导致进程在就绪队列中等待的时间变长，因为每个进程需要等待更长的时间才能获得 CPU。</li></ol><p>因此，时间片大小的设置需要根据具体情况进行调整，不能简单地认为增加时间片大小一定会减少平均周转时间。需要根据系统中进程的数量、执行时间等因素来选择合适的时间片大小，从而达到更好的系统性能。</p><h1 id="实验4-基于内核栈切换的进程切换"><a class="markdownIt-Anchor" href="#实验4-基于内核栈切换的进程切换"></a> 实验4 基于内核栈切换的进程切换</h1><hr /><p>我这个实验做的不是很好，建议本实验参考其他的博客</p><h2 id="1-修改schedule函数"><a class="markdownIt-Anchor" href="#1-修改schedule函数"></a> 1.  修改schedule函数</h2><p>在TSS切换中，依赖TR寄存器找到下一个进程的tss，从而实现切换，因此在switch_to中没有next的PCB。要在<code>switch_to</code>函数中，将TSS的切换改为内核栈的切换，首先要在<code>schedule</code>函数中给<code>switch_to</code>函数传入next的PCB。因为这里没有TSS的切换，需要再单独做LDT表的切换。<br />在函数声明中，参数列表是从左到右依次列出的，而在函数栈帧中，参数是从右到左依次压入的。因此调用<code>switch_to</code>函数后，当前进程的内核中依次压入了LDT(next)，pnext和返回地址<br />因为这里涉及函数调用和栈，所以补充一下<code>%esp</code>和<code>%ebp</code>的知识：</p><blockquote><p>ESP寄存器用于指向当前栈帧的顶部，即栈中当前可用的最高地址。而EBP寄存器则通常用于指向当前函数的栈帧，也称为帧指针。EBP寄存器存储的是当前栈帧的起始位置，也就是栈中当前函数的参数和局部变量存储的位置。在函数执行期间，ESP寄存器的值会随着栈中数据的压入和弹出而不断变化，以保持其始终指向当前栈帧的顶部。而EBP寄存器的值通常不会被修改，以保持其一直指向当前函数的栈帧。这样可以确保函数能够正确地访问和修改栈帧中的参数、局部变量和返回地址等信息，而不会干扰其他函数的栈帧。<br />在函数调用过程中，处理器会将该函数的参数值和返回地址等信息压入当前函数的栈帧中，并将ESP寄存器的值减少相应的字节数。如果在函数执行期间没有再将其他数据压入栈中，那么ESP寄存器的值将等于EBP寄存器的值，即它们都指向栈帧的底部。需要注意的是，函数栈帧的大小通常是在编译时确定的，因此在函数调用前，编译器就已经为该函数分配了足够的栈空间。如果在函数执行期间需要动态分配更多的栈空间，那么ESP和EBP寄存器的值就会发生变化，以指向新分配的栈空间的位置<br />因此，ESP指向栈帧的顶部，EBP指向栈帧的起始位置，两者配合使用，能够在函数执行期间正确地访问和修改栈帧中的数据。</p></blockquote><p><strong>旁注：LDT表实现进程间的地址隔离</strong></p><blockquote><p>在x86架构中，进程与LDT（Local Descriptor Table）有密切的关系，LDT可以用来隔离和保护不同进程的地址空间。<br />LDT是一种描述符表，用于存储局部数据段和局部代码段的信息。与全局描述符表（GDT）不同，LDT表是针对每个进程单独维护的，每个进程都可以有自己的LDT表。LDT表的主要作用是实现地址空间的隔离，以保护、不同进程的内存空间不被其他进程访问或修改。<br />在x86架构中，进程的地址空间通常被划分为多个段，每个段都有自己的基地址和大小。通过使用LDT表中的描述符，可以将进程的地址空间划分为多个不同的段，并且每个进程都有自己独立的LDT表，这样可以实现不同进程的地址空间之间的隔离和保护。<strong>进程中的所有数据段和代码段都必须使用LDT中的描述符进行描述，以便在进程运行时能够正确地访问和修改这些段中的数据</strong>。<br />在Linux 0.11内核中，进程的LDT表存储在进程控制块（PCB）中，每个进程都有自己独立的LDT表。当进程被调度执行时，LDT表的选择子被存储在进程的TSS（Task State Segment）中，用于访问进程的LDT表。通过使用LDT表，可以实现不同进程之间的地址空间隔离和保护，提高系统的安全性和稳定性。<br />总之，LDT表是实现进程地址空间隔离和保护的重要手段，可以帮助操作系统实现不同进程之间的资源隔离和保护。在x86架构下，LDT表和进程的地址空间划分密切相关，每个进程都有自己独立的LDT表和地址空间划分。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>next<span class="token punctuation">,</span>c<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pnext <span class="token operator">=</span> <span class="token operator">&amp;</span>init_task<span class="token punctuation">.</span>task <span class="token punctuation">;</span>  <span class="token comment">//指向下一个进程的PCB的PCB指针,初始化指向进程0</span><span class="token comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&lt;</span> jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGALRM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>_BLOCKABLE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>blocked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">==</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">=</span>TASK_RUNNING<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* this is the scheduler proper: */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">=</span> NR_TASKS<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">></span> c<span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">,</span> next <span class="token operator">=</span> i<span class="token punctuation">,</span> pnext <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>priority<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">switch_to</span><span class="token punctuation">(</span>pnext<span class="token punctuation">,</span> <span class="token function">_LDT</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  传递下一个进程的PCB (切换执行序列)和LDT (切换内存空间)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-修改switch_to函数"><a class="markdownIt-Anchor" href="#2-修改switch_to函数"></a> 2. 修改switch_to函数</h2><p><code>switch_to</code>函数是一个宏函数，位于<code>include/linux/sched.h</code>中，我们先注释掉这个原版<code>switch_to</code>，在<code>kernel/system_call.s</code>中编写新的<code>switch_to</code>函数。</p><pre class="line-numbers language-none"><code class="language-none">ESP0&#x3D; 0x04KERNEL_STACK    &#x3D; 0x0C # kernel_stack变量在task_struct中的偏移量switch_to:        pushl %ebp     # 压入C函数schedule的栈帧        movl %esp,%ebp # 将当前进程的栈顶指针esp拷贝给%ebp，使它指向刚刚压入的esp值        pushl %ecx     # 这几个寄存器可能是调用函数schedule中用到的寄存器，因此先保存        pushl %ebx        pushl %eax        movl 8(%ebp),%ebx   #取出传入的pnext参数，即下一个进程的PCB指针        cmpl %ebx,current           je 1f               # next是否是当前进程，如果是，则向前(Forward)跳转到标号1开始执行，不执行转换# PCB        movl %ebx,%eax        xchgl %eax,current  # exchange value, 切换进程PCB, 此时%eax指向当前进程，current指向下一个进程# TSS 使用户栈能找到内核栈，借用进程0的tss保存内核栈的esp0信息        movl tss, %ecx  # 在kernel&#x2F;sched.c中定义tss &#x3D; &amp; init_task.task.tss        addl $4096, %ebx   # 让ebx指向页表最高地址处，这里也是内核栈的基址        movl %ebx, ESP0(%ecx) # 修改tss中的esp0(偏移量为4)，使它指向内核栈的栈顶位置，此时就是栈基址# switch kernel_stack   切换的关键        movl %esp, KERNEL_STACK(%eax) # 取出CPU.esp 保存到当前进程的PCB中，task_struct中需要添加kernel_stack变量，并修改INIT_TASK        movl 8(%ebp),%ebx # 重新取出下一个进程的PCB        movl KERNEL_STACK(%ebx), %esp # 将下一个进程的PCB中的内核栈的栈顶信息esp放入CPU中# switch LDT        movl 12(%ebp), %ecx  # 取出传入的 LDT(next)参数        lldt %cx  # lldt指令用于将LDT的段选择子加载到LDTR寄存器中，LDTR寄存器是一个16位的寄存器，存储LDT的段选择子，硬件根据LDTR在GDT中查找以获取LDT的地址        movl $0x17,%ecx  # 重置 fs寄存器        mov %cx,%fs        cmpl %eax,last_task_used_math        jne 1f        clts1:          popl %eax  # 返回C函数schedule，恢复寄存器(特别是帧指针%ebp)        popl %ebx        popl %ecx        popl %ebp        ret.align 2first_return_from_kernel:  # 一段包含iret的代码，用于返回用户栈        popl %edx        popl %edi        popl %esi        pop %gs        pop %fs        pop %es        pop %ds        iret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/272c3457121ac25449d18a44519a3a56.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/2486dfe436507ac24b973c6b4c513e77.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><h2 id="3-修改copy_process函数"><a class="markdownIt-Anchor" href="#3-修改copy_process函数"></a> 3.  修改copy_process函数</h2><p>在fork.c的copy_process部分添加以下代码用于设置进程的内核栈， 并注释掉设置tss的部分</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*set up kernel stack *&#x2F;long * krnstack &#x3D;(long)(PAGE_SIZE + (long)p);*(--krnstack) &#x3D; ss &amp; 0xffff;  # 压入SS:SP*(--krnstack) &#x3D; esp;*(--krnstack) &#x3D; eflags;*(--krnstack) &#x3D; cs &amp; 0xffff;  # 压入CS:IP*(--krnstack) &#x3D; eip;*(--krnstack) &#x3D; ds &amp; 0xffff;*(--krnstack) &#x3D; es &amp; 0xffff;*(--krnstack) &#x3D; fs &amp; 0xffff;*(--krnstack) &#x3D; gs &amp; 0xffff;*(--krnstack) &#x3D; esi;*(--krnstack) &#x3D; edi;*(--krnstack) &#x3D; edx;*(--krnstack) &#x3D; (long) first_return_from_kernel; &#x2F;&#x2F; a code segment with iret instruction*(--krnstack) &#x3D; ebp;*(--krnstack) &#x3D; ecx;*(--krnstack) &#x3D; ebx;*(--krnstack) &#x3D; 0;p-&gt;kernel_stack &#x3D; krnstack;  # 设置PCB中的内核栈栈顶指针信息为初始化后的栈顶指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验5-信号量的实现与应用"><a class="markdownIt-Anchor" href="#实验5-信号量的实现与应用"></a> 实验5 信号量的实现与应用</h1><h2 id="1-前提-2"><a class="markdownIt-Anchor" href="#1-前提-2"></a> 1. 前提</h2><h3 id="1-系统调用open打开文件"><a class="markdownIt-Anchor" href="#1-系统调用open打开文件"></a> (1) 系统调用open打开文件</h3><p>要使用系统调用方式打开文件，可以使用 open 系统调用。该系统调用的原型定义在 &lt;fcntl.h&gt; 头文件中，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，pathname 参数是要打开的文件名，可以是相对路径或绝对路径，可以包含目录名和文件名；flags 参数是打开文件的选项和标志，比如只读、只写、追加、创建等；mode 参数是创建文件时的权限，仅在创建文件时使用，可以指定文件的读写权限。<br />常用的打开选项和标志包括：</p><ul><li>O_RDONLY：只读模式打开文件。</li><li>O_WRONLY：只写模式打开文件。</li><li>O_RDWR：读写模式打开文件。</li><li>O_CREAT：如果文件不存在则创建文件。</li><li>O_TRUNC：如果文件已存在则清空文件内容。</li><li>O_APPEND：在文件末尾追加内容。</li><li>O_EXCL：在创建文件时，如果文件已存在则返回错误。</li></ul><p>如果成功打开文件，系统调用返回一个非负整数，即文件描述符（file descriptor），用于后续访问文件内容。如果出错，则返回一个负值，表示出错的类型。<br />对第2个参数flags，可以使用了<code>|</code>运算符将多个选项参数组合在一起。这是因为 open 系统调用的选项参数是一个位掩码，每个选项都有一个对应的位标志，可以使用位运算符组合多个选项。<br />对第3个参数mode，文件的访问权限是一个八进制数，表示文件的所有者、所属组和其他用户对文件的访问权限。<br />每个访问权限位的含义如下：</p><ul><li>读权限：4</li><li>写权限：2</li><li>执行权限：1</li></ul><p>在使用 open 系统调用创建文件时，可以通过一个八进制数来指定文件的访问权限。通常情况下，可以将三个访问权限位组合在一起，得到一个八进制数，作为 mode 参数传递给 open 系统调用。例如，如果要将文件的访问权限设置为所有用户都有<strong>写</strong>权限，可以使用以下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_WRONLY<span class="token punctuation">,</span> <span class="token number">0222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 0开头的数字表示这是一个八进制数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-系统调用write写入文件"><a class="markdownIt-Anchor" href="#2-系统调用write写入文件"></a> (2) 系统调用write写入文件</h3><p>在 C 语言中，write 函数用于向文件或者文件描述符写入数据，其函数原型为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>write 函数的三个参数分别表示：</p><ol><li>fd：文件描述符，它是一个整数，用于指定要写入数据的文件或设备。在 Linux 系统中，标准输入、标准输出和标准错误分别对应文件描述符 0、1 和 2。用户可以使用 open 函数打开其他文件或设备，并获得相应的文件描述符。</li><li>buf：指向要写入数据的缓冲区的指针。在写入数据之前，用户需要将数据存储在缓冲区中，然后将缓冲区的地址传递给 write 函数。</li><li>count：要写入的字节数。用户需要指定要写入数据的长度，以字节数为单位。如果缓冲区中的数据长度小于 count，则 write 函数只会写入部分数据；如果缓冲区中的数据长度大于 count，则 write 函数只会写入 count 字节的数据。</li></ol><p>当 write() 函数成功写入数据时，内核会更新文件偏移量，以便下一次读写操作从正确的位置开始。<br />需要注意的是，write 函数返回值是 ssize_t 类型，表示成功写入的字节数，如果返回值为负数，则表示写入失败。</p><h3 id="3-系统调用read从文件读取数据"><a class="markdownIt-Anchor" href="#3-系统调用read从文件读取数据"></a> (3) 系统调用read从文件读取数据</h3><p>在 Linux 系统中，read() 是一个用于从文件描述符中读取数据的系统调用。该调用的原型如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>read() 函数有三个参数：</p><ol><li>fd：要读取的文件的文件描述符。</li><li>buf：用于存储读取数据的缓冲区。</li><li>count：要读取的字节数。</li></ol><p>read() 函数会从指定的文件描述符 fd 中读取 count 个字节的数据，并将其存储到 buf 缓冲区中。函数返回实际读取的字节数，如果读取出错，则返回 -1。<br />read() 函数在读取数据时可能会阻塞进程，直到有数据可读或发生错误。如果读取到文件末尾，函数返回 0。如果读取的字节数小于 count，则可能是因为已经到达文件末尾或者因为发生了错误。<br />当使用 read() 函数读取数据时，内核会将文件偏移量更新为读取数据后的下一个位置。例如，如果你使用 read() 函数从文件的位置 100 处读取 50 个字节的数据，则文件偏移量会从 100 更新为 150 (100~149)。这样，下一次读取数据操作将从文件位置 150 处开始。使用 lseek() 函数可以显式地设置文件偏移量。<br />read() 函数可以用于读取文件、套接字、管道等类型的文件描述符。</p><h3 id="4-系统调用lseek移动文件指针"><a class="markdownIt-Anchor" href="#4-系统调用lseek移动文件指针"></a> (4) 系统调用lseek移动文件指针</h3><p>lseek函数用于在文件中移动文件指针的位置。该函数的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// off_t 是long的别名，在&lt;sys/types.h>中定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，fd 是已打开文件的文件描述符，offset 是需要移动的偏移量，whence 则用于指定相对于何处进行偏移，其取值可以为 SEEK_SET、SEEK_CUR 或 SEEK_END。这三个常量在&lt;unistd.h&gt; 头文件中定义</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/ee06a722e7ba781e506f36fd67cfc32c.png" class=""><ul><li>当 whence 值为 SEEK_SET时，文件指针将被设置为相对于文件开头偏移 offset 个字节的位置。</li><li>当 whence 值为 SEEK_CUR时，文件指针将被设置为相对于当前位置偏移 offset 个字节的位置。</li><li>当 whence 值为 SEEK_END时，文件指针将被设置为相对于文件末尾偏移 offset 个字节的位置。</li></ul><p>lseek() 函数返回新的文件指针位置，如果出现错误则返回 -1。通过调用 lseek() 函数可以实现随机访问文件的功能，比如读取文件中的任意部分内容、覆盖文件中的任意部分内容等。</p><h2 id="2-创建semaphore类型"><a class="markdownIt-Anchor" href="#2-创建semaphore类型"></a> 2. 创建semaphore类型</h2><p>在<code>include/linux/sem.h</code>写入以下内容</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_SEM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_SEM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span>   <span class="token comment">// for task_struct definition</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_TABLE_LEN</span> <span class="token expression"><span class="token number">20</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME_LEN</span><span class="token expression"><span class="token number">20</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">semaphore</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span>SEM_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>queue<span class="token punctuation">;</span>   <span class="token comment">// wait queue</span><span class="token punctuation">&#125;</span><span class="token class-name">sem_t</span><span class="token punctuation">;</span><span class="token class-name">sem_t</span> sem_table<span class="token punctuation">[</span>SEM_TABLE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建信号量相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建信号量相关的系统调用"></a> 3. 创建信号量相关的系统调用</h2><p>在<code>kernel/sem.c</code>中写入以下内容，包括信号量的创建<code>sys_sem_open</code>，P操作<code>sys_sem_wait</code>，V操作<code>sys_sem_post</code>，和释放信号量<code>sys_sem_unlink</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/tty.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/fdreg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/system.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/io.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;asm/segment.h></span></span><span class="token comment">// #include&lt;string.h>  // avoid unknowned error</span><span class="token keyword">int</span> cnt<span class="token punctuation">;</span>   <span class="token comment">// the number of semaphores in sem_table, auto initial to zero</span><span class="token class-name">sem_t</span> <span class="token operator">*</span> <span class="token function">sys_sem_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> name_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> isExist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> sem_name_len <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> kernel_sem_name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"\0"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token class-name">sem_t</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>name_len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>         kernel_sem_name<span class="token punctuation">[</span>name_len<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token operator">++</span>name_len<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">// printk("name_len: %d\tstrlen: %d\n",name_len,strlen(kernel_sem_name));</span><span class="token keyword">if</span><span class="token punctuation">(</span>name_len <span class="token operator">></span> SEM_NAME_LEN<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">/*find duplicate*/</span><span class="token punctuation">&#123;</span>sem_name_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// printk("%d:%s!\t%d:%s!\n",sem_name_len,sem_table[cnt].name,name_len,kernel_sem_name);</span><span class="token keyword">if</span><span class="token punctuation">(</span>sem_name_len <span class="token operator">==</span> name_len <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kernel_sem_name<span class="token punctuation">,</span> sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>isExist <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>isExist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//printk("i am consumer!\n");</span>p <span class="token operator">=</span> sem_table<span class="token operator">+</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>sem_table<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> kernel_sem_name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// printk("ID:(%d)\t %d\t%s!\t%d\t%s!\n",cnt,strlen(sem_table[cnt].name),sem_table[cnt].name,strlen(kernel_sem_name),kernel_sem_name);</span>sem_table<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>p <span class="token operator">=</span> sem_table<span class="token operator">+</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span>        <span class="token comment">//printk("i am producer!\n");</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sys_sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>sem<span class="token operator">-></span>value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>sem<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sys_sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>sem<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>sem<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sys_sem_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> name_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>name_len<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">++</span>name_len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>name_len <span class="token operator">></span> SEM_NAME_LEN<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">char</span> kernel_sem_name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>name_len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>kernel_sem_name<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get_fs_byte</span><span class="token punctuation">(</span>name<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> isExist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> sem_name_len <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sem_name_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sem_name_len <span class="token operator">==</span> name_len <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kernel_sem_name<span class="token punctuation">,</span> sem_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>isExist <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>isExist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> tmp <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>tmp<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sem_table<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> sem_table<span class="token punctuation">[</span>tmp<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// overwrite</span><span class="token punctuation">&#125;</span><span class="token operator">--</span>cnt<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将sys_function添加到内核的系统调用已在lab2讲解过，这里只上截图</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c15ef0cb21a3f300d2f857ed2dfe1f93.png" class=""><p>修改Makefile</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/51c4ca221a6f533faf3e74d6c11da93c.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/86a7f4e3d5fbd9a340787a51970cdda0.png" class=""><h2 id="4-创建生产者-消费者进程"><a class="markdownIt-Anchor" href="#4-创建生产者-消费者进程"></a> 4. 创建生产者-消费者进程</h2><p>在<code>pc.c</code>中写入以下内容</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem_open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_wait<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_post<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> sem_unlink<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_CONSUMER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_PRODUCTS <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> pro_nr<span class="token punctuation">,</span> csm_pro_nr<span class="token punctuation">;</span> <span class="token comment">/*product number, consumed product number*/</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> FILENAME <span class="token operator">=</span> <span class="token string">"/usr/root/buffer_file"</span><span class="token punctuation">;</span> <span class="token comment">/*default buffer file*/</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token operator">*</span>full<span class="token punctuation">,</span> <span class="token operator">*</span>empty<span class="token punctuation">;</span><span class="token keyword">int</span> f_in<span class="token punctuation">;</span>   <span class="token comment">/* for producer*/</span><span class="token keyword">int</span> f_out<span class="token punctuation">;</span>  <span class="token comment">/* for consumer*/</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> file_name <span class="token operator">=</span> argc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> FILENAME<span class="token punctuation">;</span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token keyword">int</span> cnt<span class="token punctuation">;</span> <span class="token comment">/* must declare cnt here */</span><span class="token comment">/*open buffer file */</span>f_in <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> O_CREAT<span class="token operator">|</span>O_TRUNC<span class="token operator">|</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f_out <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span>O_TRUNC<span class="token operator">|</span>O_RDONLY<span class="token punctuation">,</span> <span class="token number">0444</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*create semaphores*/</span>mutex <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>full <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>empty <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*parent process as producer*/</span>pro_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\t producer created!\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>pro_nr <span class="token operator">&lt;</span> NR_PRODUCTS<span class="token punctuation">)</span> <span class="token comment">/*until product all products then producer exit*/</span><span class="token punctuation">&#123;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>pro_nr <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">lseek</span><span class="token punctuation">(</span>f_in<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*10 products per turn*/</span><span class="token function">write</span><span class="token punctuation">(</span>f_in<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>pro_nr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pro_nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\t produces product %d!\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> pro_nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>pro_nr<span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*child process create child processes to be consumer*/</span><span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>cnt <span class="token operator">=</span> NR_CONSUMER<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\t consumer %d created!\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> NR_CONSUMER<span class="token operator">-</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>csm_pro_nr <span class="token operator">==</span> NR_PRODUCTS<span class="token punctuation">)</span> <span class="token keyword">goto</span> OK<span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">read</span><span class="token punctuation">(</span>f_out<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>csm_pro_nr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>csm_pro_nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">/*end of file,reset*/</span><span class="token punctuation">&#123;</span><span class="token function">lseek</span><span class="token punctuation">(</span>f_out<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span>f_out<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>csm_pro_nr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>csm_pro_nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid:%d:\t consumer %d consume product %d\n"</span><span class="token punctuation">,</span>pid<span class="token punctuation">,</span> NR_CONSUMER<span class="token operator">-</span>cnt<span class="token punctuation">,</span>csm_pro_nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>OK<span class="token operator">:</span><span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>f_in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>f_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-验证结果"><a class="markdownIt-Anchor" href="#5-验证结果"></a> 5. 验证结果</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#current catalogue: OSLab5</span>./mount-hdc<span class="token comment">#更新标准库</span><span class="token function">cp</span> include/unistd.h hdc/usr/include   <span class="token function">cp</span> include/linux/sem.h hdc/usr/include <span class="token comment">#run</span><span class="token function">cp</span> pc.c hdc/usr/root./run<span class="token comment">#在bochs中执行</span>gcc <span class="token parameter variable">-o</span> pc pc.c./pc <span class="token operator">></span> sem_output <span class="token comment"># 将输出结果重定向到文件sem_output，便于查看</span><span class="token function">sync</span>  <span class="token comment">#将所有的缓存数据写入磁盘，lab3中出现过</span><span class="token comment">#回到ubuntu执行</span>./mount-hdc<span class="token function">cp</span> hdc/usr/root/sem_output sem_outputgedit sem_output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/86a7f4e3d5fbd9a340787a51970cdda0.png" class=""><p>查看sem_output验证信号量机制的正确性</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>可以看出，producer每生产一轮，即填满容量为10的缓冲区后，5个consumer就开始消耗缓冲区，消耗完后producer又生产一轮，直到达到最大产品数量<code>NR_PRODUCTS = 50</code>(0~49)后退出，consumer在消耗完所有产品后也退出<br /><a href="https://www.cnblogs.com/mirage-mc/p/12913993.html">reference</a></p><h1 id="实验6-地址映射与共享"><a class="markdownIt-Anchor" href="#实验6-地址映射与共享"></a> 实验6 地址映射与共享</h1><h2 id="1-跟踪地址翻译过程"><a class="markdownIt-Anchor" href="#1-跟踪地址翻译过程"></a> 1. 跟踪地址翻译过程</h2><ol><li>启动调试，获取i的逻辑地址为<code>ds:0x3004</code>，ds表明该地址属于由ds寄存器指示的段 (后续称ds段)</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/be0fe056a34a3f0d79a4adbf9469162b.png" class=""><ol start="2"><li>通过段表(LDT)，确定ds段的起始地址，进而将逻辑地址转化为虚拟地址。段表由LDTR指示，运行命令<code>sreg</code>查看LDTR的值，该寄存器用于从GDT中取出进程的LDT地址</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/96f0f5111b99db234b71b696fffa6d9b.png" class=""><p>LDTR的值为<code>0x68 = 0x0000 0000 0110 1000</code>，取3~15位表示段选择子<code>1101</code>，说明目标LDT在GDT的第13项(从0索引)<br />GDT的地址已经由gdtr指出为<code>0x00005cb8</code>，因为GDT每项段描述符占8个字节，因此查看GDT的<code>0x00005cb8+8*13</code>处的8个字节，这8个字节就是目标LDT的段描述符</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>根据段描述符的结构，从0x<strong>52d0</strong>0068 0x<strong>00</strong>0082<strong>fd</strong>(0~64bits）提取出<code>0x00fd52d0</code>，这就是目标LDT的基地址</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>ds段的基地址由ds寄存器(段选择子)在LDT中指示，我们先用<code>sreg</code>查看ds的值</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/96f0f5111b99db234b71b696fffa6d9b.png" class=""><p>段选择子ds的值是0x0017 = 0x <strong>0000 0000 0001 0</strong>111 (16bits)，根据段选择子的结构</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c15ef0cb21a3f300d2f857ed2dfe1f93.png" class=""><p>从ds中提取出段选择符的索引<code>0x10</code>，可见ds段在LDT的第3项(从0编号)，于是接下来查看目标LDT的前四项(每项占四个字节)</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/96f0f5111b99db234b71b696fffa6d9b.png" class=""><p>获取了目标LDT中第3个段描述符的数据: 0x<strong>0000</strong>3fff 0x<strong>10</strong>c0f3<strong>00</strong>，根据段描述符的结构，提取出基地址: <code>1000 0000</code>，自此我们可以将<code>i</code>逻辑地址转化为虚拟地址(线性地址)了<br />虚拟地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>0000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>3004</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>3004</mn></mrow><annotation encoding="application/x-tex">base +offset=0x1000\,0000 + 0x3004 =0x1000\,3004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span></p><ol start="3"><li>将虚拟地址映射到的物理地址</li></ol><p>根据虚拟地址结构，可知<code>0x1000 3004 = 0x0001 0000...0000 0011 000..0 0100</code>表示的物理地址在页目录64对应的页表中，页号为3(页号连续，因此由第3个页表项指示)，页内偏移为4</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/7f643184367f37c18a7cd185b7c1f91d.png" class=""><p>内存中页目录表的位置由寄存器CR3指示，使用<code>creg</code>查看CR3寄存器的值</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>CR3的值为0x00000000，所以页目录表从地址0x00000000开始，我们要获取第64项，页目录表每项占4个字节，因此使用<code>xp /2w 0+64*4</code>查看第64项的内容</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/be0fe056a34a3f0d79a4adbf9469162b.png" class=""><p>得到第64个页目录项的内容为: 0x<strong>00fa7</strong>027 0x00000000，根据页目录项的结构，前20位表示所指向的页表的地址的高20位 (<a href="https://stackoverflow.com/questions/26858196/why-does-page-directory-entries-need-20-bits-to-point-210-page-tables">why</a>）为<code>0x00fa7</code>，因为页表物理地址的低12位为0（对齐到4KB的倍数），因此页表的最终的物理地址为<code>0x00fa7000</code></p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>一个页表项占4个字节，使用<code>xp /2w 0x00fa7000+4*3</code>查找目标页表的第3个页表项(物理页框)</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>得到第3个页表项的内容为0x<strong>00fa6</strong>067 0x00000000<br />根据页表项的结构，前20项表示物理页框的高20位地址: 0x00fa6 (物理页面大小为4KB，基地址与4KB对齐，为 0x**** **** **** **** **** 0000 0000 0000) ,因此目标物理页框的基地址为0x00fa6000</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><p>最后我们加上页内偏移4，得到最终的物理地址<code>0x00fa6004</code></p><ol start="4"><li>验证</li></ol><p>执行<code>xp /w 0x00fa6004</code>查看我们确定的物理地址的数据内容</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/be0fe056a34a3f0d79a4adbf9469162b.png" class=""><p>这个值与<code>i</code>在程序中的值相一致<br />用命令<code>setpmem 0x00fa6004 4 0</code>将<code>0x00fa6004</code>开始的4个字节(i为int型)全部设置为0，即设置i为0，则程序从原本的无限循环中退出</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/a732a95e6628aa8f992d859de9548ce8.png" class=""><h2 id="2-添加共享内存功能"><a class="markdownIt-Anchor" href="#2-添加共享内存功能"></a> 2. 添加共享内存功能</h2><h3 id="1-前提-通过brk划分虚拟内存"><a class="markdownIt-Anchor" href="#1-前提-通过brk划分虚拟内存"></a> (1) 前提: 通过brk划分虚拟内存</h3><p>进程栈和堆之间的内存空间可以映射到共享的物理页面，brk作为指向进程堆的末尾的指针（即下图中处于下方的虚线），将brk加上进程数据段在虚拟内存中的基址，便可以得到brk的虚拟地址，以这个地址为起点，划分出大小为PAGE_SIZE的虚拟内存，再将这部分虚拟内存通过<code>put_page</code>映射到共享内存上<br /><img src="https://i.stack.imgur.com/1aV6B.png#from=url&amp;id=Lavvc&amp;originHeight=193&amp;originWidth=128&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" /></p><h3 id="2-创建用于管理共享内存的数据结构"><a class="markdownIt-Anchor" href="#2-创建用于管理共享内存的数据结构"></a> (2) 创建用于管理共享内存的数据结构</h3><p><code>linux-0.11/include/linux/shm.h</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SHM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__SHM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_SIZE</span> <span class="token expression"><span class="token number">32</span> </span><span class="token comment">/*Maximum number of shared pages*/</span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">key_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">shm</span><span class="token punctuation">&#123;</span>        <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>          <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> page<span class="token punctuation">;</span> <span class="token comment">/*shared page address */</span><span class="token punctuation">&#125;</span>shm<span class="token punctuation">;</span>shm shm_list<span class="token punctuation">[</span>SHM_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-创建共享内存相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建共享内存相关的系统调用"></a> (3) 创建共享内存相关的系统调用</h3><p><code>linux-0.11/kernel/shm.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span> <span class="token comment">/*for current define*/</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/shm.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/mm.h></span> <span class="token comment">/* PAGE_SIZE,get_free_page */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token comment">/*function: apply for a shared page, return shm_id according to key*/</span><span class="token keyword">int</span> <span class="token function">sys_shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">void</span><span class="token operator">*</span> page<span class="token punctuation">;</span>      <span class="token comment">/*printk("hello, i am here for debug!\n");*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">></span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token comment">/*size beyond border*/</span>        <span class="token punctuation">&#123;</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"size beyond PAGE_SIZE!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>SHM_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>   <span class="token comment">/*constructed before*/</span>                <span class="token punctuation">&#123;</span>                        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"constructed before!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        page <span class="token operator">=</span> <span class="token function">get_free_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span>   <span class="token comment">/*no free memory*/</span>        <span class="token punctuation">&#123;</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"no free page!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                errno <span class="token operator">=</span> ENOMEM<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"shmget get memory's address is 0x%08x\n"</span><span class="token punctuation">,</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>SHM_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token comment">// record for manage</span>                <span class="token punctuation">&#123;</span>                        shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>                         shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>                        shm_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>                        <span class="token keyword">return</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/*shm_list is full and key is invalid*/</span>        <span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sys_shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> data_base<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> brk<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>shmid<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> shmid<span class="token operator">>=</span>SHM_SIZE <span class="token operator">||</span> shm_list<span class="token punctuation">[</span>shmid<span class="token punctuation">]</span><span class="token punctuation">.</span>page <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                errno <span class="token operator">=</span> EINVAL<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        data_base <span class="token operator">=</span> <span class="token function">get_base</span><span class="token punctuation">(</span>current<span class="token operator">-></span>ldt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*I know get_base from copy_mem() function*/</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"current data_base = 0x%08x, new page = 0x%08x\n"</span><span class="token punctuation">,</span>data_base<span class="token punctuation">,</span>shm_list<span class="token punctuation">[</span>shmid<span class="token punctuation">]</span><span class="token punctuation">.</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* brk is the end of heap section,         * the virtual memory space between heap and stack can map to shared physical page,         * so slice this part of virtual memory to map the shared page */</span>        <span class="token comment">/*logic address convert to virtual address by adding base address*/</span>        brk <span class="token operator">=</span> current<span class="token operator">-></span>brk<span class="token operator">+</span>data_base<span class="token punctuation">;</span>        current<span class="token operator">-></span>brk <span class="token operator">+=</span>PAGE_SIZE<span class="token punctuation">;</span>        <span class="token function">put_page</span><span class="token punctuation">(</span>shm_list<span class="token punctuation">[</span>shmid<span class="token punctuation">]</span><span class="token punctuation">.</span>page<span class="token punctuation">,</span> brk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>current<span class="token operator">-></span>brk <span class="token operator">-</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*logic address*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-创建生产者进程"><a class="markdownIt-Anchor" href="#4-创建生产者进程"></a> (4) 创建生产者进程</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem_open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_wait<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_post<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> sem_unlink<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    <span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> shmget<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> shmat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmid<span class="token punctuation">)</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> NR_PRODUCTS <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> SHM_KEY <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_id<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment">/*point to the shared memory*/</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">/* products number */</span>    <span class="token keyword">int</span> buffer_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token class-name">sem_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token operator">*</span>full<span class="token punctuation">,</span> <span class="token operator">*</span>empty<span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    full <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    empty <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    shm_id <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>SHM_KEY<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_id <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shm_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_PRODUCTS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span>buffer_pos<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d:\tproducer produces product %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer_pos <span class="token operator">=</span> <span class="token punctuation">(</span>buffer_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>BUFFER_SIZE<span class="token punctuation">;</span>  <span class="token comment">/*end of the buffer,refresh*/</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-创建消费者进程"><a class="markdownIt-Anchor" href="#5-创建消费者进程"></a> (5) 创建消费者进程</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIBRARY__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/sched.h></span></span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem_open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_wait<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> sem_post<span class="token punctuation">,</span> <span class="token class-name">sem_t</span><span class="token operator">*</span><span class="token punctuation">,</span> sem<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> sem_unlink<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token function">_syscall2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> shmget<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> shmat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmid<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_PRODUCTS <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> SHM_KEY <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_id<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> used_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/*products count*/</span>    <span class="token keyword">int</span> buffer_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token operator">*</span>full<span class="token punctuation">,</span> <span class="token operator">*</span>empty<span class="token punctuation">;</span>mutex <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>full <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>empty <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        shm_id <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>SHM_KEY<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_id <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shm_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid %d consumer consumes products %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ptr<span class="token punctuation">[</span>buffer_pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer_pos <span class="token operator">=</span> <span class="token punctuation">(</span>buffer_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>BUFFER_SIZE<span class="token punctuation">;</span>  <span class="token comment">/*end of the buffer,refresh*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>used_cnt <span class="token operator">==</span> NR_PRODUCTS<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"EMPTY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"MUTEX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token string">"FULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-添加到系统调用和修改makefile"><a class="markdownIt-Anchor" href="#6-添加到系统调用和修改makefile"></a> (6) 添加到系统调用和修改MakeFile</h3><ol><li>添加到系统调用</li></ol><p>如之前的lab一样，验证结果时将unistd.h复制到hdc/usr/include目录下，记得将shm.h也复制到对应目录中</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/e8b42fd0449952451907b1e0f34ce770.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9b9b2cd55c94679c33508fb4312374e4.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9b9b2cd55c94679c33508fb4312374e4.png" class=""><ol start="2"><li>修改MakeFile</li></ol><p><code>linux-0.11/kernel/Makefile</code></p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/e8b42fd0449952451907b1e0f34ce770.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9b9b2cd55c94679c33508fb4312374e4.png" class=""><h3 id="7-踩的坑"><a class="markdownIt-Anchor" href="#7-踩的坑"></a> (7) 踩的坑</h3><ol><li>编译shm.c时，总是出现<code>parse error before int</code>的错误，耗时调试了一个小时还是无法解决，Google后发现原因在于linux0.11下的C标准为C89，要求声明变量的语句只能出现在非声明语句的前面 (声明同时又赋值语句的可以)</li><li>lab5的sem.c写的有问题，consumer进程一直处于sleep状态，添加了几条打印语句后发现，consumer进程和producer进程未使用同一套信号量，原因在于sem.c的sys_sem_open函数内定义kernel_sem_name未显式的初始化，我以为该变量会<a href="https://stackoverflow.com/questions/18688971/c-char-array-initialization-what-happens-if-there-are-less-characters-in-the-st">默认初始化为0值</a> (‘\0’)，但在c89的标准下，未显式初始化的字符数组不会被默认初始化，这将导致未知的行为，发现这点花了我不少时间。在显式初始化<code>char kernel_sem_name[25]=&#123;&quot;\0&quot;&#125;;</code>后结果正确</li><li>consumer进程会出现&quot;kernel panic: trying to free free page&quot;，出现这个问题的原因是producer进程和consumer进程共用一个页面，producer生产完全部产品后先退出同时释放共享内存，这将导致consumer进程退出时试图释放已经释放的页面，解决方法是注释掉memery.c文件中free_page函数中的相关panic语句</li></ol><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c1c065677d7c02278e139b2ba94820eb.png" class=""><h2 id="3-验证结果"><a class="markdownIt-Anchor" href="#3-验证结果"></a> 3. 验证结果</h2><img src="/2023/05/06/HIT_os/HIT-OS-Labs/e8b42fd0449952451907b1e0f34ce770.png" class=""><pre class="line-numbers language-none"><code class="language-none">.&#x2F;mount-hdccp hdc&#x2F;usr&#x2F;root&#x2F;c_output c_output.txtcp hdc&#x2F;usr&#x2F;root&#x2F;p_output p_output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h1 id="实验7-终端设备的控制"><a class="markdownIt-Anchor" href="#实验7-终端设备的控制"></a> 实验7 终端设备的控制</h1><h2 id="1-添加新的f12响应函数"><a class="markdownIt-Anchor" href="#1-添加新的f12响应函数"></a> 1. 添加新的f12响应函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> switch_by_f12_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">press_f12_handle</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>switch_by_f12_flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        switch_by_f12_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        switch_by_f12_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c1c065677d7c02278e139b2ba94820eb.png" class=""><h2 id="2-设置响应函数入口"><a class="markdownIt-Anchor" href="#2-设置响应函数入口"></a> 2. 设置响应函数入口</h2><p>键盘输入后，操作系统会将键盘扫描码做为下标，调用key_table函数数组中保存的与该按键对应的响应函数，因此要让CPU在按下f12之后跳转到新的响应函数执行需要修改key_table，从该数组一旁的注释就可以看出f12对应的scan code是88D (58H)</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/c1c065677d7c02278e139b2ba94820eb.png" class=""><h2 id="3-修改con_write函数"><a class="markdownIt-Anchor" href="#3-修改con_write函数"></a> 3. 修改con_write函数</h2><p>con_write函数执行最终的输出显示器操作，该函数先用GETCH从输出缓冲区中提取一个字节字符到变量<code>c</code>，再写入显存中。我们根据flag修改变量<code>c</code>的值即可，为了实验结果更可观，我们选择只对字母和数字的输出进行转换</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h2 id="4-修改ttyh"><a class="markdownIt-Anchor" href="#4-修改ttyh"></a> 4. 修改tty.h</h2><p>在头文件中包含<code>switch_by_f12_flag</code>变量和响应函数的声明，以便在其他文件中使用</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h2 id="5-验证结果-2"><a class="markdownIt-Anchor" href="#5-验证结果-2"></a> 5. 验证结果</h2><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h1 id="实验8-proc文件系统的实现"><a class="markdownIt-Anchor" href="#实验8-proc文件系统的实现"></a> 实验8 proc文件系统的实现</h1><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><h3 id="vsprintf函数"><a class="markdownIt-Anchor" href="#vsprintf函数"></a> vsprintf函数</h3><p>vsprintf 是一个C库函数，用于将可变参数列表（va_list）中的值格式化为字符串，并将结果字符串存储在指定的字符数组（缓冲区）中。vsprintf 是 sprintf 函数的可变参数版本，通常在需要处理可变数量参数的情况下使用。<br />vsprintf 函数的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数说明：</p><ol><li>str：指向目标字符数组（缓冲区）的指针，用于存储格式化后的字符串。</li><li>format：一个格式字符串，它描述了如何将参数列表中的值格式化为字符串。格式字符串可以包含普通字符和转换说明符（例如 %d、%s 等）。</li><li>ap：一个 va_list 类型的参数列表，用于存储需要格式化的值。</li></ol><p>返回值：vsprintf 函数返回写入目标字符数组（不包括最后的空字符）的字符数。如果发生错误，返回负值。<br />因为该函数接受一个va_list类型的参数而不是一个通常使用的可变参数，因此我们要使用va_start函数获取一个va_list的参数<br />va_start 是C语言标准库中的一个宏，用于处理可变参数列表。va_start 用于在可变参数函数中初始化一个 va_list 类型的变量，使其指向传入的第一个可变参数。通常与 va_arg 和 va_end 宏一起使用，分别用于访问可变参数列表中的参数和完成参数列表的处理 (va_end释放为 va_list 类型的变量分配的资源)。<br />va_start 宏的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">va_start</span><span class="token punctuation">(</span>va_list ap<span class="token punctuation">,</span> last_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>ap：一个 va_list 类型的变量，用于存储指向可变参数列表的状态。</li><li>last_arg：函数参数列表中最后一个<strong>固定参数</strong>的名称 (可变参数在固定参数之后)。在初始化 va_list 时，va_start 会找到此固定参数在内存中的位置，从而确定可变参数列表的起始位置。</li></ol><h3 id="mknod系统调用"><a class="markdownIt-Anchor" href="#mknod系统调用"></a> mknod系统调用</h3><p>mknod 系统调用用于创建特殊文件（设备文件）在文件系统中。特殊文件通常用于表示设备，如字符设备和块设备。字符设备通常用于表示可逐字符读写的设备，如终端设备；块设备通常用于表示可按块读写的设备，如磁盘设备。本实验用它来创建proc文件。<br />mknod 系统调用的主要参数包括：</p><ol><li>路径名（pathname）：要创建的特殊文件的路径名。</li><li>文件模式（mode）：描述新创建的特殊文件类型和权限的位掩码。文件类型可以是字符设备（S_IFCHR）或块设备（S_IFBLK）。</li><li>设备号（dev）：设备号用于唯一标识设备。通常分为主设备号和次设备号。主设备号用于标识设备类型或驱动程序，而次设备号用于标识同一类型设备的实例。</li></ol><p>当调用 mknod 系统调用时，操作系统会执行以下操作：</p><ol><li>根据提供的路径名找到目标目录。</li><li>在目标目录中创建一个新的目录项，设置其文件名和 inode 号(更新目录树)。</li><li>分配一个新的 inode，并将其与目录项关联。</li><li>设置 inode 的属性，如文件类型（字符设备或块设备）、权限和设备号等。</li><li>更新文件系统元数据，如目录和 inode 的更改时间等。</li></ol><p>创建特殊文件后，应用程序可以使用设备文件与相应的设备进行通信。例如，通过 open、read、write 和 ioctl 系统调用与设备驱动程序进行交互。这使得设备操作看起来与普通文件操作相似，简化了应用程序的开发。</p><h2 id="添加proc类型文件"><a class="markdownIt-Anchor" href="#添加proc类型文件"></a> 添加proc类型文件</h2><p>OS根据文件类型选择不同处理函数，从而实现对不同类型的文件的操作，我们先在linux0.11中添加proc类型文件，之后再编写对应的处理函数就能完成proc文件系统的添加了。</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/40e187fa3aba0142eecbbd33961b9403.png" class=""><h2 id="修改mknod系统调用"><a class="markdownIt-Anchor" href="#修改mknod系统调用"></a> 修改mknod系统调用</h2><p>我们已经提到，mknod用于创建特殊文件，即块设备文件和字符流文件。现在我们要给它添加对proc文件的支持。</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><h2 id="创建proc目录文件proc普通文件"><a class="markdownIt-Anchor" href="#创建proc目录文件proc普通文件"></a> 创建proc目录文件，proc普通文件</h2><p>在系统初始化时，根目录文件挂载之后 (这样传递给mknod的路径才有效)，创建proc文件系统的目录文件和文件。<br />因为此时在用户态，因此要通过添加系统调用的方式使用mkdir和mknod，而不能直接使用sys_mkdir和sys_mknod</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><h2 id="验证文件是否创建成功"><a class="markdownIt-Anchor" href="#验证文件是否创建成功"></a> 验证文件是否创建成功</h2><img src="/2023/05/06/HIT_os/HIT-OS-Labs/b0b5ce1ce892390ca5bd7e49ad3adba9.png" class=""><p>可以看到，我们已经成功在根目录下创建了proc目录文件，并在该文件下创建了proc普通文件，这三个文件分别表示系统进程信息，系统硬件信息，系统存储信息<br />这里使用cat输出了一行信息和一行报错，要明白这两条信息怎么来的，首先要知道cat命令背后执行了什么操作: 用sys_open打开一个文件，用sys_read将文件内容读入缓冲区，最后用printf打印缓冲区的内容到屏幕上</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><p>通过查看sys_read的源码，我们可以找到这两条信息的来源。当sys_read打开proc类型文件没有对应的处理函数时，就会出现这两条信息，因此我们接下来为proc类型文件编写对应的处理函数proc_read即可</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><p>为proc文件添加处理分支</p><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><h2 id="编写proc文件处理函数"><a class="markdownIt-Anchor" href="#编写proc文件处理函数"></a> 编写proc文件处理函数</h2><p>添加<code>linux-0.11/fs/proc_read.c</code>，这里只完成了进程信息的获取</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/segment.h></span>  <span class="token comment">// put_fs_byte</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h></span>  <span class="token comment">// process-related variables: task struct, FIRST_TASK</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span>       <span class="token comment">//  vs_start va_end</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">char</span> krnbuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'\0'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> va_list args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">// initalize args to first changeable parameter</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// vsprintf function returns the number of characters written to the buffer</span>    i <span class="token operator">=</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">get_psinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> buf_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span>                          <span class="token string">"pid\tstate\tfather\tcounter\tstart_time\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK<span class="token punctuation">;</span> p <span class="token operator">>=</span> <span class="token operator">&amp;</span>FIRST_TASK<span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>father<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\t"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>            buf_offset <span class="token operator">+=</span>                <span class="token function">sprintf</span><span class="token punctuation">(</span>krnbuf <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>start_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> buf_offset<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">proc_read</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>pos<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos <span class="token operator">/</span> BLOCK_SIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// already read a whole block, start write</span>    <span class="token punctuation">&#123;</span>        <span class="token function">get_psinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>krnbuf<span class="token punctuation">[</span><span class="token operator">*</span>pos <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// end of message</span>        <span class="token function">put_fs_byte</span><span class="token punctuation">(</span>krnbuf<span class="token punctuation">[</span><span class="token operator">*</span>pos <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span>                    buf <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// synchronous replication</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>pos <span class="token operator">+=</span> i<span class="token punctuation">;</span> <span class="token comment">// change f_pos</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token comment">// return the actual number of bytes read</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改makefile"><a class="markdownIt-Anchor" href="#修改makefile"></a> 修改Makefile</h2><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><h2 id="验证结果"><a class="markdownIt-Anchor" href="#验证结果"></a> 验证结果</h2><img src="/2023/05/06/HIT_os/HIT-OS-Labs/9ea47fc33eb2a545878bf9a8d583db88.png" class=""><p><a href="https://www.cnblogs.com/mirage-mc/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/">reference</a></p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CMU CS15213] CSAPP</title>
      <link href="/2023/03/06/CSAPP_lab/CSAPP-LAB/"/>
      <url>/2023/03/06/CSAPP_lab/CSAPP-LAB/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1-datalab"><a class="markdownIt-Anchor" href="#lab1-datalab"></a> lab1 dataLab</h1><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><p>确保有一个linux系统，并已经执行过以下两条命令:<br />安装gcc：<code>sudo apt-get install build-essential</code><br />安装<a href="https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea">gcc的交叉编译环境</a>.)：<code>sudo apt-get install gcc-multilib</code>，因为实验的程序需要以32位方式编译<br />在<a href="http://csapp.cs.cmu.edu/3e/labs.html">CMU的CSAPP网站</a>上下载实验所需资料，包括** README, Writeup，Self-Study Handout，** 这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件</p><h2 id="1bitxorxy"><a class="markdownIt-Anchor" href="#1bitxorxy"></a> 1.bitXor(x,y)</h2><p>要用~和&amp;实现异或^，即将结果中 1-0，0-1对应的位设置为1<br />x&amp;y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br />(<sub>x&amp;</sub>y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br />两个做交集即为结果。（位向量可以表示集合，&amp;，|，~可视为 交，并，补操作）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*bitXor - x^y using only ~ and &amp;Example: bitXor(4, 5) = 1Legal ops: ~ &amp;Max ops: 14Rating: 1*/</span><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span>  <span class="token operator">~</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token operator">&amp;</span><span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// if regardless '+' is illegal:(~x&amp;y) + ((x)&amp;(~y)) or ~((x&amp;y) + ((~x)&amp;(~y)))</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin"></a> 2.tmin</h2><p>最简单的一题：<code>000...001</code> --&gt; <code>1000...000</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*tmin - return minimum two's complement integerLegal ops: ! ~ &amp; ^ | + &lt;&lt; >>Max ops: 4Rating: 1*/</span><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3istmaxx"><a class="markdownIt-Anchor" href="#3istmaxx"></a> 3.isTmax(x)</h2><p>这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了<code>!((~x) + (~x))</code>，但<a href="https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471">测试结果出乎意料</a>，加法溢出导致了未知的行为。<br />根据 Tmax +1 = Tmin 的性质可以得出 ,  <code>100...000</code> + <code>011...111</code> = <code>111..1111</code> (-1)，可得出<code>!(~x^(x+1))</code>（^可替换为+）<br />处理特例-1： -1同样会产生结果1，根据 <code>-1+1==0</code>,<code>Tmax+1!=0</code>，进而<code>!(-1+1) !=0</code> ，<code>!(Tmax+1) ==0</code>.<br />所以<code>对Tmax, x+(x+1) = x</code> , <code>对-1,x+(x+1)!=x</code><br />用<code>x+(x+1)</code> 替换原式中的第一项x，最终得出结果：<code>!(~((x+!(x+1))^(x+1)))</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*isTmax - returns 1 if x is the maximum, two's complement number,and 0 otherwiseegal ops: ! ~ &amp; ^ | +Max ops: 10Rating: 1*/</span><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>   <span class="token comment">// !((~x) + (~x));  it should be right, the operator "!" seem to not work</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4alloddbitsx"><a class="markdownIt-Anchor" href="#4alloddbitsx"></a> 4.allOddBits(x)</h2><p>这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br />用好异或即可解决：构造<code>101...1010</code>，再用该数提取x中的奇数位，最后再与<code>101...1010</code>比较</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*allOddBits - return 1 if all odd-numbered bits in word set to 1where bits are numbered from 0 (least significant) to 31 (most significant)Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1Legal ops: ! ~ &amp; ^ | + &lt;&lt; >>Max ops: 12Rating: 2*/</span><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> allOdd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xAA</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">0xAA</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">0xAA</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xAA</span><span class="token punctuation">;</span> <span class="token comment">// 10101010..101</span>  <span class="token keyword">return</span> <span class="token operator">!</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>allOdd <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">^</span> allOdd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5isasciidigitx"><a class="markdownIt-Anchor" href="#5isasciidigitx"></a> 5.isAsciiDigit(x)</h2><p>有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验—用异或执行比较操作。<br />x的最后四位，3bit 与 1,2bit不能同时为1，因而有<code>!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)))</code>，难点在于怎么处理好式中三部分的逻辑关系</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') *   Example: isAsciiDigit(0x35) = 1. *            isAsciiDigit(0x3a) = 0. *            isAsciiDigit(0x05) = 0. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 15 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> mask1 <span class="token operator">=</span> <span class="token number">0x3</span><span class="token punctuation">;</span>   <span class="token comment">// 000...0011</span>  <span class="token keyword">int</span> mask2 <span class="token operator">=</span> <span class="token number">0xA</span><span class="token punctuation">;</span>   <span class="token comment">// 1010</span>  <span class="token keyword">int</span> mask3 <span class="token operator">=</span> <span class="token number">0xC</span><span class="token punctuation">;</span>   <span class="token comment">// 1100</span>  <span class="token keyword">return</span>  <span class="token operator">!</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">^</span>mask1<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>mask2<span class="token punctuation">)</span><span class="token operator">^</span>mask2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>mask3<span class="token punctuation">)</span><span class="token operator">^</span>mask3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6conditional"><a class="markdownIt-Anchor" href="#6conditional"></a> 6.conditional</h2><p>比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br />涉及的操作是把x转化为0与1两个值，再把<code>000...0001</code>转化为<code>111...1111</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * conditional - same as x ? y : z *   Example: conditional(2,4,5) = 4 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 16 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span>  judge <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x=0 -> judge=1,whereas x!=0 -> judge=0</span>  judge <span class="token operator">=</span> <span class="token punctuation">(</span>judge <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment">// 000...000 or 111...111</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>judge<span class="token punctuation">)</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>judge<span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7islessorequalx-y"><a class="markdownIt-Anchor" href="#7islessorequalx-y"></a> 7.isLessOrEqual(x, y)</h2><p>可通过减法<code>y-x&gt;=0</code>判断<code>x&lt;=y</code>，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br />那么这题就涉及加法溢出,需要对<code>x+uw  y</code>结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br />更好的想法是<strong>分析式子</strong><code>**y-x**</code><strong>并加入一个conditional操作</strong>：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * isLessOrEqual - if x &lt;= y  then return 1, else return 0 *   Example: isLessOrEqual(4,5) = 1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 24 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Tmin <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment">// 100...0000</span>  <span class="token keyword">int</span> signY <span class="token operator">=</span> Tmin <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>  <span class="token keyword">int</span> signX <span class="token operator">=</span> Tmin <span class="token operator">&amp;</span> x<span class="token punctuation">;</span>  <span class="token keyword">int</span> judge <span class="token operator">=</span> <span class="token punctuation">(</span>signY <span class="token operator">^</span> signX<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>judge<span class="token operator">&amp;</span>signX<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>judge<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">+</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span>Tmin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8logicalnegx"><a class="markdownIt-Anchor" href="#8logicalnegx"></a> 8.logicalNeg(x)</h2><p>这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br />于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的<strong>positive overflow</strong>现象，即 Tmax + x ，对任意x&gt;0均会使结果变为负数，符号位由0 --&gt;1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致<a href="http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3">undefined behavior</a>）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * logicalNeg - implement the ! operator, using all of *              the legal operators except ! *   Examples: logicalNeg(3) = 0, logi'calNeg(0) = 1 *   Legal ops: ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> Tmin <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> Tmax <span class="token operator">=</span> <span class="token operator">~</span>Tmin<span class="token punctuation">;</span>  <span class="token keyword">int</span> signX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>Tmin<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>signX<span class="token operator">^</span><span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> Tmax<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0x1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0x1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9howmanybitsx"><a class="markdownIt-Anchor" href="#9howmanybitsx"></a> 9.howManyBits(x)</h2><p>这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：<strong>当数的符号位为1时，将数按符号位扩展之后其值不会变</strong>，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br />要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -&gt; 0010)<br />按二分法逐步缩小范围，找到最左边的1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* howManyBits - return the minimum number of bits required to represent x in *             two's complement *  Examples: howManyBits(12) = 5 *            howManyBits(298) = 10 *            howManyBits(-5) = 4 *            howManyBits(0)  = 1 *            howManyBits(-1) = 1 *            howManyBits(0x80000000) = 32 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *  Max ops: 90 *  Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> b16<span class="token punctuation">,</span>b8<span class="token punctuation">,</span>b4<span class="token punctuation">,</span>b2<span class="token punctuation">,</span>b1<span class="token punctuation">,</span>b0<span class="token punctuation">;</span>  <span class="token keyword">int</span> signX <span class="token operator">=</span> x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>signX<span class="token punctuation">)</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>signX<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// if x is negative, let sign bit:1-> 0</span>  b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 16 bits exist 1 or not</span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b16<span class="token punctuation">;</span>  b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 8 bits</span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b8<span class="token punctuation">;</span>  b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 4 bits</span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b4<span class="token punctuation">;</span>  b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ensure high 2 bits</span>  x<span class="token operator">=</span>x<span class="token operator">>></span>b2<span class="token punctuation">;</span>  b1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ensure 31 bits or not</span>  x <span class="token operator">=</span> x<span class="token operator">>></span>b1<span class="token punctuation">;</span>  b0 <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">return</span> b0<span class="token operator">+</span>b1<span class="token operator">+</span>b2<span class="token operator">+</span>b4<span class="token operator">+</span>b8<span class="token operator">+</span>b16<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1: sign bit</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10floatscale2uf"><a class="markdownIt-Anchor" href="#10floatscale2uf"></a> 10.floatScale2(uf)</h2><p>先对题目做出一点解释：传入一个<code>unsigned</code>类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br /><strong>整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论</strong><br />注意点：对normalized，f* 2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么<code>frac = frac &lt;&lt;1</code>，这也使得denormalized能转化到normalized (smoothly)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//float</span><span class="token comment">/* * floatScale2 - Return bit-level equivalent of expression 2*f for *   floating point argument f. *   Both the argument and result are passed as unsigned int's, but *   they are to be interpreted as the bit-level representation of *   single-precision floating point values. *   When argument is NaN, return argument    // revision: NaN or infinity *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> musk_exp<span class="token punctuation">,</span>musk_frac<span class="token punctuation">,</span>sign<span class="token punctuation">,</span>exp<span class="token punctuation">,</span>frac<span class="token punctuation">,</span>result<span class="token punctuation">;</span>  musk_exp <span class="token operator">=</span> <span class="token number">0xFF</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>  musk_frac <span class="token operator">=</span> <span class="token number">0x7FFFFF</span><span class="token punctuation">;</span>  exp <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> musk_exp<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">;</span>  frac <span class="token operator">=</span> uf <span class="token operator">&amp;</span> musk_frac<span class="token punctuation">;</span>  sign <span class="token operator">=</span> <span class="token number">0x1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span> <span class="token operator">&amp;</span> uf<span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0xFF</span>  <span class="token punctuation">)</span> <span class="token comment">// NaN</span>     result <span class="token operator">=</span> uf<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span> <span class="token comment">// denormalized</span>  <span class="token punctuation">&#123;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>frac <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span>  <span class="token comment">// -0.0</span>           result <span class="token operator">=</span> uf<span class="token punctuation">;</span>        <span class="token keyword">else</span>     <span class="token comment">// +0.0</span>           result <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>        frac <span class="token operator">=</span> frac <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> sign<span class="token operator">+</span> <span class="token punctuation">(</span>exp<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">+</span> frac<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">!=</span> <span class="token number">0x0</span> <span class="token operator">&amp;&amp;</span> exp <span class="token operator">!=</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token comment">// normalized</span>  <span class="token punctuation">&#123;</span>     exp <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>     result <span class="token operator">=</span> sign<span class="token operator">+</span> <span class="token punctuation">(</span>exp<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">+</span> frac<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11floatfloat2intuf"><a class="markdownIt-Anchor" href="#11floatfloat2intuf"></a> 11.floatFloat2Int(uf)</h2><p>浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br />对题目的解释：返回浮点数f的int型表示，如输入<code>12345.0 (0x4640E400)</code>, 正确输出为<code>12345 (0x3039)</code><br />注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E&gt;31时，属于out of range</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * floatFloat2Int - Return bit-level equivalent of expression (int) f *   for floating point argument f. *   Argument is passed as unsigned int, but *   it is to be interpreted as the bit-level representation of a *   single-precision floating point value. *   Anything out of range (including NaN and infinity) should return *   0x80000000u. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> musk_exp<span class="token punctuation">,</span>musk_frac<span class="token punctuation">,</span>exp<span class="token punctuation">,</span>frac<span class="token punctuation">,</span>sign<span class="token punctuation">,</span>E<span class="token punctuation">,</span>Bias<span class="token punctuation">,</span>result<span class="token punctuation">;</span>  musk_exp <span class="token operator">=</span> <span class="token number">0xFF</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>  musk_frac <span class="token operator">=</span> <span class="token number">0x7FFFFF</span><span class="token punctuation">;</span>  exp <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> musk_exp<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">;</span>  frac <span class="token operator">=</span> uf <span class="token operator">&amp;</span> musk_frac<span class="token punctuation">;</span>  sign <span class="token operator">=</span> <span class="token number">0x1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span> <span class="token operator">&amp;</span> uf<span class="token punctuation">;</span>  Bias <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0xFF</span>  <span class="token punctuation">)</span> <span class="token comment">// NaN or infinity</span>     result <span class="token operator">=</span> <span class="token number">0x80000000u</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span>     result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">!=</span> <span class="token number">0x0</span> <span class="token operator">&amp;&amp;</span> exp <span class="token operator">!=</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token comment">// normalized</span>  <span class="token punctuation">&#123;</span>     E <span class="token operator">=</span> exp <span class="token operator">-</span>Bias<span class="token punctuation">;</span>  <span class="token comment">// bit_num of fraction</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>E <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>E<span class="token operator">></span><span class="token number">31</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token number">0x80000000u</span><span class="token punctuation">;</span>     <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>        frac <span class="token operator">=</span> frac<span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">23</span><span class="token operator">-</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> E<span class="token punctuation">)</span> <span class="token operator">+</span> frac <span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sign <span class="token operator">==</span> <span class="token number">0x1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">)</span>           result <span class="token operator">=</span> <span class="token operator">-</span> result<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12floatpower2x"><a class="markdownIt-Anchor" href="#12floatpower2x"></a> 12.floatPower2(x)</h2><p>注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x *   (2.0 raised to the power x) for any 32-bit integer x. * *   The unsigned value that is returned should have the identical bit *   representation as the single-precision floating-point number 2.0^x. *   If the result is too small to be represented as a denorm, return *   0. If too large, return +INF. * *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> exp<span class="token punctuation">,</span>frac<span class="token punctuation">,</span>E<span class="token punctuation">,</span>Bias<span class="token punctuation">,</span>result<span class="token punctuation">;</span>  Bias <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  E <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">0x1</span> <span class="token operator">||</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>     frac <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>     exp <span class="token operator">=</span> E<span class="token operator">+</span>Bias<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">></span> <span class="token number">254</span><span class="token punctuation">)</span>  <span class="token comment">// 1111 1110</span>        <span class="token punctuation">&#123;</span>           exp <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>           result <span class="token operator">=</span> exp <span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token operator">+</span>frac<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>exp<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">+</span> frac<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="consequence"><a class="markdownIt-Anchor" href="#consequence"></a> consequence</h2><p><code>make</code><br /><code>./driver.pl</code></p><h3 id="-swig28-"><a class="markdownIt-Anchor" href="#-swig28-"></a> <img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a4c293cc441f32d00b3dbc0cdac50ab4.png" class=""></h3><hr /><h1 id="lab2-bomblab"><a class="markdownIt-Anchor" href="#lab2-bomblab"></a> lab2 bombLab</h1><h2 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> phase_1</h2><ol><li>反汇编<code>main</code>函数：<code>read_line</code>函数之后寄存器<code>%rax</code>和<code>%rdi</code>存储了我们输入的字符串的首地址(后续的phase都是如此)</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/d0b5436e3bd694ef9dadbf62a885e8f4.png" class=""><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=128&amp;id=u1267f1f6&amp;originHeight=128&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=59576&amp;status=done&amp;style=none&amp;taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&amp;width=1060" alt="验证%rdi指向输入字符串(1)" title="验证%rdi指向输入字符串(1)" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=77&amp;id=ubbe401e0&amp;originHeight=77&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=31472&amp;status=done&amp;style=none&amp;taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&amp;width=723" alt="验证%rdi指向输入字符串(2)" title="验证%rdi指向输入字符串(2)" /></p><ol start="2"><li>反汇编<code>strings_not_equal</code>函数：该函数在输入字符串与目的字符串相同时，将寄存器<code>%rax</code>（通常用作函数返回值）赋值为0 (1 vice versa)</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/82696a312b38b2caffbed1decdebe663.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/68c822853ca0f63de658940ba09b7003.png" class=""><ol start="3"><li>反汇编<code>phase_1</code>函数：<code>strings_not_equal</code>函数返回值为0时，<code>test %eax, %eax</code>能使<code>je 0x400ef7&lt;phase_1+23&gt;</code>执行，phase_1 defused (explode vice versa)</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/19429a3d7d01b10593c4e4448702d955.png" class=""><ol start="4"><li>至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用<code>strings_not_equal</code>函数之前赋值的<code>%esi：0x402400</code>寄存器中</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/848f00e31ae9e6e18106b6038356b61c.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/dd5ff3c83ce1679eab6d51fba602f527.png" class=""><h2 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> phase_2</h2><ol><li>反汇编<code>read_six_numbers</code>函数：可以推断出其实现了<code>sscanf(input, &quot;%d %d %d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6)</code>的功能，其中<code>&amp;a1~&amp;a6</code>分别在1)<code>%rcx:0x4(%rsi)</code>2)<code>%r8:0x8(%rsi)</code>3)<code>%r9:0xc(%rsi)</code>4)<code>%rsp:0x10(%rsi)</code>5)<code>0x8(%rsp):0x14(%rsi), 0x18(%rsi) </code> 前3个指针存储在寄存器中传递给<code>sscanf</code>函数，后三个指针存储在为<code>read_six_numbers</code>函数分配的栈空间中,可以推断出<code>%rsi</code>为一个含有六个元素的数组的首地址</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/49e195de46edde2a13a3d612e3f4436f.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/848f00e31ae9e6e18106b6038356b61c.png" class=""><ol start="2"><li>反汇编<code>phase_2</code>函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a2c1f6510d1747ac9f31f9caaa5f0cf6.png" class=""><ol start="3"><li>自此，我们可以判断出这六个数字分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>1</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>3</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>4</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2^0,2^1,2^2,2^3,2^4,2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/cc9b4103bc02a8d67f35043fedfface7.png" class=""><h2 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h2><ol><li>反汇编<code>phase_3</code>：从<code>(%esi)</code>的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(<code>cmpl 0x7,0x8(rsp)</code>)，并根据这个值执行间接跳转操作(<code>jmp *0x402470(,rax,8)</code>)</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/8f19c8e6410929f9f8eadf10f37a2ccd.png" class=""><ol start="2"><li>查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的<code>0x8(%rsp</code>：1 2 3 4 5 6 7</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/ba11b3ecaddba2f5b95962aa2edd2a17.png" class=""><ol start="3"><li>根据后续的赋值-跳转指令，可以得到对应的7个<code>0xc(%rsp)</code>：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)</li></ol><p><img src="attachment/9fe1343ecdbd946c3404a678738f74d7.png" alt="" /><img src="attachment/49e195de46edde2a13a3d612e3f4436f.png" alt="" /><br /><img src="attachment/c8c8680d6369eb064a9fb0434b0b3d31.png" alt="" /><img src="attachment/8f19c8e6410929f9f8eadf10f37a2ccd.png" alt="" /><img src="attachment/c8c8680d6369eb064a9fb0434b0b3d31.png" alt="" /><img src="attachment/cc9b4103bc02a8d67f35043fedfface7.png" alt="" /><img src="attachment/cc9b4103bc02a8d67f35043fedfface7.png" alt="" /><img src="attachment/49e195de46edde2a13a3d612e3f4436f.png" alt="" /><img src="attachment/33260348d45935dfc16fd4da8e94e9a0.png" alt="" /></p><h2 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> phase_4</h2><ol><li>反汇编<code>phase_4</code>函数：开头部分具有与<code>phase_3</code>函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(<code>cmpl $0xe, 0x8(%rsp)</code>)，之后函数调用<code>func4</code>函数，传入三个参数<code>%edx</code>, <code>%esi</code>, <code>0x8(%rsp)</code>。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(<code>test %eax, %eax</code>)。后续的<code>cmpl $0x0, 0xc(%rsp)</code>足以确定第2个值为0</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/e36a2a99955dab7372f26e5f6c54cea0.png" class=""><ol start="2"><li>反汇编<code>func4</code>函数：出现了<code>func4</code>调用自身的情况，所以<code>func4</code>是一个递归函数。第1部分将<code>%rax</code>赋值为<code>%edx</code>-<code>%esi</code>,再加上它的最高位(<code>%rax &gt;&gt; 31</code>)，接着执行算数右移。这里加上最高位的原因在于，当后续<code>%rax</code>在递归中值减少为-1时，最高位是符号位1，两者相加能保证<code>%rax</code>始终大于等于0，结合后续汇编内容，可以推断出第一个值<code>0x8(%rsp)</code>应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果<code>%ecx &gt; %edi</code>，那么就使<code>%ecx</code>变为<code>%esi</code>到<code>%edx</code>的中间值(<code>lea -0x1(%rcx), %edx</code>)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回<code>phase_4</code>的<code>%rax</code>值为1</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/e6d3379fc4d365ff408c77b2babf4d21.png" class=""><ol start="3"><li>自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)</li></ol><p><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /><br /><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /><img src="attachment/7e450d69c1d03c9011f11f0b067acb76.png" alt="" /></p><h2 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> phase_5</h2><ol><li>反汇编<code>phase_5</code>函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> index<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// %rax</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>index <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>index <span class="token operator">=</span> index<span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">;</span> <span class="token comment">// take lower four bits</span>dest<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// dest: (%rsp+0x10+%rax) source: 0x4024b0</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">string_not_equal</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// target: 0x40245e --- "flyers"</span>      <span class="token comment">//defuse</span><span class="token keyword">else</span>   <span class="token function">explode_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/257036f48e30c46dedcbdf50015da107.png" class=""><ol start="2"><li>分别查看<code>source: 0x4024b0</code>和<code>target: 0x40245e</code>处的字符串，我们要做的就是使输入字符串形成的索引值能够从<code>0x4024b0</code>处的字符集中提取出 “flyers”</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/60e7bd6e50d50fb77b707637148c0e04.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/d363fbe15afd12811daeb0a66ede9589.png" class=""><ol start="3"><li>我们的输入字符串每个字符在内存中占一个byte，<code>movzbl (%rbx, %rax, 1), %ecx</code>说明了一次循环提取一个字符，并只取该字符的低四位(<code>and $0xf, %edx</code>)作为索引值</li><li>首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw</li></ol><p><img src="attachment/e01a62cd2c34aaab94c959af6be846d3.png" alt="" /><img src="attachment/e6d3379fc4d365ff408c77b2babf4d21.png" alt="" /></p><h2 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> phase_6</h2><ol><li>thinking process</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// %r12d</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy <span class="token operator">=</span> input<span class="token punctuation">;</span> <span class="token comment">// mov %rsp, %r13</span><span class="token keyword">int</span> val<span class="token punctuation">;</span> <span class="token comment">// %eax</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    val <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input_copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x0(%r13)</span>    val <span class="token operator">=</span> val<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">></span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 元素值不得大于6</span>    <span class="token operator">++</span>a1<span class="token punctuation">;</span> <span class="token comment">// add $0x1, %r12d</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// jmp 95</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">// mov %r12d, %ebx</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 65</span>        val <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token operator">*</span>input_copy<span class="token punctuation">)</span>            <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>a2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>a2<span class="token operator">&lt;=</span> <span class="token number">5</span> <span class="token punctuation">)</span> <span class="token comment">// 87</span>    <span class="token operator">++</span>input_copy<span class="token punctuation">;</span> <span class="token comment">// add $0x4, %r13</span><span class="token punctuation">&#125;</span> <span class="token comment">// 93</span><span class="token comment">/*两个信息：(已验证)1. 输入字符串中所有元素不大于62. 输入字符串中所有元素互不相等 */</span> <span class="token number">0</span><span class="token operator">~</span><span class="token number">6</span><span class="token keyword">int</span><span class="token operator">*</span> sentry <span class="token operator">=</span> input<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// mov 0x18(%rsp), %rsi   95</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy_2 <span class="token operator">=</span> input<span class="token punctuation">;</span> <span class="token comment">// %rax</span><span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// %edx, %ecx</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>input_copy_2<span class="token punctuation">)</span> <span class="token operator">=</span> a3 <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span>input_copy_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>input_copy_2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>input_copy_2 <span class="token operator">!=</span> sentry<span class="token punctuation">)</span><span class="token comment">/* 更新输入字符串所有值为：7-初始值(已证实),结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */</span><span class="token keyword">int</span> a4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 123 %esi  -- index</span><span class="token keyword">int</span> a5<span class="token punctuation">;</span> <span class="token comment">// %edx</span><span class="token keyword">int</span> a6<span class="token punctuation">;</span> <span class="token comment">// %eax  -- index</span>offset_166<span class="token operator">:</span><span class="token keyword">if</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>a4<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 166  %ecx</span><span class="token punctuation">&#123;</span>    a5 <span class="token operator">=</span> <span class="token number">0x6032d0</span><span class="token punctuation">;</span> <span class="token comment">// 143</span>    offset_148<span class="token operator">:</span>    <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">0x20</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>a4<span class="token punctuation">)</span> <span class="token operator">=</span> a5<span class="token punctuation">;</span> <span class="token comment">// 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48</span>                             <span class="token comment">//   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320</span>    a4 <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// add $0x4, %rsi</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a4 <span class="token operator">==</span>  <span class="token number">24</span> <span class="token punctuation">)</span>        <span class="token keyword">goto</span> offset_183<span class="token punctuation">;</span> <span class="token comment">// 161</span>    <span class="token keyword">else</span>        <span class="token keyword">goto</span> offset_166<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>  <span class="token comment">// 均要走这个else， 可能有一个不走这个else -->肯定有一个不走</span><span class="token punctuation">&#123;</span>    a6 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 171</span>    <span class="token operator">&amp;</span>a5 <span class="token operator">=</span> <span class="token number">0x6032d0</span><span class="token punctuation">;</span> <span class="token comment">// 176  这个地址+0x8能多次跳转</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span> <span class="token comment">// 130</span>        a5 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a5 <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// mov 0x8(%rdx),%rdx  链表?</span>        <span class="token operator">++</span>a6<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>a6 <span class="token operator">!=</span> <span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span>a4<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)</span>    <span class="token keyword">goto</span> offset_148<span class="token punctuation">;</span>         <span class="token comment">// recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5</span><span class="token punctuation">&#125;</span> <span class="token comment">// 181</span>offset_183：    function<span class="token operator">:</span> link node in order<span class="token keyword">int</span> a7 <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy_3 <span class="token operator">=</span> input<span class="token operator">+</span><span class="token number">10</span> <span class="token comment">// %rax  0x28(%rsp)</span><span class="token keyword">int</span><span class="token operator">*</span> input_copy_4 <span class="token operator">=</span> input<span class="token operator">+</span><span class="token number">20</span> <span class="token comment">// %rsi  0x50(%rsp)</span>a3 <span class="token operator">=</span> a7<span class="token punctuation">;</span> <span class="token comment">// a3:%rcx</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 201</span>    a5 <span class="token operator">=</span> <span class="token operator">*</span>input_copy_3<span class="token punctuation">;</span> <span class="token comment">//a5:%rdx [10][12]...[18][20] 6</span>    <span class="token operator">*</span><span class="token punctuation">(</span>a3<span class="token operator">+</span><span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> a5<span class="token punctuation">;</span> <span class="token comment">// 0x8(%rcx)</span>    input_copy_3 <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 0x8</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>input_copy_3 <span class="token operator">==</span> input_copy_4<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 215</span>    a3 <span class="token operator">=</span> a5<span class="token punctuation">;</span> <span class="token comment">// mov %rdx, %rcx</span><span class="token punctuation">&#125;</span>    <span class="token comment">//   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)</span><span class="token comment">// 结束时 %rdx = * (input + 18)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 222   set last node's pointer to nullptr</span><span class="token keyword">int</span> a8 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// %ebp</span><span class="token keyword">int</span> a9 <span class="token comment">// %rax</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span> <span class="token operator">&amp;</span>a9 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>a7<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// %rax   initial a7 = input[8]</span>  a9 <span class="token operator">=</span> <span class="token operator">*</span>a9<span class="token punctuation">;</span> <span class="token comment">// mov (%rax), %eax</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> a9<span class="token punctuation">)</span> <span class="token comment">// cmp %eax, (%rbx)</span>    <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 验证是否降序</span>a7 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>input<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mov 0x8(%rbx), %rbx 更新%rbx</span><span class="token operator">--</span>a8<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>a8<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// over</span><span class="token comment">/*inital:0x14c(0): 332;0x0a8(1): 168;0x39c(2): 924;0x2b3(3): 6910x1dd(4): 4770x1bb(5): 4432->3->4->5->0->1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是<code>0x6032d0</code>这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使<code>0x6032d0</code>这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/acd690b3b50691d1f6e3f12a5cbd3c85.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/40edff8d78bfb0c20b5b843703546e03.png" class=""><h2 id="secret_phase"><a class="markdownIt-Anchor" href="#secret_phase"></a> secret_phase</h2><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/532ab5bef0f2b1fbcb4e3a75616980cc.png" class=""><ol><li>发现彩蛋</li></ol><p>以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用<code>objdump -t bomb</code>查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/022618c6c2df7c53f1385e093b46d9bf.png" class=""><ol start="2"><li>怎么触发</li></ol><p>1)谁调用了secret_phase：<code>secret_phase</code>既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在<code>main</code>函数中寻找可能调用<code>secret_base</code>的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在<code>phase_defused</code>函数中，反汇编<code>phase_defused</code>函数，果然发现了调用<code>secret_phase</code>的指令<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png" alt="" /><br />2）在phase_defused中如何触发：从<code>main</code>函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次<code>phase_defused</code>。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/02e77af27b1c4e865e36db8907ca7b63.png" class=""><p>接着从地址<code>0x603870</code>处读取两个数字，一个字符串</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/840754c4bede736bec5534802d03b4c2.png" class=""><p>经过验证，地址<code>0x603870</code>为phase_4阶段输入字符串的开始地址<br /><img src="attachment/a660c4c01c2033e2876e3574083862bd.png" alt="" /><img src="attachment/42cd427d395bd0887302dfbe5f3a095f.png" alt="" /><br />根据后续逻辑，只要在phase_4阶段时输入<code>&quot;7 0 DrEvil&quot;</code>即可触发<code>secret_bomb</code></p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/172349e0413d8582ce691ac2f1abecf3.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/6275de0a9feabb7b06a305b4e04ba190.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a7dc7f4a3fb6f6a4c1c13204acce6c2e.png" class=""><ol start="3"><li>终章：拆解secret_phase</li></ol><p>1）反编译secret_base</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">secret_phase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> input_2<span class="token punctuation">;</span><span class="token comment">// (%rdi)</span>    <span class="token operator">&amp;</span>input_2 <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  %rdi</span>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">0xa</span><span class="token punctuation">;</span> <span class="token comment">// %edx</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span> <span class="token comment">// %esi</span>    <span class="token keyword">long</span> <span class="token keyword">int</span> input_num_1 <span class="token operator">=</span> <span class="token function">strtol</span><span class="token punctuation">(</span>input_2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// %rax</span>    <span class="token keyword">long</span> <span class="token keyword">int</span> input_num_2 <span class="token operator">=</span> input_num_1 <span class="token comment">// %rbx</span>    input_num_1 <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>input_num_1 <span class="token operator">></span> <span class="token number">0x3e8</span> <span class="token comment">/*1000*/</span><span class="token punctuation">)</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输入的数字字符串 值小于 1001</span>    a2 <span class="token operator">=</span> input_num_2<span class="token punctuation">;</span><span class="token comment">// mov %ebx, %esi</span>    <span class="token operator">&amp;</span>input_2 <span class="token operator">=</span> <span class="token number">0x6030f0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span>a2<span class="token punctuation">,</span>input_num_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ret_value: %rax</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0x2</span><span class="token punctuation">)</span>        <span class="token function">defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">explode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> input_num_1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2 <span class="token operator">==</span> <span class="token number">0x0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// avoid endless recursion</span>    <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 9 %edx   initial a3 = 24</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a3 <span class="token operator">&lt;=</span> a2<span class="token punctuation">)</span> <span class="token keyword">goto</span> offset_28<span class="token punctuation">;</span> <span class="token comment">// 13  a2是输入值</span>    <span class="token comment">// a3 > a2</span>    input_2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2 <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// +2  turn left</span>    input_num_1 <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> input_num_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 19</span>    input_num_1 <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// input_num_q is 1 here</span>    <span class="token keyword">return</span> input_num_1<span class="token punctuation">;</span>    offset_28<span class="token operator">:</span>    input_num_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a3 <span class="token operator">==</span> a2<span class="token punctuation">)</span> <span class="token keyword">return</span> input_num_1<span class="token punctuation">;</span>    <span class="token comment">// a3 &lt; a2</span>    input_2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2 <span class="token operator">+</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// +4   turn right</span>    input_num_1 <span class="token operator">=</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input_2<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> input_num_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>    input_num_1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>input_num_1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>    <span class="token keyword">return</span> input_num_1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）有了phase_6的经验，我在查看了特殊地址<code>0x6030f0</code>的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址<code>0x6030f0</code>为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合<code>secret_phase</code>的逻辑，在子函数<code>fun7</code>返回值为2时defuse，经过分析，<code>fun7</code>这个递归函数，在最后三次递归时为turn left(<code>&amp;input_2 + 0x8</code>）-&gt;turn right(<code>&amp;input_2 + 0x10</code>) -&gt; return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a05e697174deb4b8d970e125f4076696.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/d198271aa8a29539467dd82ee47ef6ad.png" class=""><ol start="3"><li>至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/022618c6c2df7c53f1385e093b46d9bf.png" class=""><hr /><h1 id="lab3-attacklab"><a class="markdownIt-Anchor" href="#lab3-attacklab"></a> lab3 attacklab</h1><h2 id="前提-2"><a class="markdownIt-Anchor" href="#前提-2"></a> 前提</h2><ol><li>注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04</li></ol><p>博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题</p><ol start="2"><li>exploit string用工具<code>hex/2raw</code>构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。</li></ol><p>writeup的附录A介绍了多种<code>hex/2raw</code>接受输入字符串并传递给ctarget的多种方式，我习惯用：<br /><code>./hex2raw &lt; exploit_string.txt | ./ctarget -q</code><br />这条命令将<code>exploit_string.txt</code>作为<code>hex2raw</code>的输入，并建立管道将<code>hex2raw</code>的输出传输到<code>./ctarget</code>中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行<code>./hex2raw</code>那么将无法中止输入</p><h2 id="phase_1-2"><a class="markdownIt-Anchor" href="#phase_1-2"></a> phase_1</h2><ol><li>反汇编<code>ctarget</code>：可用<code>objdump -d ctarget</code>获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/5e39b3abb1bc5e7f4330d928004e1682.png" class=""><p>这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了</p><ol start="2"><li><code>vim dis_ctarget.asm</code>查看<code>getbuf</code>函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者<code>test</code>函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看<code>touch1</code>函数，它的地址在<code>0x004017c0</code>处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/77ee6da89546a4114df2d33fbf821a72.png" class=""><ol start="3"><li><code>vim phase_1.txt</code>输入</li></ol><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>0</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>40</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\  &amp;00 &amp;00  &amp; 00 &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;c0 &amp;17  &amp;40  &amp;00  &amp;00  &amp;00  &amp;00\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.200000000000001em;vertical-align:-3.35em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-5.8500000000000005em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.650000000000001em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.05em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:0.1500000000000002em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span><br />最后留了一个字节以供gets放入’ \n ’ (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/77ee6da89546a4114df2d33fbf821a72.png" class=""><h2 id="phase_2-2"><a class="markdownIt-Anchor" href="#phase_2-2"></a> phase_2</h2><ol><li>编写汇编代码，转化为字节码：<code>vim asb.s</code>，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/97bcb18bfbfeb7e9317be7ad13681c7d.png" class=""><p>line1将<code>cookie</code>值赋给<code>%rdi</code>传参给<code>touch2</code>；ine2将2<code>touch2</code>的地址压入栈中，目的在于在<code>ret</code>指令执行后，从栈中弹出并赋值给<code>%rip</code>的返回地址是<code>touch2</code>的地址</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/aeea8b6bce1c1c133dbdb9f1a3d99fc5.png" class=""><p>writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br /><code>gcc -c asb.s</code><br /><code>objdump -d asb.o &gt; asb.d</code><br />这样我们就得到了指令序列的字节码，可用于构造exploit_string</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/545f6b671736fb44dfde1345b0c75cff.png" class=""><ol start="2"><li>构造<code>phase_2.txt</code>，因为<code>asb.o</code>中的代码本身就已经逆序，所以直接输入即可；用于覆盖<code>test</code>栈帧中返回地址的值可由<code>%rsp</code>的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是<code>%rsp</code>的值</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/7ff73ffc1bf9e9611f1cd79ae7de1f2c.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/6a17fd900e3467ceb030942fd0334f13.png" class=""><ol start="3"><li>攻击生效</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/0cf71efb20d9854b0a1e6e1cfb8a3252.png" class=""><h2 id="phase_3-2"><a class="markdownIt-Anchor" href="#phase_3-2"></a> phase_3</h2><ol><li>与<code>phase_2</code>很像，但这次要传递的参数是字符串形式的<code>cookie</code>。因为<code>getbuf</code>的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串<code>cookie</code>放在<code>test</code>函数的栈帧中，地址<code>0x5561dca8</code>；获取<code>touch3</code>函数的地址，编写攻击代码</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/7210c3d6fbde68b1e7705b12b56e6d38.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/75eb7fac02ee199b822f199e5e69d09f.png" class=""><ol start="2"><li><code>ascii -ax</code>查看十六进制形式的ascii-table，得出<code>&quot;59b997fa&quot;</code>的ascii形式为<code>35 39 62 39 39 37 66 61</code></li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a05e697174deb4b8d970e125f4076696.png" class=""><ol start="3"><li>覆盖返回地址和test栈帧，写入攻击代码的地址和字符串<code>cookie</code></li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a05e697174deb4b8d970e125f4076696.png" class=""><ol start="4"><li>攻击生效</li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a85afbd69b690948359583ead1d13729.png" class=""><h2 id="phase_4-2"><a class="markdownIt-Anchor" href="#phase_4-2"></a> phase_4</h2><p>确定攻击方案：<code>rtarget</code>由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用<code>ctarget</code>自身的代码实现攻击，具体做法是通过地址跳转，截取<code>ctarget</code>的部分代码用作攻击代码；<code>gadget</code>指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串<code>gadget</code>的地址，那么一旦执行其中一个<code>gadget</code>，<code>ret</code>指令就会不断的从栈中弹出新的<code>gadget</code>的地址赋给<code>%rip</code>,由此引发多个<code>gadget</code>的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）</p><ol><li><code>cookie</code>的值不可能从<code>rgadget</code>中找到，需要我们自己放到栈中，如同<code>phase_3</code>一样，放的位置不能是<code>getbuf</code>的缓冲区，因此我们将其放到<code>test</code>的栈帧中；接着要实现<code>mov $0x59b997fa,%rdi</code>，需执行<code>popq %rdi</code>，根据writeup的参照表，先在<code>start_farm</code>和<code>end_farm</code>之间寻找<code>5f</code>，结果没有，但是找到了<code>58 90</code>,地址为<code>0x004019ab</code>，这代表<code>popq %rax  nop</code>，因此我们需要用<code>%rax</code>作介质传递<code>cookie</code>给<code>%rdi</code>，而在farm中我们也确实找到了<code>movq %rax, %rdi：48 89 c7</code>，地址为<code>0x004019c5</code>，一共用到了两个<code>gadget</code></li></ol><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/bbea916ea56dfc9a947de21da0b02567.png" class=""><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/a85afbd69b690948359583ead1d13729.png" class=""><ol start="2"><li>按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒</li></ol><p><img src="attachment/db45ead78f5aca153cab1156d508daef.png" alt="" /><img src="attachment/50bc769c1e6db59af741f48d8624ac96.png" alt="" /></p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/7c0c3e8a239918e820904293bd7101c2.png" class=""><hr /><h1 id="lab4-cachelab"><a class="markdownIt-Anchor" href="#lab4-cachelab"></a> lab4 cachelab</h1><h2 id="parta"><a class="markdownIt-Anchor" href="#parta"></a> PartA</h2><h3 id="1-要做什么"><a class="markdownIt-Anchor" href="#1-要做什么"></a> 1. 要做什么：</h3><p><a href="https://www.yuque.com/attachments/yuque/0/2023/pdf/29536731/1679034059665-5dc8f6ef-14b4-44d3-b7d7-86d86787439b.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F29536731%2F1679034059665-5dc8f6ef-14b4-44d3-b7d7-86d86787439b.pdf%22%2C%22name%22%3A%22cachelab.pdf%22%2C%22size%22%3A61287%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ucfed49fb-dba4-4b45-976d-96d9752defc%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22iZZyy%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">cachelab.pdf</a> <a href="https://www.yuque.com/attachments/yuque/0/2023/pdf/29536731/1679034059905-2f06047b-ba4e-4abb-b642-f43a20552896.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F29536731%2F1679034059905-2f06047b-ba4e-4abb-b642-f43a20552896.pdf%22%2C%22name%22%3A%22rec07.pdf%22%2C%22size%22%3A373293%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u3bcb76bc-9a98-45cd-a08f-c450961f38a%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22M2QOk%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">rec07.pdf</a><br />partA 中提到的<code>.trace</code>文件是一个可执行文件的内存访问记录，由Linux程序<code>valgrind</code>产生。partA要求我们构造一个模拟cache行为的<code>cache simulator</code>，将<code>.trace</code>文件作为输入(实际上就是一条条内存访问记录，模拟内存访问过程)，并伴有三个输入参数：</p><ol><li>组索引位数 -s  （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">S = 2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span>为高速缓存组的组数）</li><li>高速缓存行数 -E</li><li>块偏移位数 -b （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B = 2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>为高速缓存块的大小）</li></ol><p>根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用<code>printSummary(hit_count, miss_count, eviction_count)</code>函数完成，输出结果应当与作者提供给我们的<code>reference cache simulator</code>相同，运行<code>make</code>+<code>./test-csim</code>获取评分</p><h3 id="2-getopt函数的用法"><a class="markdownIt-Anchor" href="#2-getopt函数的用法"></a> 2. getopt函数的用法</h3><p>由于三个参数通过命令行输入，因此我们需要通过C语言库中的<code>getopt</code>函数，结合switch语句从命令行中获取参数值<br />C语言中的<code>main</code>函数是程序的入口函数，它包含两个参数：<code>argc</code>和<code>argv</code>。它们的作用如下：</p><ol><li>argc参数</li></ol><p>argc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。</p><ol><li>argv参数</li></ol><p>argv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br />通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br />C语言中的<code>getopt</code>函数可以帮助程序解析命令行参数。<code>getopt</code>函数通常与<code>argc</code>和<code>argv</code>参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是<code>getopt</code>函数的一般用法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> opt<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"abc:d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -a\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'b'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'c'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -c with value '%s'\n"</span><span class="token punctuation">,</span> optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Option -d\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'?'</span><span class="token operator">:</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unknown option: %c\n"</span><span class="token punctuation">,</span> optopt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，<code>getopt</code>函数的第一个参数是<code>argc</code>，第二个参数是<code>argv</code>，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，<code>&quot;abc:d&quot;</code>表示可接受的选项有<code>-a</code>、<code>-b</code>、<code>-c</code>和<code>-d</code>，其中<code>-c</code>选项需要接受一个参数。<br /><code>getopt</code>函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用<code>switch</code>语句根据选项进行相应的操作。如果<code>getopt</code>函数发现了一个未知的选项，它会返回<code>?</code>,并将这个选项保存在<code>optopt</code>变量中。<br />以下是一些示例命令行及其对应的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./a.out <span class="token parameter variable">-a</span> <span class="token parameter variable">-b</span> <span class="token parameter variable">-c</span> filename <span class="token parameter variable">-d</span>Option <span class="token parameter variable">-a</span>Option <span class="token parameter variable">-b</span>Option <span class="token parameter variable">-c</span> with value <span class="token string">'filename'</span>Option <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./a.out <span class="token parameter variable">-a</span> <span class="token parameter variable">-b</span> <span class="token parameter variable">-c</span>Option <span class="token parameter variable">-a</span>Option <span class="token parameter variable">-b</span>Unknown option: c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在使用<code>getopt</code>函数时，需要注意以下几点：</p><ol><li>在循环中，<code>optarg</code>变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过<code>atoi</code>函数转化为整型。</li><li>如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，<code>getopt</code>函数会返回<code>?</code>，并将这个选项保存在<code>optopt</code>变量</li><li>如果一个选项在可接受的选项字符串中没有指定，<code>getopt</code>函数会返回<code>-1</code>，并结束循环</li></ol><p><code>getopt</code>函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br />虽然<code>getopt</code>函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，<code>getopt</code>函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br />可接受选项字符串可以告诉<code>getopt</code>函数哪些选项是合法的，以及它们是否需要参数，从而使<code>getopt</code>函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串<code>&quot;ab:c&quot;</code>表示程序支持三个选项<code>-a</code>、<code>-b</code>和<code>-c</code>, 其中<code>-c</code>选项需要一个参数。</p><h3 id="3-fscanf的用法"><a class="markdownIt-Anchor" href="#3-fscanf的用法"></a> 3. fscanf的用法</h3><p><code>fscanf</code>是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。<code>fscanf</code>函数的基本格式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，第一个参数<code>stream</code>是指向要读取数据的文件的指针；第二个参数<code>format</code>是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br />例如，如果你有一个文件<code>data.txt</code>，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量<code>a</code>、<code>b</code>、<code>c</code>中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>    <span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d, b = %d, c = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，<code>fscanf</code>函数的第一个参数是文件指针<code>fp</code>，第二个参数是格式化字符串<code>&quot;%d %d %d&quot;</code>，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量<code>a</code>、<code>b</code>、<code>c</code>的地址，<code>fscanf</code>函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。</p><h3 id="4-编写程序"><a class="markdownIt-Anchor" href="#4-编写程序"></a> 4. 编写程序</h3><p>这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量</p><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/ea760dfad84e022b238df1bf264916b5.png" class=""><ol><li>cache结构声明</li></ol><p>cache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cache_line</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> valid_bit<span class="token punctuation">;</span><span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> time_stamp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cache_line<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cache</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> S<span class="token punctuation">;</span><span class="token keyword">int</span> E<span class="token punctuation">;</span><span class="token keyword">int</span> B<span class="token punctuation">;</span>cache_line<span class="token operator">*</span><span class="token operator">*</span> Cache<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cache<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>main</li></ol><p>主要在于正确解析命令行参数，会用<code>getopt</code>就行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>hit_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> miss_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> eviction_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s<span class="token punctuation">,</span> E<span class="token punctuation">,</span> b<span class="token punctuation">,</span>opt<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> trace_name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token operator">*</span> my_cache<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"s:E:b:t:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'s'</span><span class="token operator">:</span>   s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'E'</span><span class="token operator">:</span>   E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'b'</span><span class="token operator">:</span>   b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'t'</span><span class="token operator">:</span>   <span class="token function">strcpy</span><span class="token punctuation">(</span>trace_name<span class="token punctuation">,</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'?'</span><span class="token operator">:</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unknown option: %c\n"</span><span class="token punctuation">,</span>optopt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     my_cache <span class="token operator">=</span> <span class="token function">construct_cache</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>E<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> s<span class="token punctuation">,</span> b<span class="token punctuation">,</span> trace_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hit_count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>miss_count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>eviction_count<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">free_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printSummary</span><span class="token punctuation">(</span>hit_count<span class="token punctuation">,</span> miss_count<span class="token punctuation">,</span> eviction_count<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>construct_cache</li></ol><p>根据输入的命令行参数<code>s</code>,<code>E</code>,<code>b</code>构造cache，并初始化每一个高速缓存行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cache<span class="token operator">*</span> <span class="token function">construct_cache</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> E<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cache<span class="token operator">*</span> my_cache <span class="token operator">=</span><span class="token punctuation">(</span>cache<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// construct Cache</span> my_cache<span class="token operator">-></span>S <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span> my_cache<span class="token operator">-></span>B <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">;</span> my_cache<span class="token operator">-></span>E <span class="token operator">=</span> E<span class="token punctuation">;</span> my_cache<span class="token operator">-></span>Cache <span class="token operator">=</span> <span class="token punctuation">(</span>cache_line<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>S <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cache_line<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>my_cache<span class="token operator">-></span>S<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>cache_line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>E <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cache_line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token comment">// initialize</span><span class="token punctuation">&#123;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> my_cache<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>update_LRU</li></ol><p>我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">update_LRU</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_tag<span class="token punctuation">,</span> <span class="token keyword">int</span> line_index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit<span class="token punctuation">)</span> <span class="token operator">++</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>line_index<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>line_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>line_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> ad_tag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>get_line_index</li></ol><p>每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">get_line_index</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_tag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit <span class="token operator">&amp;&amp;</span> my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> ad_tag<span class="token punctuation">)</span><span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token comment">// hit</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// miss</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>is_not_full</li></ol><p>。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">is_not_full</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid_bit<span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>find_LRU</li></ol><p>对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find_LRU</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> max_stamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> evict_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> my_cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>temp <span class="token operator">=</span> my_cache<span class="token operator">-></span>Cache<span class="token punctuation">[</span>ad_set<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>time_stamp<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">></span> max_stamp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>max_stamp <span class="token operator">=</span> temp<span class="token punctuation">;</span>evict_line <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> evict_line<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="8"><li>access_cache</li></ol><p>我们需要用<code>fscanf</code>对数据访问操作进行解析，注意此处的<code>&quot; %c %x,%d&quot;</code>,<code>%c</code>前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数<code>real_access_cache</code>。M等于L+S，因此需要两次更新。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">access_cache</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> trace_name<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> hit_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> miss_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> eviction_count_ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  FILE<span class="token operator">*</span> pFile<span class="token punctuation">;</span>   <span class="token comment">// receive access</span>     pFile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>trace_name<span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pFile<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">char</span> identifier<span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> address<span class="token punctuation">;</span>     <span class="token keyword">int</span> size<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">fscanf</span><span class="token punctuation">(</span>pFile<span class="token punctuation">,</span><span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>identifier<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token operator">&amp;</span>size<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mask <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">64</span><span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ad_set <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span><span class="token keyword">int</span> ad_tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>s<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>identifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'M'</span><span class="token operator">:</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'L'</span><span class="token operator">:</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'S'</span><span class="token operator">:</span><span class="token function">real_access_cache</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> hit_count_ptr<span class="token punctuation">,</span> miss_count_ptr<span class="token punctuation">,</span> eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>pFile<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">real_access_cache</span><span class="token punctuation">(</span>cache<span class="token operator">*</span> my_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_set<span class="token punctuation">,</span> <span class="token keyword">int</span> ad_tag<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> hit_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> miss_count_ptr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> eviction_count_ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> line_index<span class="token punctuation">,</span>free_line<span class="token punctuation">,</span> evict_line<span class="token punctuation">;</span>line_index <span class="token operator">=</span> <span class="token function">get_line_index</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>line_index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>hit_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">update_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> line_index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>free_line <span class="token operator">=</span> <span class="token function">is_not_full</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>free_line <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>miss_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">update_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> free_line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>miss_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>eviction_count_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>evict_line <span class="token operator">=</span> <span class="token function">find_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span>ad_set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">update_LRU</span><span class="token punctuation">(</span>my_cache<span class="token punctuation">,</span> ad_set<span class="token punctuation">,</span> ad_tag<span class="token punctuation">,</span> evict_line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-结果"><a class="markdownIt-Anchor" href="#5-结果"></a> 5. 结果</h3><img src="/2023/03/06/CSAPP_lab/CSAPP-LAB/f79658fdbb805322f1a6a578ef030add.png" class="">]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[汇编语言(王爽)] 实验流程</title>
      <link href="/2023/02/04/CSAPP_lab/assembly/"/>
      <url>/2023/02/04/CSAPP_lab/assembly/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言：</h1><p>前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的bomb lab完成了</p><hr /><h1 id="实验1-查看cpu和内存用机器指令和汇编指令编程"><a class="markdownIt-Anchor" href="#实验1-查看cpu和内存用机器指令和汇编指令编程"></a> 实验1 查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="debug环境搭建参考此文"><a class="markdownIt-Anchor" href="#debug环境搭建参考此文"></a> debug环境搭建：<a href="https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506">参考此文</a></h2><h2 id="assignment-1"><a class="markdownIt-Anchor" href="#assignment-1"></a> assignment 1</h2><ol><li>用A命令向内存中写入汇编指令，用U命令查看</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/be45e9be004d61829c5b03272132030c.png" class=""><ol start="2"><li>用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><h2 id="assignment-2"><a class="markdownIt-Anchor" href="#assignment-2"></a> assignment 2</h2><ol><li>写入并查看指令</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/3433e861e5085ced9ca3c7be18ad26e6.png" class=""><ol start="2"><li>修改_CS:IP_指向</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/be45e9be004d61829c5b03272132030c.png" class=""><ol start="3"><li>执行指令，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，结果为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>X</mi><mo>=</mo><mn>0100</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">AX = 0100H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><h2 id="assignment-3"><a class="markdownIt-Anchor" href="#assignment-3"></a> assignment 3</h2><ol><li>用D命令查找，最终在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mn>5</mn><mi>H</mi><mo>→</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>C</mi><mi>H</mi><mtext>（</mtext><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>:</mo><mn>0005</mn><mo>→</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>:</mo><mn>000</mn><mi>C</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">FFFF5H \to FFFFCH（FFFF:0005 \to FFFF:000C）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">）</span></span></span></span>发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>d</mi><mi mathvariant="normal">/</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>y</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">dd/mm/yy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>字样的生产日期</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/26795f5d2a90e3b1abc6b1fdc9d39408.png" class=""><ol start="2"><li>尝试用E命令修改，该操作失效，因为这是ROM</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/5fd1fddb244160f8985c8162d69751f1.png" class=""><h2 id="assignment-4"><a class="markdownIt-Anchor" href="#assignment-4"></a> assignment 4</h2><p>1.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>0000</mn><mi>H</mi><mo>→</mo><mi>B</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">A0000H \to BFFFFH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石</p><img src="/2023/02/04/CSAPP_lab/assembly/3433e861e5085ced9ca3c7be18ad26e6.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><hr /><h1 id="实验2-用机器指令和汇编指令编程"><a class="markdownIt-Anchor" href="#实验2-用机器指令和汇编指令编程"></a> 实验2 用机器指令和汇编指令编程</h1><h2 id="assignment-1-2"><a class="markdownIt-Anchor" href="#assignment-1-2"></a> assignment 1</h2><ol><li>用A指令向内存中写入汇编指令，用U指令查看</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/69e55d7cd42de97dab21bb828f85738e.png" class=""><ol start="2"><li>修改CS:IP使其指向代码段</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/9f2dfda5f53b12dff0c5b678c0230fe1.png" class="">、<ol start="3"><li>t命令逐步执行指令后查看AX、BX、SP寄存器内容</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><h2 id="assignment-2-2"><a class="markdownIt-Anchor" href="#assignment-2-2"></a> assignment 2</h2><p>在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）</p><hr /><h1 id="实验3-编程-编译-链接-跟踪"><a class="markdownIt-Anchor" href="#实验3-编程-编译-链接-跟踪"></a> 实验3 编程、编译、链接、跟踪</h1><h2 id="assignment-1-3"><a class="markdownIt-Anchor" href="#assignment-1-3"></a> assignment 1</h2><ol><li>编译链接生成可执行文件</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/9a986e22ba33aa2f07fb537819658b5d.png" class=""><h2 id="assignment-2-3"><a class="markdownIt-Anchor" href="#assignment-2-3"></a> assignment 2</h2><ol><li>debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mo>=</mo><mn>075</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">DS=075C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，则PSP的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>075</mn><mi>C</mi><mo>:</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">075C:0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，程序的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>0</mn><mtext>  </mtext><mo stretchy="false">(</mo><mn>075</mn><mi>C</mi><mo>+</mo><mn>10</mn><mo>:</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">076C:0\;(075C+10:0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi><mo>:</mo><mi>I</mi><mi>P</mi><mo>=</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0000</mn></mrow><annotation encoding="application/x-tex">CS:IP = 076C:0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/9f2dfda5f53b12dff0c5b678c0230fe1.png" class=""><ol start="2"><li>跟踪程序执行过程</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/4558f12f037760ce42478fc1c563f99a.png" class=""><p>用P命令执行<code>INT 21</code></p><img src="/2023/02/04/CSAPP_lab/assembly/55386b9183e912238f4ef08482495438.png" class=""><h2 id="assignment-3-2"><a class="markdownIt-Anchor" href="#assignment-3-2"></a> assignment 3</h2><ol><li>查看PSP的内容</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><hr /><h1 id="实验4-bx和loop的使用"><a class="markdownIt-Anchor" href="#实验4-bx和loop的使用"></a> 实验4 [bx]和loop的使用</h1><h2 id="assignment-1-4"><a class="markdownIt-Anchor" href="#assignment-1-4"></a> assignment 1</h2><ol><li>编写源程序</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentmov ax, 0020Hmov ds, axmov bx, 0mov dx, 0mov cx, 64s: mov [bx],dxinc bxinc dxloop smov ax, 4c00h int 21hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>编译，链接生成可执行文件</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/9a986e22ba33aa2f07fb537819658b5d.png" class=""><ol start="3"><li>查看载入内存的程序，可以看见标签s已被替换为地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>000</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076C:000E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><ol start="4"><li>执行程序，验证结果，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/69e55d7cd42de97dab21bb828f85738e.png" class=""><h2 id="assignment-2-4"><a class="markdownIt-Anchor" href="#assignment-2-4"></a> assignment 2</h2><ol><li>编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentmov ax, 0020Hmov ds, axmov bx, 0mov cx, 64s: mov [bx],bxinc bxloop smov ax, 4c00h int 21hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>其它步骤与assigment 1一致，验证结果，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><h2 id="assignment-3-3"><a class="markdownIt-Anchor" href="#assignment-3-3"></a> assignment 3</h2><ol><li>复制的是什么：复制程序的第一条指令<code>mov ax,cs</code>到 <code>loop s</code> 指令至内存地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0020</mn><mo>:</mo><mn>0000</mn></mrow><annotation encoding="application/x-tex">0020:0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>处</li><li>如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在<code>mov cx,_____</code> 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>0000</mn><mo>→</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0015</mn></mrow><annotation encoding="application/x-tex">076C:0000 \to 076C:0015</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">5</span></span></span></span>，共<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>H</mi><mtext> </mtext><mo stretchy="false">(</mo><mn>23</mn><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">16H\,(23D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>个字节,因此第二个空应该填入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">16H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><hr /><h1 id="实验5-编写-调试具有多个段的程序"><a class="markdownIt-Anchor" href="#实验5-编写-调试具有多个段的程序"></a> 实验5 编写、调试具有多个段的程序</h1><h2 id="assignment-1-5"><a class="markdownIt-Anchor" href="#assignment-1-5"></a> assignment 1</h2><ol><li>将程序载入内存后查看，可知data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/d589f866c98c4ea05c31a837ae10ba82.png" class=""><ol start="2"><li>Q1：<code>G 001D</code>执行程序至程序返回前，用U命令查看data段内容: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0123</mn><mi>H</mi><mo separator="true">,</mo><mn>0456</mn><mi>H</mi><mo separator="true">,</mo><mn>0789</mn><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>A</mi><mi>B</mi><mi>C</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>D</mi><mi>E</mi><mi>F</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>F</mi><mi>E</mi><mi>D</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>C</mi><mi>B</mi><mi>A</mi><mi>H</mi><mo separator="true">,</mo><mn>0987</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">8</span><span class="mord">9</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">9</span><span class="mord">8</span><span class="mord">7</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/f1c8bb9ffed9738a412d85eba74d5094.png" class=""><ol start="3"><li>Q2：R命令查看各个段寄存器的值  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo><mtext>  </mtext><mi>C</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">\to \;CS:076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">DS:076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">SS:076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/4558f12f037760ce42478fc1c563f99a.png" class=""><ol start="4"><li>Q3：data段和stack段分别占16个字节，因此设code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mn>1</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X-1H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mn>2</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X-2H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>（做了assignment2后可以发现这里说法并不准确）</li></ol><h2 id="assignment-2-5"><a class="markdownIt-Anchor" href="#assignment-2-5"></a> assignment 2</h2><ol><li>步骤与assigment1 完全一致</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/2a60b33897c958a72dcac6c90c6195cf.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/74a158dbaf8f30c5bda7baeaf9e299e7.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/e32c2fe4dd55436bc2d3d5814bd82eec.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/b61143a70bf02c04d76e0e636905efe6.png" class=""><ol start="2"><li>得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍</li></ol><h2 id="assignment-3-4"><a class="markdownIt-Anchor" href="#assignment-3-4"></a> assignment 3</h2><ol><li>步骤与assignment1完全一致</li></ol><p>2， 设code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>+</mo><mn>3</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X+3H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>+</mo><mn>4</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X+4H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></p><h2 id="assignment-4-2"><a class="markdownIt-Anchor" href="#assignment-4-2"></a> assignment 4</h2><p>如果去掉通知编译器程序的入口的<code>end start </code>语句，那么唯一可正确运行的是起始段为code段的程序3</p><h2 id="assignment-5"><a class="markdownIt-Anchor" href="#assignment-5"></a> assignment 5</h2><ol><li>编写源程序，注意在将段地址写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>时，要借助一个寄存器充当介质，因为立即数无法直接写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codea segment db 1,2,3,4,5,6,7,8a endsb segmentdb 1,2,3,4,5,6,7,8b endsc segment db 0,0,0,0,0,0,0,0c endscode segmentstart:mov bx, 0mov cx, 8s:mov dx, amov ds,dxmov ax, [bx]mov dx, bmov ds,dxadd ax, [bx]mov dx, cmov ds,dxmov [bx], axinc bxloop smov ax,4c00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>用debug跟踪程序，可以看到a段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、b段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>、c段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><ol start="3"><li>执行程序，查看c段内容，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/1902be5182e1e33b83c2ed1578768ca2.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/7e5d09d22bc0f75cb757fda650a9b4eb.png" class=""><h2 id="assignment-6"><a class="markdownIt-Anchor" href="#assignment-6"></a> assignment 6</h2><ol><li>编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codea segmentdw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffha endsb segment dw 0,0,0,0,0,0,0,0b endscode segment start:mov ax, amov ds, axmov ax, b mov ss, axmov sp, 0010Hmov bx, 0mov cx, 8s:push [bx]add bx, 2loop smov ax, 4c00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>用debug跟踪程序，可以看到a段段地址： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 、 b段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>、code段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>F</mi></mrow><annotation encoding="application/x-tex">076F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></li></ol><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><ol start="3"><li>执行程序，查看b段内容，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><hr /><h1 id="实验6-实践课程中的程序"><a class="markdownIt-Anchor" href="#实验6-实践课程中的程序"></a> 实验6 实践课程中的程序</h1><h2 id="assignment-1-6"><a class="markdownIt-Anchor" href="#assignment-1-6"></a> assignment 1</h2><ol><li>这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesg, ds:datasg, ss:stacksgdatasg segment db &#39;ibm             &#39;db &#39;dec             &#39;db &#39;dos             &#39;db &#39;vax             &#39;datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscodesg segmentstart:mov ax, stacksgmov ss, axmov sp, 10Hmov ax, datasgmov ds, axmov bx, 0mov cx, 4s0:push cxmov si, 0mov cx, 3s:mov al, [bx+si]and al, 11011111Bmov [bx+si], alinc siloop s pop cxadd bx, 10Hloop s0mov ax, 4c00Hint 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>跟踪程序，查看data段内容</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><ol start="3"><li>执行程序后，查看data段内容，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><h2 id="assignment-2-6"><a class="markdownIt-Anchor" href="#assignment-2-6"></a> assignment 2</h2><ol><li>编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesg, ds:datasg, ss:stacksgstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endsdatasg segment db &#39;1. display      &#39;db &#39;2. brows        &#39;db &#39;3. replace      &#39;db &#39;4. modify       &#39;datasg endscodesg segmentstart:mov ax, stacksgmov ss, axmov sp, 10H mov ax, datasgmov ds, axmov bx, 0mov cx, 4s0:push cxmov cx, 4mov si, 0s: mov al, [bx+3+si]and al, 11011111Bmov [bx+3+si], alinc siloop spop cxadd bx, 10Hloop s0mov ax, 4c00Hint 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>跟踪程序，查看data段内容</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><ol start="3"><li>执行程序，查看data段内容，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><hr /><h1 id="实验7-寻址方式在结构化数据访问中的应用"><a class="markdownIt-Anchor" href="#实验7-寻址方式在结构化数据访问中的应用"></a> 实验7 寻址方式在结构化数据访问中的应用</h1><ol><li>编写源程序，用<code>word ptr / byte ptr</code>指定内存单元大小主要应用在<code>div</code>指令或用于向内存写入立即数</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgstack segmentdw 0,0,0,0,0,0,0,0stack endsdata segmentdb &#39;1975&#39;,&#39;1976&#39;, &#39;1977&#39;, &#39;1978&#39;, &#39;1979&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;,&#39;1983&#39;db &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;db &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;dd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514dd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226dw 11542,14430,15257,17800data endstable segmentdb 21 dup (&#39;year summ ne ?? &#39;)table endscodesg segmentstart:mov ax, stack ;0776Cmov ss, axmov sp, 10Hmov ax, data ; 076Dmov es, axmov ax, table ; 077bmov ds, axmov bx,0mov si,0mov cx,21year:push cxmov cx, 4mov di, 0char:mov al, es:[si]mov [bx+di], alinc diinc siloop charpop cxadd bx, 10Hloop yearmov cx, 21mov bx, 0income:push cxmov cx, 2mov di, 0dwInt:mov ax, es:[si]mov [bx].5[di], axadd si, 2add di, 2loop dwIntpop cxadd bx, 10Hloop incomemov cx, 21mov bx, 0staff:mov ax, es:[si]mov [10+bx], axadd si, 2;add bx, 10Hloop staffmov cx, 21mov bx, 0average:mov dx, [bx+7]mov ax, [bx+5]div word ptr [bx+0AH]mov [bx+0Dh], axadd bx, 10Hloop averagemov ax, 4C00Hint 21Hcodesg endsend start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>查看原始table段的内容</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/9bc6319e4399ae16eed295b023956965.png" class=""><ol start="3"><li>执行程序后，查看table段的内容，正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><h1 id="实验8-分析一个奇怪的程序"><a class="markdownIt-Anchor" href="#实验8-分析一个奇怪的程序"></a> 实验8 分析一个奇怪的程序</h1><ol><li>程序从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span></span></span></span>入口处开始执行，一个<code>nop</code>指令占一个字节并表示No operation，此处用了两个<code>nop</code>指令的目的是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处预留两个字节的空间，程序执行<code>mov cs:[di], ax</code>之后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的两个字节被试图写入<code>jmp short s1</code>，接着程序向下执行<code>jmp short s</code>使得程序跳转回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处开始执行。</li><li><code>jmp short s1</code>到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>跳转到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span>，即从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>处的jmp指令的下一指令<code>nop</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0022</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(076C:0022)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>跳转到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span>处的<code>mov ax, 0</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0018</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(076C:0018)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>，因为<code>jmp short 标号</code>是依据位移进行转移的指令，而此处位移大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0022</mn><mi>H</mi><mo>−</mo><mn>0018</mn><mi>H</mi><mo>=</mo><mo>−</mo><mn>10</mn><mi>D</mi><mo stretchy="false">(</mo><mi>F</mi><mn>6</mn><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0022H-0018H =-10D(F6H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的<code>jmp short s</code>指令的机器码为<code>EBF6</code>（刚好占两个字节，因此可以被正确写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处）</li><li>执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的跳转指令，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mo>=</mo><mi>I</mi><mi>P</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IP = IP+(-10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为<code>mov ax, 4c00H</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>000</mn><mi>A</mi><mi>H</mi><mo>−</mo><mn>0010</mn><mi>H</mi><mo>=</mo><mn>0000</mn><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(000AH-0010H=0000H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，程序从此处开始向下执行，最终可以正确退出</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/7244d292d962167035026ae6d17647cd.png" class=""><h1 id="实验9-根据材料编程"><a class="markdownIt-Anchor" href="#实验9-根据材料编程"></a> 实验9 根据材料编程</h1><ol><li>编写源程序：最开始我试图用<code>mov address，data</code>的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据<code>welcome to masm!</code>，利用寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">ax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgdata segmentdb &#39;welcome to masm!&#39;data endscodesg segmentstart: mov ax, datamov ds, axmov ax, 0B800Hmov es, axmov bx, 0mov si, 1824mov cx, 10Hs0:mov ah, 82Hmov al, [bx]mov es:[si], axinc bxadd si, 2loop s0mov bx, 0 mov si, 1984mov cx, 10Hs1:mov ah, 0A4Hmov al, [bx]mov es:[si], axinc bxadd si, 2loop s1mov bx, 0 mov si, 2144mov cx, 10Hs2:mov ah, 11110001Bmov al, [bx]mov es:[si], axinc bxadd si, 2loop s2mov ax, 4c00Hint 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>最终效果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><h1 id="实验10-编写子程序"><a class="markdownIt-Anchor" href="#实验10-编写子程序"></a> 实验10 编写子程序</h1><h2 id="assignment-1-7"><a class="markdownIt-Anchor" href="#assignment-1-7"></a> assignment 1</h2><ol><li>编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（<strong>注意入栈顺序与出栈顺序相反</strong>）</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segmentdb &quot;welcome to masm!&quot;, 0data endsstack segmentdw 16 dup (0)stack endscode segmentstart:mov dh, 8mov dl, 3mov cl, 2mov ax, datamov ds, axmov ax, stackmov sp, 20Hmov si, 0call show_strmov ax, 4C00Hint 21Hshow_str:push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复push bxpush cxpush dxpush espush simov ax, 0B800H; 80×25彩色模式显示缓冲区mov es, axmov al, 160 ; 设置指定打印位置inc dh ; 行数从0开始mul dh ; 8位乘法，结果存储在ax中mov bx, axmov al, 2mul dladd bx, axmov ah, clprint:mov cl, [si] ; 设置cxmov ch, 0jcxz ok ;判断字符串是否结束mov al, cl ; 设置字符属性和值mov es:[bx],axinc siadd bx, 2jmp printok:pop sipop espop dxpop cxpop bxpop axret code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><h2 id="assignment-2-7"><a class="markdownIt-Anchor" href="#assignment-2-7"></a> assignment 2</h2><ol><li><p>编写源程序，利用除法溢出公式</p><pre><code>            $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$</code></pre></li></ol><p>该公式的基本思想是将可能发生除法溢出的32位除法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">X/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span>，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>+</mo><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(H/n)*65536 + (L/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br /><strong>商（32位）：</strong><br />高十六位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">int(H/2)*65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span>,低十六为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>r</mi><mi>e</mi><mi>m</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>+</mo><mi>L</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">int([rem(H/n)*65536+L]/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br /><strong>余数（16位）：</strong><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>m</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>r</mi><mi>e</mi><mi>m</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>+</mo><mi>L</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rem([rem(H/n)*65536+L]/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br />（注：对这个公式的理解有限）</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codestack segmentdw 16 dup (0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 4240Hmov dx, 000FHmov cx, 0AHcall divdwmov ax, 4C00Hint 21Hdivdw:push bxmov bx, ax ; 暂存Lmov ax, dx ; H&#x2F;Nmov dx, 0div cx ; int(H&#x2F;N)在ax中，rem(H&#x2F;N)在dx中push ax ; 暂存int(H&#x2F;N)，除数mov ax, bx; dx and ax constitute rem(H&#x2F;N)*65535+Ldiv cx ; ax store the resultmov cx, dxpop dx ; int(H&#x2F;N)pop bxretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果正确</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/3e62cb394c3e34f04693136b17ab094f.png" class=""><h2 id="assignment-3-5"><a class="markdownIt-Anchor" href="#assignment-3-5"></a> assignment 3</h2><ol><li>编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segmentdb 10 dup(0)data endsstack segmentdw 16 dup(0)stack endscode segmentstart:mov ax, 12666mov bx, datamov ds, bxmov si, 0mov bx, stackmov ss, bxmov sp, 20Hcall dtocmov dh, 8mov dl, 3mov cl, 2call show_strmov ax, 4C00Hint 21Hdtoc:push axpush bxpush cxpush dxpush sipush dimov dx, 0 ; 被除数高16位 置0mov bx, 10mov di, 0 ; 字符计数divide:mov cx, ax jcxz overinc didiv bx ; 32位除法，商在ax，余数在dxadd dx, 30Hpush dxmov dx, 0jmp divideover:mov cx, dimove: pop bxmov [si], blinc siloop movepop dipop sipop dxpop cxpop bxpop axretshow_str:push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复push bxpush cxpush dxpush espush simov ax, 0B800H; 80×25彩色模式显示缓冲区mov es, axmov al, 160 ; 设置指定打印位置inc dh ; 行数从0开始mul dh ; 8位乘法，结果存储在ax中mov bx, axmov dh, 0mov al, 2mul dladd bx, axmov ah, clprint:mov cl, [si] ; 设置cxmov ch, 0jcxz ok ;判断字符串是否结束mov al, cl ; 设置字符属性和值mov es:[bx],axinc siadd bx, 2jmp printok:pop sipop espop dxpop cxpop bxpop axret code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/4a2d01950618f1bd82fc3ef321645928.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/641df2d303642523f5b106137fff3bf6.png" class=""><h1 id="实验11-编写子程序"><a class="markdownIt-Anchor" href="#实验11-编写子程序"></a> 实验11 编写子程序</h1><ol><li>编写源程序：主要用到了<code>cmp</code>指令和条件转移指令组合形成的if逻辑</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgdatasg segmentdb &quot;Beginner&#39;s All-purpose Symbolic Instruction Code.&quot;,0datasg endscodesg segmentbegin:mov ax, datasgmov ds, axmov si, 0call lettercmov ax, 4C00Hint 21Hletterc:push axpush cxCapital:mov al, [si]mov cl, almov ch, 0jcxz OKcmp al, 97jb NOcmp al, 122ja NOand al, 11011111Bmov [si], alNO:inc sijmp short CapitalOK:pop cxpop axretcodesg endsend begin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/ae00e48f345b630c03e516d571016343.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/fcb4683184a6c0d79d2699bc79186aa3.png" class=""><h1 id="实验12-编写0号中断的处理程序"><a class="markdownIt-Anchor" href="#实验12-编写0号中断的处理程序"></a> 实验12 编写0号中断的处理程序</h1><ol><li>编写源程序</li></ol><p>总体来说就3个任务：</p><ul><li>编写中断处理程序</li><li>复制中断处理程序至内存空闲区域(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn><mo>:</mo><mn>0200</mn><mi>H</mi><mo>→</mo><mn>0000</mn><mo>:</mo><mn>02</mn><mi>F</mi><mi>F</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">0000:0200H\to0000:02FFH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>)</li><li>修改中断向量表（中断处理程序地址入口表）</li></ul><p>注意在用<code>jcxz</code>条件转移指令时，要<code>jmp short</code>回程序开头</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset do0 ; 076C:0028mov ax, 0mov es, axmov di, 0200Hmov cx, offset do0end- offset do0; 0034Hcldrep movsb ; 复制程序到0:200mov word ptr es:[0], 0200Hmov word ptr es:[0+2], 0 ; 修改中断向量表mov ax, 4C00Hint 21Hdo0:jmp short do0startdb &quot;divide error&quot;,0 do0start:mov ax, 0B800Hmov es, axmov di, 160*12+34*2mov ax, csmov ds, axmov si, 202Hprint:mov cL, [si]mov ch, 0jcxz okmov ah, 04h ;redmov al, clmov es:[di], axinc siadd di, 2 jmp short printok:mov ax, 4C00Hint 21Hdo0end: ;005Cnopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/3e62cb394c3e34f04693136b17ab094f.png" class=""><h1 id="实验13-编写-应用中断例程"><a class="markdownIt-Anchor" href="#实验13-编写-应用中断例程"></a> 实验13 编写、应用中断例程</h1><h2 id="assignment-1-8"><a class="markdownIt-Anchor" href="#assignment-1-8"></a> assignment 1</h2><ol><li>编写源程序：与lab10-1的show_str基本一致，只需将<code>call-ret</code>更改为 <code>int 7cH - iret</code></li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset printmov ax, 0mov es, axmov di, 0200Hmov cx, offset printed - offset printcldrep  movsbmov word ptr es:[7cH*4], 0200Hmov word ptr es:[7cH*4+2], 0 mov ax, 4C00Hint 21Hprint:push bxpush cxpush espush sipush axpush dxmov ax, 0B800Hmov es, axmov al, 160inc dhmul dh ; 160*(10+1) in axmov bx, axmov al, 2mul dl ; 10*2 in axadd bx, axmov ah, clstPrint:mov ch, 0mov cl, [si]jcxz okmov al, clmov es:[bx], axadd bx, 2inc sijmp short stPrintok:pop dxpop axpop sipop espop cxpop bxiretprinted:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/07b1a26be34a52d64824abce91c15e76.png" class=""><h2 id="assignment-2-8"><a class="markdownIt-Anchor" href="#assignment-2-8"></a> assignment 2</h2><ol><li>编写源程序</li></ol><p>用中断例程实现loop指令，主要需要解决三个问题</p><ul><li>怎么取得标号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的段地址和偏移地址？</li></ul><p>有一对段地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>和偏移地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>在中断过程时被压入栈，标号的段地址就是该CS，标号       的偏移地址可由该IP加上转移地址(<code>offset s - offset se</code>)得到</p><ul><li>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的段地址和偏移地址后，如何设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi><mo>:</mo><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">CS:IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></li></ul><p>用<code>iret</code>指令：<code>pop IP , pop CS ,  popf</code></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset lpmov ax, 0mov es, axmov di, 0200Hmov cx, offset lped - offset lpcldrep  movsbmov word ptr es:[7cH*4], 0200Hmov word ptr es:[7cH*4+2], 0 mov ax, 4C00Hint 21Hlp:dec cxjcxz lpretpush bpmov bp, spadd [bp+2], bxlpret:pop bpiretlped:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/3e62cb394c3e34f04693136b17ab094f.png" class=""><h2 id="assignment-3-6"><a class="markdownIt-Anchor" href="#assignment-3-6"></a> assignment 3</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segments1: db &#39;Good,better,best,&#39;,&#39;$&#39;s2: db &#39;Never let it rest,&#39;,&#39;$&#39; s3: db &#39;Till good is better,&#39;,&#39;$&#39;s4: db &#39;And better,best.&#39;, &#39;$&#39;s: dw offset s1, offset s2, offset s3, offset s4 row: db 2,4,6,8start:mov ax, cs mov ds, axmov bx, offset smov si, offset rowmov cx, 4ok:mov bh, 0 mov dh, [si]mov dl, 0mov ah, 2 ; BIOS中断例程--设置光标int 10h mov dx, [bx]                                           mov ah, 9 ; DOS中断例程--打印字符串int 21hinc siadd bx, 2loop okmov ax, 4C00H; DOS中断例程--程序返回，返回值在alint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验14-访问-cmos-ram"><a class="markdownIt-Anchor" href="#实验14-访问-cmos-ram"></a> 实验14 访问 CMOS RAM</h1><ol><li>编写源程序</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codestack segmentdw 16 dup (0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 0B800Hmov ds, axmov al, 9mov bx, 160*12+36*2call GetAscillmov byte ptr [bx+4], &#39;&#x2F;&#39;mov al, 8add bx, 6call GetAscillmov byte ptr [bx+4], &#39;&#x2F;&#39;mov al, 7add bx, 6call GetAscillmov byte ptr [bx+4], &#39; &#39;mov al, 4add bx, 6call GetAscillmov byte ptr [bx+4], &#39;:&#39;mov al, 2add bx, 6call GetAscillmov byte ptr [bx+4], &#39;:&#39;mov al, 0add bx, 6call GetAscillmov ax, 4C00Hint 21HGetAscill:push axpush bxpush cxpush dxout 70H, alin al, 71Hmov ah, almov cl, 4shr ah, cland al, 00001111Badd ah, 30Hadd al, 30Hmov dx, 0B800Hmov es, dxmov es:[bx], ah mov byte ptr es:[bx+1], 02H ; greenmov es:[bx+2], almov byte ptr es:[bx+3], 02Hpop dxpop cxpop bxpop axretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/a1984fc0ae5d3f224966bb4c15b2e0ea.png" class=""><h1 id="实验15-安装新的int-9-中断例程"><a class="markdownIt-Anchor" href="#实验15-安装新的int-9-中断例程"></a> 实验15 安装新的int 9 中断例程</h1><h2 id="前置练习1"><a class="markdownIt-Anchor" href="#前置练习1"></a> 前置练习1</h2><p>在屏幕中间依次显示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a\to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>,按Esc键后改变与颜色</p><ol><li>编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把<code>call dword ptr ds:[0]</code>写成了<code>call word ptr ds:[0]</code>，导致整个系统没有正确的int 9中断例程，因此出现了错误。</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:codestack segmentdb 64 dup(0)stack endsdata segmentdw 0,0data endscode segmentstart:mov ax, stackmov ss, axmov sp, 40Hmov ax, datamov ds, axmov ax, 0mov es, axpush es:[9*4]pop ds:[0]push es:[9*4+2]pop ds:[2] ; 保存原int 9中断例程的入口地址climov word ptr es:[9*4], offset int9mov es:[9*4+2], cs;设置新的入口地址stimov ax, 0B800Hmov es,axmov dh, &#39;a&#39;s:mov es:[160*12+40*2], dhcall delayinc dhcmp dh, &#39;z&#39;jna s ; 依次打印a~zmov ax, 0 mov es, axclipush ds:[0]pop es:[9*4]push ds:[2]pop es:[9*4+2] ;恢复原int 9中断例程的入口地址stimov ax, 4C00hint 21Hdelay:push axpush dxmov ax, 0mov dx, 10Hse:sub ax, 1 ; 不能用decsbb dx, 0cmp ax, 0jne secmp dx, 0jne sepop dxpop axret ; 延时int9:push axpush esin al, 60Hpushfcall dword ptr ds:[0]cmp al, 01Hjne int9retmov ax, 0B800Hmov es, axinc byte ptr es:[160*12+40*2+1] ; 修改字符属性int9ret:pop espop axiretcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/cc6fd8aa713248d3063b863655b4b1eb.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/175b1d630705c9664b4ee1403d07af35.png" class=""><h2 id="前置练习2"><a class="markdownIt-Anchor" href="#前置练习2"></a> 前置练习2</h2><p>在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理</p><ol><li>编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>:</mo><mn>0200</mn><mo>→</mo><mn>0</mn><mo>:</mo><mn>0203</mn></mrow><annotation encoding="application/x-tex">0:0200 \to 0:0203</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">3</span></span></span></span>,可在新int 9中断例程中通过<code>cs:[200H]</code>访问</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ss:stackstack segmentdb 32 dup(0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 0mov es, axmov di, 0204Hmov ax, csmov ds, axmov si, offset int9mov cx, offset int9ed - offset int9cldrep movsb; 安装push es:[9*4]pop es:[200H]push es:[9*4+2]pop es:[202H] ; 保存原int 9入口地址climov word ptr es:[9*4], 204Hmov word ptr es:[9*4+2], 0 ; 修改中断向量表stimov ax, 4C00Hint 21Hint9:push axpush cxpush espush diin al, 60Hpushfcall dword ptr cs:[200H] ; 调用原int 9cmp al, 3BHjne int9retmov ax, 0B800Hmov es, axmov di, 1mov cx, 2000s:inc byte ptr es:[di]add di, 2loop sint9ret:pop dipop espop cxpop axiretint9ed:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/877445709c8ed9e5d56a7314e57f8ea3.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/030425252bf3048fb11aa73425e64b26.png" class=""><h2 id="assignment-1-9"><a class="markdownIt-Anchor" href="#assignment-1-9"></a> assignment 1</h2><ol><li>编写源程序</li></ol><p>与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码<code>cmp aL, 1EH+80H</code></p><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ss:stackstack segmentdb 32 dup(0)stack endscode segmentstart:mov ax, stackmov ss, axmov sp, 20Hmov ax, 0mov es, axmov di, 0204Hmov ax, csmov ds, axmov si, offset int9mov cx, offset int9ed - offset int9cldrep movsb; 安装push es:[9*4]pop es:[200H]push es:[9*4+2]pop es:[202H] ; 保存原int 9入口地址climov word ptr es:[9*4], 204Hmov word ptr es:[9*4+2], 0 ; 修改中断向量表stimov ax, 4C00Hint 21Hint9:push axpush cxpush espush diin aL,60hpushfcall dword ptr cs:[200H]cmp aL, 1EH+80Hjne int9retmov cx, 2000mov ax, 0B800Hmov es, axmov di, 0s:mov byte ptr es:[di], &#39;A&#39;mov byte ptr es:[di+1], 02Hadd di, 2loop sint9ret:pop dipop espop cxpop axiretint9ed:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/ef86dd4e7df68488abe8bf379be285f3.png" class=""><h1 id="实验16-编写包含多个功能子程序的中断例程"><a class="markdownIt-Anchor" href="#实验16-编写包含多个功能子程序的中断例程"></a> 实验16 编写包含多个功能子程序的中断例程</h1><ol><li>编写源程序</li></ol><p>注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ax, csmov ds, axmov si, offset int7chmov ax, 0mov es, axmov di, 0200Hmov cx, offset int7ched - offset int7chcldrep  movsbmov word ptr es:[7cH*4], 0200Hmov word ptr es:[7cH*4+2], 0 mov ax, 4C00Hint 21Hint7ch:jmp short int7chStarttable dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200Hint7chStart:push axpush bxcmp ah, 3ja int7chRetmov bl, ahmov bh, 0add bx, bxcall word ptr cs:(table-int7ch+200H)[bx]int7chRet:pop bxpop axiretSub1:push axpush bxpush cxpush dsmov ax, 0B800Hmov ds, axmov cx, 2000mov bx, 0s1:mov byte ptr [bx], &#39; &#39;add bx, 2loop s1pop dspop cxpop bxpop axretSub2:push axpush bxpush cxpush dsmov bx, 0B800Hmov ds, bxmov cx, 2000mov bx, 1s2:and byte ptr [bx], 11111000B ; 只设置最后3位or byte ptr [bx], aladd bx, 2loop s2pop dspop cxpop bxpop axretSub3:push axpush bxpush cxpush dsmov bx, 0B800Hmov ds, bxmov cl, 4shl al, clmov cx, 2000mov bx, 1s3:and byte ptr [bx], 10001111Bor [bx], aladd bx, 2loop s3pop dspop cxpop bxpop axretSub4:push axpush bxpush cxpush dspush espush sipush dimov bx, 08B00Hmov es, bxmov ds, bxmov si, 160mov di, 0cldmov cx, 24s4:push cxmov cx, 160rep movsbpop cxloop s4mov cx, 80mov si, 0s41:mov byte ptr [160*24+si], &#39; &#39;add si ,2loop s41pop dipop sipop espop dspop cxpop bxpop axretint7ched:nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:mov ah,1 ; 0 2 3mov al,2int 7CHmov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/4c1ca28437ff3c577a43f65b910fda7a.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/e142cd676fd54b10899408183ed6cb5a.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/11cdf681ec8c986a3cde650b18515366.png" class=""><h1 id="实验17-编写包含多个功能子程序的中断例程"><a class="markdownIt-Anchor" href="#实验17-编写包含多个功能子程序的中断例程"></a> 实验17 编写包含多个功能子程序的中断例程</h1><p>第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了</p><h2 id="练习17-1"><a class="markdownIt-Anchor" href="#练习17-1"></a> 练习17-1</h2><p>接受用户的键盘输入，输入&quot;r&quot;，“g”,“b”分别将屏幕上的字符设置为红色，绿色，蓝色</p><ol><li>编写源程序</li></ol><p>用功能号为0的int 16H中断例程读取键盘输入即可</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart:show:push axpush espush dimov ah, 0int 16Hmov bl, 1cmp al,&#39;b&#39;je showstshl bl, 1cmp al, &#39;g&#39;je showstshl bl, 1cmp al, &#39;r&#39;je showstjmp short FRetshowst:mov ax, 0B800Hmov es, axmov di, 1mov cx, 2000s:and byte ptr es:[di], 11111000Bor es:[di], bladd di, 2loop sFRet:mov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>运行结果</li></ol><img src="/2023/02/04/CSAPP_lab/assembly/3ac9ffcac28dbfa0df02e9ddeb39586e.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/d94e14d3995f026c2ff6eae5847929ca.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/1902559d0ee1576594f6400ef5ea21dc.png" class=""><h1 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h1><h2 id="1-理解assume伪指令的作用"><a class="markdownIt-Anchor" href="#1-理解assume伪指令的作用"></a> 1. 理解assume伪指令的作用</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datadata segmenta db 1,2,3,4,5,6,7,8b dw 0data endscode segmentstart:mov ax, datamov ds, axmov si, 0mov cx, 8s:mov ah, 0mov al, a[si]add b, axinc siloop smov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>assume ds:data ss:stack</code></li></ol><ul><li>assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mtext>、</mtext><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS、SS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:<code>mov ax, data ``mov ds, ax</code></li><li>assume是伪指令，用于指示编译器将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mtext>、</mtext><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS、SS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>分别与data段和stack段关联。①关联是什么意思呢？就是<strong>在编译时默认data段中的数据标号a、b的段地址在</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><strong>中</strong>，因此如果要正确访问到a、b的内容，必须用指令将data填入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此<code>mov ax, data</code>在编译器看来是<code>mov ax, data段段地址</code>，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax</li></ul><p>如果在程序中省略<code>assume ds:data</code>，则会出现_不能用段寄存器寻址_的错误</p><img src="/2023/02/04/CSAPP_lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><ol start="2"><li><code>assume cs:codesg</code></li></ol><p>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>与代码段关联，在程序加载时将代码段(codesg)的段地址放入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中. 如果去掉该语句，则程序编译不通过，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的值不确定</p><img src="/2023/02/04/CSAPP_lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><h2 id="2-理解数据标号"><a class="markdownIt-Anchor" href="#2-理解数据标号"></a> 2. 理解数据标号</h2><ol><li>数据标号与地址标号的不同</li></ol><p>地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）</p><pre class="line-numbers language-none"><code class="language-none">assume cs:code, es:datadata segmenta db 1,2,3,4,5,6,7,8b dw 0data endscode segmentstart:mov ax, datamov es, axmov si, 0mov cx, 8s:mov ah, 0mov al, a[si]add b, axinc siloop smov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的a和b分别指代了</p><ul><li><strong>地址为</strong><code>**seg data:0**</code><strong>, 长度为byte的字节单元</strong></li><li><strong>地址为</strong><code>**seg data:8**</code><strong>, 长度为word的字单元</strong></li></ul><ol start="2"><li>如何用数据标号以简洁形式访问内存中的数据</li></ol><p>在上一个程序中，我们用<code>mov al, a[si]</code> <code>add b, ax</code>访问了data段的内容，在编译器看来，这两条语句是这样的: <code>mov al, es:0[si]``add es:[8], ax</code></p><img src="/2023/02/04/CSAPP_lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><p>我们现在用更熟悉的<code>mov al, [si+a]</code> <code>add b[0], ax</code>形式，从编译器角度来看，这两种形式没有区别<br />这说明了在指令中<strong>a等价于</strong><code>**byte ptr [0]**</code><strong>，b等价于</strong><code>**word ptr [8]**</code>（仅含偏移地址信息，默认段地址在es中，因为<code>assume es:data</code>）</p><img src="/2023/02/04/CSAPP_lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><ol start="3"><li>将标号当作数据定义</li></ol><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datadata segmenta db 1,2,3,4,5,6,7,8b dw 0c dw a, bdata endscode segmentstart:mov ax, datamov ds, axmov dx, 2mov dx, cmov ax, c[1]mov ax, 4C00Hint 21Hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>c dw a, b</code>将数据标号当作数据定义，c指代地址为<code>seg data:000A</code>的字单元，<strong>该字单元的内容是a的偏移地址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn></mrow><annotation encoding="application/x-tex">0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，下面是验证</p><img src="/2023/02/04/CSAPP_lab/assembly/48b3a4564299e00c537ad89e4a1aa6e0.png" class=""><img src="/2023/02/04/CSAPP_lab/assembly/00b606854598c5ba4b5d5647c190adcf.png" class="">]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> assembly language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
