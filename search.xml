<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[HIT-OS]哈工大操作系统实验lab1~8</title>
      <link href="/2023/05/06/Learning-OS/HIT-Labs/"/>
      <url>/2023/05/06/Learning-OS/HIT-Labs/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><a name="Sy3c5"></a><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><em>Learning operating system by coding it！</em></p><p><a name="LIwaN"></a></p><h1 id="实验0-实验环境搭建"><a class="markdownIt-Anchor" href="#实验0-实验环境搭建"></a> 实验0 实验环境搭建</h1><hr /><p><a href="https://hoverwinter.gitbooks.io/hit-oslab-manual/content/environment.html">reference1</a><br /><a href="https://blog.csdn.net/zy010101/article/details/108085192">reference2</a><br />遇到的问题：在编译linux0.11时，出现<code>fatal error：asm/ioctl.h: No such file or directory</code>，<code>loctl.h</code>这个文件是在库<code>linux-lib-dev</code>中的，而且我已经安装了这个库，但还是有这个错误<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679055607952-a7d970dc-d0af-4bf9-8a10-389fbf39cd71.png#averageHue=%23323130&amp;clientId=u3a7860c6-b5b9-4&amp;from=paste&amp;height=253&amp;id=ua58a300b&amp;originHeight=380&amp;originWidth=1554&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=169952&amp;status=done&amp;style=none&amp;taskId=u654359bb-fcf7-4d06-85f5-9faa172d7aa&amp;title=&amp;width=1036" alt="image.png" /><br /> 解决方法：使用i386版本的linux-libc-dev</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-libc-dev:i386</span><br></pre></td></tr></table></figure><p><a name="CgYpM"></a></p><h1 id="实验1-操作系统的引导"><a class="markdownIt-Anchor" href="#实验1-操作系统的引导"></a> 实验1 操作系统的引导</h1><hr /><p><a name="rsI0N"></a></p><h2 id="1-改写bootsects"><a class="markdownIt-Anchor" href="#1-改写bootsects"></a> 1. 改写bootsect.s</h2><ol><li>我们只需要<code>bootsect.s</code>源码中打印字符串的部分，因为不涉及迁移<code>bootsect</code>从<code>0x07c00</code>到<code>0x90000</code>的操作，所以<code>bootsect.s</code>读入内存后还是在<code>0x07c00</code>的位置，因此要添加<code>mov es, #07c0</code>才能使<code>es:bp</code>指向正确的字符串起始位置。此外，<code>cx</code>参数的大小为字符串大小+6，这里的6是3个CR/LF (carriage return/line feed: 13 10)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679306853262-7e6f4ca7-68d6-4641-83f8-e0edbf6e9a65.png#averageHue=%23f0f0f0&amp;clientId=ub2e2e66c-6eae-4&amp;from=paste&amp;height=293&amp;id=u332a1dd5&amp;originHeight=293&amp;originWidth=1264&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104104&amp;status=done&amp;style=none&amp;taskId=u27f27fa8-2816-477c-8a4b-416f08ee4ee&amp;title=&amp;width=1264" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679120889905-e4fdb498-a155-4fbc-9485-851c42da41cc.png#averageHue=%23292928&amp;clientId=u2a122f00-1508-4&amp;from=paste&amp;height=164&amp;id=hO11h&amp;originHeight=246&amp;originWidth=994&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=69573&amp;status=done&amp;style=none&amp;taskId=u0269a0c9-fa2b-422e-b66d-5402077e146&amp;title=&amp;width=662.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679121050256-f419626e-7a21-4ac1-83f9-1b95d1360eb3.png#averageHue=%23292929&amp;clientId=u2a122f00-1508-4&amp;from=paste&amp;height=163&amp;id=TTKfL&amp;originHeight=245&amp;originWidth=1350&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=104566&amp;status=done&amp;style=none&amp;taskId=u6208cb08-47ef-43f9-90cb-c0dd2f14ca8&amp;title=&amp;width=900" alt="image.png" /></p><ol start="2"><li>改写<code>bootsect.s</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">movah,#0x03! read cursor pos</span><br><span class="line">xorbh,bh</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">movcx,#34</span><br><span class="line">movbx,#0x0007! page 0, attribute 7 (normal)</span><br><span class="line">movbp,#msg1</span><br><span class="line">movax,#0x07c0</span><br><span class="line">moves,ax         ! set correct segment address</span><br><span class="line">movax,#0x1301! write string, move cursor</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">        jmp inf_loop     ! keep not exit</span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">.byte 13,10</span><br><span class="line">.ascii &quot;EliteX system is Loading ...&quot;</span><br><span class="line">.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510   ! jump over root_dev</span><br><span class="line">boot_flag:</span><br><span class="line">.word 0xAA55         ! effective sign</span><br></pre></td></tr></table></figure><ol start="3"><li>要仅汇编<code>bootsect.s</code>得到<code>Image</code>，运行以下命令（在实模式下，as86工具用于汇编产生目标代码，ld86工具用于连接产生可执行文件）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as86 -0 -a -o bootsect.o bootsect.s</span><br><span class="line">ld86 -0 -s -o bootsect bootsect.o</span><br><span class="line"><span class="built_in">dd</span> bs=1 <span class="keyword">if</span>=bootsect of=Image skip=32</span><br></pre></td></tr></table></figure><ol start="4"><li>结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679291194417-3bded04a-f0fa-42d5-881a-969e7b59420d.png#averageHue=%23171716&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=411&amp;id=u13c84d5d&amp;originHeight=552&amp;originWidth=946&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=45537&amp;status=done&amp;style=none&amp;taskId=uaf3fd5c0-d375-488d-a6e2-9636e569b0e&amp;title=&amp;width=704.65625" alt="image.png" /><br /><a name="VRykQ"></a></p><h2 id="2-改写setups"><a class="markdownIt-Anchor" href="#2-改写setups"></a> 2. 改写setup.s</h2><p><a name="JS2dj"></a></p><h3 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> task1</h3><ol><li>在<code>setup.s</code>中写入<code>bootsect.s</code>的内容，对字符串信息作修改，修改<code>es</code>为<code>0x07e0</code>，因为<code>setup</code>在内存紧跟<code>bootsect</code>(0x07c00 + 0x200)之后 (这里将<code>cs</code>的值通过<code>ax</code>赋给<code>es</code>，因为此时<code>cs</code>的值就是<code>0x07e0</code>）)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">movah,#0x03! read cursor pos</span><br><span class="line">xorbh,bh</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">movcx,#25</span><br><span class="line">movbx,#0x0007! page 0, attribute 7 (normal)</span><br><span class="line">movbp,#msg1</span><br><span class="line">movax,cs</span><br><span class="line">moves,ax</span><br><span class="line">movax,#0x1301! write string, move cursor</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">jmp inf_loop </span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">.byte 13,10</span><br><span class="line">.ascii &quot;Now we are in SETUP&quot;</span><br><span class="line">.byte 13,10,13,10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679295121521-d9f5ba9a-a2f3-406c-95b2-c032f4093a17.png#averageHue=%23f8f6f3&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=156&amp;id=u53cd6060&amp;originHeight=234&amp;originWidth=1106&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=121487&amp;status=done&amp;style=none&amp;taskId=ueb27f2e8-c7ae-4f15-9709-13b57b4a98b&amp;title=int%200x13&amp;width=737.3333333333334" alt="int 0x13" title="int 0x13" /></p><ol start="2"><li>在<code>**bootsect.s**</code>中添加源码中载入<code>setup</code>的部分，并修改<code>SETUPSEG</code>为<code>0x07e0</code>，原因还是在于我们没有移动<code>**bootsect**</code>**，**去掉循环并修改<code>SETUPLEN</code>为<code>2</code>，因为对我们的改写后的<code>setup</code>，仅需读入两个扇区就够了（其实一个扇区的大小也够了）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN = 1</span><br><span class="line">SETUPSEG = 0x07e0</span><br><span class="line"></span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">movah,#0x03! read cursor pos</span><br><span class="line">xorbh,bh</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">movcx,#34</span><br><span class="line">movbx,#0x0007! page 0, attribute 7 (normal)</span><br><span class="line">movbp,#msg1</span><br><span class="line">movax,#0x07c0</span><br><span class="line">moves,ax</span><br><span class="line">movax,#0x1301! write string, move cursor</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">load_setup:</span><br><span class="line">movdx,#0x0000! drive 0, head 0</span><br><span class="line">movcx,#0x0002! sector 2, track 0</span><br><span class="line">movbx,#0x0200! address = 512, in INITSEG</span><br><span class="line">movax,#0x0200+SETUPLEN! service 2, nr of sectors</span><br><span class="line">int0x13! read it</span><br><span class="line">jncok_load_setup! ok - continue</span><br><span class="line">movdx,#0x0000</span><br><span class="line">movax,#0x0000! reset the diskette</span><br><span class="line">int0x13</span><br><span class="line">jload_setup</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">jmpi0,SETUPSEG </span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">.byte 13,10</span><br><span class="line">.ascii &quot;EliteX system is Loading ...&quot;</span><br><span class="line">.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.org 510   ! jump over root_dev</span><br><span class="line">boot_flag:</span><br><span class="line">.word 0xAA55         ! effective sign</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>linux-0.11/tool/build.c</code>注释掉最后部分，以便我们借助MakeFile编译<code>bootsect.s</code>与<code>setup.s</code>，而不用两个分别手动编译</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679294169436-70675d89-6d65-4daf-8497-da686fe3a38b.png#averageHue=%230b0b0b&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=339&amp;id=u8afde1bf&amp;originHeight=564&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=160589&amp;status=done&amp;style=none&amp;taskId=u11ec5c70-12de-4770-8679-70f759df314&amp;title=&amp;width=619" alt="image.png" /></p><ol start="4"><li>结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679294501705-49ff1622-5adc-437a-8cff-1be4d2841e43.png#averageHue=%23191919&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=490&amp;id=ub64002a5&amp;originHeight=536&amp;originWidth=826&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38308&amp;status=done&amp;style=none&amp;taskId=ue6cf2b2d-8218-4f57-977c-2368cbcf023&amp;title=&amp;width=754.65625" alt="image.png" /><br /><a name="pW014"></a></p><h3 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> task2</h3><ol><li>我们需要<code>setup.s</code>源码中获取硬件信息的部分，需要解决的问题是将这些数据打印在屏幕上，利用了功能号为<code>0x0E</code>的<code>0x10</code>号中断，指导书写了一个<code>print_nl</code>来打印回车换行符，而我直接在打印的字符串中加入<code>13 10</code>实现回车换行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">INITSEG  = 0x9000</span><br><span class="line"></span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">    mov ah,#0x03     ; read cursor pos</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#25       ; Print &quot;NOW we are in SETUP&quot;</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg2 </span><br><span class="line">    mov ax,cs        ; cs: 0x07e0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">; Get Cursor Pos</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [0],dx  ; store in 9000:0</span><br><span class="line"></span><br><span class="line">; Get Memory Size</span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax      ; store in 9000:2</span><br><span class="line"></span><br><span class="line">; Get hd0 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax       ; modify ds</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax       </span><br><span class="line">    mov di,#0x0004  ; store in 9000:4</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line"></span><br><span class="line">! Be Ready to Print</span><br><span class="line">    mov ax,cs       ; 0x07e0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#INITSEG ; 9000</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">; print Cursor Position</span><br><span class="line">    mov cx,#18</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cursor</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov dx,[0]  ; pass hex number through register dx to function print_hex</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print Memory Size</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#14</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_memory</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov dx,[2]  </span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print KB</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#2</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_kb</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">; print Cyles</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#7</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cyles</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[4]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print Heads</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#8</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_heads</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[6]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print Secotrs</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#10</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_sectors</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[12]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line"></span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4   ; rotate left</span><br><span class="line">    mov    ax,#0xe0f </span><br><span class="line">    and    al,dl   ; fetch low 4 bits</span><br><span class="line">    add    al,#0x30    ; 0~9</span><br><span class="line">    cmp    al,#0x3a    </span><br><span class="line">    jl     outp</span><br><span class="line">    add    al,#0x07    ; a~f , add more 0x07</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop   print_digit</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;NOW we are in SETUP&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line">msg_cursor:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cursor position:&quot;</span><br><span class="line">msg_memory:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Memory Size:&quot;</span><br><span class="line">msg_cyles:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line">msg_heads:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line">msg_sectors:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line">msg_kb:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679390498885-fa17ae6d-b23d-42a3-b330-8ebfc78ec9e1.png#averageHue=%231d1d1c&amp;clientId=u65b4c6eb-4a7f-4&amp;from=paste&amp;height=453&amp;id=uded74e2b&amp;originHeight=559&amp;originWidth=896&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=43381&amp;status=done&amp;style=none&amp;taskId=uf6a85f2d-73a3-4faa-9cc6-46206197425&amp;title=&amp;width=725.328125" alt="image.png" /><br /><a name="zTa0D"></a></p><h1 id="实验2-系统调用"><a class="markdownIt-Anchor" href="#实验2-系统调用"></a> 实验2 系统调用</h1><hr /><p><a name="JOp3O"></a></p><h2 id="1-编写接口函数iam-whoami"><a class="markdownIt-Anchor" href="#1-编写接口函数iam-whoami"></a> 1. 编写接口函数iam, whoami</h2><p>跟<code>write</code>一样，在接口函数文件内调用宏函数<code>_syscall1</code>或<code>_syscall2</code>（依参数个数而定），程序内包括后续用于测试系统调用的<code>main</code>函数。<br />iam.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__   <span class="comment">// 定义了这个宏，unistd.h中的一个条件编译块才会编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">_syscall1(<span class="type">int</span>, iam, <span class="type">const</span> <span class="type">char</span>*, name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">iam</span>(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>whoami.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">int</span>, whoami, <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> username[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">whoami</span>(username, <span class="number">23</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;username: %s\n&quot;</span>, username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="W3D3k"></a></p><h2 id="2-修改unistdh"><a class="markdownIt-Anchor" href="#2-修改unistdh"></a> 2. 修改unistd.h</h2><p>可以跳过这步，因为之后的编译过程所用到的<code>unistd.h</code>头文件并不在这个源码树下，而是在标准头文件<code>/usr/include</code>下。<br />在<code>linux-0.11/include/unistd.h</code>添加宏<code>_NR_whoami</code>、<code>_NR_iam</code>以在<code>_syscall*</code>函数中传递正确的参数给<code>0x80</code>号中断处理程序<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679572755150-a56cb4f4-d15c-4ae1-9805-281eeb789ef7.png#averageHue=%23292929&amp;clientId=uf07d0e56-512f-4&amp;from=paste&amp;height=413&amp;id=ufd549e7e&amp;originHeight=558&amp;originWidth=1370&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=241240&amp;status=done&amp;style=none&amp;taskId=u866e49d8-c96e-4501-a177-307f9157abc&amp;title=&amp;width=1014.814886503918" alt="image.png" /><br /><a name="u7wVb"></a></p><h2 id="3-修改_sys_call_table函数表"><a class="markdownIt-Anchor" href="#3-修改_sys_call_table函数表"></a> 3. 修改_sys_call_table函数表</h2><p>在<code>linux-0.11/include/linux/sys.h</code>添加函数指针<code>sys_whoami</code>、<code>sys_iam</code>，函数在<code>sys_call_table</code>数组中的位置必须和在<code>&lt;unistd.h&gt;</code>文件中的<code>__NR_xxxxxx</code>的值对应上。在文件开头加上<code>extern</code>是让编译器在其它文件寻找这两个函数<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679573228960-b5285a35-85b6-4209-8ae9-b138c0d50cb6.png#averageHue=%232a2a2a&amp;clientId=u33e52eb9-8f95-4&amp;from=paste&amp;height=514&amp;id=ud13dda37&amp;originHeight=694&amp;originWidth=1410&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=416921&amp;status=done&amp;style=none&amp;taskId=u00862be4-becc-4d75-a056-a82d7ed996f&amp;title=&amp;width=1044.4445182266602" alt="image.png" /><br /><a name="dhvNt"></a></p><h2 id="4-实现函数sys_whoami-sys_iam"><a class="markdownIt-Anchor" href="#4-实现函数sys_whoami-sys_iam"></a> 4. 实现函数sys_whoami, sys_iam</h2><p>在<code>linux-0.11/kernel/iamwho.c</code>中编写最终的执行函数，执行这两个函数是系统调用的最后一步<br />在 Linux-0.11 内核中，<code>get_fs_byte</code> 和 <code>put_fs_byte</code> 函数用于在用户空间和内核空间之间传输数据。<br /><code>get_fs_byte</code> 函数从用户空间读取一个字节到内核空间。它接受一个指向用户空间内存地址的指针，并返回从该地址读取的字节。<br /><code>put_fs_byte</code> 函数则将一个字节从内核空间写入用户空间。它接受一个字节值和一个指向用户空间内存地址的指针。它将字节值写入指定的用户空间地址。<br />这两个函数在数据传输过程中起到了关键作用，使得内核可以与用户空间的应用程序进行安全地数据交换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/segment.h&gt;</span>  <span class="comment">// get_fs_byte, put_fs_byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str_pos[<span class="number">24</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_iam</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = get_fs_byte(name+i)) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_pos[i] = c;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">23</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;elitezx lab2 string:  %s\n&quot;</span>,str_pos );</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_whoami</span><span class="params">(<span class="type">char</span>* name, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;<span class="built_in">strlen</span>(str_pos))</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = str_pos[ans] )!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        put_fs_byte(c,name++);</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="aSQwE"></a></p><h2 id="5-执行"><a class="markdownIt-Anchor" href="#5-执行"></a> 5. 执行</h2><p>关于这部分，指导书说的比较详细了，我这里再补充一些：挂载hdc目录到虚拟机操作系统上，实现hdc目录在linux-0.11与ubuntu22.04之间的文件共享，我们把用于系统调用的测试程序<code>iam.c</code>，<code>whoami.c</code>复制到hdc目录就可以在Bochs模拟器下的linux-0.11环境中编译执行这两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mount-hdc </span><br><span class="line"><span class="built_in">cp</span> iam.c whoami.c hdc/usr/root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679722650168-38ca1876-eae9-4f73-bcd7-9049e23c5f19.png#averageHue=%231d1d1d&amp;clientId=uece2d1bc-2718-4&amp;from=paste&amp;height=376&amp;id=u8f16972f&amp;originHeight=507&amp;originWidth=777&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=32649&amp;status=done&amp;style=none&amp;taskId=u93898fba-d497-4c31-b847-ed2fc5b1fcd&amp;title=&amp;width=575.555596214266" alt="image.png" /><br />注意在<code>iam.c</code>,<code>whoami.c</code>程序内的头文件<code>&lt;unistd.h&gt;</code>是标准头文件，是由GCC编译器一同安装的，它们通常随着GCC一起打包并分发，通常位于<code>/usr/include</code>目录下，而不是在之前修过的源码树下的<code>include/unistd.h</code>, 因此我们要转入<code>hdc/usr/include</code>下修改<code>&lt;unistd.h&gt;</code>，加入两个宏<code>__NR_iam</code>,<code>__NR_whoami</code><br />编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o iam iam.c</span><br><span class="line">gcc -o <span class="built_in">whoami</span> whoami.c</span><br></pre></td></tr></table></figure><p><a name="GQLfS"></a></p><h2 id="6-验证结果"><a class="markdownIt-Anchor" href="#6-验证结果"></a> 6. 验证结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679724796210-81f3aae1-2a44-4b80-aae6-3028a859b73f.png#averageHue=%23ab9f84&amp;clientId=uece2d1bc-2718-4&amp;from=paste&amp;height=430&amp;id=u8fb9b579&amp;originHeight=580&amp;originWidth=983&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=66303&amp;status=done&amp;style=none&amp;taskId=u266c3a1b-1d68-4099-b48b-b886c550c27&amp;title=&amp;width=728.1481995863879" alt="image.png" /><br /><a name="ALw3l"></a></p><h1 id="实验3-进程运行轨迹的跟踪与统计"><a class="markdownIt-Anchor" href="#实验3-进程运行轨迹的跟踪与统计"></a> 实验3 进程运行轨迹的跟踪与统计</h1><hr /><p><a name="Vy8dW"></a></p><h2 id="1-前提"><a class="markdownIt-Anchor" href="#1-前提"></a> 1. 前提</h2><p><a name="zXQo0"></a></p><h3 id="11-系统调用times"><a class="markdownIt-Anchor" href="#11-系统调用times"></a> 1.1. 系统调用times</h3><p><code>times</code>系统调用接受一个<code>struct tms*</code>类型的参数，该结构体用于保存进程和其子进程的 CPU 时间信息，同时 times 系统调用会返回一个滴答数，即时钟周期数，该滴答数表示自OS启动以来经过的时钟周期数。<br /><code>struct tms</code>类型在<code>include/sys/times.h</code>中定义如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680080228119-8e4f099c-80bb-400b-a9c4-1707bb900cb4.png#averageHue=%23fcfbfa&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=294&amp;id=u5c5af96f&amp;originHeight=463&amp;originWidth=915&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=86220&amp;status=done&amp;style=none&amp;taskId=u227088fb-be53-4659-8beb-57d4b3ebbc7&amp;title=&amp;width=581.77783203125" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680081641847-9ce0ae8e-ea7d-426d-982a-c4ab275e0050.png#averageHue=%23fdfcfc&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=81&amp;id=u1e48b640&amp;originHeight=109&amp;originWidth=1188&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=24401&amp;status=done&amp;style=none&amp;taskId=u110b85ba-8c80-4079-ae38-3ccfc24a576&amp;title=&amp;width=880.0000621654414" alt="image.png" /><br /><code>tms_stime</code>和<code>tms_utime</code>分别记录了进程在内核态和用户态下消耗的CPU时间总和，它们的和就是进程从开始执行到调用times系统调用所经过的时间。<code>tms_stime</code>和<code>tms_utime</code>并不包括进程在睡眠状态或等待I/O操作中所消耗的时间，因此它们的和也不等于进程的实际运行时间。<br />注意这里时间的单位是CPU的滴答时间（tick），一个滴答数表示两个时钟中断的间隔。在Linux系统中，时钟中断通常由硬件定时器产生，定时器会以固定的频率向CPU发送中断信号。**每当时钟中断发生时，内核会将当前进程的时间片计数器减 1，内核会检查当前进程的时间片（counter）是否已经用完，如果用完了，就将当前进程放到就绪队列中，然后调用调度函数 schedule 选择一个新的进程运行。**这个频率通常是100Hz，即一秒发生100次，也就是说时间中断的间隔为10ms（1/100s），每隔10ms就发生一次时钟中断，linux内核中的<code>jiffies</code>变量就记录了时间中断的个数，即滴答数。那么可以看出这里的时间单位既然是滴答数，而滴答数10ms产生一个，那么实际时间应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">ticks/100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> (秒)，100是常量<code>HZ</code>的值<br />由此，如果想获取一个进程从开始到结束的CPU使用时间，即用户态下CPU时间和内核态下CPU时间之和，可用如下函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tms</span> t;</span><br><span class="line">    <span class="type">clock_t</span> clock_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程的CPU时间统计信息</span></span><br><span class="line">    clock_time = <span class="built_in">times</span>(&amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算进程的总的CPU时间</span></span><br><span class="line">    <span class="type">double</span> cpu_time = (<span class="type">double</span>)(t.tms_utime + t.tms_stime) / HZ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total CPU time: %.2f seconds\n&quot;</span>, cpu_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用到的<code>clock_t</code>在<code>include/time.h</code>中定义如下<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680082042776-a6814d15-253d-43cb-be0a-4d3e2fa9819e.png#averageHue=%23fdfcfb&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=67&amp;id=uf3bbfd6f&amp;originHeight=91&amp;originWidth=1143&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=24657&amp;status=done&amp;style=none&amp;taskId=ub62b64bd-cb85-441a-bfbf-5d591e528b7&amp;title=&amp;width=846.6667264773564" alt="image.png" /><br /><a name="eLIVz"></a></p><h3 id="12-系统调用wait"><a class="markdownIt-Anchor" href="#12-系统调用wait"></a> 1.2. 系统调用wait</h3><p><code>wait</code> 函数是一个系统调用（位于<code>include/sys/wait.h</code>）。在Unix/Linux操作系统中，<code>wait</code>函数可以等待子进程结束，并获取子进程的退出状态。在使用<code>wait</code>函数时，如果子进程已经结束，<code>wait</code>函数会立即返回并返回子进程的退出状态；如果子进程还没有结束，<code>wait</code>函数会阻塞父进程，直到子进程结束并返回其退出状态。具体来说，<code>wait</code> 函数的作用如下：<br />1 如果当前进程没有子进程，<code>wait</code> 函数会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>ECHILD</code>，表示当前进程没有子进程需要等待。<br />2 如果当前进程有一个或多个子进程正在运行，调用 <code>wait</code> 函数会阻塞当前进程，直到其中一个子进程结束。当子进程结束时，<code>wait </code>函数会返回该子进程的进程 ID，并将该子进程的退出状态保存到一个整型变量<code>status</code>中。<br />3 如果当前进程有多个子进程正在运行，调用<code>wait</code>函数会等待其中任意一个子进程结束，并且无法指定要等待哪个子进程。如果需要等待特定的子进程，可以使用 <code>waitpid</code>函数代替<code>wait</code>函数。<br />需要注意的是，如果当前进程没有调用wait函数等待其子进程结束，那么当子进程结束时，其退出状态可能会一直保存在内核中，直到当前进程调用<code>wait</code>或<code>waitpid</code>函数获取该状态。如果当前进程没有获取子进程的退出状态，那么该子进程就会成为僵尸进程（Zombie Process），占用系统资源并且无法被正常清理。<br />因此，在编写多进程程序时，通常需要在父进程中调用<code>wait</code>或<code>waitpid</code>函数等待子进程结束，并获取其退出状态，以避免产生僵尸进程。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680090411853-3ca6d5fc-a85f-4018-b853-38d6b5eab55c.png#averageHue=%23f0f0f0&amp;clientId=ud7b45409-87b8-4&amp;from=paste&amp;height=245&amp;id=uc11188b1&amp;originHeight=383&amp;originWidth=1132&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=153979&amp;status=done&amp;style=none&amp;taskId=ue946029c-b4a7-4c74-903e-d7348704955&amp;title=&amp;width=724.48" alt="image.png" /><br />对linux0.11 wait函数必须接受一个<code>int</code>参数以保存子进程退出状态，如果你不想保存该信息，可传递<code>NULL</code>。而在现代linux中，该参数为可选参数。<br /><a name="qPe7c"></a></p><h3 id="13-linux011中进程的state值"><a class="markdownIt-Anchor" href="#13-linux011中进程的state值"></a> 1.3. linux0.11中进程的state值</h3><p>在Linux 0.11中，进程状态可以被表示为以下几个值：</p><ol><li><code>TASK_RUNNING</code>：进程正在执行，也就是说CPU正在执行它的指令。但是，如果一个进程的状态为<code>TASK_RUNNING</code>，而它又没有占用CPU时间片运行，那么它就是处于就绪态。</li><li><code>TASK_INTERRUPTIBLE</code>：进程正在等待某个事件的发生（例如，等待用户输入、等待网络数据等），它已经睡眠，并且可以响应一个信号以退出等待状态。</li><li><code>TASK_UNINTERRUPTIBLE</code>：和<code>TASK_INTERRUPTIBLE</code>一样，进程也是正在等待某个事件的发生，但是进程在等待期间不会响应信号，直到事件发生后才会退出等待状态，比如I/O操作。</li><li><code>TASK_STOPPED</code>：进程已经被停止，通常是收到了一个SIGSTOP信号。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680423221854-cc012464-a635-471f-8978-9e5a9bca7ae9.png#averageHue=%23fbf9f7&amp;clientId=u36208795-4bd0-4&amp;from=paste&amp;height=151&amp;id=u89a07fa0&amp;originHeight=204&amp;originWidth=1173&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=true&amp;size=108104&amp;status=done&amp;style=none&amp;taskId=u3d9817ff-dff7-4f86-84ad-0f193cbddb3&amp;title=include%2Flinux%2Fsched.h&amp;width=868.888950269413" alt="include/linux/sched.h" title="include/linux/sched.h" /><br /><a name="BqcgZ"></a></p><h2 id="2-processc"><a class="markdownIt-Anchor" href="#2-processc"></a> 2. process.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> son_proc_pid[<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">21</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(! (son_proc_pid[i] = fork()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cpuio_bound</span>(<span class="number">20</span>,i,<span class="number">20</span>-i);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">21</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child_process_pid: %d\n&quot;</span>, son_proc_pid[i]);</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tms</span> start, pre;</span><br><span class="line"><span class="type">clock_t</span> sum_cpu_time = <span class="number">0</span> ;</span><br><span class="line"><span class="type">clock_t</span> accumulate =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">times</span>(&amp;start);</span><br><span class="line"><span class="keyword">while</span>(sum_cpu_time &lt; cpu_time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">times</span>(&amp;pre);</span><br><span class="line">sum_cpu_time = (pre.tms_utime - start.tms_utime + pre.tms_stime - pre.tms_stime)/<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sum_cpu_time&gt;=last) <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(io_time);   </span><br><span class="line"><span class="keyword">if</span>((accumulate+= io_time + cpu_time)&gt;=last)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680091964283-677f3934-2877-4b47-bb90-8de524ca7631.png#averageHue=%23016b01&amp;clientId=ueafc2590-6fa1-4&amp;from=paste&amp;height=560&amp;id=u6a843c73&amp;originHeight=875&amp;originWidth=1271&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=321878&amp;status=done&amp;style=none&amp;taskId=u1fca88b5-6987-447d-a8dc-b9523e8f249&amp;title=&amp;width=813.44" alt="image.png" /><br /><a name="TtxLI"></a></p><h2 id="3-生成log的前置工作"><a class="markdownIt-Anchor" href="#3-生成log的前置工作"></a> 3. 生成log的前置工作</h2><ol><li>修改<code>linux-0.11/init/main.c</code>，将文件描述符<code>3</code>与<code>process.log</code>关联。文件描述符是一个非负整数，它是操作系统内部用来标识一个特定文件的引用。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680092845738-eb1c4f7b-85cd-4bda-8eaf-a3c9f2965bd9.png#averageHue=%23404040&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=356&amp;id=u59def16c&amp;originHeight=480&amp;originWidth=1482&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=257225&amp;status=done&amp;style=none&amp;taskId=u48dfe7b1-b671-4b96-b4c4-ab3217f6fa5&amp;title=&amp;width=1097.777855327596" alt="image.png" /></p><ol start="2"><li>在内核中添加<code>fprintk</code>函数用于在程序中调用以写入log文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> logbuf[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintk</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> * file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">m_inode</span> * inode;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line">    count=<span class="built_in">vsprintf</span>(logbuf, fmt, args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">3</span>)    <span class="comment">/* 如果输出到stdout或stderr，直接调用sys_write即可 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $logbuf\n\t&quot;</span> <span class="comment">/* 注意对于Windows环境来说，是_logbuf,下同 */</span></span><br><span class="line">            <span class="string">&quot;pushl %1\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call sys_write\n\t&quot;</span> <span class="comment">/* 注意对于Windows环境来说，是_sys_write,下同 */</span></span><br><span class="line">            <span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (count),<span class="string">&quot;r&quot;</span> (fd):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* 假定&gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(file=task[<span class="number">0</span>]-&gt;filp[fd]))    <span class="comment">/* 从进程0的文件描述符表中得到文件句柄 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        inode=file-&gt;f_inode;</span><br><span class="line"></span><br><span class="line">        __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $logbuf\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %1\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %2\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call file_write\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl $12,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (count),<span class="string">&quot;r&quot;</span> (file),<span class="string">&quot;r&quot;</span> (inode):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改fork.c</li></ol><p>进程在创建后就立马被设置为就绪态<code>TASK_RUNNING</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680418919364-03d91541-3641-4d47-a424-34ea2bca802d.png#averageHue=%23340a19&amp;clientId=uf67f330f-a4ae-4&amp;from=paste&amp;height=204&amp;id=u37425a43&amp;originHeight=276&amp;originWidth=1287&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=89012&amp;status=done&amp;style=none&amp;taskId=u293f4087-df5d-429c-990e-d462e4a802f&amp;title=&amp;width=953.3334006792281" alt="image.png" /></p><ol start="4"><li>修改sched.c</li></ol><p>在进程的状态切换点打印进程的状态信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  linux/kernel/sched.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (C) 1991  Linus Torvalds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &#x27;sched.c&#x27; is the main kernel file. It contains scheduling primitives</span></span><br><span class="line"><span class="comment"> * (sleep_on, wakeup, schedule etc) as well as a number of simple system</span></span><br><span class="line"><span class="comment"> * call functions (type getpid(), which just extracts a field from</span></span><br><span class="line"><span class="comment"> * current-task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _S(nr) (1&lt;&lt;((nr)-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_task</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">4096</span>-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_struct);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%d: pid=%d, state=%d, &quot;</span>,nr,p-&gt;pid,p-&gt;state);</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j &amp;&amp; !((<span class="type">char</span> *)(p+<span class="number">1</span>))[i])</span><br><span class="line">        i++;</span><br><span class="line">    printk(<span class="string">&quot;%d (of %d) chars free in kernel stack\n\r&quot;</span>,i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_stat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_TASKS;i++)</span><br><span class="line">        <span class="keyword">if</span> (task[i])</span><br><span class="line">            show_task(i,task[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LATCH (1193180/HZ)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">mem_use</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">timer_interrupt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">system_call</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[PAGE_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="keyword">volatile</span> jiffies=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> startup_time=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span> =</span> &amp;(init_task.task);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">last_task_used_math</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] =</span> &#123;&amp;(init_task.task), &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> user_stack [ PAGE_SIZE&gt;&gt;<span class="number">2</span> ] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> * a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">&#125; stack_start = &#123; &amp; user_stack [PAGE_SIZE&gt;&gt;<span class="number">2</span>] , <span class="number">0x10</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;math_state_restore()&#x27; saves the current math information in the</span></span><br><span class="line"><span class="comment"> * old math state array, and gets the new ones from the current task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">math_state_restore</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    __asm__(<span class="string">&quot;fwait&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math) &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (last_task_used_math-&gt;tss.i387));</span><br><span class="line">    &#125;</span><br><span class="line">    last_task_used_math=current;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;used_math) &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;frstor %0&quot;</span>::<span class="string">&quot;m&quot;</span> (current-&gt;tss.i387));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;fninit&quot;</span>::);</span><br><span class="line">        current-&gt;used_math=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;schedule()&#x27; is the scheduler function. This is GOOD CODE! There</span></span><br><span class="line"><span class="comment"> * probably won&#x27;t be any reason to change this, as it should work well</span></span><br><span class="line"><span class="comment"> * in all circumstances (ie gives IO-bound processes good response etc).</span></span><br><span class="line"><span class="comment"> * The one thing you might take a look at is the signal-handler code here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   NOTE!!  Task 0 is the &#x27;idle&#x27; task, which gets called when no other</span></span><br><span class="line"><span class="comment"> * tasks can run. It can not be killed, and it cannot sleep. The &#x27;state&#x27;</span></span><br><span class="line"><span class="comment"> * information in task[0] is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,next,c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">                (*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">                (*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">                (*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">            &#123;</span><br><span class="line">                (*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">                <span class="comment">/*可中断睡眠 =&gt; 就绪*/</span></span><br><span class="line">                fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                (*p)-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*编号为next的进程 运行*/</span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;pid != task[next] -&gt;pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*时间片到时程序 =&gt; 就绪*/</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;state == TASK_RUNNING)</span><br><span class="line">            fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tR\t%d\n&quot;</span>,task[next]-&gt;pid,jiffies);</span><br><span class="line">    &#125;</span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">*当前进程  运行 =&gt; 可中断睡眠</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;pid != <span class="number">0</span>)</span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">        panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    tmp = *p;</span><br><span class="line">    *p = current;</span><br><span class="line">    current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">*当前进程进程 =&gt; 不可中断睡眠</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">*原等待队列 第一个进程 =&gt; 唤醒（就绪）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,tmp-&gt;pid,jiffies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">        panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    tmp=*p;</span><br><span class="line">    *p=current;</span><br><span class="line">    repeat:current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">*这一部分属于 唤醒队列中间进程，通过goto实现唤醒 队列头进程 过程中Wait</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">        (**p).state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">*当前进程进程 =&gt; 可中断睡眠 同上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">*原等待队列 第一个进程 =&gt; 唤醒（就绪）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,tmp-&gt;pid,jiffies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">        (**p).state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">*唤醒 最后进入等待序列的 进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">        *p=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OK, here are some floppy things that shouldn&#x27;t be in the kernel</span></span><br><span class="line"><span class="comment"> * proper. They are here because the floppy needs a timer, and this</span></span><br><span class="line"><span class="comment"> * was the easiest way of doing it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">wait_motor</span>[4] =</span> &#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>  mon_timer[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> moff_timer[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> current_DOR = <span class="number">0x0C</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ticks_to_floppy_on</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> selected;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mask = <span class="number">0x10</span> &lt;&lt; nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nr&gt;<span class="number">3</span>)</span><br><span class="line">        panic(<span class="string">&quot;floppy_on: nr&gt;3&quot;</span>);</span><br><span class="line">    moff_timer[nr]=<span class="number">10000</span>;<span class="comment">/* 100 s = very big :-) */</span></span><br><span class="line">    cli();<span class="comment">/* use floppy_off to turn it off */</span></span><br><span class="line">    mask |= current_DOR;</span><br><span class="line">    <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">        mask &amp;= <span class="number">0xFC</span>;</span><br><span class="line">        mask |= nr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mask != current_DOR) &#123;</span><br><span class="line">        outb(mask,FD_DOR);</span><br><span class="line">        <span class="keyword">if</span> ((mask ^ current_DOR) &amp; <span class="number">0xf0</span>)</span><br><span class="line">            mon_timer[nr] = HZ/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mon_timer[nr] &lt; <span class="number">2</span>)</span><br><span class="line">            mon_timer[nr] = <span class="number">2</span>;</span><br><span class="line">        current_DOR = mask;</span><br><span class="line">    &#125;</span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> mon_timer[nr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floppy_on</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">while</span> (ticks_to_floppy_on(nr))</span><br><span class="line">        sleep_on(nr+wait_motor);</span><br><span class="line">    sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floppy_off</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    moff_timer[nr]=<span class="number">3</span>*HZ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_floppy_timer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mask = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">4</span> ; i++,mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(mask &amp; current_DOR))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (mon_timer[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--mon_timer[i])</span><br><span class="line">                wake_up(i+wait_motor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!moff_timer[i]) &#123;</span><br><span class="line">            current_DOR &amp;= ~mask;</span><br><span class="line">            outb(current_DOR,FD_DOR);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            moff_timer[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_REQUESTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> jiffies;</span><br><span class="line">    <span class="type">void</span> (*fn)();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; timer_list[TIME_REQUESTS], * next_timer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="type">long</span> jiffies, <span class="type">void</span> (*fn)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fn)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span> (jiffies &lt;= <span class="number">0</span>)</span><br><span class="line">        (fn)();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++)</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;fn)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= timer_list + TIME_REQUESTS)</span><br><span class="line">            panic(<span class="string">&quot;No more time requests free&quot;</span>);</span><br><span class="line">        p-&gt;fn = fn;</span><br><span class="line">        p-&gt;jiffies = jiffies;</span><br><span class="line">        p-&gt;next = next_timer;</span><br><span class="line">        next_timer = p;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123;</span><br><span class="line">            p-&gt;jiffies -= p-&gt;next-&gt;jiffies;</span><br><span class="line">            fn = p-&gt;fn;</span><br><span class="line">            p-&gt;fn = p-&gt;next-&gt;fn;</span><br><span class="line">            p-&gt;next-&gt;fn = fn;</span><br><span class="line">            jiffies = p-&gt;jiffies;</span><br><span class="line">            p-&gt;jiffies = p-&gt;next-&gt;jiffies;</span><br><span class="line">            p-&gt;next-&gt;jiffies = jiffies;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">long</span> cpl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> beepcount;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sysbeepstop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beepcount)</span><br><span class="line">        <span class="keyword">if</span> (!--beepcount)</span><br><span class="line">            sysbeepstop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpl)</span><br><span class="line">        current-&gt;utime++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        current-&gt;stime++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_timer) &#123;</span><br><span class="line">        next_timer-&gt;jiffies--;</span><br><span class="line">        <span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">void</span> (*fn)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">            fn = next_timer-&gt;fn;</span><br><span class="line">            next_timer-&gt;fn = <span class="literal">NULL</span>;</span><br><span class="line">            next_timer = next_timer-&gt;next;</span><br><span class="line">            (fn)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>)</span><br><span class="line">        do_floppy_timer();</span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    current-&gt;counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cpl) <span class="keyword">return</span>;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_alarm</span><span class="params">(<span class="type">long</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = current-&gt;alarm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old)</span><br><span class="line">        old = (old - jiffies) / HZ;</span><br><span class="line">    current-&gt;alarm = (seconds&gt;<span class="number">0</span>)?(jiffies+HZ*seconds):<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getppid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_geteuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;euid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getgid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;gid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getegid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;egid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_nice</span><span class="params">(<span class="type">long</span> increment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;priority-increment&gt;<span class="number">0</span>)</span><br><span class="line">        current-&gt;priority -= increment;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction) != <span class="number">16</span>)</span><br><span class="line">        panic(<span class="string">&quot;Struct sigaction MUST be 16 bytes&quot;</span>);</span><br><span class="line">    set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">    set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">    p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">        task[i] = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Clear NT, so that we won&#x27;t have troubles with that later on */</span></span><br><span class="line">    __asm__(<span class="string">&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;</span>);</span><br><span class="line">    ltr(<span class="number">0</span>);</span><br><span class="line">    lldt(<span class="number">0</span>);</span><br><span class="line">    outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">    outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);<span class="comment">/* LSB */</span></span><br><span class="line">    outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);<span class="comment">/* MSB */</span></span><br><span class="line">    set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sys_pause在Linux0.11中，<code>sys_pause()</code>系统调用的主要作用是让进程暂停执行，直到接收到一个信号。当进程调用<code>sys_pause()</code>系统调用时，它会将自己的状态设置为<code>TASK_INTERRUPTIBLE</code>，并且将其添加到等待信号队列中。然后，进程会进入睡眠状态，直到收到一个信号或者被其他进程显式地唤醒。<br />这个系统调用通常用于实现等待信号的操作，比如等待一个定时器信号或者等待一个IO操作完成的信号。在这种情况下，进程可以使用<code>sys_pause()</code>系统调用进入睡眠状态，而不必浪费CPU资源等待信号的到来。当信号到来时，内核会唤醒进程，并且将信号传递给进程的信号处理程序进行处理。<br />需要注意的是，在Linux 2.6以后的版本中，<code>sys_pause()</code>系统调用已经被废弃，被<code>sys_rt_sigsuspend()</code>系统调用所取代。<code>sys_rt_sigsuspend()</code>系统调用可以实现类似的等待信号的操作，并且提供更多的控制选项。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680156794185-dce974ae-e57c-4560-b22c-5f6bf5caee22.png#averageHue=%23fbf8f6&amp;clientId=u11640b7c-d1e3-4&amp;from=paste&amp;height=364&amp;id=u46c71fba&amp;originHeight=491&amp;originWidth=1238&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=243762&amp;status=done&amp;style=none&amp;taskId=u9adb656e-5edb-4706-9773-14fee2abbf6&amp;title=&amp;width=917.037101818869" alt="image.png" /></p><ol start="5"><li>修改exit.c</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));</span><br><span class="line">    free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">        <span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123;</span><br><span class="line">            task[i]-&gt;father = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (task[i]-&gt;state == TASK_ZOMBIE)</span><br><span class="line">                <span class="comment">/* assumption task[1] is always init */</span></span><br><span class="line">                (<span class="type">void</span>) send_sig(SIGCHLD, task[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;filp[i])</span><br><span class="line">            sys_close(i);</span><br><span class="line">    iput(current-&gt;pwd);</span><br><span class="line">    current-&gt;pwd=<span class="literal">NULL</span>;</span><br><span class="line">    iput(current-&gt;root);</span><br><span class="line">    current-&gt;root=<span class="literal">NULL</span>;</span><br><span class="line">    iput(current-&gt;executable);</span><br><span class="line">    current-&gt;executable=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= <span class="number">0</span>)</span><br><span class="line">        tty_table[current-&gt;tty].pgrp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">        last_task_used_math = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;leader)</span><br><span class="line">        kill_session();</span><br><span class="line">    current-&gt;state = TASK_ZOMBIE;</span><br><span class="line">    current-&gt;exit_code = code;</span><br><span class="line">    fprintk(<span class="number">3</span>,<span class="string">&quot;%ld\tE\t%ld\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    tell_father(current-&gt;father);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);<span class="comment">/* just to suppress warnings */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>旁注：do_exit函数与sys_waitpid函数</strong></p><blockquote><p>在 Linux 0.11 中，<code>do_exit()</code> 函数负责终止一个进程。当一个进程调用 <code>do_exit()</code> 时，它会执行多个清理操作，包括释放进程持有的任何资源，如打开的文件和内存，并向父进程通知进程的退出状态。如果进程有任何子进程，则 <code>do_exit()</code> 也通过递归调用 <code>do_exit()</code> 终止它们。<br /><code>sys_waitpid() </code>函数用于等待子进程终止并检索其退出状态。当进程调用 <code>sys_waitpid()</code> 时，它会阻塞，直到其中一个子进程终止。如果子进程已经终止，<code>sys_waitpid() </code>将立即返回该子进程的退出状态。否则，它将继续阻塞，直到子进程终止。<br />除了等待特定的子进程外，<code>sys_waitpid() </code>还可以用于等待任何子进程终止，方法是通过传递<code> -1</code> 的 <code>pid</code> 参数。当一个进程有多个子进程并且想要等待第一个终止时，这很有用。</p></blockquote><p><a name="PLMGK"></a></p><h2 id="4-生成log"><a class="markdownIt-Anchor" href="#4-生成log"></a> 4. 生成log</h2><p>先共享文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mount-hdc</span><br></pre></td></tr></table></figure><p>移动多进程程序<code>process.c</code>到linux-0.11目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> process.c hdc/usr/root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680102556459-4dae45b1-9b54-41b1-ac91-af3f975f8622.png#averageHue=%230cb804&amp;clientId=uc1e146a1-ff2e-4&amp;from=paste&amp;height=202&amp;id=u1b11e17d&amp;originHeight=182&amp;originWidth=801&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18239&amp;status=done&amp;style=none&amp;taskId=u50fc4245-9bac-45f5-96f1-e1e5dd0e51c&amp;title=&amp;width=890.000023576949" alt="image.png" /><br />编译运行, 最后执行一个<code>sync</code>命令，确保将文件系统中的所有缓存数据写入磁盘<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680156855136-d0cd08e2-6520-4ccf-b809-43de45b15990.png#averageHue=%23222121&amp;clientId=u11640b7c-d1e3-4&amp;from=paste&amp;height=376&amp;id=uf77324e2&amp;originHeight=507&amp;originWidth=786&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=29997&amp;status=done&amp;style=none&amp;taskId=u51aea8a4-a9b1-412e-bbf5-7de3992819e&amp;title=&amp;width=582.2222633518829" alt="image.png" /><br /><strong>旁注: sync命令</strong></p><blockquote><p>sync 命令是用于将文件系统中的所有缓存数据写入磁盘的命令。在 Linux 中，当一个进程修改了一个文件时，这个修改不会立即写入磁盘，而是会先被写入内存中的缓存，以提高文件系统的性能。然而，如果系统崩溃或出现其他问题，这些修改可能会丢失。因此，为了保证数据的完整性，我们需要将缓存数据定期地写入磁盘中。<br />sync 命令会将所有的缓存数据写入磁盘中，并将所有被修改的元数据（如 i-node、目录结构等）更新到磁盘中。这样可以保证所有的修改都被写入到磁盘中，从而避免了数据的丢失。通常在关机前执行 sync 命令，以确保所有数据都已被保存到磁盘中。<br />需要注意的是，执行 sync 命令并不能保证磁盘数据的完全一致性。在磁盘数据的写入过程中，如果发生了异常情况，可能会导致数据的损坏或丢失。因此，在执行 sync 命令后，建议再执行一次磁盘检查命令（如 fsck 命令）来确保文件系统的完整性。</p></blockquote><p>将生成的<code>process.log</code>移动到虚拟机下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mount-hdc</span><br><span class="line"><span class="built_in">cp</span> hdc/var/process.log process.log</span><br></pre></td></tr></table></figure><p>查看process.log，进程0在log关联文件描述符之前就已经在运行，因此未出现在log文件中<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680415902178-9c4c2da7-7edb-4723-b55a-e9fe72e794e9.png#averageHue=%232e2d3c&amp;clientId=uf67f330f-a4ae-4&amp;from=paste&amp;height=494&amp;id=u30477769&amp;originHeight=667&amp;originWidth=989&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=72543&amp;status=done&amp;style=none&amp;taskId=u9090ad80-0a07-40ab-b6df-2b16198c3e3&amp;title=&amp;width=732.5926443447992" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680157216292-d2746d2e-ef7a-47b7-ae49-89ac6630d367.png#averageHue=%232e3345&amp;clientId=u11640b7c-d1e3-4&amp;from=paste&amp;height=340&amp;id=u6d455e29&amp;originHeight=459&amp;originWidth=1069&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=121217&amp;status=done&amp;style=none&amp;taskId=u8f7744b6-ff01-47a1-a81c-74e61b5412a&amp;title=&amp;width=791.8519077902835" alt="image.png" /><br /><a name="h8nod"></a></p><h2 id="5-分析log"><a class="markdownIt-Anchor" href="#5-分析log"></a> 5. 分析log</h2><p>用指导书给的py脚本程序<code>stat_log.py</code>分析log文件，在分析之前将py脚本文件的第一行<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2</code>（已安装python2）以适配版本，否则在python3环境下<code>print</code>函数会出错<br />为该脚本文件分配可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x stat_log.py</span><br></pre></td></tr></table></figure><p>执行脚本，分析进程9、10、11、12的运行情况（多个指标：平均周转时间，平均等待时间）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stat_log.py process.log 9 10 11 12 -g | less</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680423652089-e86380f3-f4e9-4d79-ad11-0a1ebc9798ad.png#averageHue=%23231227&amp;clientId=uccfc5aea-4473-4&amp;from=paste&amp;height=474&amp;id=ud8daee23&amp;originHeight=640&amp;originWidth=1147&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=107108&amp;status=done&amp;style=none&amp;taskId=u28cc7fdb-6a4e-4903-b874-35caa352db5&amp;title=&amp;width=849.6296896496307" alt="image.png" /><br /><a name="NJnrE"></a></p><h2 id="6-修改时间片重新分析log"><a class="markdownIt-Anchor" href="#6-修改时间片重新分析log"></a> 6. 修改时间片，重新分析log</h2><p>进程的时间片是进程的<code>counter</code>值，而counter在schedule函数中根据<code>priority</code>动态设置，因此进程的时间片受<code>counter</code>和<code>prioriy</code>两个变量的影响。进程的<code>priority</code>继承自父进程，进而所有进程的<code>priority</code>都来自于进程0 。<br />linux0.11中，<code>priority</code>和<code>counter</code>在<code>include/linux/sched.h</code>中定义<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680424066512-421f988e-49a3-4b66-a9b3-4e984c083da7.png#averageHue=%23f9f8f7&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=179&amp;id=u3cf28712&amp;originHeight=242&amp;originWidth=1399&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=102392&amp;status=done&amp;style=none&amp;taskId=udc7dd1be-caaf-44ac-8d33-1569af77da3&amp;title=&amp;width=1036.2963695029061" alt="image.png" /><br />我们修改这个值，然后重新执行process程序，分析log。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680425118028-6426a982-4e91-4b81-8fc4-7c2f2dcf7319.png#averageHue=%23320a1a&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=204&amp;id=uc99c017b&amp;originHeight=334&amp;originWidth=1215&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=77552&amp;status=done&amp;style=none&amp;taskId=u885ffd8c-f755-4bc9-8037-be7eab07b04&amp;title=&amp;width=742.0000610351562" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680425135373-cbb971da-57f6-43f9-a92b-c665b29e7410.png#averageHue=%23310a1b&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=196&amp;id=u78f7b710&amp;originHeight=287&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=66299&amp;status=done&amp;style=none&amp;taskId=u61617740-70c7-46bb-b3a7-329f0fd3129&amp;title=&amp;width=744.888916015625" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680425366848-3d2e176f-aaed-410d-a132-af6ac4df180c.png#averageHue=%23343e56&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=361&amp;id=ubd18199b&amp;originHeight=487&amp;originWidth=1101&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=83283&amp;status=done&amp;style=none&amp;taskId=u1a1720f5-a694-44f6-97d8-f4d20b23ae7&amp;title=&amp;width=815.5556131684772" alt="image.png" /><br />可以看到这里的时间平均周转时间变多了，有以下两种可能：</p><ol><li>当进程的执行时间很长时，增加时间片大小可能会导致进程在等待时间片结束时的等待时间变长，因为进程需要等待更长的时间才能获得 CPU</li><li>当进程的数量非常多时，增加时间片大小可能会导致进程在就绪队列中等待的时间变长，因为每个进程需要等待更长的时间才能获得 CPU。</li></ol><p>因此，时间片大小的设置需要根据具体情况进行调整，不能简单地认为增加时间片大小一定会减少平均周转时间。需要根据系统中进程的数量、执行时间等因素来选择合适的时间片大小，从而达到更好的系统性能。<br /><a name="R9GH2"></a></p><h1 id="实验4-基于内核栈切换的进程切换"><a class="markdownIt-Anchor" href="#实验4-基于内核栈切换的进程切换"></a> 实验4 基于内核栈切换的进程切换</h1><hr /><p>我这个实验做的不是很好，建议本实验参考其他的博客<br /><a name="XtNKt"></a></p><h2 id="1-修改schedule函数"><a class="markdownIt-Anchor" href="#1-修改schedule函数"></a> 1.  修改schedule函数</h2><p>在TSS切换中，依赖TR寄存器找到下一个进程的tss，从而实现切换，因此在switch_to中没有next的PCB。要在<code>switch_to</code>函数中，将TSS的切换改为内核栈的切换，首先要在<code>schedule</code>函数中给<code>switch_to</code>函数传入next的PCB。因为这里没有TSS的切换，需要再单独做LDT表的切换。<br />在函数声明中，参数列表是从左到右依次列出的，而在函数栈帧中，参数是从右到左依次压入的。因此调用<code>switch_to</code>函数后，当前进程的内核中依次压入了LDT(next)，pnext和返回地址<br />因为这里涉及函数调用和栈，所以补充一下<code>%esp</code>和<code>%ebp</code>的知识：</p><blockquote><p>ESP寄存器用于指向当前栈帧的顶部，即栈中当前可用的最高地址。而EBP寄存器则通常用于指向当前函数的栈帧，也称为帧指针。EBP寄存器存储的是当前栈帧的起始位置，也就是栈中当前函数的参数和局部变量存储的位置。在函数执行期间，ESP寄存器的值会随着栈中数据的压入和弹出而不断变化，以保持其始终指向当前栈帧的顶部。而EBP寄存器的值通常不会被修改，以保持其一直指向当前函数的栈帧。这样可以确保函数能够正确地访问和修改栈帧中的参数、局部变量和返回地址等信息，而不会干扰其他函数的栈帧。<br />在函数调用过程中，处理器会将该函数的参数值和返回地址等信息压入当前函数的栈帧中，并将ESP寄存器的值减少相应的字节数。如果在函数执行期间没有再将其他数据压入栈中，那么ESP寄存器的值将等于EBP寄存器的值，即它们都指向栈帧的底部。需要注意的是，函数栈帧的大小通常是在编译时确定的，因此在函数调用前，编译器就已经为该函数分配了足够的栈空间。如果在函数执行期间需要动态分配更多的栈空间，那么ESP和EBP寄存器的值就会发生变化，以指向新分配的栈空间的位置<br />因此，ESP指向栈帧的顶部，EBP指向栈帧的起始位置，两者配合使用，能够在函数执行期间正确地访问和修改栈帧中的数据。</p></blockquote><p><strong>旁注：LDT表实现进程间的地址隔离</strong></p><blockquote><p>在x86架构中，进程与LDT（Local Descriptor Table）有密切的关系，LDT可以用来隔离和保护不同进程的地址空间。<br />LDT是一种描述符表，用于存储局部数据段和局部代码段的信息。与全局描述符表（GDT）不同，LDT表是针对每个进程单独维护的，每个进程都可以有自己的LDT表。LDT表的主要作用是实现地址空间的隔离，以保护、不同进程的内存空间不被其他进程访问或修改。<br />在x86架构中，进程的地址空间通常被划分为多个段，每个段都有自己的基地址和大小。通过使用LDT表中的描述符，可以将进程的地址空间划分为多个不同的段，并且每个进程都有自己独立的LDT表，这样可以实现不同进程的地址空间之间的隔离和保护。<strong>进程中的所有数据段和代码段都必须使用LDT中的描述符进行描述，以便在进程运行时能够正确地访问和修改这些段中的数据</strong>。<br />在Linux 0.11内核中，进程的LDT表存储在进程控制块（PCB）中，每个进程都有自己独立的LDT表。当进程被调度执行时，LDT表的选择子被存储在进程的TSS（Task State Segment）中，用于访问进程的LDT表。通过使用LDT表，可以实现不同进程之间的地址空间隔离和保护，提高系统的安全性和稳定性。<br />总之，LDT表是实现进程地址空间隔离和保护的重要手段，可以帮助操作系统实现不同进程之间的资源隔离和保护。在x86架构下，LDT表和进程的地址空间划分密切相关，每个进程都有自己独立的LDT表和地址空间划分。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,next,c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> ** p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> *pnext = &amp;init_task.task ;  <span class="comment">//指向下一个进程的PCB的PCB指针,初始化指向进程0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">i = NR_TASKS;</span><br><span class="line">p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">c = (*p)-&gt;counter, next = i, pnext = *p;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">(*p)-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line">switch_to(pnext, _LDT(next));  <span class="comment">//  传递下一个进程的PCB (切换执行序列)和LDT (切换内存空间)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="R5KpS"></a></p><h2 id="2-修改switch_to函数"><a class="markdownIt-Anchor" href="#2-修改switch_to函数"></a> 2. 修改switch_to函数</h2><p><code>switch_to</code>函数是一个宏函数，位于<code>include/linux/sched.h</code>中，我们先注释掉这个原版<code>switch_to</code>，在<code>kernel/system_call.s</code>中编写新的<code>switch_to</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ESP0= 0x04</span><br><span class="line">KERNEL_STACK    = 0x0C # kernel_stack变量在task_struct中的偏移量</span><br><span class="line">switch_to:</span><br><span class="line">        pushl %ebp     # 压入C函数schedule的栈帧</span><br><span class="line">        movl %esp,%ebp # 将当前进程的栈顶指针esp拷贝给%ebp，使它指向刚刚压入的esp值</span><br><span class="line">        pushl %ecx     # 这几个寄存器可能是调用函数schedule中用到的寄存器，因此先保存</span><br><span class="line">        pushl %ebx</span><br><span class="line">        pushl %eax</span><br><span class="line">        movl 8(%ebp),%ebx   #取出传入的pnext参数，即下一个进程的PCB指针</span><br><span class="line">        cmpl %ebx,current   </span><br><span class="line">        je 1f               # next是否是当前进程，如果是，则向前(Forward)跳转到标号1开始执行，不执行转换</span><br><span class="line"></span><br><span class="line"># PCB</span><br><span class="line">        movl %ebx,%eax</span><br><span class="line">        xchgl %eax,current  # exchange value, 切换进程PCB, 此时%eax指向当前进程，current指向下一个进程</span><br><span class="line"># TSS 使用户栈能找到内核栈，借用进程0的tss保存内核栈的esp0信息</span><br><span class="line">        movl tss, %ecx  # 在kernel/sched.c中定义tss = &amp; init_task.task.tss</span><br><span class="line">        addl $4096, %ebx   # 让ebx指向页表最高地址处，这里也是内核栈的基址</span><br><span class="line">        movl %ebx, ESP0(%ecx) # 修改tss中的esp0(偏移量为4)，使它指向内核栈的栈顶位置，此时就是栈基址</span><br><span class="line"># switch kernel_stack   切换的关键</span><br><span class="line">        movl %esp, KERNEL_STACK(%eax) # 取出CPU.esp 保存到当前进程的PCB中，task_struct中需要添加kernel_stack变量，并修改INIT_TASK</span><br><span class="line">        movl 8(%ebp),%ebx # 重新取出下一个进程的PCB</span><br><span class="line">        movl KERNEL_STACK(%ebx), %esp # 将下一个进程的PCB中的内核栈的栈顶信息esp放入CPU中</span><br><span class="line"># switch LDT</span><br><span class="line">        movl 12(%ebp), %ecx  # 取出传入的 LDT(next)参数</span><br><span class="line">        lldt %cx  # lldt指令用于将LDT的段选择子加载到LDTR寄存器中，LDTR寄存器是一个16位的寄存器，存储LDT的段选择子，硬件根据LDTR在GDT中查找以获取LDT的地址</span><br><span class="line">        movl $0x17,%ecx  # 重置 fs寄存器</span><br><span class="line">        mov %cx,%fs</span><br><span class="line"></span><br><span class="line">        cmpl %eax,last_task_used_math</span><br><span class="line">        jne 1f</span><br><span class="line">        clts</span><br><span class="line">1:  </span><br><span class="line">        popl %eax  # 返回C函数schedule，恢复寄存器(特别是帧指针%ebp)</span><br><span class="line">        popl %ebx</span><br><span class="line">        popl %ecx</span><br><span class="line">        popl %ebp</span><br><span class="line">        ret</span><br><span class="line">.align 2</span><br><span class="line">first_return_from_kernel:  # 一段包含iret的代码，用于返回用户栈</span><br><span class="line">        popl %edx</span><br><span class="line">        popl %edi</span><br><span class="line">        popl %esi</span><br><span class="line">        pop %gs</span><br><span class="line">        pop %fs</span><br><span class="line">        pop %es</span><br><span class="line">        pop %ds</span><br><span class="line">        iret</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680610298744-b96a1fb9-0bd5-42c3-92fa-db7cf014e26f.png#averageHue=%230e1d24&amp;clientId=uab8d30b7-e158-4&amp;from=paste&amp;height=359&amp;id=u135e04c6&amp;originHeight=570&amp;originWidth=307&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=25038&amp;status=done&amp;style=none&amp;taskId=uc3a9f8de-69d4-45ee-9bd4-59869b11bbe&amp;title=&amp;width=193.4074249267578" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680607901100-80e1fef7-6227-4666-8b92-b7f9e77c5157.png#averageHue=%2340403f&amp;clientId=ud7da80e5-6267-4&amp;from=paste&amp;height=213&amp;id=u9cffa745&amp;originHeight=288&amp;originWidth=1249&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=131127&amp;status=done&amp;style=none&amp;taskId=uf8d01083-566e-4751-9d00-bfefb9601b0&amp;title=&amp;width=925.1852505426231" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680607923866-24c74850-2ebb-41f3-b6f8-a6bf868dc1ec.png#averageHue=%23443a2c&amp;clientId=ud7da80e5-6267-4&amp;from=paste&amp;height=126&amp;id=u80a62313&amp;originHeight=170&amp;originWidth=972&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=79341&amp;status=done&amp;style=none&amp;taskId=uff96a90b-a025-4fab-9392-f3ca2b5aeca&amp;title=&amp;width=720.0000508626338" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680613819720-4f2243c4-a2ac-4182-8b85-b8b5c9075826.png#averageHue=%23414040&amp;clientId=uf8dab7e5-7478-4&amp;from=paste&amp;height=194&amp;id=u8850a003&amp;originHeight=262&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=87892&amp;status=done&amp;style=none&amp;taskId=u3d364175-505c-40bc-b73e-0a56a05f9ab&amp;title=&amp;width=762.2222760675413" alt="image.png" /><br /><a name="Brx25"></a></p><h2 id="3-修改copy_process函数"><a class="markdownIt-Anchor" href="#3-修改copy_process函数"></a> 3.  修改copy_process函数</h2><p>在fork.c的copy_process部分添加以下代码用于设置进程的内核栈， 并注释掉设置tss的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*set up kernel stack */</span><br><span class="line">long * krnstack =(long)(PAGE_SIZE + (long)p);</span><br><span class="line">*(--krnstack) = ss &amp; 0xffff;  # 压入SS:SP</span><br><span class="line">*(--krnstack) = esp;</span><br><span class="line">*(--krnstack) = eflags;</span><br><span class="line">*(--krnstack) = cs &amp; 0xffff;  # 压入CS:IP</span><br><span class="line">*(--krnstack) = eip;</span><br><span class="line"></span><br><span class="line">*(--krnstack) = ds &amp; 0xffff;</span><br><span class="line">*(--krnstack) = es &amp; 0xffff;</span><br><span class="line">*(--krnstack) = fs &amp; 0xffff;</span><br><span class="line">*(--krnstack) = gs &amp; 0xffff;</span><br><span class="line">*(--krnstack) = esi;</span><br><span class="line">*(--krnstack) = edi;</span><br><span class="line">*(--krnstack) = edx;</span><br><span class="line"></span><br><span class="line">*(--krnstack) = (long) first_return_from_kernel; // a code segment with iret instruction</span><br><span class="line"></span><br><span class="line">*(--krnstack) = ebp;</span><br><span class="line">*(--krnstack) = ecx;</span><br><span class="line">*(--krnstack) = ebx;</span><br><span class="line">*(--krnstack) = 0;</span><br><span class="line">p-&gt;kernel_stack = krnstack;  # 设置PCB中的内核栈栈顶指针信息为初始化后的栈顶指针</span><br></pre></td></tr></table></figure><p><a name="jdsWH"></a></p><h1 id="实验5-信号量的实现与应用"><a class="markdownIt-Anchor" href="#实验5-信号量的实现与应用"></a> 实验5 信号量的实现与应用</h1><p><a name="omgks"></a></p><h2 id="1-前提-2"><a class="markdownIt-Anchor" href="#1-前提-2"></a> 1. 前提</h2><p><a name="DxhB5"></a></p><h3 id="1-系统调用open打开文件"><a class="markdownIt-Anchor" href="#1-系统调用open打开文件"></a> (1) 系统调用open打开文件</h3><p>要使用系统调用方式打开文件，可以使用 open 系统调用。该系统调用的原型定义在 &lt;fcntl.h&gt; 头文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>其中，pathname 参数是要打开的文件名，可以是相对路径或绝对路径，可以包含目录名和文件名；flags 参数是打开文件的选项和标志，比如只读、只写、追加、创建等；mode 参数是创建文件时的权限，仅在创建文件时使用，可以指定文件的读写权限。<br />常用的打开选项和标志包括：</p><ul><li>O_RDONLY：只读模式打开文件。</li><li>O_WRONLY：只写模式打开文件。</li><li>O_RDWR：读写模式打开文件。</li><li>O_CREAT：如果文件不存在则创建文件。</li><li>O_TRUNC：如果文件已存在则清空文件内容。</li><li>O_APPEND：在文件末尾追加内容。</li><li>O_EXCL：在创建文件时，如果文件已存在则返回错误。</li></ul><p>如果成功打开文件，系统调用返回一个非负整数，即文件描述符（file descriptor），用于后续访问文件内容。如果出错，则返回一个负值，表示出错的类型。<br />对第2个参数flags，可以使用了<code>|</code>运算符将多个选项参数组合在一起。这是因为 open 系统调用的选项参数是一个位掩码，每个选项都有一个对应的位标志，可以使用位运算符组合多个选项。<br />对第3个参数mode，文件的访问权限是一个八进制数，表示文件的所有者、所属组和其他用户对文件的访问权限。<br />每个访问权限位的含义如下：</p><ul><li>读权限：4</li><li>写权限：2</li><li>执行权限：1</li></ul><p>在使用 open 系统调用创建文件时，可以通过一个八进制数来指定文件的访问权限。通常情况下，可以将三个访问权限位组合在一起，得到一个八进制数，作为 mode 参数传递给 open 系统调用。例如，如果要将文件的访问权限设置为所有用户都有<strong>写</strong>权限，可以使用以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_CREAT | O_WRONLY, <span class="number">0222</span>);  <span class="comment">// 0开头的数字表示这是一个八进制数</span></span><br></pre></td></tr></table></figure><p><a name="xl1MX"></a></p><h3 id="2-系统调用write写入文件"><a class="markdownIt-Anchor" href="#2-系统调用write写入文件"></a> (2) 系统调用write写入文件</h3><p>在 C 语言中，write 函数用于向文件或者文件描述符写入数据，其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>write 函数的三个参数分别表示：</p><ol><li>fd：文件描述符，它是一个整数，用于指定要写入数据的文件或设备。在 Linux 系统中，标准输入、标准输出和标准错误分别对应文件描述符 0、1 和 2。用户可以使用 open 函数打开其他文件或设备，并获得相应的文件描述符。</li><li>buf：指向要写入数据的缓冲区的指针。在写入数据之前，用户需要将数据存储在缓冲区中，然后将缓冲区的地址传递给 write 函数。</li><li>count：要写入的字节数。用户需要指定要写入数据的长度，以字节数为单位。如果缓冲区中的数据长度小于 count，则 write 函数只会写入部分数据；如果缓冲区中的数据长度大于 count，则 write 函数只会写入 count 字节的数据。</li></ol><p>当 write() 函数成功写入数据时，内核会更新文件偏移量，以便下一次读写操作从正确的位置开始。<br />需要注意的是，write 函数返回值是 ssize_t 类型，表示成功写入的字节数，如果返回值为负数，则表示写入失败。<br /><a name="dvXWS"></a></p><h3 id="3-系统调用read从文件读取数据"><a class="markdownIt-Anchor" href="#3-系统调用read从文件读取数据"></a> (3) 系统调用read从文件读取数据</h3><p>在 Linux 系统中，read() 是一个用于从文件描述符中读取数据的系统调用。该调用的原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>read() 函数有三个参数：</p><ol><li>fd：要读取的文件的文件描述符。</li><li>buf：用于存储读取数据的缓冲区。</li><li>count：要读取的字节数。</li></ol><p>read() 函数会从指定的文件描述符 fd 中读取 count 个字节的数据，并将其存储到 buf 缓冲区中。函数返回实际读取的字节数，如果读取出错，则返回 -1。<br />read() 函数在读取数据时可能会阻塞进程，直到有数据可读或发生错误。如果读取到文件末尾，函数返回 0。如果读取的字节数小于 count，则可能是因为已经到达文件末尾或者因为发生了错误。<br />当使用 read() 函数读取数据时，内核会将文件偏移量更新为读取数据后的下一个位置。例如，如果你使用 read() 函数从文件的位置 100 处读取 50 个字节的数据，则文件偏移量会从 100 更新为 150 (100~149)。这样，下一次读取数据操作将从文件位置 150 处开始。使用 lseek() 函数可以显式地设置文件偏移量。<br />read() 函数可以用于读取文件、套接字、管道等类型的文件描述符。<br /><a name="QqDWZ"></a></p><h3 id="4-系统调用lseek移动文件指针"><a class="markdownIt-Anchor" href="#4-系统调用lseek移动文件指针"></a> (4) 系统调用lseek移动文件指针</h3><p>lseek函数用于在文件中移动文件指针的位置。该函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>; <span class="comment">// off_t 是long的别名，在&lt;sys/types.h&gt;中定义</span></span><br></pre></td></tr></table></figure><p>其中，fd 是已打开文件的文件描述符，offset 是需要移动的偏移量，whence 则用于指定相对于何处进行偏移，其取值可以为 SEEK_SET、SEEK_CUR 或 SEEK_END。这三个常量在&lt;unistd.h&gt; 头文件中定义<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680944981675-ec549d1d-1e5d-4922-bd94-824e9a2fc219.png#averageHue=%23faf8f6&amp;clientId=u8d570fae-75fa-4&amp;from=paste&amp;height=131&amp;id=PmS6E&amp;originHeight=177&amp;originWidth=1031&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=84788&amp;status=done&amp;style=none&amp;taskId=u91542c12-b250-4808-bb4f-493451efd95&amp;title=&amp;width=763.7037576536784" alt="image.png" /></p><ul><li>当 whence 值为 SEEK_SET时，文件指针将被设置为相对于文件开头偏移 offset 个字节的位置。</li><li>当 whence 值为 SEEK_CUR时，文件指针将被设置为相对于当前位置偏移 offset 个字节的位置。</li><li>当 whence 值为 SEEK_END时，文件指针将被设置为相对于文件末尾偏移 offset 个字节的位置。</li></ul><p>lseek() 函数返回新的文件指针位置，如果出现错误则返回 -1。通过调用 lseek() 函数可以实现随机访问文件的功能，比如读取文件中的任意部分内容、覆盖文件中的任意部分内容等。<br /><a name="SXM4Y"></a></p><h2 id="2-创建semaphore类型"><a class="markdownIt-Anchor" href="#2-创建semaphore类型"></a> 2. 创建semaphore类型</h2><p>在<code>include/linux/sem.h</code>写入以下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SEM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SEM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span>   <span class="comment">// for task_struct definition</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_TABLE_LEN 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_NAME_LEN20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="type">char</span> name[SEM_NAME_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">queue</span>;</span>   <span class="comment">// wait queue</span></span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_table[SEM_TABLE_LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="V2My1"></a></p><h2 id="3-创建信号量相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建信号量相关的系统调用"></a> 3. 创建信号量相关的系统调用</h2><p>在<code>kernel/sem.c</code>中写入以下内容，包括信号量的创建<code>sys_sem_open</code>，P操作<code>sys_sem_wait</code>，V操作<code>sys_sem_post</code>，和释放信号量<code>sys_sem_unlink</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/fdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include&lt;string.h&gt;  // avoid unknowned error</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt;   <span class="comment">// the number of semaphores in sem_table, auto initial to zero</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> * <span class="title function_">sys_sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> value)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> name_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> isExist = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sem_name_len =<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> kernel_sem_name[<span class="number">25</span>]=&#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"><span class="type">sem_t</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( (c = get_fs_byte(name+name_len))!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        kernel_sem_name[name_len] = c;</span><br><span class="line">        ++name_len;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// printk(&quot;name_len: %d\tstrlen: %d\n&quot;,name_len,strlen(kernel_sem_name));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(name_len &gt; SEM_NAME_LEN) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;cnt; ++i) <span class="comment">/*find duplicate*/</span></span><br><span class="line">&#123;</span><br><span class="line">sem_name_len = <span class="built_in">strlen</span>(sem_table[i].name);</span><br><span class="line">       <span class="comment">// printk(&quot;%d:%s!\t%d:%s!\n&quot;,sem_name_len,sem_table[cnt].name,name_len,kernel_sem_name);</span></span><br><span class="line"><span class="keyword">if</span>(sem_name_len == name_len &amp;&amp; !<span class="built_in">strcmp</span>(kernel_sem_name, sem_table[i].name))</span><br><span class="line">&#123;</span><br><span class="line">isExist = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isExist) </span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">//printk(&quot;i am consumer!\n&quot;);</span></span><br><span class="line">p = sem_table+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(sem_table[cnt].name, kernel_sem_name);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// printk(&quot;ID:(%d)\t %d\t%s!\t%d\t%s!\n&quot;,cnt,strlen(sem_table[cnt].name),sem_table[cnt].name,strlen(kernel_sem_name),kernel_sem_name);</span></span><br><span class="line"></span><br><span class="line">sem_table[cnt].value = value;</span><br><span class="line">p = sem_table+cnt;</span><br><span class="line">++cnt;</span><br><span class="line">        <span class="comment">//printk(&quot;i am producer!\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">cli();</span><br><span class="line"><span class="keyword">if</span>(--sem-&gt;value &lt; <span class="number">0</span> ) sleep_on(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">cli();</span><br><span class="line"><span class="keyword">if</span>(++sem-&gt;value &lt;= <span class="number">0</span>) wake_up(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> name_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(get_fs_byte(name+name_len)!=<span class="string">&#x27;\0&#x27;</span>) &#123;++name_len;&#125;</span><br><span class="line"><span class="keyword">if</span>(name_len &gt; SEM_NAME_LEN)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> kernel_sem_name[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;name_len; ++i) &#123;kernel_sem_name[i] = get_fs_byte(name+i);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> isExist = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sem_name_len =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;cnt; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sem_name_len = <span class="built_in">strlen</span>(sem_table[i].name);</span><br><span class="line"><span class="keyword">if</span>(sem_name_len == name_len &amp;&amp; !<span class="built_in">strcmp</span>(kernel_sem_name, sem_table[i].name))</span><br><span class="line">&#123;</span><br><span class="line">isExist = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isExist)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(tmp=i;i&lt;cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line">sem_table[tmp] = sem_table[tmp+<span class="number">1</span>]; <span class="comment">// overwrite</span></span><br><span class="line">&#125;</span><br><span class="line">--cnt;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将sys_function添加到内核的系统调用已在lab2讲解过，这里只上截图<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191314333-f237a891-d3aa-4009-a70a-caa03b5251f4.png#averageHue=%23320a1c&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=157&amp;id=ucafea307&amp;originHeight=212&amp;originWidth=1043&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=53782&amp;status=done&amp;style=none&amp;taskId=ubdbcf372-278d-4ac4-8df2-a83d86793b1&amp;title=&amp;width=772.5926471705011" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191398952-f295a310-8abb-420f-8dfd-82875874d4d9.png#averageHue=%232e0c2a&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=471&amp;id=u3a5df7fe&amp;originHeight=636&amp;originWidth=1626&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=238875&amp;status=done&amp;style=none&amp;taskId=uc4ed164c-d7db-431b-9e93-835b878669b&amp;title=&amp;width=1204.4445295294677" alt="image.png" /><br />修改Makefile<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191512033-b378a545-c5bb-4d3e-98d1-4666b3b778fb.png#averageHue=%23310a1c&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=121&amp;id=udb2561cb&amp;originHeight=163&amp;originWidth=1167&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38144&amp;status=done&amp;style=none&amp;taskId=ub0cbced6-d5cf-4454-a9af-16ec0f280e6&amp;title=&amp;width=864.4445055110017" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191532529-6e747c92-5ffb-4cff-bbfd-f3f0fee9c7c3.png#averageHue=%23370a1a&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=159&amp;id=ub275bef1&amp;originHeight=215&amp;originWidth=1422&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=63428&amp;status=done&amp;style=none&amp;taskId=u9f808bbe-8499-4256-8136-da26c49b809&amp;title=&amp;width=1053.333407743483" alt="image.png" /><br /><a name="kx8cN"></a></p><h2 id="4-创建生产者-消费者进程"><a class="markdownIt-Anchor" href="#4-创建生产者-消费者进程"></a> 4. 创建生产者-消费者进程</h2><p>在<code>pc.c</code>中写入以下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span>*, sem_open, <span class="type">const</span> <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, value)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_wait, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_post, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span>*, name)</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_CONSUMER = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_PRODUCTS = <span class="number">50</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pro_nr, csm_pro_nr; <span class="comment">/*product number, consumed product number*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* FILENAME = <span class="string">&quot;/usr/root/buffer_file&quot;</span>; <span class="comment">/*default buffer file*/</span></span><br><span class="line"><span class="type">sem_t</span> *mutex, *full, *empty;</span><br><span class="line"><span class="type">int</span> f_in;   <span class="comment">/* for producer*/</span></span><br><span class="line"><span class="type">int</span> f_out;  <span class="comment">/* for consumer*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * file_name = argc &gt; <span class="number">1</span> ? argv[<span class="number">1</span>] : FILENAME;</span><br><span class="line"><span class="type">int</span> pid;</span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">/* must declare cnt here */</span></span><br><span class="line"><span class="comment">/*open buffer file */</span></span><br><span class="line">f_in = open(file_name, O_CREAT|O_TRUNC|O_WRONLY, <span class="number">0222</span>);</span><br><span class="line">f_out = open(file_name,O_TRUNC|O_RDONLY, <span class="number">0444</span>);</span><br><span class="line"><span class="comment">/*create semaphores*/</span></span><br><span class="line">mutex = sem_open(<span class="string">&quot;MUTEX&quot;</span>,<span class="number">1</span>);</span><br><span class="line">full = sem_open(<span class="string">&quot;FULL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">empty = sem_open(<span class="string">&quot;EMPTY&quot;</span>,BUFFER_SIZE);</span><br><span class="line"><span class="comment">/*parent process as producer*/</span></span><br><span class="line">pro_nr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fork())</span><br><span class="line">&#123;</span><br><span class="line">pid = getpid();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid %d:\t producer created!\n&quot;</span>,pid);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">while</span>(pro_nr &lt; NR_PRODUCTS) <span class="comment">/*until product all products then producer exit*/</span></span><br><span class="line">&#123;</span><br><span class="line">sem_wait(empty);</span><br><span class="line">sem_wait(mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(pro_nr % BUFFER_SIZE)) lseek(f_in, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/*10 products per turn*/</span></span><br><span class="line"></span><br><span class="line">write(f_in,(<span class="type">char</span>*)&amp;pro_nr, <span class="keyword">sizeof</span>(pro_nr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid %d:\t produces product %d!\n&quot;</span>, pid, pro_nr);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">++pro_nr;</span><br><span class="line"></span><br><span class="line">sem_post(mutex);</span><br><span class="line">sem_post(full);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*child process create child processes to be consumer*/</span></span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line">cnt = NR_CONSUMER;</span><br><span class="line"><span class="keyword">while</span>(cnt--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(pid=fork()))</span><br><span class="line">&#123;</span><br><span class="line">pid = getpid();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid %d:\t consumer %d created!\n&quot;</span>, pid, NR_CONSUMER-cnt);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(csm_pro_nr == NR_PRODUCTS) <span class="keyword">goto</span> OK;</span><br><span class="line"></span><br><span class="line">sem_wait(full);</span><br><span class="line">sem_wait(mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!read(f_out,(<span class="type">char</span>*)&amp;csm_pro_nr, <span class="keyword">sizeof</span>(csm_pro_nr))) <span class="comment">/*end of file,reset*/</span></span><br><span class="line">&#123;</span><br><span class="line">lseek(f_out, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">read(f_out,(<span class="type">char</span>*)&amp;csm_pro_nr, <span class="keyword">sizeof</span>(csm_pro_nr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pid:%d:\t consumer %d consume product %d\n&quot;</span>,pid, NR_CONSUMER-cnt,csm_pro_nr);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">sem_post(mutex);</span><br><span class="line">sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OK:</span><br><span class="line">sem_unlink(<span class="string">&quot;MUTEX&quot;</span>);</span><br><span class="line">sem_unlink(<span class="string">&quot;FULL&quot;</span>);</span><br><span class="line">sem_unlink(<span class="string">&quot;EMPTY&quot;</span>);</span><br><span class="line"></span><br><span class="line">close(f_in);</span><br><span class="line">close(f_out);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="d4Zs9"></a></p><h2 id="5-验证结果"><a class="markdownIt-Anchor" href="#5-验证结果"></a> 5. 验证结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#current catalogue: OSLab5</span></span><br><span class="line">./mount-hdc</span><br><span class="line"><span class="comment">#更新标准库</span></span><br><span class="line"><span class="built_in">cp</span> include/unistd.h hdc/usr/include   </span><br><span class="line"><span class="built_in">cp</span> include/linux/sem.h hdc/usr/include </span><br><span class="line"><span class="comment">#run</span></span><br><span class="line"><span class="built_in">cp</span> pc.c hdc/usr/root</span><br><span class="line">./run</span><br><span class="line"><span class="comment">#在bochs中执行</span></span><br><span class="line">gcc -o pc pc.c</span><br><span class="line">./pc &gt; sem_output <span class="comment"># 将输出结果重定向到文件sem_output，便于查看</span></span><br><span class="line"><span class="built_in">sync</span>  <span class="comment">#将所有的缓存数据写入磁盘，lab3中出现过</span></span><br><span class="line"><span class="comment">#回到ubuntu执行</span></span><br><span class="line">./mount-hdc</span><br><span class="line"><span class="built_in">cp</span> hdc/usr/root/sem_output sem_output</span><br><span class="line">gedit sem_output</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681190311067-7da9d91d-d3ad-429e-aa5f-9b1248637268.png#averageHue=%23222222&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=370&amp;id=ue8d7e426&amp;originHeight=499&amp;originWidth=723&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=31439&amp;status=done&amp;style=none&amp;taskId=u02dc2475-2333-4f29-9398-9089b4f3b91&amp;title=&amp;width=535.555593388564" alt="image.png" /><br />查看sem_output验证信号量机制的正确性<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191987779-91ab0753-403e-4c53-b14e-003cf1bc245d.png#averageHue=%232d2c2a&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=551&amp;id=u70a1ec26&amp;originHeight=744&amp;originWidth=915&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=163272&amp;status=done&amp;style=none&amp;taskId=u21388cc9-64a2-48f8-a033-aca3b00b29a&amp;title=&amp;width=677.7778256577262" alt="image.png" /><br />可以看出，producer每生产一轮，即填满容量为10的缓冲区后，5个consumer就开始消耗缓冲区，消耗完后producer又生产一轮，直到达到最大产品数量<code>NR_PRODUCTS = 50</code>(0~49)后退出，consumer在消耗完所有产品后也退出<br /><a href="https://www.cnblogs.com/mirage-mc/p/12913993.html">reference</a><br /><a name="UBxgK"></a></p><h1 id="实验6-地址映射与共享"><a class="markdownIt-Anchor" href="#实验6-地址映射与共享"></a> 实验6 地址映射与共享</h1><p><a name="PCY7K"></a></p><h2 id="1-跟踪地址翻译过程"><a class="markdownIt-Anchor" href="#1-跟踪地址翻译过程"></a> 1. 跟踪地址翻译过程</h2><ol><li>启动调试，获取i的逻辑地址为<code>ds:0x3004</code>，ds表明该地址属于由ds寄存器指示的段 (后续称ds段)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682391942338-17dbc47e-efbe-4991-ac01-66a58fe29761.png#averageHue=%2361d6df&amp;clientId=u2a189deb-d8a3-4&amp;from=paste&amp;height=396&amp;id=u2fe5db91&amp;originHeight=535&amp;originWidth=1762&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=161011&amp;status=done&amp;style=none&amp;taskId=ucdae2cfd-9baf-417b-b5a5-19a5e7b74ce&amp;title=&amp;width=1305.1852773867909" alt="image.png" /></p><ol start="2"><li>通过段表(LDT)，确定ds段的起始地址，进而将逻辑地址转化为虚拟地址。段表由LDTR指示，运行命令<code>sreg</code>查看LDTR的值，该寄存器用于从GDT中取出进程的LDT地址</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682392972667-b8028c87-04e2-4da8-adcf-d9c895eabed1.png#averageHue=%230c0b0a&amp;clientId=ud47c8188-ce02-4&amp;from=paste&amp;height=322&amp;id=u637c9f1f&amp;originHeight=435&amp;originWidth=1050&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=186768&amp;status=done&amp;style=none&amp;taskId=u42a2cb9c-2fc1-4b4e-8722-de778d6716e&amp;title=&amp;width=777.777832721981" alt="image.png" /><br />LDTR的值为<code>0x68 = 0x0000 0000 0110 1000</code>，取3~15位表示段选择子<code>1101</code>，说明目标LDT在GDT的第13项(从0索引)<br />GDT的地址已经由gdtr指出为<code>0x00005cb8</code>，因为GDT每项段描述符占8个字节，因此查看GDT的<code>0x00005cb8+8*13</code>处的8个字节，这8个字节就是目标LDT的段描述符<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682393215941-b8c0d04e-4f8b-4ada-97ad-911b7141413a.png#averageHue=%23393938&amp;clientId=ud47c8188-ce02-4&amp;from=paste&amp;height=84&amp;id=u9a33146e&amp;originHeight=113&amp;originWidth=1195&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=46789&amp;status=done&amp;style=none&amp;taskId=u3711d3a6-2bff-411f-add3-cd062bb1d5f&amp;title=&amp;width=885.1852477169211" alt="image.png" /><br />根据段描述符的结构，从0x<strong>52d0</strong>0068 0x<strong>00</strong>0082<strong>fd</strong>(0~64bits）提取出<code>0x00fd52d0</code>，这就是目标LDT的基地址<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682399305124-bdd7f27d-075f-4c4a-9a65-b7860c7dd623.png#averageHue=%23fefefe&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=177&amp;id=u622fb3b7&amp;originHeight=239&amp;originWidth=803&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=32904&amp;status=done&amp;style=none&amp;taskId=u2a4729cd-97c0-43ac-825d-5ce252d761a&amp;title=&amp;width=594.8148568340483" alt="image.png" /><br />ds段的基地址由ds寄存器(段选择子)在LDT中指示，我们先用<code>sreg</code>查看ds的值<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682399914102-d58b5df4-485d-4607-9f50-2e4b00465752.png#averageHue=%230b0c09&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=125&amp;id=u9052b12d&amp;originHeight=169&amp;originWidth=986&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=77799&amp;status=done&amp;style=none&amp;taskId=ucbc01f60-3bc3-438e-aacd-43cedd3cc58&amp;title=&amp;width=730.3704219655936" alt="image.png" /><br />段选择子ds的值是0x0017 = 0x <strong>0000 0000 0001 0</strong>111 (16bits)，根据段选择子的结构<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682399993383-cfebc5a1-1647-4904-b1c1-9063b2340ec1.png#averageHue=%231e1c1b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=133&amp;id=u32177cff&amp;originHeight=180&amp;originWidth=892&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=11920&amp;status=done&amp;style=none&amp;taskId=ub641d6b7-7444-4531-bc8d-931428ae182&amp;title=&amp;width=660.7407874171496" alt="image.png" /><br />从ds中提取出段选择符的索引<code>0x10</code>，可见ds段在LDT的第3项(从0编号)，于是接下来查看目标LDT的前四项(每项占四个字节)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682400415663-fca789c0-f4cb-4158-a1ee-871abca1e98b.png#averageHue=%232b2b2b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=111&amp;id=u3c133be0&amp;originHeight=150&amp;originWidth=1694&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=50932&amp;status=done&amp;style=none&amp;taskId=ucf49bcf4-23b3-4875-b05d-f39c9cacbcb&amp;title=&amp;width=1254.8149034581293" alt="image.png" /><br />获取了目标LDT中第3个段描述符的数据: 0x<strong>0000</strong>3fff 0x<strong>10</strong>c0f3<strong>00</strong>，根据段描述符的结构，提取出基地址: <code>1000 0000</code>，自此我们可以将<code>i</code>逻辑地址转化为虚拟地址(线性地址)了<br />虚拟地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>0000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>3004</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>3004</mn></mrow><annotation encoding="application/x-tex">base +offset=0x1000\,0000 + 0x3004 =0x1000\,3004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span></p><ol start="3"><li>将虚拟地址映射到的物理地址</li></ol><p>根据虚拟地址结构，可知<code>0x1000 3004 = 0x0001 0000...0000 0011 000..0 0100</code>表示的物理地址在页目录64对应的页表中，页号为3(页号连续，因此由第3个页表项指示)，页内偏移为4<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682401178166-181bac16-0d2e-47a5-a656-3f6a96a16ea4.png#averageHue=%23050403&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=156&amp;id=u56695781&amp;originHeight=210&amp;originWidth=649&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=11892&amp;status=done&amp;style=none&amp;taskId=ubb61ef02-e3cd-4bab-b8a8-1e21ad2d939&amp;title=&amp;width=480.7407747014911" alt="image.png" /><br />内存中页目录表的位置由寄存器CR3指示，使用<code>creg</code>查看CR3寄存器的值<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682401466094-7fdd4c1a-1ada-4345-960e-2cd27d0154ca.png#averageHue=%232f2e2e&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=187&amp;id=ucb35aee7&amp;originHeight=253&amp;originWidth=1240&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=97062&amp;status=done&amp;style=none&amp;taskId=u2dc0d307-8e48-4cd6-9958-bd26cfd8156&amp;title=&amp;width=918.5185834050061" alt="image.png" /><br />CR3的值为0x00000000，所以页目录表从地址0x00000000开始，我们要获取第64项，页目录表每项占4个字节，因此使用<code>xp /2w 0+64*4</code>查看第64项的内容<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682401965918-a0fffb1d-1153-4de3-93fd-e7c0178570fe.png#averageHue=%23353434&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=90&amp;id=uf298b392&amp;originHeight=121&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=47037&amp;status=done&amp;style=none&amp;taskId=ub64f8ec9-bd77-47ac-8594-bec0aa10c5a&amp;title=&amp;width=808.8889460308602" alt="image.png" /><br />得到第64个页目录项的内容为: 0x<strong>00fa7</strong>027 0x00000000，根据页目录项的结构，前20位表示所指向的页表的地址的高20位 (<a href="https://stackoverflow.com/questions/26858196/why-does-page-directory-entries-need-20-bits-to-point-210-page-tables">why</a>）为<code>0x00fa7</code>，因为页表物理地址的低12位为0（对齐到4KB的倍数），因此页表的最终的物理地址为<code>0x00fa7000</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682402023037-66c0d317-113a-4a4f-8681-31a71bc759df.png#averageHue=%23e5e5e5&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=242&amp;id=u15511423&amp;originHeight=327&amp;originWidth=551&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=61946&amp;status=done&amp;style=none&amp;taskId=ue2fe15e8-a2cb-4888-8886-e513e46cc59&amp;title=&amp;width=408.14817698077286" alt="image.png" /><br />一个页表项占4个字节，使用<code>xp /2w 0x00fa7000+4*3</code>查找目标页表的第3个页表项(物理页框)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682403935085-f76a7727-58a8-4ede-a0cd-cb73c3bf7051.png#averageHue=%230b0b0b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=84&amp;id=u5f7c6a64&amp;originHeight=113&amp;originWidth=1078&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=62441&amp;status=done&amp;style=none&amp;taskId=u3f8c8e4c-e96f-4f43-9699-47ea9589fe7&amp;title=&amp;width=798.5185749279004" alt="image.png" /><br />得到第3个页表项的内容为0x<strong>00fa6</strong>067 0x00000000<br />根据页表项的结构，前20项表示物理页框的高20位地址: 0x00fa6 (物理页面大小为4KB，基地址与4KB对齐，为 0x**** **** **** **** **** 0000 0000 0000) ,因此目标物理页框的基地址为0x00fa6000<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682403115415-dfde4404-b9c2-4a6c-bb2f-2f2999918190.png#averageHue=%23efefef&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=406&amp;id=u89e16b01&amp;originHeight=548&amp;originWidth=961&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=108043&amp;status=done&amp;style=none&amp;taskId=u4e8e6d00-8b0f-4a14-86a6-41307468cde&amp;title=&amp;width=711.8519021388797" alt="image.png" /><br />最后我们加上页内偏移4，得到最终的物理地址<code>0x00fa6004</code></p><ol start="4"><li>验证</li></ol><p>执行<code>xp /w 0x00fa6004</code>查看我们确定的物理地址的数据内容<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682404195303-e372e6e4-8bc3-4140-b265-30c690f38f74.png#averageHue=%23272726&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=58&amp;id=u33afc753&amp;originHeight=78&amp;originWidth=822&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=18550&amp;status=done&amp;style=none&amp;taskId=ueddd5279-0ae1-4928-aace-a3f07eb3360&amp;title=&amp;width=608.8889319023508" alt="image.png" /><br />这个值与<code>i</code>在程序中的值相一致<br />用命令<code>setpmem 0x00fa6004 4 0</code>将<code>0x00fa6004</code>开始的4个字节(i为int型)全部设置为0，即设置i为0，则程序从原本的无限循环中退出<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682404491015-b0f59a2a-6474-4d82-b72e-b3f7cca247b0.png#averageHue=%232b2b2b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=116&amp;id=ud088a520&amp;originHeight=156&amp;originWidth=1326&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=47887&amp;status=done&amp;style=none&amp;taskId=u664cbb0f-3689-4614-8261-b74085ec6eb&amp;title=&amp;width=982.2222916089016" alt="image.png" /><br /><a name="Thxvd"></a></p><h2 id="2-添加共享内存功能"><a class="markdownIt-Anchor" href="#2-添加共享内存功能"></a> 2. 添加共享内存功能</h2><p><a name="prXmy"></a></p><h3 id="1-前提-通过brk划分虚拟内存"><a class="markdownIt-Anchor" href="#1-前提-通过brk划分虚拟内存"></a> (1) 前提: 通过brk划分虚拟内存</h3><p>进程栈和堆之间的内存空间可以映射到共享的物理页面，brk作为指向进程堆的末尾的指针（即下图中处于下方的虚线），将brk加上进程数据段在虚拟内存中的基址，便可以得到brk的虚拟地址，以这个地址为起点，划分出大小为PAGE_SIZE的虚拟内存，再将这部分虚拟内存通过<code>put_page</code>映射到共享内存上<br /><img src="https://i.stack.imgur.com/1aV6B.png#from=url&amp;id=Lavvc&amp;originHeight=193&amp;originWidth=128&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" /><br /><a name="loSCp"></a></p><h3 id="2-创建用于管理共享内存的数据结构"><a class="markdownIt-Anchor" href="#2-创建用于管理共享内存的数据结构"></a> (2) 创建用于管理共享内存的数据结构</h3><p><code>linux-0.11/include/linux/shm.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SHM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SHM</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 32 <span class="comment">/*Maximum number of shared pages*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">key_t</span> key;  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> size;  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> page; <span class="comment">/*shared page address */</span></span><br><span class="line">&#125;shm;</span><br><span class="line"></span><br><span class="line">shm shm_list[SHM_SIZE] =&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="VLVYG"></a></p><h3 id="3-创建共享内存相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建共享内存相关的系统调用"></a> (3) 创建共享内存相关的系统调用</h3><p><code>linux-0.11/kernel/shm.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> <span class="comment">/*for current define*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span> <span class="comment">/* PAGE_SIZE,get_free_page */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*function: apply for a shared page, return shm_id according to key*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">void</span>* page;</span><br><span class="line">      <span class="comment">/*printk(&quot;hello, i am here for debug!\n&quot;);*/</span></span><br><span class="line">        <span class="keyword">if</span>(size &gt; PAGE_SIZE) <span class="comment">/*size beyond border*/</span></span><br><span class="line">        &#123;</span><br><span class="line">                printk(<span class="string">&quot;size beyond PAGE_SIZE!\n&quot;</span>);</span><br><span class="line">                errno = EINVAL;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;SHM_SIZE; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(shm_list[i].key == key)   <span class="comment">/*constructed before*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                        printk(<span class="string">&quot;constructed before!\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page = get_free_page();</span><br><span class="line">        <span class="keyword">if</span>(!page)   <span class="comment">/*no free memory*/</span></span><br><span class="line">        &#123;</span><br><span class="line">                printk(<span class="string">&quot;no free page!\n&quot;</span>);</span><br><span class="line">                errno = ENOMEM;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;shmget get memory&#x27;s address is 0x%08x\n&quot;</span>,page);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;SHM_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (!shm_list[i].key) <span class="comment">// record for manage</span></span><br><span class="line">                &#123;</span><br><span class="line">                        shm_list[i].key = key; </span><br><span class="line">                        shm_list[i].page = page;</span><br><span class="line">                        shm_list[i].size = size;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/*shm_list is full and key is invalid*/</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sys_shmat</span><span class="params">(<span class="type">int</span> shmid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> data_base;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> brk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(shmid&lt;<span class="number">0</span> || shmid&gt;=SHM_SIZE || shm_list[shmid].page == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                errno = EINVAL;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data_base = get_base(current-&gt;ldt[<span class="number">2</span>]); <span class="comment">/*I know get_base from copy_mem() function*/</span></span><br><span class="line">        printk(<span class="string">&quot;current data_base = 0x%08x, new page = 0x%08x\n&quot;</span>,data_base,shm_list[shmid].page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk is the end of heap section,</span></span><br><span class="line"><span class="comment">         * the virtual memory space between heap and stack can map to shared physical page,</span></span><br><span class="line"><span class="comment">         * so slice this part of virtual memory to map the shared page */</span></span><br><span class="line">        <span class="comment">/*logic address convert to virtual address by adding base address*/</span></span><br><span class="line">        brk = current-&gt;brk+data_base;</span><br><span class="line">        current-&gt;brk +=PAGE_SIZE;</span><br><span class="line">        put_page(shm_list[shmid].page, brk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)(current-&gt;brk - PAGE_SIZE); <span class="comment">/*logic address*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="wE6Zi"></a></p><h3 id="4-创建生产者进程"><a class="markdownIt-Anchor" href="#4-创建生产者进程"></a> (4) 创建生产者进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span>*, sem_open, <span class="type">const</span> <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, value)</span><br><span class="line">    _syscall1(<span class="type">void</span>, sem_wait, <span class="type">sem_t</span>*, sem)</span><br><span class="line">    _syscall1(<span class="type">void</span>, sem_post, <span class="type">sem_t</span>*, sem)</span><br><span class="line">    _syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span>*, name)</span><br><span class="line"></span><br><span class="line">    _syscall2(<span class="type">int</span>, shmget, <span class="type">unsigned</span> <span class="type">int</span>, key, <span class="type">size_t</span>, size)</span><br><span class="line">    _syscall1(<span class="type">void</span>*, shmat, <span class="type">int</span>, shmid)</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NR_PRODUCTS = <span class="number">50</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHM_KEY = <span class="number">2023</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">int</span>* ptr;  <span class="comment">/*point to the shared memory*/</span></span><br><span class="line">    <span class="type">int</span> i;    <span class="comment">/* products number */</span></span><br><span class="line">    <span class="type">int</span> buffer_pos = <span class="number">0</span>; </span><br><span class="line">    <span class="type">sem_t</span> *mutex, *full, *empty;</span><br><span class="line"></span><br><span class="line">    mutex = sem_open(<span class="string">&quot;MUTEX&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    full = sem_open(<span class="string">&quot;FULL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    empty = sem_open(<span class="string">&quot;EMPTY&quot;</span>,BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    shm_id = shmget(SHM_KEY,BUFFER_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (shm_id == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ptr = (<span class="type">int</span>*)shmat(shm_id)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NR_PRODUCTS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(empty);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        ptr[buffer_pos] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid %d:\tproducer produces product %d\n&quot;</span>, getpid(), i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(full);</span><br><span class="line"></span><br><span class="line">        buffer_pos = (buffer_pos+<span class="number">1</span>)%BUFFER_SIZE;  <span class="comment">/*end of the buffer,refresh*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="GfZrr"></a></p><h3 id="5-创建消费者进程"><a class="markdownIt-Anchor" href="#5-创建消费者进程"></a> (5) 创建消费者进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span>*, sem_open, <span class="type">const</span> <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, value)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_wait, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_post, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span>*, name)</span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">int</span>, shmget, <span class="type">unsigned</span> <span class="type">int</span>, key, <span class="type">size_t</span>, size)</span><br><span class="line">_syscall1(<span class="type">void</span>*, shmat, <span class="type">int</span>, shmid)</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_PRODUCTS = <span class="number">50</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHM_KEY = <span class="number">2023</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">    <span class="type">int</span> used_cnt = <span class="number">0</span>; <span class="comment">/*products count*/</span></span><br><span class="line">    <span class="type">int</span> buffer_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">sem_t</span> *mutex, *full, *empty;</span><br><span class="line">mutex = sem_open(<span class="string">&quot;MUTEX&quot;</span>,<span class="number">1</span>);</span><br><span class="line">full = sem_open(<span class="string">&quot;FULL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">empty = sem_open(<span class="string">&quot;EMPTY&quot;</span>,BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    shm_id = shmget(SHM_KEY,BUFFER_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (shm_id == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ptr = (<span class="type">int</span>*)shmat(shm_id)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(full);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid %d consumer consumes products %d\n&quot;</span>,getpid(),ptr[buffer_pos]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(empty);</span><br><span class="line"></span><br><span class="line">        buffer_pos = (buffer_pos+<span class="number">1</span>)%BUFFER_SIZE;  <span class="comment">/*end of the buffer,refresh*/</span></span><br><span class="line">        <span class="keyword">if</span>(++used_cnt == NR_PRODUCTS) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_unlink(<span class="string">&quot;EMPTY&quot;</span>);</span><br><span class="line">    sem_unlink(<span class="string">&quot;MUTEX&quot;</span>);</span><br><span class="line">    sem_unlink(<span class="string">&quot;FULL&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="krol7"></a></p><h3 id="6-添加到系统调用和修改makefile"><a class="markdownIt-Anchor" href="#6-添加到系统调用和修改makefile"></a> (6) 添加到系统调用和修改MakeFile</h3><ol><li>添加到系统调用</li></ol><p>如之前的lab一样，验证结果时将unistd.h复制到hdc/usr/include目录下，记得将shm.h也复制到对应目录中<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520527179-52dba4f9-2fca-42f4-a647-f84bcc96483c.png#averageHue=%23020101&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=283&amp;id=u569df7d6&amp;originHeight=378&amp;originWidth=1131&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=78872&amp;status=done&amp;style=none&amp;taskId=udd4d35b1-2183-47dc-b07a-d9ed4a2cf95&amp;title=&amp;width=846.1817626953125" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520564992-dc556e6f-47fa-458d-8125-5a2f99510aa5.png#averageHue=%230a0908&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=368&amp;id=u9b1b2c93&amp;originHeight=652&amp;originWidth=1557&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=184908&amp;status=done&amp;style=none&amp;taskId=u80068af6-8005-48d8-9237-55e59b18553&amp;title=&amp;width=877.6334228515625" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520600836-449dd10e-b55b-47f2-bf13-145e43483016.png#averageHue=%23040202&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=334&amp;id=u2a625bd5&amp;originHeight=436&amp;originWidth=1164&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=89550&amp;status=done&amp;style=none&amp;taskId=u7b41d7f9-6266-4a0a-a74f-eccd206e206&amp;title=&amp;width=892.1817626953125" alt="image.png" /></p><ol start="2"><li>修改MakeFile</li></ol><p><code>linux-0.11/kernel/Makefile</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520876366-81586b4c-c432-4e3c-8e53-e64cff3cdaa4.png#averageHue=%23050404&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=152&amp;id=u00d33052&amp;originHeight=167&amp;originWidth=1093&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=25627&amp;status=done&amp;style=none&amp;taskId=ubd76bfd9-0a7c-475b-a3b2-3b08f53f50f&amp;title=&amp;width=993.636342099876" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520946452-d6ac0a1c-64c6-4e8e-9d73-1d25e0cceeb8.png#averageHue=%23080706&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=221&amp;id=u609f0929&amp;originHeight=385&amp;originWidth=1891&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=110463&amp;status=done&amp;style=none&amp;taskId=u7504a2f2-1ac2-4237-a4ad-93c287b33b0&amp;title=&amp;width=1086.6334228515625" alt="image.png" /><br /><a name="eTe1e"></a></p><h3 id="7-踩的坑"><a class="markdownIt-Anchor" href="#7-踩的坑"></a> (7) 踩的坑</h3><ol><li>编译shm.c时，总是出现<code>parse error before int</code>的错误，耗时调试了一个小时还是无法解决，Google后发现原因在于linux0.11下的C标准为C89，要求声明变量的语句只能出现在非声明语句的前面 (声明同时又赋值语句的可以)</li><li>lab5的sem.c写的有问题，consumer进程一直处于sleep状态，添加了几条打印语句后发现，consumer进程和producer进程未使用同一套信号量，原因在于sem.c的sys_sem_open函数内定义kernel_sem_name未显式的初始化，我以为该变量会<a href="https://stackoverflow.com/questions/18688971/c-char-array-initialization-what-happens-if-there-are-less-characters-in-the-st">默认初始化为0值</a> (‘\0’)，但在c89的标准下，未显式初始化的字符数组不会被默认初始化，这将导致未知的行为，发现这点花了我不少时间。在显式初始化<code>char kernel_sem_name[25]=&#123;&quot;\0&quot;&#125;;</code>后结果正确</li><li>consumer进程会出现&quot;kernel panic: trying to free free page&quot;，出现这个问题的原因是producer进程和consumer进程共用一个页面，producer生产完全部产品后先退出同时释放共享内存，这将导致consumer进程退出时试图释放已经释放的页面，解决方法是注释掉memery.c文件中free_page函数中的相关panic语句</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520309825-394372a9-02a9-4c5f-9dc2-58ee03e3ed95.png#averageHue=%23050403&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=525&amp;id=ufc7965e9&amp;originHeight=577&amp;originWidth=1085&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=113475&amp;status=done&amp;style=none&amp;taskId=ub39a6e29-54eb-479a-974d-29d06b20ef8&amp;title=&amp;width=986.3636149847807" alt="image.png" /><br /><a name="LfbWf"></a></p><h2 id="3-验证结果"><a class="markdownIt-Anchor" href="#3-验证结果"></a> 3. 验证结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682510527892-a3dc49b2-e1cb-46bb-96c5-fe0e7e047d40.png#averageHue=%23272726&amp;clientId=uba223810-dc1f-4&amp;from=paste&amp;height=452&amp;id=u977d19ee&amp;originHeight=508&amp;originWidth=779&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=43535&amp;status=done&amp;style=none&amp;taskId=u31918d60-b5af-4e51-a992-7b44e3423cc&amp;title=&amp;width=693.116455078125" alt="image.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./mount-hdc</span><br><span class="line">cp hdc/usr/root/c_output c_output.txt</span><br><span class="line">cp hdc/usr/root/p_output p_output.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682510598690-ebda0760-043b-4bd9-b4bc-9f315b8a4cba.png#averageHue=%23090807&amp;clientId=uba223810-dc1f-4&amp;from=paste&amp;height=358&amp;id=uc2dd2f1e&amp;originHeight=590&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=125426&amp;status=done&amp;style=none&amp;taskId=uf6ab358f-a3c6-4563-94bb-da662b0e4e8&amp;title=&amp;width=611.5151161705297" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682510624205-9d8041cb-2d82-441f-b820-b7426cf66505.png#averageHue=%230e0c0b&amp;clientId=uba223810-dc1f-4&amp;from=paste&amp;height=383&amp;id=ub33ee8cf&amp;originHeight=632&amp;originWidth=911&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=128917&amp;status=done&amp;style=none&amp;taskId=ue065134f-aa21-4611-a01c-608e7acf726&amp;title=&amp;width=552.1211802094673" alt="image.png" /><br /><a name="af4rt"></a></p><h1 id="实验7-终端设备的控制"><a class="markdownIt-Anchor" href="#实验7-终端设备的控制"></a> 实验7 终端设备的控制</h1><p><a name="DOBmZ"></a></p><h2 id="1-添加新的f12响应函数"><a class="markdownIt-Anchor" href="#1-添加新的f12响应函数"></a> 1. 添加新的f12响应函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> switch_by_f12_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">press_f12_handle</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (switch_by_f12_flag) &#123;</span><br><span class="line">        switch_by_f12_flag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        switch_by_f12_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683088730582-9f8b8b48-b558-4aa7-89bf-e102157de2fd.png#averageHue=%232a2e37&amp;clientId=u3918d10e-6997-4&amp;from=paste&amp;height=233&amp;id=ub2b26a91&amp;originHeight=349&amp;originWidth=878&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=54042&amp;status=done&amp;style=none&amp;taskId=uc6734c4c-d973-4e3e-a381-9fccec6e2d4&amp;title=&amp;width=585.3333333333334" alt="image.png" /><br /><a name="uYQSo"></a></p><h2 id="2-设置响应函数入口"><a class="markdownIt-Anchor" href="#2-设置响应函数入口"></a> 2. 设置响应函数入口</h2><p>键盘输入后，操作系统会将键盘扫描码做为下标，调用key_table函数数组中保存的与该按键对应的响应函数，因此要让CPU在按下f12之后跳转到新的响应函数执行需要修改key_table，从该数组一旁的注释就可以看出f12对应的scan code是88D (58H)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683098473823-070b4fb1-1f7a-4a45-9cb0-961bb203c5c9.png#averageHue=%232a2e38&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=135&amp;id=u7de7afa4&amp;originHeight=202&amp;originWidth=1049&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=54945&amp;status=done&amp;style=none&amp;taskId=ub84941cf-e8e4-4871-8ba7-82283d9a8a6&amp;title=&amp;width=699.3333333333334" alt="image.png" /><br /><a name="deXFF"></a></p><h2 id="3-修改con_write函数"><a class="markdownIt-Anchor" href="#3-修改con_write函数"></a> 3. 修改con_write函数</h2><p>con_write函数执行最终的输出显示器操作，该函数先用GETCH从输出缓冲区中提取一个字节字符到变量<code>c</code>，再写入显存中。我们根据flag修改变量<code>c</code>的值即可，为了实验结果更可观，我们选择只对字母和数字的输出进行转换<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683099712562-f91a9cf7-9e84-48c2-93e3-579a4f5ae4b5.png#averageHue=%23292e37&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=319&amp;id=u15b1877a&amp;originHeight=479&amp;originWidth=1191&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=81623&amp;status=done&amp;style=none&amp;taskId=uaa55ccf7-f1cd-41f6-8464-e0155d69970&amp;title=&amp;width=794" alt="image.png" /><br /><a name="EB7eC"></a></p><h2 id="4-修改ttyh"><a class="markdownIt-Anchor" href="#4-修改ttyh"></a> 4. 修改tty.h</h2><p>在头文件中包含<code>switch_by_f12_flag</code>变量和响应函数的声明，以便在其他文件中使用<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683098924984-6c3708f3-4872-4e7b-ad63-08a64288554e.png#averageHue=%232a2f39&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=281&amp;id=uf5d8217e&amp;originHeight=422&amp;originWidth=874&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=72774&amp;status=done&amp;style=none&amp;taskId=u57c1131d-6702-4fab-a6e7-85f3a862c71&amp;title=&amp;width=582.6666666666666" alt="image.png" /><br /><a name="eWnw0"></a></p><h2 id="5-验证结果-2"><a class="markdownIt-Anchor" href="#5-验证结果-2"></a> 5. 验证结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683100157855-0a67f662-2689-4526-8f5e-9a36485b54a8.png#averageHue=%23d6b078&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=361&amp;id=ucf7e2da6&amp;originHeight=542&amp;originWidth=921&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=48978&amp;status=done&amp;style=none&amp;taskId=uf25e680f-9f62-495d-9d8a-e452c1bff0f&amp;title=&amp;width=614" alt="image.png" /><br /><a name="LY6DX"></a></p><h1 id="实验8-proc文件系统的实现"><a class="markdownIt-Anchor" href="#实验8-proc文件系统的实现"></a> 实验8 proc文件系统的实现</h1><p><a name="wqaCO"></a></p><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><p><a name="SCacJ"></a></p><h3 id="vsprintf函数"><a class="markdownIt-Anchor" href="#vsprintf函数"></a> vsprintf函数</h3><p>vsprintf 是一个C库函数，用于将可变参数列表（va_list）中的值格式化为字符串，并将结果字符串存储在指定的字符数组（缓冲区）中。vsprintf 是 sprintf 函数的可变参数版本，通常在需要处理可变数量参数的情况下使用。<br />vsprintf 函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>str：指向目标字符数组（缓冲区）的指针，用于存储格式化后的字符串。</li><li>format：一个格式字符串，它描述了如何将参数列表中的值格式化为字符串。格式字符串可以包含普通字符和转换说明符（例如 %d、%s 等）。</li><li>ap：一个 va_list 类型的参数列表，用于存储需要格式化的值。</li></ol><p>返回值：vsprintf 函数返回写入目标字符数组（不包括最后的空字符）的字符数。如果发生错误，返回负值。<br />因为该函数接受一个va_list类型的参数而不是一个通常使用的可变参数，因此我们要使用va_start函数获取一个va_list的参数<br />va_start 是C语言标准库中的一个宏，用于处理可变参数列表。va_start 用于在可变参数函数中初始化一个 va_list 类型的变量，使其指向传入的第一个可变参数。通常与 va_arg 和 va_end 宏一起使用，分别用于访问可变参数列表中的参数和完成参数列表的处理 (va_end释放为 va_list 类型的变量分配的资源)。<br />va_start 宏的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list ap, last_arg)</span>;</span><br></pre></td></tr></table></figure><ol><li>ap：一个 va_list 类型的变量，用于存储指向可变参数列表的状态。</li><li>last_arg：函数参数列表中最后一个<strong>固定参数</strong>的名称 (可变参数在固定参数之后)。在初始化 va_list 时，va_start 会找到此固定参数在内存中的位置，从而确定可变参数列表的起始位置。<br /><a name="HKqfx"></a></li></ol><h3 id="mknod系统调用"><a class="markdownIt-Anchor" href="#mknod系统调用"></a> mknod系统调用</h3><p>mknod 系统调用用于创建特殊文件（设备文件）在文件系统中。特殊文件通常用于表示设备，如字符设备和块设备。字符设备通常用于表示可逐字符读写的设备，如终端设备；块设备通常用于表示可按块读写的设备，如磁盘设备。本实验用它来创建proc文件。<br />mknod 系统调用的主要参数包括：</p><ol><li>路径名（pathname）：要创建的特殊文件的路径名。</li><li>文件模式（mode）：描述新创建的特殊文件类型和权限的位掩码。文件类型可以是字符设备（S_IFCHR）或块设备（S_IFBLK）。</li><li>设备号（dev）：设备号用于唯一标识设备。通常分为主设备号和次设备号。主设备号用于标识设备类型或驱动程序，而次设备号用于标识同一类型设备的实例。</li></ol><p>当调用 mknod 系统调用时，操作系统会执行以下操作：</p><ol><li>根据提供的路径名找到目标目录。</li><li>在目标目录中创建一个新的目录项，设置其文件名和 inode 号(更新目录树)。</li><li>分配一个新的 inode，并将其与目录项关联。</li><li>设置 inode 的属性，如文件类型（字符设备或块设备）、权限和设备号等。</li><li>更新文件系统元数据，如目录和 inode 的更改时间等。</li></ol><p>创建特殊文件后，应用程序可以使用设备文件与相应的设备进行通信。例如，通过 open、read、write 和 ioctl 系统调用与设备驱动程序进行交互。这使得设备操作看起来与普通文件操作相似，简化了应用程序的开发。<br /><a name="L6DWu"></a></p><h2 id="添加proc类型文件"><a class="markdownIt-Anchor" href="#添加proc类型文件"></a> 添加proc类型文件</h2><p>OS根据文件类型选择不同处理函数，从而实现对不同类型的文件的操作，我们先在linux0.11中添加proc类型文件，之后再编写对应的处理函数就能完成proc文件系统的添加了。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683344038857-05b21492-6ac6-44e0-b550-cfa4e091c11f.png#averageHue=%232a2f39&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=453&amp;id=ub1b8ac4b&amp;originHeight=566&amp;originWidth=939&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=117376&amp;status=done&amp;style=none&amp;taskId=u902c17e5-7d02-45ea-a89f-cb91bafcf81&amp;title=&amp;width=751.2" alt="image.png" /><br /><a name="J0puW"></a></p><h2 id="修改mknod系统调用"><a class="markdownIt-Anchor" href="#修改mknod系统调用"></a> 修改mknod系统调用</h2><p>我们已经提到，mknod用于创建特殊文件，即块设备文件和字符流文件。现在我们要给它添加对proc文件的支持。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683344565695-25d10cda-e3c2-4db0-b456-342d34252c93.png#averageHue=%232c333d&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=148&amp;id=u81eb111d&amp;originHeight=185&amp;originWidth=955&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42267&amp;status=done&amp;style=none&amp;taskId=u5e6d4240-b9ac-400f-8674-5c86c82cae3&amp;title=&amp;width=764" alt="image.png" /><br /><a name="Z3MKP"></a></p><h2 id="创建proc目录文件proc普通文件"><a class="markdownIt-Anchor" href="#创建proc目录文件proc普通文件"></a> 创建proc目录文件，proc普通文件</h2><p>在系统初始化时，根目录文件挂载之后 (这样传递给mknod的路径才有效)，创建proc文件系统的目录文件和文件。<br />因为此时在用户态，因此要通过添加系统调用的方式使用mkdir和mknod，而不能直接使用sys_mkdir和sys_mknod<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683346720336-d633b22f-bc22-4b07-a373-54bac4c02511.png#averageHue=%232a2f39&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=169&amp;id=u77aca2e7&amp;originHeight=211&amp;originWidth=1192&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=54630&amp;status=done&amp;style=none&amp;taskId=ua835db87-8c11-40fc-8647-5f478bb0d3a&amp;title=&amp;width=953.6" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683344746244-3a83df22-0727-478b-b33c-7629995477af.png#averageHue=%232a2f39&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=386&amp;id=uf6850421&amp;originHeight=483&amp;originWidth=992&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=106228&amp;status=done&amp;style=none&amp;taskId=ua5ef05d2-fdcd-43b0-8e65-129289cd21d&amp;title=&amp;width=793.6" alt="image.png" /><br /><a name="gW5xS"></a></p><h2 id="验证文件是否创建成功"><a class="markdownIt-Anchor" href="#验证文件是否创建成功"></a> 验证文件是否创建成功</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683345269096-07a4e3fa-4d74-4671-b7b4-8788f81f56f1.png#averageHue=%231c1c1c&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=179&amp;id=ubff94101&amp;originHeight=224&amp;originWidth=525&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=9192&amp;status=done&amp;style=none&amp;taskId=u6a360e8c-a94f-4bb8-b4d0-bef4f08b435&amp;title=&amp;width=420" alt="image.png" /><br />可以看到，我们已经成功在根目录下创建了proc目录文件，并在该文件下创建了proc普通文件，这三个文件分别表示系统进程信息，系统硬件信息，系统存储信息<br />这里使用cat输出了一行信息和一行报错，要明白这两条信息怎么来的，首先要知道cat命令背后执行了什么操作: 用sys_open打开一个文件，用sys_read将文件内容读入缓冲区，最后用printf打印缓冲区的内容到屏幕上<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683345351627-af875807-b6e7-4414-87dc-3931056261db.png#averageHue=%23fefbf6&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=114&amp;id=u0eb7e43e&amp;originHeight=142&amp;originWidth=741&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=60182&amp;status=done&amp;style=none&amp;taskId=u5688375e-3cee-4ccd-8b3f-87e4ee3d67a&amp;title=&amp;width=592.8" alt="image.png" /><br />通过查看sys_read的源码，我们可以找到这两条信息的来源。当sys_read打开proc类型文件没有对应的处理函数时，就会出现这两条信息，因此我们接下来为proc类型文件编写对应的处理函数proc_read即可<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683345501591-9a30e972-a450-4a62-b646-c3cf609c774a.png#averageHue=%232a303a&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=574&amp;id=ub3f0c372&amp;originHeight=718&amp;originWidth=1163&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=158548&amp;status=done&amp;style=none&amp;taskId=ua74627e7-72f8-428b-9e9d-f492c9565ed&amp;title=&amp;width=930.4" alt="image.png" /><br />为proc文件添加处理分支<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683359020684-3518ed23-5359-432a-be5e-d9fa88f8691e.png#averageHue=%232a2f38&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=193&amp;id=u47a43b1e&amp;originHeight=241&amp;originWidth=1203&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47427&amp;status=done&amp;style=none&amp;taskId=ue8f26e3f-5760-413d-8759-456062cf094&amp;title=&amp;width=962.4" alt="image.png" /><br /><a name="PNhv9"></a></p><h2 id="编写proc文件处理函数"><a class="markdownIt-Anchor" href="#编写proc文件处理函数"></a> 编写proc文件处理函数</h2><p>添加<code>linux-0.11/fs/proc_read.c</code>，这里只完成了进程信息的获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span>  <span class="comment">// put_fs_byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span>  <span class="comment">// process-related variables: task struct, FIRST_TASK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>       <span class="comment">//  vs_start va_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> krnbuf[<span class="number">1024</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// initalize args to first changeable parameter</span></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="comment">// vsprintf function returns the number of characters written to the buffer</span></span><br><span class="line">    i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_psinfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> buf_offset = <span class="number">0</span>;</span><br><span class="line">    buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;pid\tstate\tfather\tcounter\tstart_time\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;LAST_TASK; p &gt;= &amp;FIRST_TASK; --p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;pid);</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;state);</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;father);</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;counter);</span><br><span class="line">            buf_offset +=</span><br><span class="line">                <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\n&quot;</span>, (*p)-&gt;start_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_read</span><span class="params">(<span class="type">int</span> dev, <span class="type">off_t</span> *pos, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (*pos / BLOCK_SIZE == <span class="number">0</span>)  <span class="comment">// already read a whole block, start write</span></span><br><span class="line">    &#123;</span><br><span class="line">        get_psinfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (krnbuf[*pos + i] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;  <span class="comment">// end of message</span></span><br><span class="line">        put_fs_byte(krnbuf[*pos + i],</span><br><span class="line">                    buf + i + *pos);  <span class="comment">// synchronous replication</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pos += i; <span class="comment">// change f_pos</span></span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// return the actual number of bytes read</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ej6HQ"></a></p><h2 id="修改makefile"><a class="markdownIt-Anchor" href="#修改makefile"></a> 修改Makefile</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683359075672-0ca43074-35e7-4167-97fa-921965a0eee0.png#averageHue=%232b3038&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=290&amp;id=u7d54a842&amp;originHeight=362&amp;originWidth=1110&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=63292&amp;status=done&amp;style=none&amp;taskId=u92de2be4-4696-4b77-b24a-9546f172053&amp;title=&amp;width=888" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683359107388-9a8e3ccf-81d7-4d45-b5ff-0eadbe9eaf32.png#averageHue=%232f353f&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=138&amp;id=uef988170&amp;originHeight=173&amp;originWidth=1139&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38277&amp;status=done&amp;style=none&amp;taskId=u4190510b-24d2-419c-b480-af056ec9165&amp;title=&amp;width=911.2" alt="image.png" /><br /><a name="GwS7w"></a></p><h2 id="验证结果"><a class="markdownIt-Anchor" href="#验证结果"></a> 验证结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683358947951-c0766d83-d70a-46b7-8dbd-f0880676086b.png#averageHue=%23202020&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=394&amp;id=u29a576cb&amp;originHeight=493&amp;originWidth=801&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=24025&amp;status=done&amp;style=none&amp;taskId=u18bf1a2d-4fd4-431e-a56b-c40069b6f49&amp;title=&amp;width=640.8" alt="image.png" /><br /><a href="https://www.cnblogs.com/mirage-mc/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/">reference</a></p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
          <category> HIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu界面Mac化</title>
      <link href="/2023/03/27/ubuntu_mac/"/>
      <url>/2023/03/27/ubuntu_mac/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>最终效果:<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904915178-2b8d446d-4d5f-42d7-9850-d5a4c0dc0bcf.png#averageHue=%232dc92b&amp;clientId=u8ce3d915-14ae-4&amp;from=paste&amp;height=565&amp;id=ueeea8242&amp;name=image.png&amp;originHeight=848&amp;originWidth=1914&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=159245&amp;status=done&amp;style=none&amp;taskId=u5fb92b60-b558-40fb-9a44-b1f4da5e687&amp;title=&amp;width=1276" alt="image.png" /></p><h1 id="1-安装gnome-tweaks"><a class="markdownIt-Anchor" href="#1-安装gnome-tweaks"></a> 1. 安装GNOME Tweaks</h1><p>这个软件可以让你配置Ubuntu的交互界面，你可以在Ubuntu自带的由GNOME Software 下载<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679900946204-c742a5d9-a91a-4b67-8a85-b82a66b80d98.png#averageHue=%235e5e5e&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u117233a8&amp;name=image.png&amp;originHeight=743&amp;originWidth=1084&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=75219&amp;status=done&amp;style=none&amp;taskId=uaaab7274-262a-40dc-b6b7-e1858e9749d&amp;title=&amp;width=568.760009765625" alt="image.png" /></p><span id="more"></span><p><a name="i6Rr5"></a></p><h1 id="2下载安装模拟mac风格的交互界面主题whitesur-gtk-theme"><a class="markdownIt-Anchor" href="#2下载安装模拟mac风格的交互界面主题whitesur-gtk-theme"></a> 2.下载安装模拟Mac风格的交互界面主题<a href="https://github.com/vinceliuice/WhiteSur-gtk-theme">WhiteSur-gtk-theme</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vinceliuice/WhiteSur-gtk-theme.git</span><br><span class="line"><span class="built_in">cd</span> WhiteSur-gtk-theme</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p><a name="dH9pb"></a></p><h1 id="3-下载mac图标集"><a class="markdownIt-Anchor" href="#3-下载mac图标集"></a> 3. 下载Mac图标集</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vinceliuice/WhiteSur-icon-theme</span><br><span class="line"><span class="built_in">cd</span>  WhiteSur-icon-theme</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p><a name="cwXmK"></a></p><h1 id="4-解除gnome-tweak-tool-中的扩展禁用状态"><a class="markdownIt-Anchor" href="#4-解除gnome-tweak-tool-中的扩展禁用状态"></a> 4. 解除Gnome Tweak Tool 中的扩展禁用状态</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901490751-dac0bd23-34aa-40db-a176-024e2f42459f.png#averageHue=%234d4c4c&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=400&amp;id=u37ab7a7f&amp;name=image.png&amp;originHeight=625&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=100597&amp;status=done&amp;style=none&amp;taskId=u1f3960dc-937b-4e46-b496-68fe90b71d4&amp;title=&amp;width=668.16" alt="image.png" /><br />安装<code>chrome-gnome-shell</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure><p>接着跳转到<a href="https://extensions.gnome.org/extension/19/user-themes/">User Themes</a><br />安装该插件并开启<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901620872-e69d3a78-b565-4b13-9736-46750d55fe6b.png#averageHue=%23fcfcfb&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=272&amp;id=uaa079ca5&amp;name=image.png&amp;originHeight=425&amp;originWidth=1447&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=60616&amp;status=done&amp;style=none&amp;taskId=uf904ddd5-8741-44fd-b6ad-7a7442b5c3c&amp;title=&amp;width=926.08" alt="image.png" /><br />解决<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679901649198-a2f7d303-960f-4b35-b96e-0bc7c8ae464b.png#averageHue=%23353534&amp;clientId=ud601214a-d7ed-4&amp;from=paste&amp;height=390&amp;id=u3191091d&amp;name=image.png&amp;originHeight=609&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=76490&amp;status=done&amp;style=none&amp;taskId=u79e6d1ca-ed2a-420f-9c0b-caec1b63807&amp;title=&amp;width=668.16" alt="image.png" /></p><p><a name="p4iNI"></a></p><h1 id="5-安装mac风格的dock"><a class="markdownIt-Anchor" href="#5-安装mac风格的dock"></a> 5. 安装Mac风格的Dock</h1><p>安装并开启<a href="https://extensions.gnome.org/extension/307/dash-to-dock/">Dash to Dock</a>，并可自行设置Dock样式<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679903078052-658ae42a-c311-4990-93f7-dc8700c3ddb5.png#averageHue=%23696969&amp;clientId=u33b15efd-72b8-4&amp;from=paste&amp;height=437&amp;id=ub859c8a3&amp;name=image.png&amp;originHeight=683&amp;originWidth=1385&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=168939&amp;status=done&amp;style=none&amp;taskId=u7cf1d85f-9a5e-4770-8407-ce5971d3b0b&amp;title=&amp;width=886.4" alt="image.png" /></p><p><a name="EAoF9"></a></p><h1 id="6-将交通灯移动到窗口右侧"><a class="markdownIt-Anchor" href="#6-将交通灯移动到窗口右侧"></a> 6. 将交通灯移动到窗口右侧</h1><p>在GNOME Tweaks -&gt; Window Titlebars -&gt; Left<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679904374525-112bf886-c3ed-4b08-8636-460188802e21.png#averageHue=%23393938&amp;clientId=u053a5944-acf3-4&amp;from=paste&amp;height=429&amp;id=u3ec2f613&amp;name=image.png&amp;originHeight=643&amp;originWidth=1066&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=79002&amp;status=done&amp;style=none&amp;taskId=u3d4a3f13-0d2f-4d62-9dff-3a863f75003&amp;title=&amp;width=710.6666666666666" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> gadget </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] cachelab</title>
      <link href="/2023/03/16/CSAPP-Lab/cachelab/"/>
      <url>/2023/03/16/CSAPP-Lab/cachelab/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><a name="HHpvX"></a><h1 id="lab4-cachelab"><a class="markdownIt-Anchor" href="#lab4-cachelab"></a> lab4 cachelab</h1><span id="more"></span><h2 id="1-要做什么"><a class="markdownIt-Anchor" href="#1-要做什么"></a> 1. 要做什么</h2><ol><li>组索引位数 -s  （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">S = 2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span>为高速缓存组的组数）</li><li>高速缓存行数 -E</li><li>块偏移位数 -b （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B = 2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>为高速缓存块的大小）</li></ol><p>根据内存访问记录，输出每条访问的结果（hit/miss/evict)，输出操作通过调用<code>printSummary(hit_count, miss_count, eviction_count)</code>函数完成，输出结果应当与作者提供给我们的<code>reference cache simulator</code>相同，运行<code>make</code>+<code>./test-csim</code>获取评分<br /><a name="i3aH1"></a></p><h2 id="2-getopt函数的用法"><a class="markdownIt-Anchor" href="#2-getopt函数的用法"></a> 2. getopt函数的用法</h2><p>由于三个参数通过命令行输入，因此我们需要通过C语言库中的<code>getopt</code>函数，结合switch语句从命令行中获取参数值 <br />C语言中的<code>main</code>函数是程序的入口函数，它包含两个参数：<code>argc</code>和<code>argv</code>。它们的作用如下：</p><ol><li>argc参数</li></ol><p>argc参数表示程序运行时命令行参数的个数（argument count），包括程序名本身。因此，argc的值至少为1，即第一个参数是程序名本身。如果程序没有接受任何命令行参数，则argc的值为1。</p><ol start="2"><li>argv参数</li></ol><p>argv参数是一个字符串指针数组（argument vector），每个元素指向一个命令行参数。其中，argv[0]指向程序名本身，argv[1]、argv[2]等等依次指向后续的命令行参数。<br />通过argc和argv参数，程序可以接收命令行传递的参数，从而实现更加灵活和可配置的功能。例如，可以通过命令行参数指定程序要处理的文件名、程序要使用的配置文件、程序要输出的日志级别等等。程序可以根据不同的命令行参数采取不同的行为，从而实现更加灵活和可配置的功能。<br />C语言中的<code>getopt</code>函数可以帮助程序解析命令行参数。<code>getopt</code>函数通常与<code>argc</code>和<code>argv</code>参数一起使用，可以从命令行中提取选项和参数，并根据需要执行相应的操作。以下是<code>getopt</code>函数的一般用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;abc:d&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -a\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -b\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -c with value &#x27;%s&#x27;\n&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -d\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Unknown option: %c\n&quot;</span>, optopt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>getopt</code>函数的第一个参数是<code>argc</code>，第二个参数是<code>argv</code>，第三个参数是一个字符串，它包含可接受的选项和参数信息。在这个字符串中，每个字符表示一个选项，如果这个选项需要接受一个参数，则在后面加上一个冒号。例如，<code>&quot;abc:d&quot;</code>表示可接受的选项有<code>-a</code>、<code>-b</code>、<code>-c</code>和<code>-d</code>，其中<code>-c</code>选项需要接受一个参数。<br /><code>getopt</code>函数会循环遍历命令行中的所有选项，每次返回一个选项和其参数（如果有）。在循环中，使用<code>switch</code>语句根据选项进行相应的操作。如果<code>getopt</code>函数发现了一个未知的选项，它会返回<code>?</code>,并将这个选项保存在<code>optopt</code>变量中。<br />以下是一些示例命令行及其对应的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out -a -b -c filename -d</span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Option -c with value <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">Option -d</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out -a -b -c</span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Unknown option: c</span><br></pre></td></tr></table></figure><p>在使用<code>getopt</code>函数时，需要注意以下几点：</p><ol><li>在循环中，<code>optarg</code>变量保存当前选项的参数（如果有），可以通过这个变量获取参数的值。变量类型为字符串，可通过<code>atoi</code>函数转化为整型。</li><li>如果一个选项需要接受一个参数，但是没有给出参数，或者参数不合法，<code>getopt</code>函数会返回<code>?</code>，并将这个选项保存在<code>optopt</code>变量</li><li>如果一个选项在可接受的选项字符串中没有指定，<code>getopt</code>函数会返回<code>-1</code>，并结束循环</li></ol><p><code>getopt</code>函数的第三个参数是一个字符串，用于指定程序支持的命令行选项和参数。<br />虽然<code>getopt</code>函数可以遍历所有命令行参数，但是在不指定可接受选项字符串的情况下，<code>getopt</code>函数不知道哪些参数是选项，哪些是参数，也不知道选项是否需要参数。指定<br />可接受选项字符串可以告诉<code>getopt</code>函数哪些选项是合法的，以及它们是否需要参数，从而使<code>getopt</code>函数能够正确地解析命令行参数。接受选项字符串的格式为一个字符串，由选项和参数组成，每个选项用一个字符表示，如果选项需要参数，则在选项字符后面跟一个冒号。例如，字符串<code>&quot;ab:c&quot;</code>表示程序支持三个选项<code>-a</code>、<code>-b</code>和<code>-c</code>, 其中<code>-c</code>选项需要一个参数。<br /><a name="kBmQw"></a></p><h2 id="3-fscanf的用法"><a class="markdownIt-Anchor" href="#3-fscanf的用法"></a> 3. fscanf的用法</h2><p><code>fscanf</code>是C语言标准库中的一个函数，它可以从一个文件中读取格式化数据，并将读取的结果存储到指定的变量中，该函数返回成功填充参数列表的项目数。<code>fscanf</code>函数的基本格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>其中，第一个参数<code>stream</code>是指向要读取数据的文件的指针；第二个参数<code>format</code>是一个字符串，用于指定读取数据的格式；第三个及之后的参数是要读取数据的变量名。<br />例如，如果你有一个文件<code>data.txt</code>，里面包含了三个整数，每个整数之间用空格分隔，你可以使用下面的代码将这些整数读取到三个变量<code>a</code>、<code>b</code>、<code>c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>fscanf</code>函数的第一个参数是文件指针<code>fp</code>，第二个参数是格式化字符串<code>&quot;%d %d %d&quot;</code>，它表示要读取三个整数，每个整数之间用空格分隔。第三个、第四个和第五个参数分别是三个整数变量<code>a</code>、<code>b</code>、<code>c</code>的地址，<code>fscanf</code>函数将读取到的整数存储到这些变量中。最后，我们打印出这些变量的值，以检查是否正确读取了文件中的数据。<br /><a name="dKoHs"></a></p><h2 id="4-编写程序"><a class="markdownIt-Anchor" href="#4-编写程序"></a> 4. 编写程序</h2><p>这个实验不是真的让你去实现一个cache，而是让你编写一个能对访问记录进行应答的程序，这也是为什么writeup里强调所有的内存访问操作所需的块都不会超过行的容量<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1678952903754-2052873c-6eb8-47c2-84e6-48ae84c0df8f.png" alt="yuque_diagram.png" /></p><ol><li>cache结构声明</li></ol><p>cache本质上是一个2D array，因此我们在结构体中声明一个指向二维数组的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cache_line</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> valid_bit;</span><br><span class="line"><span class="type">int</span> tag;</span><br><span class="line">    <span class="type">int</span> time_stamp;</span><br><span class="line">&#125;cache_line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> S;</span><br><span class="line"><span class="type">int</span> E;</span><br><span class="line"><span class="type">int</span> B;</span><br><span class="line">cache_line** Cache; </span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure><ol start="2"><li>main</li></ol><p>主要在于正确解析命令行参数，会用<code>getopt</code>就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span>hit_count = <span class="number">0</span>, miss_count = <span class="number">0</span>, eviction_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s, E, b,opt;</span><br><span class="line">    <span class="type">char</span>* trace_name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">30</span>);</span><br><span class="line">    cache* my_cache;</span><br><span class="line">    <span class="keyword">while</span>((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;s:E:b:t:&quot;</span>))!= <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">   s = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">   E = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">   b = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">   <span class="built_in">strcpy</span>(trace_name,optarg);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;unknown option: %c\n&quot;</span>,optopt);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     my_cache = <span class="built_in">construct_cache</span>(s,E,b);</span><br><span class="line">     <span class="built_in">access_cache</span>(my_cache, s, b, trace_name, &amp;hit_count, &amp;miss_count, &amp;eviction_count);</span><br><span class="line">     <span class="built_in">free_cache</span>(my_cache);</span><br><span class="line">     <span class="built_in">printSummary</span>(hit_count, miss_count, eviction_count);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>construct_cache</li></ol><p>根据输入的命令行参数<code>s</code>,<code>E</code>,<code>b</code>构造cache，并初始化每一个高速缓存行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cache* <span class="title">construct_cache</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cache* my_cache =(cache*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(cache));  <span class="comment">// construct Cache</span></span><br><span class="line"> my_cache-&gt;S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line"> my_cache-&gt;B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line"> my_cache-&gt;E = E;</span><br><span class="line"> my_cache-&gt;Cache = (cache_line**)<span class="built_in">malloc</span>(my_cache-&gt;S * <span class="built_in">sizeof</span>(cache_line*) );</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;my_cache-&gt;S;++i)</span><br><span class="line"> &#123;</span><br><span class="line">my_cache-&gt;Cache[i] = (cache_line*)<span class="built_in">malloc</span>(my_cache-&gt;E * <span class="built_in">sizeof</span>(cache_line));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;my_cache-&gt;E; ++j) <span class="comment">// initialize</span></span><br><span class="line">&#123;</span><br><span class="line">my_cache-&gt;Cache[i][j].valid_bit = <span class="number">0</span>;</span><br><span class="line">my_cache-&gt;Cache[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">my_cache-&gt;Cache[i][j].time_stamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> my_cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>update_LRU</li></ol><p>我是通过对每个高速缓冲行维护一个time_stamp实现的LRU，因此更新Cache中各行的LRU操作很重要。对访问的行，time_stamp置0，有效位和tag位也要做更新，其余行的time_stamp加1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_LRU</span><span class="params">(cache* my_cache, <span class="type">int</span> ad_set, <span class="type">int</span> ad_tag, <span class="type">int</span> line_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class="line"><span class="keyword">if</span>(my_cache-&gt;Cache[ad_set][i].valid_bit) ++(my_cache-&gt;Cache[ad_set][i].time_stamp);</span><br><span class="line"></span><br><span class="line">my_cache-&gt;Cache[ad_set][line_index].time_stamp = <span class="number">0</span>;</span><br><span class="line">my_cache-&gt;Cache[ad_set][line_index].valid_bit = <span class="number">1</span>;</span><br><span class="line">my_cache-&gt;Cache[ad_set][line_index].tag = ad_tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>get_line_index</li></ol><p>每次访问cache，要得知hit，miss，eviction等信息，通过该函数实现：查找cache中所有行，如果找到有效位为1且tag位符合的行，则命中，否则miss</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line_index</span><span class="params">(cache* my_cache, <span class="type">int</span> ad_set, <span class="type">int</span> ad_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(my_cache-&gt;Cache[ad_set][i].valid_bit &amp;&amp; my_cache-&gt;Cache[ad_set][i].tag == ad_tag)</span><br><span class="line"><span class="keyword">return</span> i;  <span class="comment">// hit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// miss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>is_not_full</li></ol><p>。进一步对miss，遍历cache所有行，如果找不到有效位为0的行，则说明cache is full，那么就额外涉及有eviction操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_not_full</span><span class="params">(cache* my_cache, <span class="type">int</span> ad_set)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class="line"><span class="keyword">if</span>(!my_cache-&gt;Cache[ad_set][i].valid_bit) <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>find_LRU</li></ol><p>对eviction操作，执行我们的LRU替换策略，先找到时间戳最大的行，再进行覆盖操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_LRU</span><span class="params">(cache* my_cache, <span class="type">int</span> ad_set)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> max_stamp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evict_line = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; my_cache-&gt;E; ++i)</span><br><span class="line">&#123;</span><br><span class="line">temp = my_cache-&gt;Cache[ad_set][i].time_stamp;</span><br><span class="line"><span class="keyword">if</span>(temp &gt; max_stamp)</span><br><span class="line">&#123;</span><br><span class="line">max_stamp = temp;</span><br><span class="line">evict_line = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> evict_line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>access_cache</li></ol><p>我们需要用<code>fscanf</code>对数据访问操作进行解析，注意此处的<code>&quot; %c %x,%d&quot;</code>,<code>%c</code>前有一个whitespace，目的在于忽略对指令访问操作。由于不同数据访问指令执行的cache操作次数不同，因此我将对cache进行操作的部分分割成一个独立的函数<code>real_access_cache</code>。M等于L+S，因此需要两次更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">access_cache</span><span class="params">(cache* my_cache, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">char</span>* trace_name, <span class="type">int</span>* hit_count_ptr, <span class="type">int</span>* miss_count_ptr, <span class="type">int</span>* eviction_count_ptr)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  FILE* pFile;   <span class="comment">// receive access</span></span><br><span class="line">     pFile = <span class="built_in">fopen</span>(trace_name,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(!pFile) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     <span class="type">char</span> identifier;</span><br><span class="line">     <span class="type">unsigned</span> address;</span><br><span class="line">     <span class="type">int</span> size;</span><br><span class="line">     <span class="keyword">while</span>(<span class="built_in">fscanf</span>(pFile,<span class="string">&quot; %c %x,%d&quot;</span>,&amp;identifier,&amp;address,&amp;size)&gt;<span class="number">0</span>)</span><br><span class="line">     &#123;     </span><br><span class="line"><span class="type">int</span> mask =(<span class="type">unsigned</span>)(<span class="number">-1</span>)&gt;&gt;(<span class="number">64</span>-s);</span><br><span class="line"><span class="type">int</span> ad_set = (address &gt;&gt; b) &amp; mask;</span><br><span class="line"><span class="type">int</span> ad_tag = address &gt;&gt; (s+b);</span><br><span class="line"><span class="keyword">switch</span>(identifier)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line"><span class="built_in">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class="line"><span class="built_in">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line"><span class="built_in">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line"><span class="built_in">real_access_cache</span>(my_cache, ad_set, ad_tag, hit_count_ptr, miss_count_ptr, eviction_count_ptr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(pFile);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">real_access_cache</span><span class="params">(cache* my_cache, <span class="type">int</span> ad_set, <span class="type">int</span> ad_tag, <span class="type">int</span>* hit_count_ptr, <span class="type">int</span>* miss_count_ptr, <span class="type">int</span>* eviction_count_ptr)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="type">int</span> line_index,free_line, evict_line;</span><br><span class="line">line_index = <span class="built_in">get_line_index</span>(my_cache, ad_set, ad_tag);</span><br><span class="line"><span class="keyword">if</span>(line_index != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">++(*hit_count_ptr);</span><br><span class="line"><span class="built_in">update_LRU</span>(my_cache, ad_set, ad_tag, line_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">free_line = <span class="built_in">is_not_full</span>(my_cache, ad_set);</span><br><span class="line"><span class="keyword">if</span>(free_line != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">++(*miss_count_ptr);</span><br><span class="line"><span class="built_in">update_LRU</span>(my_cache, ad_set, ad_tag, free_line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++(*miss_count_ptr);</span><br><span class="line">++(*eviction_count_ptr);</span><br><span class="line">evict_line = <span class="built_in">find_LRU</span>(my_cache,ad_set);</span><br><span class="line"><span class="built_in">update_LRU</span>(my_cache, ad_set, ad_tag, evict_line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="XOedv"></a></p><h2 id="5-结果"><a class="markdownIt-Anchor" href="#5-结果"></a> 5. 结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1678885115012-43a6dad1-7672-42f8-b302-42c04af83585.png" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] datalab, bomblab, attacklab</title>
      <link href="/2023/03/06/CSAPP-Lab/datalab-bomblab-attacklab/"/>
      <url>/2023/03/06/CSAPP-Lab/datalab-bomblab-attacklab/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a name="IR5gF"></a></p><h1 id="lab1-datalab"><a class="markdownIt-Anchor" href="#lab1-datalab"></a> lab1 dataLab</h1><span id="more"></span><p><a name="RKm5i"></a></p><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><p>确保有一个linux系统，并已经执行过以下两条命令:<br />安装gcc：<code>sudo apt-get install build-essential</code>  <br />安装<a href="https://askubuntu.com/questions/855945/what-exactly-does-gcc-multilib-mean-on-ubuntu#:~:text=gcc%2Dmultilib%20is%20useful%20for,you%20get%20the%20idea">gcc的交叉编译环境</a>.)：<code>sudo apt-get install gcc-multilib</code>，因为实验的程序需要以32位方式编译<br />在<a href="http://csapp.cs.cmu.edu/3e/labs.html">CMU的CSAPP网站</a>上下载实验所需资料，包括**README, Writeup，Self-Study Handout，**这三部分均包含对实验的要求说明（Handout的说明在其包含的bits.c文件中由注释给出），Self-Study Handout包括用于测试的文件<br /><a name="IOcHR"></a></p><h2 id="1bitxorxy"><a class="markdownIt-Anchor" href="#1bitxorxy"></a> 1.bitXor(x,y)</h2><p>要用~和&amp;实现异或^，即将结果中 1-0，0-1对应的位设置为1<br />x&amp;y中为1的位(bit)对应 1-1； 取反后为：0-0、0-1、1-0；<br />(<sub>x&amp;</sub>y)为1的位(bit)对应 0-0； 取反后为：1-1、0-1、1-0；<br />两个做交集即为结果。（位向量可以表示集合，&amp;，|，~可视为 交，并，补操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment">Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment">Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment">Max ops: 14</span></span><br><span class="line"><span class="comment">Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ~(x&amp;y) &amp; ~(~x&amp;~y) ; <span class="comment">// if regardless &#x27;+&#x27; is illegal:(~x&amp;y) + ((x)&amp;(~y)) or ~((x&amp;y) + ((~x)&amp;(~y)))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mB5XE"></a></p><h2 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin"></a> 2.tmin</h2><p>最简单的一题：<code>000...001</code> --&gt; <code>1000...000</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">Max ops: 4</span></span><br><span class="line"><span class="comment">Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pr9MQ"></a></p><h2 id="3istmaxx"><a class="markdownIt-Anchor" href="#3istmaxx"></a> 3.isTmax(x)</h2><p>这题最开始想到 Tmin的一个性质，即对二进制补码 Tmax关于加法的逆为其本身：Tmax+Tmax = 0；因此利用这个性质写出了<code>!((~x) + (~x))</code>，但<a href="https://stackoverflow.com/questions/74541471/datalab-of-csappistmax-seems-unoperative?noredirect=1#comment131585049_74541471">测试结果出乎意料</a>，加法溢出导致了未知的行为。<br />根据 Tmax +1 = Tmin 的性质可以得出 ,  <code>100...000</code> + <code>011...111</code> = <code>111..1111</code> (-1)，可得出<code>!(~x^(x+1))</code>（^可替换为+）<br />处理特例-1： -1同样会产生结果1，根据 <code>-1+1==0</code>,<code>Tmax+1!=0</code>，进而<code>!(-1+1) !=0</code> ，<code>!(Tmax+1) ==0</code>.<br />所以<code>对Tmax, x+(x+1) = x</code> , <code>对-1,x+(x+1)!=x</code><br />用<code>x+(x+1)</code> 替换原式中的第一项x，最终得出结果：<code>!(~((x+!(x+1))^(x+1)))</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment">and 0 otherwise </span></span><br><span class="line"><span class="comment">egal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment">Max ops: 10</span></span><br><span class="line"><span class="comment">Rating: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(~((x+!(x+<span class="number">1</span>)) ^ (x+<span class="number">1</span>))) ; </span><br><span class="line">   <span class="comment">// !((~x) + (~x));  it should be right, the operator &quot;!&quot; seem to not work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="kHLgK"></a></p><h2 id="4alloddbitsx"><a class="markdownIt-Anchor" href="#4alloddbitsx"></a> 4.allOddBits(x)</h2><p>这道题没想出来，在x上shift的方式想了一个多小时，总是不能满足所有测试用例，说明在x上shift是行不通的。<br />用好异或即可解决：构造<code>101...1010</code>，再用该数提取x中的奇数位，最后再与<code>101...1010</code>比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment">where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment">Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment">Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment">Max ops: 12</span></span><br><span class="line"><span class="comment">Rating: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> allOdd = (<span class="number">0xAA</span> &lt;&lt; <span class="number">24</span>) + (<span class="number">0xAA</span> &lt;&lt; <span class="number">16</span>) + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>) + <span class="number">0xAA</span>; <span class="comment">// 10101010..101</span></span><br><span class="line">  <span class="keyword">return</span> ! ((allOdd &amp; x) ^ allOdd);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sswhY"></a></p><h2 id="5isasciidigitx"><a class="markdownIt-Anchor" href="#5isasciidigitx"></a> 5.isAsciiDigit(x)</h2><p>有点难，还是自己做出来了，主要使用了掩码提取x中的指定位，再运用前几题的经验—用异或执行比较操作。<br />x的最后四位，3bit 与 1,2bit不能同时为1，因而有<code>!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)))</code>，难点在于怎么处理好式中三部分的逻辑关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mask1 = <span class="number">0x3</span>;   <span class="comment">// 000...0011</span></span><br><span class="line">  <span class="type">int</span> mask2 = <span class="number">0xA</span>;   <span class="comment">// 1010</span></span><br><span class="line">  <span class="type">int</span> mask3 = <span class="number">0xC</span>;   <span class="comment">// 1100</span></span><br><span class="line">  <span class="keyword">return</span>  !( ((x&gt;&gt;<span class="number">4</span>)^mask1) | (!((x&amp;mask2)^mask2) + (!((x&amp;mask3)^mask3)) ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="DZZaa"></a></p><h2 id="6conditional"><a class="markdownIt-Anchor" href="#6conditional"></a> 6.conditional</h2><p>比较简单，主要实现这样一个逻辑：x!=0，返回y；x=0，返回z；<br />涉及的操作是把x转化为0与1两个值，再把<code>000...0001</code>转化为<code>111...1111</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; </span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>  judge = !(x ^ <span class="number">0x0</span>); <span class="comment">// x=0 -&gt; judge=1,whereas x!=0 -&gt; judge=0</span></span><br><span class="line">  judge = (judge &lt;&lt; <span class="number">31</span>)&gt;&gt;<span class="number">31</span>; <span class="comment">// 000...000 or 111...111</span></span><br><span class="line">  <span class="keyword">return</span> ((~judge)&amp;y) | (judge&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="MZZvz"></a></p><h2 id="7islessorequalx-y"><a class="markdownIt-Anchor" href="#7islessorequalx-y"></a> 7.isLessOrEqual(x, y)</h2><p>可通过减法<code>y-x&gt;=0</code>判断<code>x&lt;=y</code>，由于不存在-符，所以取x关于加法的逆-x，进而变为 x+y<br />那么这题就涉及加法溢出,需要对<code>x+uw  y</code>结果的三种情况的判断(negative overflow ， positive overflow)，变得复杂起来。<br />更好的想法是<strong>分析式子</strong><code>**y-x**</code><strong>并加入一个conditional操作</strong>：如果两者异号(正-负，负-正)，那么结果的正负的确定的；如果两者同号(同号相减不可能溢出)，则通过与Tmin相与提取符号位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span>&lt;&lt;<span class="number">31</span>; <span class="comment">// 100...0000</span></span><br><span class="line">  <span class="type">int</span> signY = Tmin &amp; y;</span><br><span class="line">  <span class="type">int</span> signX = Tmin &amp; x;</span><br><span class="line">  <span class="type">int</span> judge = (signY ^ signX)&lt;&lt;<span class="number">31</span>; </span><br><span class="line">  x = (~x)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (judge&amp;signX) | (~(judge&gt;&gt;<span class="number">31</span>) &amp; !((y+x)&amp;Tmin)) ; <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="WP1Li"></a></p><h2 id="8logicalnegx"><a class="markdownIt-Anchor" href="#8logicalnegx"></a> 8.logicalNeg(x)</h2><p>这题要求自己实现一个 ！逻辑，即输入0返回1，输入N（N!=0）返回0。一开始的出发点是：x=0，返回1；x 位向量存在为1的位，返回0。但是仅靠逻辑运算符无法实现该想法。<br />于是换了一个想法：先得到x的符号位signX。signx为1，说明x为负数，可以直接得到结果；sign为0，说明x即可能为0也可能为正数，那么就要利用补码加法操作会发生的<strong>positive overflow</strong>现象，即 Tmax + x ，对任意x&gt;0均会使结果变为负数，符号位由0 --&gt;1。（positive overflow 不同于 negative overflow，并没有产生整数溢出，因此不会导致<a href="http://port70.net/~nsz/c/c11/n1570.html#3.4.3p3">undefined behavior</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logi&#x27;calNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> Tmin = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> Tmax = ~Tmin;</span><br><span class="line">  <span class="type">int</span> signX = ((x&amp;Tmin)&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">return</span> (signX^<span class="number">0x1</span>) &amp; ((((x + Tmax)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>)^<span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Y5Acb"></a></p><h2 id="9howmanybitsx"><a class="markdownIt-Anchor" href="#9howmanybitsx"></a> 9.howManyBits(x)</h2><p>这题一开始想的是去除符号位后，找位向量中最左边的1的位置序号，但是我忽略了补码的一个性质：<strong>当数的符号位为1时，将数按符号位扩展之后其值不会变</strong>，如1101与101表示的是同一个值(-3)，因此找到最左边的1并不能得到最短的位数。<br />要找到能表示负数的最短位数，而又不受符号位拓展的影响，便要找最左边的0，而不是1。为与对正数的操作相统一，做法是把负数按位取反(Such as: 1101 -&gt; 0010)<br />按二分法逐步缩小范围，找到最左边的1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="type">int</span> signX = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = ((~signX) &amp; x) | (signX&amp;(~x));<span class="comment">// if x is negative, let sign bit:1-&gt; 0</span></span><br><span class="line">  </span><br><span class="line">  b16 = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>; <span class="comment">// ensure high 16 bits exist 1 or not</span></span><br><span class="line">  x=x&gt;&gt;b16;</span><br><span class="line">  b8 = (!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>; <span class="comment">// ensure high 8 bits </span></span><br><span class="line">  x=x&gt;&gt;b8;</span><br><span class="line">  b4 = (!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>; <span class="comment">// ensure high 4 bits </span></span><br><span class="line">  x=x&gt;&gt;b4;  </span><br><span class="line">  b2 = (!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>; <span class="comment">// ensure high 2 bits </span></span><br><span class="line">  x=x&gt;&gt;b2; </span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>); <span class="comment">// ensure 31 bits or not </span></span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> b0+b1+b2+b4+b8+b16+<span class="number">1</span>; <span class="comment">// 1: sign bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="glYde"></a></p><h2 id="10floatscale2uf"><a class="markdownIt-Anchor" href="#10floatscale2uf"></a> 10.floatScale2(uf)</h2><p>先对题目做出一点解释：传入一个<code>unsigned</code>类型的参数，但是函数内将它解释为一个浮点数类型，即参数的值不是参数的十进制值，而是其二进制形式表示的浮点数值(M×2E)<br /><strong>整体思路：用掩码分别提取sign,exponent,fraction三部分，再根据exp的值分类讨论</strong><br />注意点：对normalized，f*2的2是乘在了2E；而对denormalized，是乘在了frac表示的M上，这也是为什么<code>frac = frac &lt;&lt;1</code>，这也使得denormalized能转化到normalized (smoothly)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument    // revision: NaN or infinity</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> musk_exp,musk_frac,sign,exp,frac,result;</span><br><span class="line">  musk_exp = <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  musk_frac = <span class="number">0x7FFFFF</span>;</span><br><span class="line">  exp = (uf &amp; musk_exp)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  frac = uf &amp; musk_frac;</span><br><span class="line">  sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span> &amp; uf;</span><br><span class="line">  result = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(exp == <span class="number">0xFF</span>  ) <span class="comment">// NaN</span></span><br><span class="line">     result = uf;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp == <span class="number">0x0</span>) <span class="comment">// denormalized</span></span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="keyword">if</span>(frac == <span class="number">0x0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(sign)  <span class="comment">// -0.0</span></span><br><span class="line">           result = uf;</span><br><span class="line">        <span class="keyword">else</span>     <span class="comment">// +0.0</span></span><br><span class="line">           result = <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">        frac = frac &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result = sign+ (exp&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp != <span class="number">0x0</span> &amp;&amp; exp != <span class="number">0xFF</span>) <span class="comment">// normalized</span></span><br><span class="line">  &#123;</span><br><span class="line">     exp += <span class="number">1</span>;</span><br><span class="line">     result = sign+ (exp&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="tO8yh"></a></p><h2 id="11floatfloat2intuf"><a class="markdownIt-Anchor" href="#11floatfloat2intuf"></a> 11.floatFloat2Int(uf)</h2><p>浮点数类型的这几题比前面的题要轻松很多，大概是因为可用符号和结构比较充足的原因吧。<br />对题目的解释：返回浮点数f的int型表示，如输入<code>12345.0 (0x4640E400)</code>, 正确输出为<code>12345 (0x3039)</code><br />注意点：当f的值超过32bit的int类型位向量所能表示的最大值时(2^31-1)，即E&gt;31时，属于out of range</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> musk_exp,musk_frac,exp,frac,sign,E,Bias,result;</span><br><span class="line">  musk_exp = <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  musk_frac = <span class="number">0x7FFFFF</span>;</span><br><span class="line">  exp = (uf &amp; musk_exp)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  frac = uf &amp; musk_frac;</span><br><span class="line">  sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span> &amp; uf;</span><br><span class="line">  Bias = <span class="number">127</span>;</span><br><span class="line">  result = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(exp == <span class="number">0xFF</span>  ) <span class="comment">// NaN or infinity</span></span><br><span class="line">     result = <span class="number">0x80000000</span>u;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp == <span class="number">0x0</span>)</span><br><span class="line">     result = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(exp != <span class="number">0x0</span> &amp;&amp; exp != <span class="number">0xFF</span>) <span class="comment">// normalized</span></span><br><span class="line">  &#123;</span><br><span class="line">     E = exp -Bias;  <span class="comment">// bit_num of fraction</span></span><br><span class="line">     <span class="keyword">if</span>(E &lt; <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (E&gt;<span class="number">31</span>)</span><br><span class="line">        result = <span class="number">0x80000000</span>u;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">        frac = frac&gt;&gt;(<span class="number">23</span>-E);</span><br><span class="line">        result = (<span class="number">0x1</span> &lt;&lt; E) + frac ; </span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>)</span><br><span class="line">           result = - result;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UlJMS"></a></p><h2 id="12floatpower2x"><a class="markdownIt-Anchor" href="#12floatpower2x"></a> 12.floatPower2(x)</h2><p>注意点：当2^x超过位向量所能表示的最大值（largest normalized）时，即exp 大于 254（1111 1110），属于too large</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> exp,frac,E,Bias,result;</span><br><span class="line">  Bias = <span class="number">127</span>;</span><br><span class="line">  result = <span class="number">5</span>;</span><br><span class="line">  E = x;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">1</span> &amp;&amp; x!=<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= <span class="number">0x1</span> || x == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     frac = <span class="number">0x0</span>;</span><br><span class="line">     exp = E+Bias;</span><br><span class="line">     <span class="keyword">if</span>(exp &gt; <span class="number">254</span>)  <span class="comment">// 1111 1110</span></span><br><span class="line">        &#123;</span><br><span class="line">           exp = <span class="number">0xFF</span>;</span><br><span class="line">           result = exp &lt;&lt;<span class="number">23</span>+frac;         </span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        result = (exp&lt;&lt;<span class="number">23</span>) + frac; </span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="iHsuB"></a></p><h2 id="consequence"><a class="markdownIt-Anchor" href="#consequence"></a> consequence</h2><p><code>make</code><br /><code>./driver.pl</code><br /><a name="SLl25"></a></p><h3 id="data_lab_successpng"><a class="markdownIt-Anchor" href="#data_lab_successpng"></a> <img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1669795434321-27bd7778-bde0-4d21-9ae0-425e1e785bd1.png#averageHue=%230d0c0c&amp;clientId=u8b4f2be4-4c9f-4&amp;from=ui&amp;id=ue9c8e7dc&amp;name=data_lab_success.png&amp;originHeight=631&amp;originWidth=1162&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183673&amp;status=done&amp;style=none&amp;taskId=u00d5bd76-a7dc-4107-8697-fafe865d7ec&amp;title=" alt="data_lab_success.png" /></h3><hr /><p><a name="FsQk5"></a></p><h1 id="lab2-bomblab"><a class="markdownIt-Anchor" href="#lab2-bomblab"></a> lab2 bombLab</h1><p><a name="mm3BW"></a></p><h2 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> phase_1</h2><ol><li>反汇编<code>main</code>函数：<code>read_line</code>函数之后寄存器<code>%rax</code>和<code>%rdi</code>存储了我们输入的字符串的首地址(后续的phase都是如此)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677142575501-aadca48e-4054-40dc-977b-4719009de3e3.png#averageHue=%2362372c&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=113&amp;id=u7f5a75e8&amp;name=image.png&amp;originHeight=113&amp;originWidth=1058&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65961&amp;status=done&amp;style=none&amp;taskId=u19a9cc96-f38d-462d-9d4b-fbdd1e6cd16&amp;title=&amp;width=1058" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163430669-16842232-e1ab-4ac7-a90d-8f9a18e1c5d2.png#averageHue=%232d2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=128&amp;id=u1267f1f6&amp;name=image.png&amp;originHeight=128&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=59576&amp;status=done&amp;style=none&amp;taskId=ufdd9544b-0308-49f4-86fd-49a8013d976&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%281%29&amp;width=1060" alt="image.png" title="验证%rdi指向输入字符串(1)" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677163457263-f780263b-09ed-4875-bafc-0f00d7e8e894.png#averageHue=%23323232&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=77&amp;id=ubbe401e0&amp;name=image.png&amp;originHeight=77&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=31472&amp;status=done&amp;style=none&amp;taskId=u152fe82b-0961-427e-bd1e-8a6755f1504&amp;title=%E9%AA%8C%E8%AF%81%25rdi%E6%8C%87%E5%90%91%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%282%29&amp;width=723" alt="image.png" title="验证%rdi指向输入字符串(2)" /></p><ol start="2"><li>反汇编<code>strings_not_equal</code>函数：该函数在输入字符串与目的字符串相同时，将寄存器<code>%rax</code>（通常用作函数返回值）赋值为0 (1 vice versa)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143001741-9ecdcda9-b9a6-4b31-a450-5d80ed226850.png#averageHue=%23302f2f&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=147&amp;id=u575b769d&amp;name=image.png&amp;originHeight=147&amp;originWidth=1140&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79269&amp;status=done&amp;style=none&amp;taskId=u9916894f-f032-4f63-b09d-6ce04314c3f&amp;title=&amp;width=1140" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143020716-757eda92-ee3e-4fe0-9c1b-597af2e24eab.png#averageHue=%23323131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=214&amp;id=uca455390&amp;name=image.png&amp;originHeight=214&amp;originWidth=973&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98661&amp;status=done&amp;style=none&amp;taskId=u7c4aadd7-6706-4e4d-8a95-2e31a1df894&amp;title=&amp;width=973" alt="image.png" /></p><ol start="3"><li>反汇编<code>phase_1</code>函数：<code>strings_not_equal</code>函数返回值为0时，<code>test %eax, %eax</code>能使<code>je 0x400ef7&lt;phase_1+23&gt;</code>执行，phase_1 defused (explode vice versa)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143312955-e1e9a80c-1730-48ae-84f7-5dfded69d3a9.png#averageHue=%232e2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=361&amp;id=ue40fcfa2&amp;name=image.png&amp;originHeight=361&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=206173&amp;status=done&amp;style=none&amp;taskId=u54ecca10-9722-4536-ba3f-f972c656feb&amp;title=&amp;width=1126" alt="image.png" /></p><ol start="4"><li>至此，只需找出目的字符串的位置即可，而目的字符串的地址明显在调用<code>strings_not_equal</code>函数之前赋值的<code>%esi：0x402400</code>寄存器中</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143752561-a0f86e1a-fc9c-4ff2-b386-d8d929f293c5.png#averageHue=%23333333&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=102&amp;id=ua334cc19&amp;name=image.png&amp;originHeight=102&amp;originWidth=1118&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39885&amp;status=done&amp;style=none&amp;taskId=u26286ab1-642e-4f50-9434-8d65b1add7d&amp;title=&amp;width=1118" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677143789980-9946be38-59bb-4852-bd3c-72747f67fc16.png#averageHue=%23333333&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=152&amp;id=u0cd1b8f0&amp;name=image.png&amp;originHeight=152&amp;originWidth=1065&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=69532&amp;status=done&amp;style=none&amp;taskId=u1b6e1505-7e71-4000-8504-44c050e2921&amp;title=&amp;width=1065" alt="image.png" /><br /><a name="aPHyw"></a></p><h2 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> phase_2</h2><ol><li>反汇编<code>read_six_numbers</code>函数：可以推断出其实现了<code>sscanf(input, &quot;%d %d %d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6)</code>的功能，其中<code>&amp;a1~&amp;a6</code>分别在1)<code>%rcx:0x4(%rsi)</code>2)<code>%r8:0x8(%rsi)</code>3)<code>%r9:0xc(%rsi)</code>4)<code>%rsp:0x10(%rsi)</code>5)<code>0x8(%rsp):0x14(%rsi), 0x18(%rsi) </code> 前3个指针存储在寄存器中传递给<code>sscanf</code>函数，后三个指针存储在为<code>read_six_numbers</code>函数分配的栈空间中,可以推断出<code>%rsi</code>为一个含有六个元素的数组的首地址</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677148614935-cd29c501-e2a8-4185-9924-0829124ef293.png#averageHue=%232e2d2d&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=506&amp;id=ue62a1cc7&amp;name=image.png&amp;originHeight=506&amp;originWidth=1045&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=292132&amp;status=done&amp;style=none&amp;taskId=udf564ea8-5d5d-4db1-9fe7-6784845d360&amp;title=&amp;width=1045" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150202265-dda02d42-7661-48f0-9ec1-5b420d781e9d.png#averageHue=%23313131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=74&amp;id=u5d32cc04&amp;name=image.png&amp;originHeight=74&amp;originWidth=675&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24474&amp;status=done&amp;style=none&amp;taskId=u7f387e07-3b4e-4ad1-bae1-5f9cf213c77&amp;title=&amp;width=675" alt="image.png" /></p><ol start="2"><li>反汇编<code>phase_2</code>函数：判断a1与0x1相等，不相等则explode；接着判断a2与2*a1是否相等，不相等则explode，接着都是一样的模式：判断当前数据是否与前一个数据的2倍相等，不相等则explode，直到判断完六个数据</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150067118-dd3962a5-1458-4a3e-9399-4cf1699ca7a7.png#averageHue=%23423227&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=656&amp;id=u8a1ec132&amp;name=image.png&amp;originHeight=656&amp;originWidth=885&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=478280&amp;status=done&amp;style=none&amp;taskId=u1da79441-ac63-407b-ab6c-037fd3e1450&amp;title=&amp;width=885" alt="image.png" /></p><ol start="3"><li>自此，我们可以判断出这六个数字分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>1</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>3</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>4</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2^0,2^1,2^2,2^3,2^4,2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677149991615-e3f805b9-b4b0-4f49-bfbf-36dc2153557b.png#averageHue=%23313131&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=112&amp;id=ua5f4ba93&amp;name=image.png&amp;originHeight=112&amp;originWidth=782&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34849&amp;status=done&amp;style=none&amp;taskId=u43537a4a-415e-4df2-b80d-0601d361576&amp;title=&amp;width=782" alt="image.png" /><br /><a name="XKRDk"></a></p><h2 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h2><ol><li>反汇编<code>phase_3</code>：从<code>(%esi)</code>的字符串可以看出该函数先读取了两个输入的值，接着判断第一个值是否大于7(<code>cmpl 0x7,0x8(rsp)</code>)，并根据这个值执行间接跳转操作(<code>jmp *0x402470(,rax,8)</code>)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677150892423-92750918-b2b5-4aa5-9b0e-e08eec5cffdd.png#averageHue=%23141313&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=150&amp;id=uf4734a85&amp;name=image.png&amp;originHeight=150&amp;originWidth=1074&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=61373&amp;status=done&amp;style=none&amp;taskId=u56bba885-3031-4576-9ddd-85ccf2060e9&amp;title=&amp;width=1074" alt="image.png" /></p><ol start="2"><li>查看0x402470附近存储的地址值(用于实现switch语句的跳转表)，只要地址值的地址可以由0x402470加上一个8的倍数得到，就是符合条件的，最后验证出来有7个地址值，进而有7个符合条件的<code>0x8(%rsp</code>：1 2 3 4 5 6 7</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677072562462-74d53e52-6a59-498d-9186-02f1b43b8be5.png#averageHue=%23131313&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=324&amp;id=u10476384&amp;name=image.png&amp;originHeight=324&amp;originWidth=1067&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80101&amp;status=done&amp;style=none&amp;taskId=u49754a92-19b8-499c-8daf-4c666824406&amp;title=&amp;width=1067" alt="image.png" /></p><ol start="3"><li>根据后续的赋值-跳转指令，可以得到对应的7个<code>0xc(%rsp)</code>：311 707 256 389 206 682 327，所以最终答案有7个: (1, 311)，(2, 707)，(3, 256)，(4, 389)，(5, 206)，(6, 682)，(7, 327)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151557789-3726bd23-9a03-48c7-bb2b-1a31a71ae4c0.png#averageHue=%23121212&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=286&amp;id=ud77abcea&amp;name=image.png&amp;originHeight=327&amp;originWidth=347&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72813&amp;status=done&amp;style=none&amp;taskId=uaa3da35e-6e2a-42ba-af96-025e357b784&amp;title=&amp;width=304" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677151578594-a2486d66-586a-473a-ba87-8ed30e462b01.png#averageHue=%231e1e1e&amp;clientId=u40dabece-2d53-4&amp;from=paste&amp;height=294&amp;id=ud120ef9a&amp;name=image.png&amp;originHeight=391&amp;originWidth=354&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101567&amp;status=done&amp;style=none&amp;taskId=ub5d0284e-6af4-4113-b8cd-89ebdce0f6d&amp;title=&amp;width=266" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073427546-61c8a627-e902-4132-922f-d9c30d888865.png#averageHue=%23303030&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=50&amp;id=u47146b93&amp;name=image.png&amp;originHeight=75&amp;originWidth=297&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8224&amp;status=done&amp;style=none&amp;taskId=u32d95d06-a5d5-44ea-9c62-17652eea139&amp;title=&amp;width=197" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073446185-f50d15ab-e6e5-4d7f-b87a-7c41585c225e.png#averageHue=%232f2f2f&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=47&amp;id=ue4a4e105&amp;name=image.png&amp;originHeight=70&amp;originWidth=287&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8707&amp;status=done&amp;style=none&amp;taskId=u21abdc4b-34e0-4b23-8ae8-6a213e06389&amp;title=&amp;width=192" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073458555-0aefc97d-f40a-4b0b-8e5e-1c592d1478fb.png#averageHue=%23313131&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=51&amp;id=u12915178&amp;name=image.png&amp;originHeight=74&amp;originWidth=307&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8649&amp;status=done&amp;style=none&amp;taskId=u884bf4d9-3d42-48e3-9d32-a6cc91f0115&amp;title=&amp;width=212" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073483221-c6634274-ca68-4d70-b35d-bcf9c12bc64d.png#averageHue=%23292929&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=48&amp;id=u8a9d1cb9&amp;name=image.png&amp;originHeight=71&amp;originWidth=296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10382&amp;status=done&amp;style=none&amp;taskId=u3d742e48-f459-45a3-abcb-5a2e46a9698&amp;title=&amp;width=201" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073498912-78462783-24d1-48c5-bd9c-dc0efd391d71.png#averageHue=%232a2a29&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=47&amp;id=uc7e8ea56&amp;name=image.png&amp;originHeight=75&amp;originWidth=290&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11606&amp;status=done&amp;style=none&amp;taskId=u579ff7da-06cc-49aa-bbb5-7d665920365&amp;title=&amp;width=183" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073505761-bdd3ef17-0fcd-491a-8c9d-c021bd67b4a8.png#averageHue=%23272727&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=53&amp;id=u656875e3&amp;name=image.png&amp;originHeight=78&amp;originWidth=307&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11833&amp;status=done&amp;style=none&amp;taskId=u1ec87705-b895-47c3-98cb-1da89ebe401&amp;title=&amp;width=208" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677073525247-e99ecac4-12c7-4929-ac87-722029dcb4fd.png#averageHue=%23303030&amp;clientId=u39d47224-2023-4&amp;from=paste&amp;height=49&amp;id=uaaf9dd91&amp;name=image.png&amp;originHeight=74&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8976&amp;status=done&amp;style=none&amp;taskId=u262b648d-9811-41df-9106-07a991aca4a&amp;title=&amp;width=208" alt="image.png" /><br /><a name="Qae7S"></a></p><h2 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> phase_4</h2><ol><li>反汇编<code>phase_4</code>函数：开头部分具有与<code>phase_3</code>函数相似的部分，均需输入两个值（留意这里，其实只需保证填充了两个值就可以），且规定了第1个值不大于14(<code>cmpl $0xe, 0x8(%rsp)</code>)，之后函数调用<code>func4</code>函数，传入三个参数<code>%edx</code>, <code>%esi</code>, <code>0x8(%rsp)</code>。虽然目前不清楚func4做了什么，但可以确定返回值必须为0(<code>test %eax, %eax</code>)。后续的<code>cmpl $0x0, 0xc(%rsp)</code>足以确定第2个值为0</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206362623-39fe4977-5cab-4016-9003-2541d41dbe6a.png#averageHue=%232a2823&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=416&amp;id=ubcbcc5b1&amp;name=image.png&amp;originHeight=587&amp;originWidth=1125&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=601648&amp;status=done&amp;style=none&amp;taskId=ucd50703b-cd59-4e1b-b4f1-5fefbaddeb2&amp;title=&amp;width=797" alt="image.png" /></p><ol start="2"><li>反汇编<code>func4</code>函数：出现了<code>func4</code>调用自身的情况，所以<code>func4</code>是一个递归函数。第1部分将<code>%rax</code>赋值为<code>%edx</code>-<code>%esi</code>,再加上它的最高位(<code>%rax &gt;&gt; 31</code>)，接着执行算数右移。这里加上最高位的原因在于，当后续<code>%rax</code>在递归中值减少为-1时，最高位是符号位1，两者相加能保证<code>%rax</code>始终大于等于0，结合后续汇编内容，可以推断出第一个值<code>0x8(%rsp)</code>应当是一个无符号数，范围为0~14; 第2部分，可以看出这是一个二分查找的过程，如果<code>%ecx &gt; %edi</code>，那么就使<code>%ecx</code>变为<code>%esi</code>到<code>%edx</code>的中间值(<code>lea -0x1(%rcx), %edx</code>)；第3部分，结合eax返回必须为0的条件，可以推断出所有递归的函数调用均不应使第3部分的跳转指令执行，否则会使返回<code>phase_4</code>的<code>%rax</code>值为1</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677204842268-34841e29-56e5-4d63-9e9f-b1576cec24a4.png#averageHue=%232b2a2a&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=562&amp;id=u81eba999&amp;name=image.png&amp;originHeight=843&amp;originWidth=1305&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=520895&amp;status=done&amp;style=none&amp;taskId=u37b9260f-a9c9-4dd9-abb9-dd995610f26&amp;title=&amp;width=870" alt="image.png" /></p><ol start="3"><li>自此，可以推断出第1个值随递归调用次数增多而减少，进而有多个不同的值，并在减少为0时停止变化。分析后可得出有以下4个值7 3 1 0，结合第2个值为0的条件，得出符合条件的字符串有(7, 0), (3, 0), (1, 0), (0, 0)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206164369-fa35758d-403b-483b-ad52-af80ef73df84.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=u3b0eedfa&amp;name=image.png&amp;originHeight=74&amp;originWidth=649&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17085&amp;status=done&amp;style=none&amp;taskId=ub467ca8a-a273-4b74-b425-f72d9e99ae4&amp;title=&amp;width=432.6666666666667" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206214348-cbc56dfd-faed-4afb-8859-c6bb00e4be62.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=ub80967c2&amp;name=image.png&amp;originHeight=74&amp;originWidth=686&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17880&amp;status=done&amp;style=none&amp;taskId=u78e1925a-de3d-4ff7-a76b-00e4657dd48&amp;title=&amp;width=457.3333333333333" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206249049-10571826-c506-4fdf-bcae-4ca9487bd383.png#averageHue=%232d2d2d&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=46&amp;id=u3c92002a&amp;name=image.png&amp;originHeight=75&amp;originWidth=713&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17666&amp;status=done&amp;style=none&amp;taskId=u81f0177a-9477-484d-bc60-f8009a91d73&amp;title=&amp;width=435.3333435058594" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677206271742-0b02d5c9-234f-465e-9fb7-6a9cb6c3b2f3.png#averageHue=%232c2c2c&amp;clientId=u15f83395-fa33-4&amp;from=paste&amp;height=49&amp;id=u0a7235e4&amp;name=image.png&amp;originHeight=73&amp;originWidth=674&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=17218&amp;status=done&amp;style=none&amp;taskId=u48f4584a-4771-47be-b5b5-5281e909d12&amp;title=&amp;width=449.3333333333333" alt="image.png" /><br /><a name="Kxq7k"></a></p><h2 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> phase_5</h2><ol><li>反汇编<code>phase_5</code>函数：要求输入字符串包含六个字符（注意！包含空格），根据后续汇编逻辑，可反编译得到以下程序 (%fs:0x28在这里的作用：作为金丝雀值，提供堆栈保护检查)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span> <span class="comment">// %rax</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">index = *(input+i);</span><br><span class="line">index = index&amp; <span class="number">0xf</span>; <span class="comment">// take lower four bits</span></span><br><span class="line">dest[<span class="number">0</span>] = source[index]; <span class="comment">// dest: (%rsp+0x10+%rax) source: 0x4024b0</span></span><br><span class="line"><span class="keyword">if</span>(string_not_equal(dest, target) == <span class="number">0</span>) <span class="comment">// target: 0x40245e --- &quot;flyers&quot;</span></span><br><span class="line">      <span class="comment">//defuse</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   explode_bomb();</span><br><span class="line">&#125;<span class="keyword">while</span>(i&gt;<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227102569-50a0daeb-22b8-4911-84ee-83283088ca0d.png#averageHue=%23211710&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=629&amp;id=u029c0758&amp;name=image.png&amp;originHeight=944&amp;originWidth=901&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=467386&amp;status=done&amp;style=none&amp;taskId=uaa2e377e-a27a-4e06-9129-f19ece505a9&amp;title=&amp;width=600.6666666666666" alt="image.png" /></p><ol start="2"><li>分别查看<code>source: 0x4024b0</code>和<code>target: 0x40245e</code>处的字符串，我们要做的就是使输入字符串形成的索引值能够从<code>0x4024b0</code>处的字符集中提取出 “flyers”</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227207876-48a2e806-f23e-49ec-982e-698183c7bc19.png#averageHue=%23151515&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=52&amp;id=u3302b9b7&amp;name=image.png&amp;originHeight=78&amp;originWidth=1766&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=39766&amp;status=done&amp;style=none&amp;taskId=u6f4121a7-1717-4bf8-9d35-1f34adc43a8&amp;title=&amp;width=1177.3333333333333" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677227244326-73d2e1d2-8fa8-4452-bb1c-64b132ecd786.png#averageHue=%23131313&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=49&amp;id=u7ad1cd69&amp;name=image.png&amp;originHeight=73&amp;originWidth=906&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=18317&amp;status=done&amp;style=none&amp;taskId=u0a7a9ee0-efaa-4b08-8a9e-6e726ed5958&amp;title=&amp;width=604" alt="image.png" /></p><ol start="3"><li>我们的输入字符串每个字符在内存中占一个byte，<code>movzbl (%rbx, %rax, 1), %ecx</code>说明了一次循环提取一个字符，并只取该字符的低四位(<code>and $0xf, %edx</code>)作为索引值</li><li>首先先确定索引值，然后推出字符串：对比source和target两个字符串，可以确定索引值为：7 15 14 5 6 7，这6个索引值在ASCII表中对应的字符是无法输入的（eg：7 BEL），因此我们要利用只取低四位作索引值这一特点，索引值对应的四位二进制为：1001，1111，1110，0101，0110，0111 ， 因此所有(prefer a~z)低四位为以上二进制组合的均可以defuse，如ionefg，yONuvw</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228092474-185f8fde-3015-4a64-ae85-2a4931bb2ca9.png#averageHue=%23191919&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=72&amp;id=u2762ccc0&amp;name=image.png&amp;originHeight=108&amp;originWidth=741&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24485&amp;status=done&amp;style=none&amp;taskId=u4d7584c2-7474-4bc2-8df3-b7710936568&amp;title=&amp;width=494" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677228432835-1ddc8d9b-d067-4d80-82c1-d63b067d6c25.png#averageHue=%23191919&amp;clientId=ub432d06a-c081-4&amp;from=paste&amp;height=71&amp;id=uaf8564a8&amp;name=image.png&amp;originHeight=107&amp;originWidth=705&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24585&amp;status=done&amp;style=none&amp;taskId=ud201852c-7855-4553-8543-43f2a63028c&amp;title=&amp;width=470" alt="image.png" /><br /><a name="BuuHr"></a></p><h2 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> phase_6</h2><ol><li>thinking process</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">phase_6(input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">0</span>;  <span class="comment">// %r12d</span></span><br><span class="line"><span class="type">int</span>* input_copy = input; <span class="comment">// mov %rsp, %r13</span></span><br><span class="line"><span class="type">int</span> val; <span class="comment">// %eax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    val = *(input_copy); <span class="comment">// 0x0(%r13)</span></span><br><span class="line">    val = val<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val&gt;<span class="number">5</span>)  explode()  <span class="comment">// 元素值不得大于6</span></span><br><span class="line">        </span><br><span class="line">    ++a1; <span class="comment">// add $0x1, %r12d</span></span><br><span class="line">    <span class="keyword">if</span>(a1 == <span class="number">6</span>) <span class="keyword">break</span>; <span class="comment">// jmp 95</span></span><br><span class="line">    <span class="type">int</span> a2 = a1; <span class="comment">// mov %r12d, %ebx</span></span><br><span class="line">    <span class="keyword">do</span>&#123;   <span class="comment">// 65</span></span><br><span class="line">        val = *(input+a2);</span><br><span class="line">        <span class="keyword">if</span>(val == *input_copy)</span><br><span class="line">            explode();</span><br><span class="line">        ++a2;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a2&lt;= <span class="number">5</span> ) <span class="comment">// 87</span></span><br><span class="line">    ++input_copy; <span class="comment">// add $0x4, %r13</span></span><br><span class="line">&#125; <span class="comment">// 93</span></span><br><span class="line"><span class="comment">/*两个信息：(已验证)</span></span><br><span class="line"><span class="comment">1. 输入字符串中所有元素不大于6</span></span><br><span class="line"><span class="comment">2. 输入字符串中所有元素互不相等 */</span> <span class="number">0</span>~<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* sentry = input+<span class="number">6</span>; <span class="comment">// mov 0x18(%rsp), %rsi   95</span></span><br><span class="line"><span class="type">int</span>* input_copy_2 = input; <span class="comment">// %rax</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">7</span>; <span class="comment">// %edx, %ecx</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    *(input_copy_2) = a3 - *(input_copy_2);</span><br><span class="line">    ++input_copy_2;</span><br><span class="line">&#125;<span class="keyword">while</span>(input_copy_2 != sentry)</span><br><span class="line"><span class="comment">/* 更新输入字符串所有值为：7-初始值(已证实), </span></span><br><span class="line"><span class="comment">结合之前的信息，说明此时的输入字符串均不小于1，且只可能存在一个等于1 */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a4 = <span class="number">0</span>; <span class="comment">// 123 %esi  -- index</span></span><br><span class="line"><span class="type">int</span> a5; <span class="comment">// %edx</span></span><br><span class="line"><span class="type">int</span> a6; <span class="comment">// %eax  -- index</span></span><br><span class="line">offset_166:</span><br><span class="line"><span class="keyword">if</span>(input[a4] &lt;= <span class="number">1</span>) <span class="comment">// 166  %ecx</span></span><br><span class="line">&#123;</span><br><span class="line">    a5 = <span class="number">0x6032d0</span>; <span class="comment">// 143</span></span><br><span class="line">    offset_148:</span><br><span class="line">    *(input+<span class="number">0x20</span>+<span class="number">2</span>*a4) = a5; <span class="comment">// 148 [8]:20, [10]:28, [12]:30, [14]:38, [16]:40,[18]:48</span></span><br><span class="line">                             <span class="comment">//   0x6032d0, 0x6032e0  0x6032f0 0x603200 0x603310 0x603320   </span></span><br><span class="line">    a4 += <span class="number">4</span>; <span class="comment">// add $0x4, %rsi </span></span><br><span class="line">    <span class="keyword">if</span>(a4 ==  <span class="number">24</span> )</span><br><span class="line">        <span class="keyword">goto</span> offset_183; <span class="comment">// 161 </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">goto</span> offset_166;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">// 均要走这个else， 可能有一个不走这个else --&gt;肯定有一个不走</span></span><br><span class="line">&#123;</span><br><span class="line">    a6 = <span class="number">1</span>;  <span class="comment">// 171  </span></span><br><span class="line">    &amp;a5 = <span class="number">0x6032d0</span>; <span class="comment">// 176  这个地址+0x8能多次跳转</span></span><br><span class="line">    <span class="keyword">do</span>&#123; <span class="comment">// 130</span></span><br><span class="line">        a5 = *(&amp;a5 + <span class="number">0x8</span>) ; <span class="comment">// mov 0x8(%rdx),%rdx  链表?</span></span><br><span class="line">        ++a6; </span><br><span class="line">    &#125;<span class="keyword">while</span>(a6 != *(input+a4) ) <span class="comment">// 139  (must have 1-6), 2-5, 3-4 , 4-3, 5-2, 6-1, (7-0)</span></span><br><span class="line">    <span class="keyword">goto</span> offset_148;         <span class="comment">// recorrect: 3-4, 4-3,5-2,6-1,1-6,2-5</span></span><br><span class="line">&#125; <span class="comment">// 181</span></span><br><span class="line"></span><br><span class="line">offset_183：    function: link node in order</span><br><span class="line"><span class="type">int</span> a7 = input[<span class="number">8</span>]; <span class="comment">//%rbx 0x20(%rsp)   *(input+ 8) ~ *(input+16) all represent a address</span></span><br><span class="line"><span class="type">int</span>* input_copy_3 = input+<span class="number">10</span> <span class="comment">// %rax  0x28(%rsp)</span></span><br><span class="line"><span class="type">int</span>* input_copy_4 = input+<span class="number">20</span> <span class="comment">// %rsi  0x50(%rsp)</span></span><br><span class="line">a3 = a7; <span class="comment">// a3:%rcx</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">// 201</span></span><br><span class="line">    a5 = *input_copy_3; <span class="comment">//a5:%rdx [10][12]...[18][20] 6</span></span><br><span class="line">    *(a3+<span class="number">0x8</span>) = a5; <span class="comment">// 0x8(%rcx)</span></span><br><span class="line">    input_copy_3 += <span class="number">2</span>; <span class="comment">// 0x8 </span></span><br><span class="line">    <span class="keyword">if</span>(input_copy_3 == input_copy_4) <span class="keyword">break</span>; <span class="comment">// 215 </span></span><br><span class="line">    a3 = a5; <span class="comment">// mov %rdx, %rcx</span></span><br><span class="line">&#125;    <span class="comment">//   make  *(a[i-2] + 0x8) = a[i] (i = i+2: 10 12 .. 18)</span></span><br><span class="line"><span class="comment">// 结束时 %rdx = * (input + 18)</span></span><br><span class="line"></span><br><span class="line">*(*(input+<span class="number">18</span>) + <span class="number">2</span> ) = <span class="number">0</span>; <span class="comment">// 222   set last node&#x27;s pointer to nullptr</span></span><br><span class="line"><span class="type">int</span> a8 = <span class="number">5</span>; <span class="comment">// %ebp</span></span><br><span class="line"><span class="type">int</span> a9 <span class="comment">// %rax </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"> &amp;a9 = *(a7+<span class="number">2</span>); <span class="comment">// %rax   initial a7 = input[8]</span></span><br><span class="line">  a9 = *a9; <span class="comment">// mov (%rax), %eax</span></span><br><span class="line"><span class="keyword">if</span>(*(*(input+<span class="number">8</span>)) &lt; a9) <span class="comment">// cmp %eax, (%rbx) </span></span><br><span class="line">    explode();   <span class="comment">// 验证是否降序</span></span><br><span class="line">a7 = *(*(input+<span class="number">8</span>)+<span class="number">2</span>); <span class="comment">// mov 0x8(%rbx), %rbx 更新%rbx  </span></span><br><span class="line">--a8;</span><br><span class="line">&#125;<span class="keyword">while</span>(a8&gt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// over</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*inital:</span></span><br><span class="line"><span class="comment">0x14c(0): 332;</span></span><br><span class="line"><span class="comment">0x0a8(1): 168;</span></span><br><span class="line"><span class="comment">0x39c(2): 924;</span></span><br><span class="line"><span class="comment">0x2b3(3): 691</span></span><br><span class="line"><span class="comment">0x1dd(4): 477</span></span><br><span class="line"><span class="comment">0x1bb(5): 443</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2-&gt;3-&gt;4-&gt;5-&gt;0-&gt;1 */</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>我完成phase_6的时间比前五个加起来还多，从第一次反汇编phase_6到彻底搞清楚phase_6各个步骤做了什么并推出答案花的时间可能接近有6，7个小时了，确定了这是一个链表问题，将链表排序并验证。这个phase里很关键的信息就是<code>0x6032d0</code>这个地址值，通过查看该地址后24个字的内容，可以看见这里储存了一个含有6个结点的链表，然后根据这个信息分析并反编译汇编代码， 即可发现我们的最终目的是使<code>0x6032d0</code>这里的链表降序排列。输入自己推算出的答案，看见终端显示出拆弹成功真的超开心</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677403752602-71565a7a-ae83-4e0e-a0d7-cdd2e3df1fd5.png#averageHue=%23232222&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=165&amp;id=u5a9db9de&amp;name=image.png&amp;originHeight=248&amp;originWidth=1501&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=164901&amp;status=done&amp;style=none&amp;taskId=u365af322-15ad-46fb-9cfc-245887947ea&amp;title=list%20after%20sort&amp;width=1000.6666666666666" alt="image.png" title="list after sort" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677402131273-de3ea8a9-669e-4bf2-8194-cccb235cd58b.png#averageHue=%23282828&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=217&amp;id=ucd4dd2ed&amp;name=image.png&amp;originHeight=325&amp;originWidth=1104&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146781&amp;status=done&amp;style=none&amp;taskId=u67c0a4b5-d060-40b2-9b3c-921a69962c7&amp;title=&amp;width=736" alt="image.png" /><br /><a name="QjpMp"></a></p><h2 id="secret_phase"><a class="markdownIt-Anchor" href="#secret_phase"></a> secret_phase</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404056138-294107ed-6f1c-4477-83c9-44b00041ef4b.png#averageHue=%232a2929&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=152&amp;id=u674c8aa7&amp;name=image.png&amp;originHeight=228&amp;originWidth=1213&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=42994&amp;status=done&amp;style=none&amp;taskId=u89aa5f1c-7b78-46bb-b51c-a2062f218dc&amp;title=&amp;width=808.6666666666666" alt="image.png" /></p><ol><li>发现彩蛋</li></ol><p>以上语句说明邪恶博士还给我们留了一手， 拆弹还没彻底完成，这个easter egg在bomb.c中是发现不了的，只能在bomb文件中寻找。CMU给出的writeup给了我们明确的提示，可以用<code>objdump -t bomb</code>查看函数的符号表，包括全局变量的名称和所有函数的名称，进而我们可以在符号表中发现secret_phase。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404753141-3d41a656-d41d-476c-aae5-e51421f24d6e.png#averageHue=%230b0b0a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=338&amp;id=u59b20a1e&amp;name=image.png&amp;originHeight=507&amp;originWidth=1706&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=217929&amp;status=done&amp;style=none&amp;taskId=ub07a14e6-ebf4-4769-b55c-e586658a966&amp;title=&amp;width=1137.3333333333333" alt="image.png" /></p><ol start="2"><li>怎么触发</li></ol><p>1)谁调用了secret_phase：<code>secret_phase</code>既然作为一个函数，那么就需要被调用，邪恶博士不会做了炸弹而不接引线，因此我们要在<code>main</code>函数中寻找可能调用<code>secret_base</code>的语句，既然phase_1到phase_6我们都分析过源码，所以调用语句肯定只能存在<code>phase_defused</code>函数中，反汇编<code>phase_defused</code>函数，果然发现了调用<code>secret_phase</code>的指令<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677404954528-c0e39bd3-077e-49cd-a460-d820f2047ce8.png#averageHue=%232b2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=488&amp;id=u9e4e339a&amp;name=image.png&amp;originHeight=732&amp;originWidth=1266&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=459111&amp;status=done&amp;style=none&amp;taskId=u6d1b7d59-0bf7-4df3-9948-00a20fc914f&amp;title=&amp;width=844" alt="image.png" /><br />2）在phase_defused中如何触发：从<code>main</code>函数可以看出，bomb文件在每次未触发炸弹而执行完一个phase的时候都会调用一次<code>phase_defused</code>。分析phase_defused，该函数当输入字符串表示分隔的数字值时，如果数字个数小于6个，直接返回，对应phase1~phase5；如果数字等于6个，继续执行，对应phase6<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414713624-83322f4b-2b99-42ce-9152-3c094464743d.png#averageHue=%232a2a29&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=167&amp;id=u4e91d4e7&amp;name=image.png&amp;originHeight=251&amp;originWidth=1753&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=206560&amp;status=done&amp;style=none&amp;taskId=u8107d152-8bbe-44eb-beb6-bd477c6e492&amp;title=&amp;width=1168.6666666666667" alt="image.png" /><br />接着从地址<code>0x603870</code>处读取两个数字，一个字符串<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414792269-cc61be84-af1a-449f-b88a-efdf5b602450.png#averageHue=%23262626&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=52&amp;id=u54634d3d&amp;name=image.png&amp;originHeight=78&amp;originWidth=676&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=25535&amp;status=done&amp;style=none&amp;taskId=uf1933c57-b4a3-46a2-a583-11eeb6c7623&amp;title=&amp;width=450.6666666666667" alt="image.png" /><br />经过验证，地址<code>0x603870</code>为phase_4阶段输入字符串的开始地址<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414872028-db9b7aa7-d78c-450a-877d-8d643d89022d.png#averageHue=%23272626&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=52&amp;id=u20d9ba63&amp;name=image.png&amp;originHeight=78&amp;originWidth=763&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=32367&amp;status=done&amp;style=none&amp;taskId=uf4f5ab27-77d8-4b6a-9614-34ea9d69b04&amp;title=&amp;width=508.6666666666667" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677414887631-8de449af-6eff-4f20-9632-860f0d751f77.png#averageHue=%232b2b2b&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=51&amp;id=u78a64d3f&amp;name=image.png&amp;originHeight=76&amp;originWidth=856&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=31655&amp;status=done&amp;style=none&amp;taskId=u1f45d585-4254-407d-a785-6859f161d5b&amp;title=&amp;width=570.6666666666666" alt="image.png" /><br />根据后续逻辑，只要在phase_4阶段时输入<code>&quot;7 0 DrEvil&quot;</code>即可触发<code>secret_bomb</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415081966-c8dd9474-52be-4ca5-b73b-da79cea387f2.png#averageHue=%232b2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=289&amp;id=uff04a21c&amp;name=image.png&amp;originHeight=434&amp;originWidth=1193&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=295794&amp;status=done&amp;style=none&amp;taskId=uc3d47c14-4fd2-4066-8097-d303800fa51&amp;title=&amp;width=795.3333333333334" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415023030-75fb6b08-160a-41a7-ac0c-2cd054c806ee.png#averageHue=%23272727&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=53&amp;id=u647b3556&amp;name=image.png&amp;originHeight=79&amp;originWidth=501&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=19252&amp;status=done&amp;style=none&amp;taskId=ubfabe50b-c88f-4d79-8759-413c728c17a&amp;title=&amp;width=334" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677415142283-f37e926f-a289-4c18-9170-346e631d561e.png#averageHue=%232a2a2a&amp;clientId=u54232b82-dfec-4&amp;from=paste&amp;height=361&amp;id=uc5b1fa4e&amp;name=image.png&amp;originHeight=542&amp;originWidth=1158&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=228864&amp;status=done&amp;style=none&amp;taskId=u4bbc5a61-2cb2-48b7-95b7-d8b064cb1ad&amp;title=&amp;width=772" alt="image.png" /></p><ol start="3"><li>终章：拆解secret_phase</li></ol><p>1）反编译secret_base</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">secret_phase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> input_2;<span class="comment">// (%rdi)</span></span><br><span class="line">    &amp;input_2 = read_line(); <span class="comment">//  %rdi</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">0xa</span>; <span class="comment">// %edx</span></span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">0x0</span>; <span class="comment">// %esi</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> input_num_1 = strtol(input_2); <span class="comment">// %rax</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> input_num_2 = input_num_1 <span class="comment">// %rbx</span></span><br><span class="line">    input_num_1 -= <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(input_num_1 &gt; <span class="number">0x3e8</span> <span class="comment">/*1000*/</span>) explode();</span><br><span class="line">    <span class="comment">// 输入的数字字符串 值小于 1001</span></span><br><span class="line">    a2 = input_num_2;<span class="comment">// mov %ebx, %esi  </span></span><br><span class="line">    &amp;input_2 = <span class="number">0x6030f0</span>;</span><br><span class="line">    <span class="type">int</span> ret = fun7(&amp;input_2,a2,input_num_1); <span class="comment">// ret_value: %rax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0x2</span>)</span><br><span class="line">        defused();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        explode(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(&amp;input_2, a2, input_num_1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;input_2 == <span class="number">0x0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// avoid endless recursion</span></span><br><span class="line">    <span class="type">int</span> a3 = *(&amp;input_2);  <span class="comment">// 9 %edx   initial a3 = 24</span></span><br><span class="line">    <span class="keyword">if</span>(a3 &lt;= a2) <span class="keyword">goto</span> offset_28; <span class="comment">// 13  a2是输入值 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a3 &gt; a2</span></span><br><span class="line">    input_2 = *(&amp;input_2 + <span class="number">0x8</span>); <span class="comment">// +2  turn left</span></span><br><span class="line">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">    input_num_1 *= <span class="number">2</span>; <span class="comment">// input_num_q is 1 here</span></span><br><span class="line">    <span class="keyword">return</span> input_num_1;</span><br><span class="line"></span><br><span class="line">    offset_28:</span><br><span class="line">    input_num_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a3 == a2) <span class="keyword">return</span> input_num_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a3 &lt; a2</span></span><br><span class="line">    input_2 = *(&amp;input_2 + <span class="number">0x10</span>); <span class="comment">// +4   turn right</span></span><br><span class="line">    input_num_1 = fun7(&amp;input_2, a2, input_num_1); <span class="comment">// 0</span></span><br><span class="line">    input_num_1 = <span class="number">2</span>*input_num_1 + <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> input_num_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）有了phase_6的经验，我在查看了特殊地址<code>0x6030f0</code>的内容后很快就反应出这又是链表相关的问题，扩大查看的地址范围后，我发现地址<code>0x6030f0</code>为起点进行索引，后面120个字大小的地址空间，表示一个高度为3，结点大小为8 words的二叉搜索树；再结合<code>secret_phase</code>的逻辑，在子函数<code>fun7</code>返回值为2时defuse，经过分析，<code>fun7</code>这个递归函数，在最后三次递归时为turn left(<code>&amp;input_2 + 0x8</code>）-&gt;turn right(<code>&amp;input_2 + 0x10</code>) -&gt; return 0时才能保证最终返回值为2，画出二叉树后，可以很清楚的看到，满足这样三步走的有且仅有子结点22 （子结点22再左走一步到叶子结点20，只是重复了一遍return 0，也满足要求，因此20也是最终答案，）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484445488-99b96bb8-8026-406a-8606-b6ed814389d7.png#averageHue=%232b2b2b&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=565&amp;id=u5030ad8b&amp;name=image.png&amp;originHeight=848&amp;originWidth=1530&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=595091&amp;status=done&amp;style=none&amp;taskId=uf7e602a3-1dfa-4402-88da-6b6d06e26db&amp;title=&amp;width=1020" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484586007-34081aec-ae5a-409a-9270-7503f23d697b.png#averageHue=%23fefefe&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=268&amp;id=u3886e51a&amp;name=image.png&amp;originHeight=321&amp;originWidth=613&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=45328&amp;status=done&amp;style=none&amp;taskId=uc94db6c6-0837-40f5-8324-986eeadfa19&amp;title=&amp;width=511.66668701171875" alt="image.png" /><br />3) 至此，整个bomblab就结束了，花费了我十多个小时完成了这个lab还是很值得的，伴随这一个又一个defuse，成就感是满满的，哈哈哈<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677484822762-1f6d54b5-8a8f-405e-ab5b-b3de5c095440.png#averageHue=%232d2d2d&amp;clientId=u289fcf2a-d904-4&amp;from=paste&amp;height=309&amp;id=ua22fc755&amp;name=image.png&amp;originHeight=463&amp;originWidth=1657&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=276450&amp;status=done&amp;style=none&amp;taskId=ua2ea40a4-48b8-410d-a36d-c5de36dd026&amp;title=&amp;width=1104.6666666666667" alt="image.png" /></p><hr /><p><a name="SLpu6"></a></p><h1 id="lab3-attacklab"><a class="markdownIt-Anchor" href="#lab3-attacklab"></a> lab3 attacklab</h1><p><a name="UbCO7"></a></p><h2 id="前提-2"><a class="markdownIt-Anchor" href="#前提-2"></a> 前提</h2><ol><li>注意！该实验在ubuntu22.04上是没法做的，任何形式的攻击都会引发segment fault，建议用ubuntu22.04的同学跟博主一样另外再安装一个ubuntu20.04</li></ol><p>博主就是在这踩了坑，一直以为操作有问题，后来带着实验的执行环境google了一下才发现这个问题</p><ol start="2"><li>exploit string用工具<code>hex/2raw</code>构造并传递给字符串，该工具要求输入的每个字节用2-digit 十六进制数表示，两个字节之间用空格分开，输出对应的二进制序列。</li></ol><p>writeup的附录A介绍了多种<code>hex/2raw</code>接受输入字符串并传递给ctarget的多种方式，我习惯用：<br /><code>./hex2raw &lt; exploit_string.txt | ./ctarget -q</code><br />这条命令将<code>exploit_string.txt</code>作为<code>hex2raw</code>的输入，并建立管道将<code>hex2raw</code>的输出传输到<code>./ctarget</code>中，-q命令选项表示不向评分服务器发送信息，如果你是CMU的可以不用这个选项（哈哈哈）。该工具应该只接受文件流的输入，如果在终端直接执行<code>./hex2raw</code>那么将无法中止输入<br /><a name="Kk3w5"></a></p><h2 id="phase_1-2"><a class="markdownIt-Anchor" href="#phase_1-2"></a> phase_1</h2><ol><li>反汇编<code>ctarget</code>：可用<code>objdump -d ctarget</code>获取ctarget的汇编版本，为了方便，我们直接将输出定向到一个asm文件中</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585087533-3d1cfcba-4dd9-41f4-8cc8-bb4c35b8674f.png#averageHue=%231b1b1b&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=40&amp;id=u07c104d6&amp;name=image.png&amp;originHeight=60&amp;originWidth=1223&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=26128&amp;status=done&amp;style=none&amp;taskId=u6e9b8aa5-d406-4587-b032-e270697a03a&amp;title=&amp;width=815.3333333333334" alt="image.png" /><br />这样我们每次查看ctarget的汇编版本时，就不用重新反汇编一次了</p><ol start="2"><li><code>vim dis_ctarget.asm</code>查看<code>getbuf</code>函数的汇编代码，可以看见它的栈帧长度为0x28（40）个字节，因此要覆盖在这之上的调用者<code>test</code>函数的ret地址，只需在缓冲区写入0x30（48）个字节即可；查看<code>touch1</code>函数，它的地址在<code>0x004017c0</code>处，因此要在exploit_string的最后8个字节上填入c0 17 40 00（little-endian）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677585873581-353e1114-4253-4b23-aceb-6ba85c12e660.png#averageHue=%231c1c1c&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=318&amp;id=ub151bf36&amp;name=image.png&amp;originHeight=477&amp;originWidth=1375&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=178834&amp;status=done&amp;style=none&amp;taskId=u661b7e64-355d-4240-a2ac-0d48718019c&amp;title=&amp;width=916.6666666666666" alt="image.png" /></p><ol start="3"><li><code>vim phase_1.txt</code>输入</li></ol><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>0</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>40</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>00</mn></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\  &amp;00 &amp;00  &amp; 00 &amp;00  &amp;00  &amp;00  &amp;00 &amp;00 \\  &amp;00  &amp;00  &amp;00  &amp;00 &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00  &amp;00\\  &amp;c0 &amp;17  &amp;40  &amp;00  &amp;00  &amp;00  &amp;00\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.200000000000001em;vertical-align:-3.35em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-5.8500000000000005em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.650000000000001em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.05em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:0.1500000000000002em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span><br />最后留了一个字节以供gets放入’ \n ’ (不放也没事，执行touch1能直接退出程序)。最后一行result显示PASS就说明攻击生效了<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677586525442-cc13fc97-7de2-4bc6-90c7-bdb9356cc9b4.png#averageHue=%231c1c1c&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=196&amp;id=u93bb9ade&amp;name=image.png&amp;originHeight=294&amp;originWidth=1896&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=129168&amp;status=done&amp;style=none&amp;taskId=u503e0466-2b33-4b30-9a9e-f21980d78e7&amp;title=&amp;width=1264" alt="image.png" /><br /><a name="xCSRi"></a></p><h2 id="phase_2-2"><a class="markdownIt-Anchor" href="#phase_2-2"></a> phase_2</h2><ol><li>编写汇编代码，转化为字节码：<code>vim asb.s</code>，输入以下汇编代码（push可直接压入地址，不必先放入寄存器）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637642575-745a9de7-6e49-4ef0-9f44-46dbe3cfb8a0.png#averageHue=%23232323&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=62&amp;id=uc88e8483&amp;name=image.png&amp;originHeight=93&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=15349&amp;status=done&amp;style=none&amp;taskId=u1fe3d97e-2ee2-4e3f-b2f0-921ac53df4e&amp;title=&amp;width=253.33333333333334" alt="image.png" /><br />line1将<code>cookie</code>值赋给<code>%rdi</code>传参给<code>touch2</code>；ine2将2<code>touch2</code>的地址压入栈中，目的在于在<code>ret</code>指令执行后，从栈中弹出并赋值给<code>%rip</code>的返回地址是<code>touch2</code>的地址<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677637347348-81a97333-5ab5-4766-b689-e0a40d50a9b1.png#averageHue=%23131313&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=221&amp;id=u494680d1&amp;name=image.png&amp;originHeight=331&amp;originWidth=1165&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=130023&amp;status=done&amp;style=none&amp;taskId=u8d81b4ca-fd2a-4ce9-ba46-d1e09ded02c&amp;title=%E8%8E%B7%E5%8F%96touch2%E7%9A%84%E5%9C%B0%E5%9D%80&amp;width=776.6666666666666" alt="image.png" title="获取touch2的地址" /><br />writeup的附录B提示我们将gcc与objdump结合使用产生指令序列的字节码<br /><code>gcc -c asb.s</code><br /><code>objdump -d asb.o &gt; asb.d</code><br />这样我们就得到了指令序列的字节码，可用于构造exploit_string<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638192080-ecafc66a-645a-4bf0-a9d2-af3a00412381.png#averageHue=%23191918&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=203&amp;id=u9041b219&amp;name=image.png&amp;originHeight=304&amp;originWidth=962&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=84296&amp;status=done&amp;style=none&amp;taskId=ue5e430b5-0a7a-42c3-8791-f51017acec7&amp;title=&amp;width=641.3333333333334" alt="image.png" /></p><ol start="2"><li>构造<code>phase_2.txt</code>，因为<code>asb.o</code>中的代码本身就已经逆序，所以直接输入即可；用于覆盖<code>test</code>栈帧中返回地址的值可由<code>%rsp</code>的值推算出（取决于你将字节码放在缓冲区的位置），这里为了方便， 我将字节码放在了缓冲区的开头，则用于覆盖的地址就是<code>%rsp</code>的值</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677591555601-28a75db3-4efc-445a-bd75-67d6722d57ee.png#averageHue=%231d1d1d&amp;clientId=u2c7b2c0d-00ea-4&amp;from=paste&amp;height=359&amp;id=pvcAu&amp;name=image.png&amp;originHeight=539&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=188389&amp;status=done&amp;style=none&amp;taskId=u8ffbde5e-78e3-433e-a1a6-dfa4742b694&amp;title=%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%80%BC&amp;width=783.3333333333334" alt="image.png" title="获取栈顶值" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638376139-5fb21190-4237-424f-a168-1c204bce6ef7.png#averageHue=%231b1b1b&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=406&amp;id=ud656f730&amp;name=image.png&amp;originHeight=609&amp;originWidth=806&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=117050&amp;status=done&amp;style=none&amp;taskId=u39e09168-0d44-4223-a419-2cad498a46f&amp;title=phase_2_exploit_string&amp;width=537.3333333333334" alt="image.png" title="phase_2_exploit_string" /></p><ol start="3"><li>攻击生效</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677638454464-852c44b4-14f9-43fe-8e9f-a927c267b260.png#averageHue=%230b0b0b&amp;clientId=u7f8a8b62-e84b-4&amp;from=paste&amp;height=233&amp;id=ua99fc494&amp;name=image.png&amp;originHeight=349&amp;originWidth=1225&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146341&amp;status=done&amp;style=none&amp;taskId=uba333293-f36a-4b4a-bd6b-7ab4d63bd03&amp;title=&amp;width=816.6666666666666" alt="image.png" /><br /><a name="TVVPU"></a></p><h2 id="phase_3-2"><a class="markdownIt-Anchor" href="#phase_3-2"></a> phase_3</h2><ol><li>与<code>phase_2</code>很像，但这次要传递的参数是字符串形式的<code>cookie</code>。因为<code>getbuf</code>的栈帧在函数结束后就被操作系统收回，且会被后续函数调用占用，因此我们将字符串<code>cookie</code>放在<code>test</code>函数的栈帧中，地址<code>0x5561dca8</code>；获取<code>touch3</code>函数的地址，编写攻击代码</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677673769317-083e3c3d-3eb7-4716-8b34-154511f96d34.png#averageHue=%231c1c1c&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=236&amp;id=ufe6c6401&amp;name=image.png&amp;originHeight=354&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=123850&amp;status=done&amp;style=none&amp;taskId=ue426e205-3b8c-42f1-a2ca-516774edd68&amp;title=&amp;width=788.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678328785-d2f2582c-e25c-484b-83d8-4a0a2595ab07.png#averageHue=%23060606&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=61&amp;id=u15b6d558&amp;name=image.png&amp;originHeight=91&amp;originWidth=347&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=11449&amp;status=done&amp;style=none&amp;taskId=u1ce98f2a-043c-4c00-b0a0-20b0f14e918&amp;title=&amp;width=231.33333333333334" alt="image.png" /></p><ol start="2"><li><code>ascii -ax</code>查看十六进制形式的ascii-table，得出<code>&quot;59b997fa&quot;</code>的ascii形式为<code>35 39 62 39 39 37 66 61</code></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678551264-8b3b6a28-3390-45cb-bbc6-b20f241eb472.png#averageHue=%231d1d1d&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=247&amp;id=u95244bf5&amp;name=image.png&amp;originHeight=370&amp;originWidth=1204&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=116378&amp;status=done&amp;style=none&amp;taskId=u6e6beaa6-64b0-4c0c-ba41-3a88510ea43&amp;title=&amp;width=802.6666666666666" alt="image.png" /></p><ol start="3"><li>覆盖返回地址和test栈帧，写入攻击代码的地址和字符串<code>cookie</code></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678755332-3ea51646-6c2b-4212-8f6a-d6fe5551fa9a.png#averageHue=%23202020&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=210&amp;id=u5caf20c9&amp;name=image.png&amp;originHeight=315&amp;originWidth=871&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=61586&amp;status=done&amp;style=none&amp;taskId=uc183fab2-b53c-4109-9912-d5f30dc3d02&amp;title=&amp;width=580.6666666666666" alt="image.png" /></p><ol start="4"><li>攻击生效</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677678782689-4f003174-6f36-4200-87cd-d46e586d9907.png#averageHue=%231d1d1d&amp;clientId=ub6cccc71-6474-4&amp;from=paste&amp;height=235&amp;id=u145918cd&amp;name=image.png&amp;originHeight=353&amp;originWidth=1184&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=131718&amp;status=done&amp;style=none&amp;taskId=u08615a2d-ec29-45b1-bc0c-7f9a93e2212&amp;title=&amp;width=789.3333333333334" alt="image.png" /><br /><a name="UnHwd"></a></p><h2 id="phase_4-2"><a class="markdownIt-Anchor" href="#phase_4-2"></a> phase_4</h2><p>确定攻击方案：<code>rtarget</code>由于具备栈随机化，以及栈内代码不可执行这两个属性，所以如果要在栈中插入攻击代码将面临两个问题：1）用于指向攻击代码的地址无法确定：因为我们要把攻击代码放入栈中，但栈的位置不确定，进而我们也无法创建指向攻击代码的指针  2）攻击代码无法执行，因为栈被标注为不可执行。writeup给了我们明确的提示，既然我们无法插入自己的攻击代码，那么就用<code>ctarget</code>自身的代码实现攻击，具体做法是通过地址跳转，截取<code>ctarget</code>的部分代码用作攻击代码；<code>gadget</code>指的是几条指令后跟着一条ret指令的程序片段，如果把函数栈设置为一连串<code>gadget</code>的地址，那么一旦执行其中一个<code>gadget</code>，<code>ret</code>指令就会不断的从栈中弹出新的<code>gadget</code>的地址赋给<code>%rip</code>,由此引发多个<code>gadget</code>的连续执行（注意函数调用栈地址的随机化跟程序代码的地址无关）</p><ol><li><code>cookie</code>的值不可能从<code>rgadget</code>中找到，需要我们自己放到栈中，如同<code>phase_3</code>一样，放的位置不能是<code>getbuf</code>的缓冲区，因此我们将其放到<code>test</code>的栈帧中；接着要实现<code>mov $0x59b997fa,%rdi</code>，需执行<code>popq %rdi</code>，根据writeup的参照表，先在<code>start_farm</code>和<code>end_farm</code>之间寻找<code>5f</code>，结果没有，但是找到了<code>58 90</code>,地址为<code>0x004019ab</code>，这代表<code>popq %rax  nop</code>，因此我们需要用<code>%rax</code>作介质传递<code>cookie</code>给<code>%rdi</code>，而在farm中我们也确实找到了<code>movq %rax, %rdi：48 89 c7</code>，地址为<code>0x004019c5</code>，一共用到了两个<code>gadget</code></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748308138-674aa437-9522-414c-afcf-828967ad2c1b.png#averageHue=%231f1f1f&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=82&amp;id=ueb5eeaef&amp;name=image.png&amp;originHeight=123&amp;originWidth=1061&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=44128&amp;status=done&amp;style=none&amp;taskId=u3043295b-c67b-407d-81b2-642907b3b41&amp;title=&amp;width=707.3333333333334" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677748250489-e3dcf01c-ae26-4997-a969-4efde7d2c835.png#averageHue=%231c1b1b&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=163&amp;id=ube7f5b3e&amp;name=image.png&amp;originHeight=244&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=73997&amp;status=done&amp;style=none&amp;taskId=ub3c3a582-4fc1-4e85-ac8e-de93a3fa7d2&amp;title=&amp;width=706.6666666666666" alt="image.png" /></p><ol start="2"><li>按照下图逻辑编写phase_4，可实现攻击。自此attacklab就结束了，第一次感觉自己当了一名hacker，感觉很棒</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750944719-6ccf095c-ffce-4020-8cb6-f5b0f0fde9f8.png#averageHue=%2310222d&amp;clientId=u0689b11d-a2d1-4&amp;from=ui&amp;height=546&amp;id=u0eb7edee&amp;name=yuque_diagram.png&amp;originHeight=1110&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38484&amp;status=done&amp;style=none&amp;taskId=uf668df10-5035-4532-8f4f-6e2ef500940&amp;title=&amp;width=187" alt="yuque_diagram.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677751046005-10305a9e-443a-4de9-9d53-344ef204db84.png#averageHue=%23202020&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=186&amp;id=u3879cf7f&amp;name=image.png&amp;originHeight=279&amp;originWidth=762&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=62095&amp;status=done&amp;style=none&amp;taskId=uef71dd0c-5925-4f87-8c3b-ca049535c44&amp;title=&amp;width=508" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1677750954828-918501d5-682b-4638-ac25-f66bced64fb7.png#averageHue=%231c1c1c&amp;clientId=u0689b11d-a2d1-4&amp;from=paste&amp;height=235&amp;id=u61b7152b&amp;name=image.png&amp;originHeight=353&amp;originWidth=1387&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=128770&amp;status=done&amp;style=none&amp;taskId=u3e63c29c-34df-412e-b6ae-c66bfaa71c6&amp;title=&amp;width=924.6666666666666" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言【王爽】实验流程</title>
      <link href="/2023/02/04/assembly/"/>
      <url>/2023/02/04/assembly/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><a name="MTE7s"></a># 前言：前前后后看完这本书，做完所有实验和检测点，用了接近一个月的时间，除了最后几天比较认真，其余时间是比较懒散的，这本书其实最多半个月就能解决掉。接下来会步入CSAPP第三章的学习，争取早日把有名的attack lab完成了<span id="more"></span>---<p><a name="PhqOH"></a></p><h1 id="实验1-查看cpu和内存用机器指令和汇编指令编程"><a class="markdownIt-Anchor" href="#实验1-查看cpu和内存用机器指令和汇编指令编程"></a> 实验1 查看CPU和内存，用机器指令和汇编指令编程</h1><p><a name="xymUo"></a></p><h2 id="debug环境搭建参考此文"><a class="markdownIt-Anchor" href="#debug环境搭建参考此文"></a> debug环境搭建：<a href="https://blog.csdn.net/YuzuruHanyu/article/details/80287419?spm=1001.2014.3001.5506">参考此文</a></h2><p><a name="UrdzB"></a></p><h2 id="assignment-1"><a class="markdownIt-Anchor" href="#assignment-1"></a> assignment 1</h2><ol><li>用A命令向内存中写入汇编指令，用U命令查看</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249473372-3a80b2ab-d9e2-483c-ac41-140d30fdd765.png#averageHue=%23161616&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=248&amp;id=ub963f2d1&amp;name=image.png&amp;originHeight=245&amp;originWidth=374&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6659&amp;status=done&amp;style=none&amp;taskId=u0fa9efb8-dccf-4ce1-b3ea-8d79929c540&amp;title=&amp;width=378" alt="image.png" /></p><ol start="2"><li>用R命令分别修改CS、IP寄存器，即CS:IP的指向，用T命令逐条执行</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673249669344-d36231e5-8310-46ba-a3c6-155e2601ff58.png#averageHue=%230e0e0e&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=309&amp;id=udc060390&amp;name=image.png&amp;originHeight=309&amp;originWidth=608&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7838&amp;status=done&amp;style=none&amp;taskId=udc51570f-ded8-4f72-a2f5-ee442502176&amp;title=&amp;width=608" alt="image.png" /><br /><a name="rTW1r"></a></p><h2 id="assignment-2"><a class="markdownIt-Anchor" href="#assignment-2"></a> assignment 2</h2><ol><li>写入并查看指令</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250172971-61fbb876-feda-4ca9-b81d-e558cc0e5a6a.png#averageHue=%23151515&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=174&amp;id=u55f6e2fe&amp;name=image.png&amp;originHeight=174&amp;originWidth=376&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4324&amp;status=done&amp;style=none&amp;taskId=u9c9ba619-9a5c-4e5c-9e9d-45d5a6ea724&amp;title=&amp;width=376" alt="image.png" /></p><ol start="2"><li>修改_CS:IP_指向</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250237721-ec3e62f5-f6bc-4890-8f25-b62f6d89e60e.png#averageHue=%230c0c0c&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=228&amp;id=u87c23aee&amp;name=image.png&amp;originHeight=228&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7409&amp;status=done&amp;style=none&amp;taskId=u0c70f1dc-bfd2-4472-a4d5-84a3fe97214&amp;title=&amp;width=642" alt="image.png" /></p><ol start="3"><li>执行指令，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，结果为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>X</mi><mo>=</mo><mn>0100</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">AX = 0100H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673250558182-3582fd8d-9783-421c-9731-0d83ae5c81a8.png#averageHue=%23121212&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=72&amp;id=u92a48cc6&amp;name=image.png&amp;originHeight=72&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2934&amp;status=done&amp;style=none&amp;taskId=ud124b271-ce25-43f5-aabf-1f9dd478c19&amp;title=&amp;width=583" alt="image.png" /><br /><a name="QAZ3Z"></a></p><h2 id="assignment-3"><a class="markdownIt-Anchor" href="#assignment-3"></a> assignment 3</h2><ol><li>用D命令查找，最终在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mn>5</mn><mi>H</mi><mo>→</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>C</mi><mi>H</mi><mtext>（</mtext><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>:</mo><mn>0005</mn><mo>→</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>:</mo><mn>000</mn><mi>C</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">FFFF5H \to FFFFCH（FFFF:0005 \to FFFF:000C）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">）</span></span></span></span>发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>d</mi><mi mathvariant="normal">/</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>y</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">dd/mm/yy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>字样的生产日期</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251622812-ca79ef23-5a2a-46b2-ba9f-326aa9d3bc54.png#averageHue=%23161616&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=68&amp;id=ud8481a70&amp;name=image.png&amp;originHeight=68&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3411&amp;status=done&amp;style=none&amp;taskId=u26b9075a-3732-4bca-831f-f7252d9a335&amp;title=&amp;width=630" alt="image.png" /></p><ol start="2"><li>尝试用E命令修改，该操作失效，因为这是ROM</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673251941938-25cdf39e-5c26-49a3-81da-f108dff28da7.png#averageHue=%230f0f0f&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=120&amp;id=u23687460&amp;name=image.png&amp;originHeight=120&amp;originWidth=632&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4133&amp;status=done&amp;style=none&amp;taskId=uca81322b-a794-4e03-b596-0d7a694a021&amp;title=&amp;width=632" alt="image.png" /><br /><a name="CHS7t"></a></p><h2 id="assignment-4"><a class="markdownIt-Anchor" href="#assignment-4"></a> assignment 4</h2><p>1.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>0000</mn><mi>H</mi><mo>→</mo><mi>B</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">A0000H \to BFFFFH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>对8086 PC机是显存地址，往这个范围内的内存写入数据，会改变显示器上的内容，我们可以看见屏幕上出现了笑脸、爱心和钻石<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253290191-823908a7-61e0-4e4d-ac20-66184b8a4509.png#averageHue=%23141414&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=24&amp;id=udb4b1014&amp;name=image.png&amp;originHeight=24&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=646&amp;status=done&amp;style=none&amp;taskId=uc1f68660-8c22-4e6b-81ab-8168f9d217e&amp;title=&amp;width=316" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673253301915-ead25a09-d4a2-48f2-ba25-7bb4b7279d64.png#averageHue=%230000aa&amp;clientId=uc99250e8-54b1-4&amp;from=paste&amp;height=46&amp;id=u1f906edf&amp;name=image.png&amp;originHeight=46&amp;originWidth=489&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1808&amp;status=done&amp;style=none&amp;taskId=u8980a613-e82f-4ceb-a518-1e33c095648&amp;title=&amp;width=489" alt="image.png" /></p><hr /><p><a name="hcb7h"></a></p><h1 id="实验2-用机器指令和汇编指令编程"><a class="markdownIt-Anchor" href="#实验2-用机器指令和汇编指令编程"></a> 实验2 用机器指令和汇编指令编程</h1><p><a name="vDc8z"></a></p><h2 id="assignment-1-2"><a class="markdownIt-Anchor" href="#assignment-1-2"></a> assignment 1</h2><ol><li>用A指令向内存中写入汇编指令，用U指令查看</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596808599-b129a717-4d20-42a3-8823-64dc726440e3.png#averageHue=%23151515&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=236&amp;id=uc9b341b4&amp;name=image.png&amp;originHeight=236&amp;originWidth=374&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6210&amp;status=done&amp;style=none&amp;taskId=uf45debe0-8185-465e-b3c1-03874bac6c7&amp;title=&amp;width=374" alt="image.png" /></p><ol start="2"><li>修改CS:IP使其指向代码段</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673596896692-f6335ebe-e9b7-44cf-9a38-d686dde7d140.png#averageHue=%230a0a0a&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=162&amp;id=u325eac60&amp;name=image.png&amp;originHeight=162&amp;originWidth=577&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4064&amp;status=done&amp;style=none&amp;taskId=uaa5719c7-c665-4f9e-baa5-b5de2b24fc8&amp;title=&amp;width=577" alt="image.png" />、</p><ol start="3"><li>t命令逐步执行指令后查看AX、BX、SP寄存器内容</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673597028389-791ccf84-0268-4f23-976f-53e6ecd97b36.png#averageHue=%23121212&amp;clientId=u2caa9258-9642-4&amp;from=paste&amp;height=374&amp;id=ueb563e3c&amp;name=image.png&amp;originHeight=374&amp;originWidth=635&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15302&amp;status=done&amp;style=none&amp;taskId=u24406e7c-e085-4926-bf36-d7ff7eeb06a&amp;title=&amp;width=635" alt="image.png" /><br /><a name="NB9fg"></a></p><h2 id="assignment-2-2"><a class="markdownIt-Anchor" href="#assignment-2-2"></a> assignment 2</h2><p>在使用T命令进行单步追踪的时候，产生了中断，为了保护现场，CPU将PSW、CS和IP依此入栈，导致了内存相关位置内容的改变（保留疑问）</p><hr /><p><a name="jpe3I"></a></p><h1 id="实验3-编程-编译-链接-跟踪"><a class="markdownIt-Anchor" href="#实验3-编程-编译-链接-跟踪"></a> 实验3 编程、编译、链接、跟踪</h1><p><a name="QMUAH"></a></p><h2 id="assignment-1-3"><a class="markdownIt-Anchor" href="#assignment-1-3"></a> assignment 1</h2><ol><li>编译链接生成可执行文件</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673681789903-cb9f13be-b044-4c3f-be1d-8fa401195306.png#averageHue=%230b0b0b&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=328&amp;id=ufc540080&amp;name=image.png&amp;originHeight=328&amp;originWidth=524&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8289&amp;status=done&amp;style=none&amp;taskId=uaf6acc9d-3a30-400a-b361-0bea1d87366&amp;title=&amp;width=524" alt="image.png" /><br /><a name="bm7kI"></a></p><h2 id="assignment-2-3"><a class="markdownIt-Anchor" href="#assignment-2-3"></a> assignment 2</h2><ol><li>debug将程序载入内存，设置CS:IP：程序所在内存段的段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mo>=</mo><mn>075</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">DS=075C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，则PSP的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>075</mn><mi>C</mi><mo>:</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">075C:0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，程序的地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>0</mn><mtext>  </mtext><mo stretchy="false">(</mo><mn>075</mn><mi>C</mi><mo>+</mo><mn>10</mn><mo>:</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">076C:0\;(075C+10:0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi><mo>:</mo><mi>I</mi><mi>P</mi><mo>=</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0000</mn></mrow><annotation encoding="application/x-tex">CS:IP = 076C:0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682350829-98451696-0d75-4414-87c5-b527b5c96169.png#averageHue=%23111111&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=90&amp;id=u24027707&amp;name=image.png&amp;originHeight=90&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3436&amp;status=done&amp;style=none&amp;taskId=u88d9a7fb-f08c-4035-82ab-48a67509d8f&amp;title=&amp;width=583" alt="image.png" /></p><ol start="2"><li>跟踪程序执行过程</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682565168-917f19d2-8e0c-44ab-84e5-453c301bcda0.png#averageHue=%23111111&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=378&amp;id=u739eac5d&amp;name=image.png&amp;originHeight=378&amp;originWidth=593&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13977&amp;status=done&amp;style=none&amp;taskId=u7a4cf037-0141-418c-a6bc-3a455f22fa1&amp;title=&amp;width=593" alt="image.png" /><br />用P命令执行<code>INT 21</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682678668-4d6f6ba6-a61b-408a-8aa9-f84fdd1abc8a.png#averageHue=%230d0d0d&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=386&amp;id=ue3d6f0ce&amp;name=image.png&amp;originHeight=386&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12637&amp;status=done&amp;style=none&amp;taskId=ud602a7a4-6c24-495c-b269-66ce57ddba3&amp;title=&amp;width=620" alt="image.png" /><br /><a name="fqp3r"></a></p><h2 id="assignment-3-2"><a class="markdownIt-Anchor" href="#assignment-3-2"></a> assignment 3</h2><ol><li>查看PSP的内容</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673682886059-386e1af8-2b73-480f-92b1-d2ea01cce40a.png#averageHue=%23161616&amp;clientId=ufc3ba72b-b1bc-4&amp;from=paste&amp;height=175&amp;id=ueb72f5b4&amp;name=image.png&amp;originHeight=175&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=6346&amp;status=done&amp;style=none&amp;taskId=ufec3ae9d-8d07-4ba6-ae47-78454c6ed61&amp;title=&amp;width=625" alt="image.png" /></p><hr /><p><a name="eTiIA"></a></p><h1 id="实验4-bx和loop的使用"><a class="markdownIt-Anchor" href="#实验4-bx和loop的使用"></a> 实验4 [bx]和loop的使用</h1><p><a name="Ypsn2"></a></p><h2 id="assignment-1-4"><a class="markdownIt-Anchor" href="#assignment-1-4"></a> assignment 1</h2><ol><li>编写源程序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax, 0020H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov dx, 0</span><br><span class="line">mov cx, 64</span><br><span class="line"></span><br><span class="line">s: </span><br><span class="line">mov [bx],dx</span><br><span class="line">inc bx</span><br><span class="line">inc dx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="2"><li>编译，链接生成可执行文件</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673769654198-dcf5a11b-b298-4d67-ac52-e6412baa7953.png#averageHue=%230a0a0a&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=308&amp;id=ucb1b0e3f&amp;name=image.png&amp;originHeight=308&amp;originWidth=563&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9162&amp;status=done&amp;style=none&amp;taskId=ud2798294-b700-4d36-9278-b89b6f31b7e&amp;title=&amp;width=563" alt="image.png" /></p><ol start="3"><li>查看载入内存的程序，可以看见标签s已被替换为地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>000</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076C:000E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770040980-f6175097-5e41-41f0-a0d4-ed6dcc9e2d26.png#averageHue=%230f0f0f&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=257&amp;id=ub7d89c02&amp;name=image.png&amp;originHeight=257&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9471&amp;status=done&amp;style=none&amp;taskId=u76baa400-787b-4ed1-b282-488abb7c243&amp;title=&amp;width=601" alt="image.png" /></p><ol start="4"><li>执行程序，验证结果，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673770269260-0b535c86-7318-4bea-9b9b-151df8786503.png#averageHue=%23151515&amp;clientId=ua6d781cd-6a2a-4&amp;from=paste&amp;height=144&amp;id=u9760e10a&amp;name=image.png&amp;originHeight=144&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4621&amp;status=done&amp;style=none&amp;taskId=u407ff41a-3998-40b9-80e2-b904a9486e8&amp;title=&amp;width=480" alt="image.png" /><br /><a name="q95Oy"></a></p><h2 id="assignment-2-4"><a class="markdownIt-Anchor" href="#assignment-2-4"></a> assignment 2</h2><ol><li>编写源程序：将bx寄存器两用，即作偏移地址，又作操作数，可将程序缩短为9条指令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax, 0020H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 64</span><br><span class="line"></span><br><span class="line">s: </span><br><span class="line">mov [bx],bx</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h </span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="2"><li>其它步骤与assigment 1一致，验证结果，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673771416582-e853218d-46c6-4bf8-98d6-cacae4200dbb.png#averageHue=%231a1a1a&amp;clientId=u7cc11769-d150-4&amp;from=paste&amp;height=359&amp;id=u85d074a9&amp;name=image.png&amp;originHeight=373&amp;originWidth=490&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9679&amp;status=done&amp;style=none&amp;taskId=uca7996c4-5515-4485-9bd2-5bed6cf48b4&amp;title=&amp;width=472" alt="image.png" /><br /><a name="b3BKL"></a></p><h2 id="assignment-3-3"><a class="markdownIt-Anchor" href="#assignment-3-3"></a> assignment 3</h2><ol><li>复制的是什么：复制程序的第一条指令<code>mov ax,cs</code>到 <code>loop s</code> 指令至内存地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0020</mn><mo>:</mo><mn>0000</mn></mrow><annotation encoding="application/x-tex">0020:0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>处</li><li>如何知道程序的字节数：首先可以确定第一个空应该填入CS，这是程序的段地址，其次在<code>mov cx,_____</code> 上先随意填一个1，用debug跟踪程序，用U命令查看程序所占地址范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi><mo>:</mo><mn>0000</mn><mo>→</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0015</mn></mrow><annotation encoding="application/x-tex">076C:0000 \to 076C:0015</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">5</span></span></span></span>，共<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>H</mi><mtext> </mtext><mo stretchy="false">(</mo><mn>23</mn><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">16H\,(23D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>个字节,因此第二个空应该填入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">16H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673774640766-de55642e-4594-4add-9f75-ac17f9cf3628.png#averageHue=%230d0d0d&amp;clientId=u7cc11769-d150-4&amp;from=paste&amp;height=282&amp;id=u704b4ac0&amp;name=image.png&amp;originHeight=282&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9580&amp;status=done&amp;style=none&amp;taskId=u46b6c23e-98fc-45b4-ad17-7f7d7bef327&amp;title=&amp;width=616" alt="image.png" /></p><hr /><p><a name="l6DRo"></a></p><h1 id="实验5-编写-调试具有多个段的程序"><a class="markdownIt-Anchor" href="#实验5-编写-调试具有多个段的程序"></a> 实验5 编写、调试具有多个段的程序</h1><p><a name="y07m5"></a></p><h2 id="assignment-1-5"><a class="markdownIt-Anchor" href="#assignment-1-5"></a> assignment 1</h2><ol><li>将程序载入内存后查看，可知data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877104816-d24fcee5-293b-4965-a116-55b74e84812c.png#averageHue=%23101010&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=266&amp;id=u68a1fe4a&amp;name=image.png&amp;originHeight=266&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10189&amp;status=done&amp;style=none&amp;taskId=u25c1d019-e4f1-4cb3-9fef-a5363cacec8&amp;title=&amp;width=619" alt="image.png" /></p><ol start="2"><li>Q1：<code>G 001D</code>执行程序至程序返回前，用U命令查看data段内容: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0123</mn><mi>H</mi><mo separator="true">,</mo><mn>0456</mn><mi>H</mi><mo separator="true">,</mo><mn>0789</mn><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>A</mi><mi>B</mi><mi>C</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>D</mi><mi>E</mi><mi>F</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>F</mi><mi>E</mi><mi>D</mi><mi>H</mi><mo separator="true">,</mo><mn>0</mn><mi>C</mi><mi>B</mi><mi>A</mi><mi>H</mi><mo separator="true">,</mo><mn>0987</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">8</span><span class="mord">9</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">9</span><span class="mord">8</span><span class="mord">7</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，与初状态(源程序)一致，该程序按顺序做了入栈和出栈操作，因此数据不变</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877337524-5a528fcf-a7ec-47a7-ba04-6014616d76ff.png#averageHue=%231a1a1a&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=51&amp;id=u84a23991&amp;name=image.png&amp;originHeight=51&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1917&amp;status=done&amp;style=none&amp;taskId=u5609cee2-98bd-479e-9a89-84510ea0a9d&amp;title=&amp;width=480" alt="image.png" /></p><ol start="3"><li>Q2：R命令查看各个段寄存器的值  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo><mtext>  </mtext><mi>C</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">\to \;CS:076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">DS:076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mo>:</mo><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">SS:076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673877858110-72e7472f-1574-4c88-ae28-a064f40894e4.png#averageHue=%23131313&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=73&amp;id=u1f2d1ce2&amp;name=image.png&amp;originHeight=73&amp;originWidth=592&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3486&amp;status=done&amp;style=none&amp;taskId=ub88918a8-2d91-4abe-b21e-299699ae7ce&amp;title=&amp;width=592" alt="image.png" /></p><ol start="4"><li>Q3：data段和stack段分别占16个字节，因此设code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mn>1</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X-1H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mn>2</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X-2H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>（做了assignment2后可以发现这里说法并不准确）<br /><a name="qSFne"></a></li></ol><h2 id="assignment-2-5"><a class="markdownIt-Anchor" href="#assignment-2-5"></a> assignment 2</h2><ol><li>步骤与assigment1 完全一致</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878358257-7f67627a-48a8-45cf-bc4a-1f51e9552faa.png#averageHue=%230f0f0f&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=265&amp;id=u246ed639&amp;name=image.png&amp;originHeight=265&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=9903&amp;status=done&amp;style=none&amp;taskId=ud7500b3a-6b24-43c1-8498-3e220eabeef&amp;title=%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E5%90%8E%E7%94%A8U%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%90%84%E4%B8%AA%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&amp;width=615" alt="image.png" title="源程序载入内存后用U命令查看，发现各个段的地址与assignment1完全一致" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878450151-f2a27665-630b-4784-9a07-7c364c930469.png#averageHue=%23111111&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=84&amp;id=u67d44730&amp;name=image.png&amp;originHeight=84&amp;originWidth=582&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3313&amp;status=done&amp;style=none&amp;taskId=u45570d21-23d5-4112-8fa2-e8d2f41ad8a&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D&amp;width=582" alt="image.png" title="执行程序至程序返回前" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878510541-e58f6906-dc84-4df0-a6a2-59cfdf0b4a07.png#averageHue=%231a1a1a&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=54&amp;id=u68b4b398&amp;name=image.png&amp;originHeight=54&amp;originWidth=504&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2010&amp;status=done&amp;style=none&amp;taskId=u823673f9-a9eb-4ebf-a4ee-ae34390d952&amp;title=%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%80%E8%87%B4%EF%BC%8C%E6%9C%AA%E6%94%B9%E5%8F%98&amp;width=504" alt="image.png" title="查看data段数据，与源程序一致，未改变" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673878562565-32d00b48-a53b-4868-916e-9e7ddb4a279d.png#averageHue=%23131313&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=72&amp;id=udc9f18e6&amp;name=image.png&amp;originHeight=72&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3334&amp;status=done&amp;style=none&amp;taskId=uf3897f64-0600-409f-903a-e0c60d2a195&amp;title=%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%EF%BC%8C%E5%90%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%E4%B8%8Eassignment1%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4&amp;width=598" alt="image.png" title="查看寄存器内容，各段寄存器内容与assignment1完全一致" /></p><ol start="2"><li>得出结论：段无论大小，在源程序载入内存后，段所占内存大小一定为16的整数倍<br /><a name="AiceH"></a></li></ol><h2 id="assignment-3-4"><a class="markdownIt-Anchor" href="#assignment-3-4"></a> assignment 3</h2><ol><li>步骤与assignment1完全一致</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879121558-74eaedb2-acd9-4a9c-a318-e028bba49db2.png#averageHue=%23101010&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=264&amp;id=u5b46f0b2&amp;name=image.png&amp;originHeight=264&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=9249&amp;status=done&amp;style=none&amp;taskId=uab9b0f8d-e010-40c9-ba7f-3de6b6e1d63&amp;title=%E8%B5%B7%E5%A7%8B%E6%AE%B5%E4%B8%BAcode%E6%AE%B5%20%28076C%29%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80data%E6%AE%B5%28076F%29%E5%92%8Cstack%E6%AE%B5%280770%29&amp;width=583" alt="image.png" title="起始段为code段 (076C)，后面跟着data段(076F)和stack段(0770)" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673879373761-d05b59a9-6591-4c25-8033-e83698bff61e.png#averageHue=%23171717&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=294&amp;id=u7e2149b7&amp;name=image.png&amp;originHeight=294&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=10607&amp;status=done&amp;style=none&amp;taskId=u25c23b4d-250b-45e7-aa47-be84b0e1458&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%87%B3%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%89%8D%EF%BC%8C%E6%9F%A5%E7%9C%8Bdata%E6%AE%B5%E5%86%85%E5%AE%B9%E5%92%8C%E5%90%84%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC&amp;width=625" alt="image.png" title="执行程序至程序返回前，查看data段内容和各个段寄存器的值" /><br />2， 设code段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么data段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>+</mo><mn>3</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X+3H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>，stack段段地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>+</mo><mn>4</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">X+4H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span><br /><a name="NxsNH"></a></p><h2 id="assignment-4-2"><a class="markdownIt-Anchor" href="#assignment-4-2"></a> assignment 4</h2><p>如果去掉通知编译器程序的入口的<code>end start </code>语句，那么唯一可正确运行的是起始段为code段的程序3<br /><a name="oVwXx"></a></p><h2 id="assignment-5"><a class="markdownIt-Anchor" href="#assignment-5"></a> assignment 5</h2><ol><li>编写源程序，注意在将段地址写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>时，要借助一个寄存器充当介质，因为立即数无法直接写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment </span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment </span><br><span class="line">db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s:</span><br><span class="line">mov dx, a</span><br><span class="line">mov ds,dx</span><br><span class="line">mov ax, [bx]</span><br><span class="line">mov dx, b</span><br><span class="line">mov ds,dx</span><br><span class="line">add ax, [bx]</span><br><span class="line">mov dx, c</span><br><span class="line">mov ds,dx</span><br><span class="line">mov [bx], ax</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>用debug跟踪程序，可以看到a段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、b段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>D</mi></mrow><annotation encoding="application/x-tex">076D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>、c段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882442409-a3ef513e-eb43-4f18-abf5-ea6f262cc3f6.png#averageHue=%230e0e0e&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=333&amp;id=u80ddd30c&amp;name=image.png&amp;originHeight=333&amp;originWidth=603&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11543&amp;status=done&amp;style=none&amp;taskId=u0f76c72f-ed96-431c-8d71-352a3ca1f86&amp;title=&amp;width=603" alt="image.png" /></p><ol start="3"><li>执行程序，查看c段内容，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882790995-352f2b4b-203d-458a-b5a2-878acfd29335.png#averageHue=%231e1e1e&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=59&amp;id=uc023038f&amp;name=image.png&amp;originHeight=59&amp;originWidth=498&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2633&amp;status=done&amp;style=none&amp;taskId=ucae589f2-04bc-4644-899d-6fdbd17e620&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%89%8D%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&amp;width=498" alt="image.png" title="执行程序前，C段内容" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673882830219-1912f93e-456b-47b1-b06a-32816e308e07.png#averageHue=%23171717&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=95&amp;id=ud9a53aa1&amp;name=image.png&amp;originHeight=95&amp;originWidth=479&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=3576&amp;status=done&amp;style=none&amp;taskId=udb82a728-cd51-436e-9481-a8a6f072f71&amp;title=%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8CC%E6%AE%B5%E5%86%85%E5%AE%B9&amp;width=479" alt="image.png" title="执行程序后，C段内容" /><br /><a name="azFBM"></a></p><h2 id="assignment-6"><a class="markdownIt-Anchor" href="#assignment-6"></a> assignment 6</h2><ol><li>编写源程序，注意bx变化值应为2，因为push、pop操作是以字为单位的</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start:</span><br><span class="line">mov ax, a</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, b </span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0010H</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s:</span><br><span class="line">push [bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>用debug跟踪程序，可以看到a段段地址： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">076C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 、 b段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">076E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>、code段段地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>076</mn><mi>F</mi></mrow><annotation encoding="application/x-tex">076F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885232599-a5e6bf92-ae97-421b-ad5b-904f427aef76.png#averageHue=%230f0f0f&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=296&amp;id=ub52c7fd8&amp;name=image.png&amp;originHeight=296&amp;originWidth=590&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10267&amp;status=done&amp;style=none&amp;taskId=ub78885e9-2d92-486e-abce-ac5186f563b&amp;title=&amp;width=590" alt="image.png" /></p><ol start="3"><li>执行程序，查看b段内容，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673885271367-eddf0cc8-98aa-4fe8-a38f-a014ed5f8179.png#averageHue=%231b1b1b&amp;clientId=u1b2351c9-0f42-4&amp;from=paste&amp;height=228&amp;id=ud387c905&amp;name=image.png&amp;originHeight=228&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10970&amp;status=done&amp;style=none&amp;taskId=u9df34674-6438-4f64-8810-2056308e5b5&amp;title=&amp;width=525" alt="image.png" /></p><hr /><p><a name="O7BgM"></a></p><h1 id="实验6-实践课程中的程序"><a class="markdownIt-Anchor" href="#实验6-实践课程中的程序"></a> 实验6 实践课程中的程序</h1><p><a name="dyxQS"></a></p><h2 id="assignment-1-6"><a class="markdownIt-Anchor" href="#assignment-1-6"></a> assignment 1</h2><ol><li>这里只实践了问题7.8的解决方案（用栈作数据缓冲区），如下</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stacksg</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 10H</span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 4</span><br><span class="line">s0:</span><br><span class="line">push cx</span><br><span class="line">mov si, 0</span><br><span class="line">mov cx, 3</span><br><span class="line">s:</span><br><span class="line">mov al, [bx+si]</span><br><span class="line">and al, 11011111B</span><br><span class="line">mov [bx+si], al</span><br><span class="line">inc si</span><br><span class="line">loop s </span><br><span class="line"></span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>跟踪程序，查看data段内容</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954476992-988989f0-7ba5-4132-8b53-011e5cfe1ce7.png#averageHue=%23111111&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=332&amp;id=u6d512701&amp;name=image.png&amp;originHeight=332&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11651&amp;status=done&amp;style=none&amp;taskId=uac27a62a-e7e2-4573-8364-30a015779f0&amp;title=&amp;width=619" alt="image.png" /></p><ol start="3"><li>执行程序后，查看data段内容，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673954644257-b63d5af0-f266-4057-b1e1-c513e09c9298.png#averageHue=%23151515&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=114&amp;id=u73878512&amp;name=image.png&amp;originHeight=114&amp;originWidth=574&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4009&amp;status=done&amp;style=none&amp;taskId=u92fc65de-f6f5-42c1-84b2-350c1e4d948&amp;title=&amp;width=574" alt="image.png" /><br /><a name="pHbEJ"></a></p><h2 id="assignment-2-6"><a class="markdownIt-Anchor" href="#assignment-2-6"></a> assignment 2</h2><ol><li>编写源程序，双层循环中，进入第二层循环之后立马将cx压入栈中暂存，可避免双层循环在使用cx寄存器上的冲突</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">db &#x27;1. display      &#x27;</span><br><span class="line">db &#x27;2. brows        &#x27;</span><br><span class="line">db &#x27;3. replace      &#x27;</span><br><span class="line">db &#x27;4. modify       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stacksg</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 10H </span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 4</span><br><span class="line">s0:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 4</span><br><span class="line">mov si, 0</span><br><span class="line">s: </span><br><span class="line">mov al, [bx+3+si]</span><br><span class="line">and al, 11011111B</span><br><span class="line">mov [bx+3+si], al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>跟踪程序，查看data段内容</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955793129-198d15a6-56f1-4375-a4c1-fa6d84e6aa7c.png#averageHue=%23111111&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=311&amp;id=u5ce4b731&amp;name=image.png&amp;originHeight=311&amp;originWidth=623&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12680&amp;status=done&amp;style=none&amp;taskId=u132e706b-1ed7-4582-becb-0f6cd930428&amp;title=&amp;width=623" alt="image.png" /></p><ol start="3"><li>执行程序，查看data段内容，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1673955864652-707fd6d7-d65d-4be6-b3f9-bbcbbc27484b.png#averageHue=%23151515&amp;clientId=ue12bca8e-25be-4&amp;from=paste&amp;height=110&amp;id=ubb174b39&amp;name=image.png&amp;originHeight=110&amp;originWidth=618&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5260&amp;status=done&amp;style=none&amp;taskId=u786ee51b-5382-4915-8eb1-9feeb54fdba&amp;title=&amp;width=618" alt="image.png" /></p><hr /><p><a name="MJU1z"></a></p><h1 id="实验7-寻址方式在结构化数据访问中的应用"><a class="markdownIt-Anchor" href="#实验7-寻址方式在结构化数据访问中的应用"></a> 实验7 寻址方式在结构化数据访问中的应用</h1><ol><li>编写源程序，用<code>word ptr / byte ptr</code>指定内存单元大小主要应用在<code>div</code>指令或用于向内存写入立即数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390, 8000, 16000,24486,50065, 97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000, 3753000, 4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793, 4037,5635, 8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">db 21 dup (&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack ;0776C</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 10H</span><br><span class="line">mov ax, data ; 076D</span><br><span class="line">mov es, ax</span><br><span class="line">mov ax, table ; 077b</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,21</span><br><span class="line"></span><br><span class="line">year:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 4</span><br><span class="line">mov di, 0</span><br><span class="line">char:</span><br><span class="line">mov al, es:[si]</span><br><span class="line">mov [bx+di], al</span><br><span class="line">inc di</span><br><span class="line">inc si</span><br><span class="line">loop char</span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop year</span><br><span class="line"></span><br><span class="line">mov cx, 21</span><br><span class="line">mov bx, 0</span><br><span class="line">income:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 2</span><br><span class="line">mov di, 0</span><br><span class="line">dwInt:</span><br><span class="line">mov ax, es:[si]</span><br><span class="line">mov [bx].5[di], ax</span><br><span class="line">add si, 2</span><br><span class="line">add di, 2</span><br><span class="line">loop dwInt</span><br><span class="line">pop cx</span><br><span class="line">add bx, 10H</span><br><span class="line">loop income</span><br><span class="line"></span><br><span class="line">mov cx, 21</span><br><span class="line">mov bx, 0</span><br><span class="line">staff:</span><br><span class="line">mov ax, es:[si]</span><br><span class="line">mov [10+bx], ax</span><br><span class="line">add si, 2;</span><br><span class="line">add bx, 10H</span><br><span class="line">loop staff</span><br><span class="line"></span><br><span class="line">mov cx, 21</span><br><span class="line">mov bx, 0</span><br><span class="line">average:</span><br><span class="line">mov dx, [bx+7]</span><br><span class="line">mov ax, [bx+5]</span><br><span class="line">div word ptr [bx+0AH]</span><br><span class="line">mov [bx+0Dh], ax</span><br><span class="line">add bx, 10H</span><br><span class="line">loop average</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure><ol start="2"><li>查看原始table段的内容</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054412418-905eb553-63b9-4352-8fd3-87d9c57ec955.png#averageHue=%231d1d1d&amp;clientId=u59b02d03-003e-4&amp;from=paste&amp;height=312&amp;id=ue1c1140e&amp;name=image.png&amp;originHeight=312&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19887&amp;status=done&amp;style=none&amp;taskId=ue6fc1e9d-9b84-43c0-852e-a69d953b492&amp;title=&amp;width=640" alt="image.png" /></p><ol start="3"><li>执行程序后，查看table段的内容，正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674054465034-493bafb1-d935-4da9-b3d0-07b0bdd54911.png#averageHue=%231b1b1b&amp;clientId=u59b02d03-003e-4&amp;from=paste&amp;height=378&amp;id=u98d88789&amp;name=image.png&amp;originHeight=378&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=21611&amp;status=done&amp;style=none&amp;taskId=u95e0d8ba-0b80-4cd2-9a0a-a3aaec2f835&amp;title=&amp;width=630" alt="image.png" /><br /><a name="wI3bu"></a></p><h1 id="实验8-分析一个奇怪的程序"><a class="markdownIt-Anchor" href="#实验8-分析一个奇怪的程序"></a> 实验8 分析一个奇怪的程序</h1><ol><li>程序从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span></span></span></span>入口处开始执行，一个<code>nop</code>指令占一个字节并表示No operation，此处用了两个<code>nop</code>指令的目的是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处预留两个字节的空间，程序执行<code>mov cs:[di], ax</code>之后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的两个字节被试图写入<code>jmp short s1</code>，接着程序向下执行<code>jmp short s</code>使得程序跳转回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处开始执行。</li><li><code>jmp short s1</code>到底做了什么：修改IP使其前进十个字节。因为该指令本身的作用是使IP从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>跳转到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span>，即从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>处的jmp指令的下一指令<code>nop</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0022</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(076C:0022)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>跳转到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span>处的<code>mov ax, 0</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>076</mn><mi>C</mi><mo>:</mo><mn>0018</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(076C:0018)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>，因为<code>jmp short 标号</code>是依据位移进行转移的指令，而此处位移大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0022</mn><mi>H</mi><mo>−</mo><mn>0018</mn><mi>H</mi><mo>=</mo><mo>−</mo><mn>10</mn><mi>D</mi><mo stretchy="false">(</mo><mi>F</mi><mn>6</mn><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0022H-0018H =-10D(F6H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的<code>jmp short s</code>指令的机器码为<code>EBF6</code>（刚好占两个字节，因此可以被正确写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处）</li><li>执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>处的跳转指令，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi><mo>=</mo><mi>I</mi><mi>P</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IP = IP+(-10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>,即向前移动十位，用debug跟踪程序，可以看到向前第十个指令为<code>mov ax, 4c00H</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>000</mn><mi>A</mi><mi>H</mi><mo>−</mo><mn>0010</mn><mi>H</mi><mo>=</mo><mn>0000</mn><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(000AH-0010H=0000H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，程序从此处开始向下执行，最终可以正确退出</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674306714709-54439679-a96b-496d-97b1-de0f2c3abf77.png#averageHue=%230d0d0d&amp;clientId=u6f9c44da-f55a-4&amp;from=paste&amp;height=383&amp;id=u78c30e80&amp;name=image.png&amp;originHeight=383&amp;originWidth=595&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10505&amp;status=done&amp;style=none&amp;taskId=uae9cedf9-248f-4122-b32a-b23020dad5f&amp;title=&amp;width=595" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674308784974-d476fbd5-6642-45a7-8e5a-a3db1e5ed646.png#averageHue=%230a0a0a&amp;clientId=u6f9c44da-f55a-4&amp;from=paste&amp;height=150&amp;id=ua98d7cca&amp;name=image.png&amp;originHeight=150&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3506&amp;status=done&amp;style=none&amp;taskId=ufcfb45ef-5abd-4191-9c60-6ca3d7ac8c6&amp;title=&amp;width=640" alt="image.png" /><br /><a name="lZyJr"></a></p><h1 id="实验9-根据材料编程"><a class="markdownIt-Anchor" href="#实验9-根据材料编程"></a> 实验9 根据材料编程</h1><ol><li>编写源程序：最开始我试图用<code>mov address，data</code>的形式直接向显存中写入数据，并且比较蠢的一个字符一个字符的输入，但这种形式的mov指令对显存区域似乎并不奏效，实操之后发现显存内容未被修改为给定值，并且其内容还在动态的变化(?)。之后利用栈存储数据<code>welcome to masm!</code>，利用寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">ax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>作介质，用mov指令实现内存之间的内容交换，避免了重复手动输入数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: </span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov bx, 0</span><br><span class="line">mov si, 1824</span><br><span class="line">mov cx, 10H</span><br><span class="line">s0:</span><br><span class="line">mov ah, 82H</span><br><span class="line">mov al, [bx]</span><br><span class="line">mov es:[si], ax</span><br><span class="line">inc bx</span><br><span class="line">add si, 2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov bx, 0 </span><br><span class="line">mov si, 1984</span><br><span class="line">mov cx, 10H</span><br><span class="line">s1:</span><br><span class="line">mov ah, 0A4H</span><br><span class="line">mov al, [bx]</span><br><span class="line">mov es:[si], ax</span><br><span class="line">inc bx</span><br><span class="line">add si, 2</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line">mov bx, 0 </span><br><span class="line">mov si, 2144</span><br><span class="line">mov cx, 10H</span><br><span class="line">s2:</span><br><span class="line">mov ah, 11110001B</span><br><span class="line">mov al, [bx]</span><br><span class="line">mov es:[si], ax</span><br><span class="line">inc bx</span><br><span class="line">add si, 2</span><br><span class="line">loop s2</span><br><span class="line"></span><br><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>最终效果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674447541217-19494cef-6da4-4fd3-b28c-6ad18c755471.png#averageHue=%23080808&amp;clientId=u2be92af7-bf87-4&amp;from=paste&amp;height=400&amp;id=u7d46ece7&amp;name=image.png&amp;originHeight=400&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8808&amp;status=done&amp;style=none&amp;taskId=u5b2b0b44-a96d-458a-878e-8f9b74b9697&amp;title=&amp;width=640" alt="image.png" /></p><p><a name="zPzcC"></a></p><h1 id="实验10-编写子程序"><a class="markdownIt-Anchor" href="#实验10-编写子程序"></a> 实验10 编写子程序</h1><p><a name="Z9mXL"></a></p><h2 id="assignment-1-7"><a class="markdownIt-Anchor" href="#assignment-1-7"></a> assignment 1</h2><ol><li>编写源程序，在子程序的开始将所有子程序将用的寄存器保存在栈中（不论子程序是否修改寄存器或返回后主程序是否使用寄存器，都应当这样做），以便从子程序返回前再恢复（<strong>注意入栈顺序与出栈顺序相反</strong>）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &quot;welcome to masm!&quot;, 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov dh, 8</span><br><span class="line">mov dl, 3</span><br><span class="line">mov cl, 2</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, stack</span><br><span class="line">mov sp, 20H</span><br><span class="line">mov si, 0</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov al, 160 ; 设置指定打印位置</span><br><span class="line">inc dh ; 行数从0开始</span><br><span class="line">mul dh ; 8位乘法，结果存储在ax中</span><br><span class="line">mov bx, ax</span><br><span class="line">mov al, 2</span><br><span class="line">mul dl</span><br><span class="line">add bx, ax</span><br><span class="line">mov ah, cl</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">mov cl, [si] ; 设置cx</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok ;判断字符串是否结束</span><br><span class="line"></span><br><span class="line">mov al, cl ; 设置字符属性和值</span><br><span class="line">mov es:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">add bx, 2</span><br><span class="line">jmp print</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1674959885930-a6c4181a-e6a1-44cb-9ec8-cc5013b1314e.png#averageHue=%23141414&amp;clientId=ue48ee0fc-f4a6-4&amp;from=paste&amp;height=427&amp;id=u8c981b1c&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12224&amp;status=done&amp;style=none&amp;taskId=u3854a69e-62d2-4b34-89c5-98dd0c0fb70&amp;title=&amp;width=642" alt="image.png" /><br /><a name="gCr3l"></a></p><h2 id="assignment-2-7"><a class="markdownIt-Anchor" href="#assignment-2-7"></a> assignment 2</h2><ol><li><p>编写源程序，利用除法溢出公式</p><pre><code>            $X/n = int(H/2)*65536 +[rem(H/n)*65536+L]/n$&lt;br /&gt;该公式的基本思想是将可能发生除法溢出的32位除法$X/n$，分解为两个十六位(实际运算时是32位，被除数高16位置0)的除法&lt;br /&gt;$(H/n)*65536 + (L/n)$&lt;br /&gt;**商（32位）：**&lt;br /&gt;高十六位为$int(H/2)*65536$,低十六为$int([rem(H/n)*65536+L]/n)$&lt;br /&gt;**余数（16位）：**&lt;br /&gt;$rem([rem(H/n)*65536+L]/n)$&lt;br /&gt;（注：对这个公式的理解有限）</code></pre></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line">mov ax, 4240H</span><br><span class="line">mov dx, 000FH</span><br><span class="line">mov cx, 0AH</span><br><span class="line">call divdw</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">divdw:</span><br><span class="line">push bx</span><br><span class="line"></span><br><span class="line">mov bx, ax ; 暂存L</span><br><span class="line">mov ax, dx ; H/N</span><br><span class="line">mov dx, 0</span><br><span class="line">div cx ; int(H/N)在ax中，rem(H/N)在dx中</span><br><span class="line"></span><br><span class="line">push ax ; 暂存int(H/N)，除数</span><br><span class="line"></span><br><span class="line">mov ax, bx; dx and ax constitute rem(H/N)*65535+L</span><br><span class="line">div cx ; ax store the result</span><br><span class="line">mov cx, dx</span><br><span class="line"></span><br><span class="line">pop dx ; int(H/N)</span><br><span class="line"></span><br><span class="line">pop bx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果正确</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675050216892-a6c856a5-19e3-42a9-9dae-62052e8d077c.png#averageHue=%23191919&amp;clientId=u68f84982-1dce-4&amp;from=paste&amp;height=427&amp;id=u69ef2d14&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16724&amp;status=done&amp;style=none&amp;taskId=u6de69850-12af-46ff-80ef-d1f8f4817f4&amp;title=&amp;width=642" alt="image.png" /><br /><a name="wHNVn"></a></p><h2 id="assignment-3-5"><a class="markdownIt-Anchor" href="#assignment-3-5"></a> assignment 3</h2><ol><li>编写源程序：由于是从数字尾部开始构造字符串，所以用栈来暂存数据再合适不过</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db 10 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, 12666</span><br><span class="line">mov bx, data</span><br><span class="line">mov ds, bx</span><br><span class="line">mov si, 0</span><br><span class="line">mov bx, stack</span><br><span class="line">mov ss, bx</span><br><span class="line">mov sp, 20H</span><br><span class="line">call dtoc</span><br><span class="line"></span><br><span class="line">mov dh, 8</span><br><span class="line">mov dl, 3</span><br><span class="line">mov cl, 2</span><br><span class="line">call show_str</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">dtoc:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov dx, 0 ; 被除数高16位 置0</span><br><span class="line">mov bx, 10</span><br><span class="line">mov di, 0 ; 字符计数</span><br><span class="line"></span><br><span class="line">divide:</span><br><span class="line">mov cx, ax </span><br><span class="line">jcxz over</span><br><span class="line">inc di</span><br><span class="line">div bx ; 32位除法，商在ax，余数在dx</span><br><span class="line">add dx, 30H</span><br><span class="line">push dx</span><br><span class="line">mov dx, 0</span><br><span class="line">jmp divide</span><br><span class="line"></span><br><span class="line">over:</span><br><span class="line">mov cx, di</span><br><span class="line">move: </span><br><span class="line">pop bx</span><br><span class="line">mov [si], bl</span><br><span class="line">inc si</span><br><span class="line">loop move</span><br><span class="line"></span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">push ax ; 保存子程序中所有将用到的寄存器的初始值，以便在返回前恢复</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H; 80×25彩色模式显示缓冲区</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov al, 160 ; 设置指定打印位置</span><br><span class="line">inc dh ; 行数从0开始</span><br><span class="line">mul dh ; 8位乘法，结果存储在ax中</span><br><span class="line">mov bx, ax</span><br><span class="line">mov dh, 0</span><br><span class="line">mov al, 2</span><br><span class="line">mul dl</span><br><span class="line">add bx, ax</span><br><span class="line">mov ah, cl</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">mov cl, [si] ; 设置cx</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok ;判断字符串是否结束</span><br><span class="line"></span><br><span class="line">mov al, cl ; 设置字符属性和值</span><br><span class="line">mov es:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">add bx, 2</span><br><span class="line">jmp print</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070403817-35e5aa0f-3d0c-42ab-803a-9d7dbf5bcb8a.png#averageHue=%231f1f1e&amp;clientId=u9270fba6-a6a8-4&amp;from=paste&amp;height=427&amp;id=uc1ace679&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=16905&amp;status=done&amp;style=none&amp;taskId=uf4805ca7-fbac-43eb-a257-f1c820ade31&amp;title=%E6%AD%A3%E7%A1%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%AE%B5&amp;width=642" alt="image.png" title="正确写入数据段" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675070685747-6e72ffff-b062-418d-9d09-67596698a4ca.png#averageHue=%23141313&amp;clientId=u9270fba6-a6a8-4&amp;from=paste&amp;height=427&amp;id=ub539738e&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=12534&amp;status=done&amp;style=none&amp;taskId=u448c5569-17ad-4eec-8879-9d56a9e0d67&amp;title=%E6%AD%A3%E7%A1%AE%E6%89%93%E5%8D%B0&amp;width=642" alt="image.png" title="正确打印" /><br /><a name="ww3wC"></a></p><h1 id="实验11-编写子程序"><a class="markdownIt-Anchor" href="#实验11-编写子程序"></a> 实验11 编写子程序</h1><ol><li>编写源程序：主要用到了<code>cmp</code>指令和条件转移指令组合形成的if逻辑</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">datasg segment</span><br><span class="line">db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">begin:</span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, 0</span><br><span class="line">call letterc</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">letterc:</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line"></span><br><span class="line">Capital:</span><br><span class="line">mov al, [si]</span><br><span class="line">mov cl, al</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz OK</span><br><span class="line">cmp al, 97</span><br><span class="line">jb NO</span><br><span class="line">cmp al, 122</span><br><span class="line">ja NO</span><br><span class="line">and al, 11011111B</span><br><span class="line">mov [si], al</span><br><span class="line"></span><br><span class="line">NO:</span><br><span class="line">inc si</span><br><span class="line">jmp short Capital</span><br><span class="line"></span><br><span class="line">OK:</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142887049-1e6b7958-8779-4745-81f5-c6a536a232ca.png#averageHue=%231d1d1d&amp;clientId=u14a9d0ea-1971-4&amp;from=paste&amp;height=427&amp;id=u9451414e&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=18343&amp;status=done&amp;style=none&amp;taskId=u733f3e2b-82d2-436e-a8de-95b8faa1f07&amp;title=%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81&amp;width=642" alt="image.png" title="初始状态" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675142878774-286c5ae3-e961-424a-96db-dae987c9a153.png#averageHue=%23212121&amp;clientId=u14a9d0ea-1971-4&amp;from=paste&amp;height=427&amp;id=ub5c49ec4&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=19861&amp;status=done&amp;style=none&amp;taskId=u7a2a2568-c507-4078-a32b-b75eef2ec62&amp;title=%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99&amp;width=642" alt="image.png" title="全部大写" /><br /><a name="bk4z5"></a></p><h1 id="实验12-编写0号中断的处理程序"><a class="markdownIt-Anchor" href="#实验12-编写0号中断的处理程序"></a> 实验12 编写0号中断的处理程序</h1><ol><li>编写源程序</li></ol><p>总体来说就3个任务：</p><ul><li>编写中断处理程序</li><li>复制中断处理程序至内存空闲区域(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn><mo>:</mo><mn>0200</mn><mi>H</mi><mo>→</mo><mn>0000</mn><mo>:</mo><mn>02</mn><mi>F</mi><mi>F</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">0000:0200H\to0000:02FFH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>)</li><li>修改中断向量表（中断处理程序地址入口表）</li></ul><p>注意在用<code>jcxz</code>条件转移指令时，要<code>jmp short</code>回程序开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset do0 ; 076C:0028</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset do0end- offset do0; 0034H</span><br><span class="line">cld</span><br><span class="line">rep movsb ; 复制程序到0:200</span><br><span class="line"></span><br><span class="line">mov word ptr es:[0], 0200H</span><br><span class="line">mov word ptr es:[0+2], 0 ; 修改中断向量表</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">do0:</span><br><span class="line">jmp short do0start</span><br><span class="line">db &quot;divide error&quot;,0 </span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 160*12+34*2</span><br><span class="line"></span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, 202H</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">mov cL, [si]</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok</span><br><span class="line">mov ah, 04h ;red</span><br><span class="line">mov al, cl</span><br><span class="line">mov es:[di], ax</span><br><span class="line">inc si</span><br><span class="line">add di, 2 </span><br><span class="line">jmp short print</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">do0end: ;005C</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果(在debug中运行检测程序lab12T无法触发中断，直接执行却可以)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675159533550-89caf027-f6da-4345-aa8c-e03159df600e.png#averageHue=%23141414&amp;clientId=u2ec176e2-9874-4&amp;from=paste&amp;height=427&amp;id=u6679d84b&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12440&amp;status=done&amp;style=none&amp;taskId=u7d87f433-7092-4f23-a3d6-b1339bf6fe9&amp;title=&amp;width=642" alt="image.png" /><br /><a name="YSdgF"></a></p><h1 id="实验13-编写-应用中断例程"><a class="markdownIt-Anchor" href="#实验13-编写-应用中断例程"></a> 实验13 编写、应用中断例程</h1><p><a name="HHw6N"></a></p><h2 id="assignment-1-8"><a class="markdownIt-Anchor" href="#assignment-1-8"></a> assignment 1</h2><ol><li>编写源程序：与lab10-1的show_str基本一致，只需将<code>call-ret</code>更改为 <code>int 7cH - iret</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset print</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset printed - offset print</span><br><span class="line">cld</span><br><span class="line">rep  movsb</span><br><span class="line"></span><br><span class="line">mov word ptr es:[7cH*4], 0200H</span><br><span class="line">mov word ptr es:[7cH*4+2], 0 </span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push ax</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov al, 160</span><br><span class="line">inc dh</span><br><span class="line">mul dh ; 160*(10+1) in ax</span><br><span class="line">mov bx, ax</span><br><span class="line">mov al, 2</span><br><span class="line">mul dl ; 10*2 in ax</span><br><span class="line">add bx, ax</span><br><span class="line">mov ah, cl</span><br><span class="line"></span><br><span class="line">stPrint:</span><br><span class="line">mov ch, 0</span><br><span class="line">mov cl, [si]</span><br><span class="line">jcxz ok</span><br><span class="line"></span><br><span class="line">mov al, cl</span><br><span class="line">mov es:[bx], ax</span><br><span class="line">add bx, 2</span><br><span class="line">inc si</span><br><span class="line">jmp short stPrint</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">printed:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675224733068-a783d5cd-5d35-46b5-8032-3c8938e8347a.png#averageHue=%23131313&amp;clientId=u8a54de4a-c425-4&amp;from=paste&amp;height=427&amp;id=u9672685d&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12092&amp;status=done&amp;style=none&amp;taskId=u4599fb35-92fc-4ea1-b9cb-e60668d8629&amp;title=&amp;width=642" alt="image.png" /><br /><a name="LKaNX"></a></p><h2 id="assignment-2-8"><a class="markdownIt-Anchor" href="#assignment-2-8"></a> assignment 2</h2><ol><li>编写源程序</li></ol><p>用中断例程实现loop指令，主要需要解决三个问题</p><ul><li>怎么取得标号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的段地址和偏移地址？</li></ul><p>有一对段地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>和偏移地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>在中断过程时被压入栈，标号的段地址就是该CS，标号       的偏移地址可由该IP加上转移地址(<code>offset s - offset se</code>)得到</p><ul><li>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的段地址和偏移地址后，如何设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi><mo>:</mo><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">CS:IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></li></ul><p>用<code>iret</code>指令：<code>pop IP , pop CS ,  popf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset lp</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset lped - offset lp</span><br><span class="line">cld</span><br><span class="line">rep  movsb</span><br><span class="line"></span><br><span class="line">mov word ptr es:[7cH*4], 0200H</span><br><span class="line">mov word ptr es:[7cH*4+2], 0 </span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">lp:</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">push bp</span><br><span class="line">mov bp, sp</span><br><span class="line">add [bp+2], bx</span><br><span class="line">lpret:</span><br><span class="line">pop bp</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">lped:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675237825483-f1ed3d6d-00cc-453b-91b3-757823355468.png#averageHue=%23171515&amp;clientId=ub529a018-e1a0-4&amp;from=paste&amp;height=427&amp;id=u272d8fd4&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12787&amp;status=done&amp;style=none&amp;taskId=u38f1e876-6c89-499b-b704-a23609bf566&amp;title=&amp;width=642" alt="image.png" /><br /><a name="TCCAl"></a></p><h2 id="assignment-3-6"><a class="markdownIt-Anchor" href="#assignment-3-6"></a> assignment 3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">s1: db &#x27;Good,better,best,&#x27;,&#x27;$&#x27;</span><br><span class="line">s2: db &#x27;Never let it rest,&#x27;,&#x27;$&#x27; </span><br><span class="line">s3: db &#x27;Till good is better,&#x27;,&#x27;$&#x27;</span><br><span class="line">s4: db &#x27;And better,best.&#x27;, &#x27;$&#x27;</span><br><span class="line">s: dw offset s1, offset s2, offset s3, offset s4 </span><br><span class="line">row: db 2,4,6,8</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">mov ax, cs </span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, offset s</span><br><span class="line">mov si, offset row</span><br><span class="line">mov cx, 4</span><br><span class="line">ok:</span><br><span class="line">mov bh, 0 </span><br><span class="line">mov dh, [si]</span><br><span class="line">mov dl, 0</span><br><span class="line">mov ah, 2 ; BIOS中断例程--设置光标</span><br><span class="line">int 10h </span><br><span class="line"></span><br><span class="line">mov dx, [bx]                                           </span><br><span class="line">mov ah, 9 ; DOS中断例程--打印字符串</span><br><span class="line">int 21h</span><br><span class="line">inc si</span><br><span class="line">add bx, 2</span><br><span class="line">loop ok</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H; DOS中断例程--程序返回，返回值在al</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><a name="zGspx"></a></p><h1 id="实验14-访问-cmos-ram"><a class="markdownIt-Anchor" href="#实验14-访问-cmos-ram"></a> 实验14 访问 CMOS RAM</h1><ol><li>编写源程序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov al, 9</span><br><span class="line">mov bx, 160*12+36*2</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 8</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 7</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27; &#x27;</span><br><span class="line"></span><br><span class="line">mov al, 4</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 2</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line">mov byte ptr [bx+4], &#x27;:&#x27;</span><br><span class="line"></span><br><span class="line">mov al, 0</span><br><span class="line">add bx, 6</span><br><span class="line">call GetAscill</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">GetAscill:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line"></span><br><span class="line">out 70H, al</span><br><span class="line">in al, 71H</span><br><span class="line"></span><br><span class="line">mov ah, al</span><br><span class="line">mov cl, 4</span><br><span class="line">shr ah, cl</span><br><span class="line">and al, 00001111B</span><br><span class="line"></span><br><span class="line">add ah, 30H</span><br><span class="line">add al, 30H</span><br><span class="line"></span><br><span class="line">mov dx, 0B800H</span><br><span class="line">mov es, dx</span><br><span class="line">mov es:[bx], ah </span><br><span class="line">mov byte ptr es:[bx+1], 02H ; green</span><br><span class="line">mov es:[bx+2], al</span><br><span class="line">mov byte ptr es:[bx+3], 02H</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675253920788-8fc4fee5-abeb-4e49-93bf-97e3873b6599.png#averageHue=%23141413&amp;clientId=uf0bf1a62-8c66-4&amp;from=paste&amp;height=388&amp;id=u067d841f&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11685&amp;status=done&amp;style=none&amp;taskId=u21f4afac-9bb2-4466-b21a-1a578f58efb&amp;title=&amp;width=583.6363509863864" alt="image.png" /><br /><a name="yTwL0"></a></p><h1 id="实验15-安装新的int-9-中断例程"><a class="markdownIt-Anchor" href="#实验15-安装新的int-9-中断例程"></a> 实验15 安装新的int 9 中断例程</h1><p><a name="TIrMX"></a></p><h2 id="前置练习1"><a class="markdownIt-Anchor" href="#前置练习1"></a> 前置练习1</h2><p>在屏幕中间依次显示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a\to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>,按Esc键后改变与颜色</p><ol><li>编写源程序：由于重新编写的int 9 例程与用于显示的程序在同时运行，所以不需要有安装程序。在编写int 9中断例程时，错把<code>call dword ptr ds:[0]</code>写成了<code>call word ptr ds:[0]</code>，导致整个系统没有正确的int 9中断例程，因此出现了错误。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 64 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 40H</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2] ; 保存原int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4], offset int9</span><br><span class="line">mov es:[9*4+2], cs;设置新的入口地址</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov dh, &#x27;a&#x27;</span><br><span class="line">s:</span><br><span class="line">mov es:[160*12+40*2], dh</span><br><span class="line">call delay</span><br><span class="line">inc dh</span><br><span class="line">cmp dh, &#x27;z&#x27;</span><br><span class="line">jna s ; 依次打印a~z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, 0 </span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">push ds:[0]</span><br><span class="line">pop es:[9*4]</span><br><span class="line">push ds:[2]</span><br><span class="line">pop es:[9*4+2] ;恢复原int 9中断例程的入口地址</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, 4C00h</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">delay:</span><br><span class="line">push ax</span><br><span class="line">push dx</span><br><span class="line">mov ax, 0</span><br><span class="line">mov dx, 10H</span><br><span class="line">se:</span><br><span class="line">sub ax, 1 ; 不能用dec</span><br><span class="line">sbb dx, 0</span><br><span class="line">cmp ax, 0</span><br><span class="line">jne se</span><br><span class="line">cmp dx, 0</span><br><span class="line">jne se</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret ; 延时</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push es</span><br><span class="line">in al, 60H</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">cmp al, 01H</span><br><span class="line">jne int9ret</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1] ; 修改字符属性</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop es</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319548168-77f7b5a6-54bb-4526-b234-adb0e561004e.png#averageHue=%237ab44c&amp;clientId=u17647ab4-03d9-4&amp;from=paste&amp;height=388&amp;id=u49a1ed0a&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=13571&amp;status=done&amp;style=none&amp;taskId=u61859af5-760b-45d0-8b8d-c62aa3a3245&amp;title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B21&amp;width=583.6363509863864" alt="image.png" title="按Esc改变颜色1" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675319563355-013b242f-ab37-4a8f-a956-6222d6e1847c.png#averageHue=%238dd756&amp;clientId=u17647ab4-03d9-4&amp;from=paste&amp;height=388&amp;id=u9a049927&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=13830&amp;status=done&amp;style=none&amp;taskId=u52c59e7d-a185-4177-8537-a05965e054e&amp;title=%E6%8C%89Esc%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B22&amp;width=583.6363509863864" alt="image.png" title="按Esc改变颜色2" /><br /><a name="vlBjq"></a></p><h2 id="前置练习2"><a class="markdownIt-Anchor" href="#前置练习2"></a> 前置练习2</h2><p>在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理</p><ol><li>编写源程序：原int 9的中断例程入口地址不能放在安装程序中，否则在进入新int 9中断例程后将丢失原int 9中断例程入口地址，导致无法调用原int 9中断例程。将原int 9中断例程入口地址放在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>:</mo><mn>0200</mn><mo>→</mo><mn>0</mn><mo>:</mo><mn>0203</mn></mrow><annotation encoding="application/x-tex">0:0200 \to 0:0203</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">3</span></span></span></span>,可在新int 9中断例程中通过<code>cs:[200H]</code>访问</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 32 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0204H</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset int9</span><br><span class="line"></span><br><span class="line">mov cx, offset int9ed - offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb; 安装</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H] ; 保存原int 9入口地址</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4], 204H</span><br><span class="line">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">in al, 60H</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H] ; 调用原int 9</span><br><span class="line"></span><br><span class="line">cmp al, 3BH</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 1</span><br><span class="line">mov cx, 2000</span><br><span class="line">s:</span><br><span class="line">inc byte ptr es:[di]</span><br><span class="line">add di, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop di</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int9ed:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322759364-2785ad21-17c7-4499-b1a3-fe6726975b02.png#averageHue=%230d0d0d&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u4340ef70&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=12813&amp;status=done&amp;style=none&amp;taskId=uc1c9e4ff-ae09-465d-a787-aba159b8b98&amp;title=%E6%8C%89%E4%B8%8BF1%201&amp;width=583.6363509863864" alt="image.png" title="按下F1 1" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675322817620-9b94c323-5bcb-4465-ba63-7a2721ba4d46.png#averageHue=%23aeaeae&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u019e66f9&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8862&amp;status=done&amp;style=none&amp;taskId=ue0c4ae51-d75f-4e13-8d7c-a26ee51e20f&amp;title=%E6%8C%89%E4%B8%8BF1%202&amp;width=583.6363509863864" alt="image.png" title="按下F1 2" /><br /><a name="XyIu0"></a></p><h2 id="assignment-1-9"><a class="markdownIt-Anchor" href="#assignment-1-9"></a> assignment 1</h2><ol><li>编写源程序</li></ol><p>与前两个练习相差不大，判断字符条件不同而已：判断是否是字符A的断码<code>cmp aL, 1EH+80H</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 32 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20H</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0204H</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset int9</span><br><span class="line"></span><br><span class="line">mov cx, offset int9ed - offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb; 安装</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H] ; 保存原int 9入口地址</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4], 204H</span><br><span class="line">mov word ptr es:[9*4+2], 0 ; 修改中断向量表</span><br><span class="line">sti</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">in aL,60h</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H]</span><br><span class="line"></span><br><span class="line">cmp aL, 1EH+80H</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov cx, 2000</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0</span><br><span class="line">s:</span><br><span class="line">mov byte ptr es:[di], &#x27;A&#x27;</span><br><span class="line">mov byte ptr es:[di+1], 02H</span><br><span class="line">add di, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop di</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">int9ed:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675329053483-60588212-d9b5-4cef-acf7-06c70f65db5f.png#averageHue=%23141313&amp;clientId=ud2f6d655-0b50-4&amp;from=paste&amp;height=388&amp;id=u7a90e8bd&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=7755&amp;status=done&amp;style=none&amp;taskId=u3c74959a-2b05-4756-8089-500ac2f8893&amp;title=%E6%8C%89%E4%B8%8BA%E5%90%8E%E6%9D%BE%E5%BC%80&amp;width=583.6363509863864" alt="image.png" title="按下A后松开" /><br /><a name="YodIM"></a></p><h1 id="实验16-编写包含多个功能子程序的中断例程"><a class="markdownIt-Anchor" href="#实验16-编写包含多个功能子程序的中断例程"></a> 实验16 编写包含多个功能子程序的中断例程</h1><ol><li>编写源程序</li></ol><p>注意中断例程安装后，直接定址表table的偏移地址发生了变化，没有了前面安装程序带来的一截偏移，同时偏移地址增加200H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, offset int7ch</span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 0200H</span><br><span class="line"></span><br><span class="line">mov cx, offset int7ched - offset int7ch</span><br><span class="line">cld</span><br><span class="line">rep  movsb</span><br><span class="line"></span><br><span class="line">mov word ptr es:[7cH*4], 0200H</span><br><span class="line">mov word ptr es:[7cH*4+2], 0 </span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">int7ch:</span><br><span class="line">jmp short int7chStart</span><br><span class="line">table dw offset Sub1-offset int7ch+200H, offset Sub2-offset int7ch+200H, offset Sub3-offset int7ch+200H, offset Sub4-offset int7ch+200H</span><br><span class="line"></span><br><span class="line">int7chStart:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">cmp ah, 3</span><br><span class="line">ja int7chRet</span><br><span class="line">mov bl, ah</span><br><span class="line">mov bh, 0</span><br><span class="line">add bx, bx</span><br><span class="line">call word ptr cs:(table-int7ch+200H)[bx]</span><br><span class="line"></span><br><span class="line">int7chRet:</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">Sub1:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov cx, 2000</span><br><span class="line">mov bx, 0</span><br><span class="line">s1:</span><br><span class="line">mov byte ptr [bx], &#x27; &#x27;</span><br><span class="line">add bx, 2</span><br><span class="line">loop s1</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">Sub2:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">mov bx, 0B800H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov cx, 2000</span><br><span class="line">mov bx, 1</span><br><span class="line">s2:</span><br><span class="line">and byte ptr [bx], 11111000B ; 只设置最后3位</span><br><span class="line">or byte ptr [bx], al</span><br><span class="line">add bx, 2</span><br><span class="line">loop s2</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">Sub3:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">mov bx, 0B800H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov cl, 4</span><br><span class="line">shl al, cl</span><br><span class="line">mov cx, 2000</span><br><span class="line">mov bx, 1</span><br><span class="line">s3:</span><br><span class="line">and byte ptr [bx], 10001111B</span><br><span class="line">or [bx], al</span><br><span class="line">add bx, 2</span><br><span class="line">loop s3</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">Sub4:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line">mov bx, 08B00H</span><br><span class="line">mov es, bx</span><br><span class="line">mov ds, bx</span><br><span class="line">mov si, 160</span><br><span class="line">mov di, 0</span><br><span class="line">cld</span><br><span class="line">mov cx, 24</span><br><span class="line"></span><br><span class="line">s4:</span><br><span class="line">push cx</span><br><span class="line">mov cx, 160</span><br><span class="line">rep movsb</span><br><span class="line">pop cx</span><br><span class="line">loop s4</span><br><span class="line"></span><br><span class="line">mov cx, 80</span><br><span class="line">mov si, 0</span><br><span class="line">s41:</span><br><span class="line">mov byte ptr [160*24+si], &#x27; &#x27;</span><br><span class="line">add si ,2</span><br><span class="line">loop s41</span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">int7ched:</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ah,1 ; 0 2 3</span><br><span class="line">mov al,2</span><br><span class="line">int 7CH</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411618416-c6c100a2-f4d1-4bc9-b3e6-22f83fcdcaee.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u97049213&amp;name=image.png&amp;originHeight=427&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=5698&amp;status=done&amp;style=none&amp;taskId=udfd4d7d0-2546-4521-8884-82d74fe5421&amp;title=%E5%8A%9F%E8%83%BD1%EF%BC%9A%E6%B8%85%E5%B1%8F&amp;width=620" alt="image.png" title="功能1：清屏" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411466691-92faf4b3-fbd7-4859-b68b-e403f87d23e1.png#averageHue=%230e0e0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u0af61a75&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=11776&amp;status=done&amp;style=none&amp;taskId=ud7c332b2-9214-4185-917e-392d79cda17&amp;title=%E5%8A%9F%E8%83%BD2%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%89%8D%E6%99%AF%E8%89%B2&amp;width=642" alt="image.png" title="功能2：设置前景色" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675411696534-79bed444-6b2a-4a77-ad72-027fb2081a4b.png#averageHue=%2300a900&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ue6689a35&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=11354&amp;status=done&amp;style=none&amp;taskId=u07994587-f0a4-4e4c-b31e-52a54f59cd3&amp;title=%E5%8A%9F%E8%83%BD3%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E8%89%B2&amp;width=642" alt="image.png" title="功能3：设置背景色" /><br /><a name="IRx7s"></a></p><h1 id="实验17-编写包含多个功能子程序的中断例程"><a class="markdownIt-Anchor" href="#实验17-编写包含多个功能子程序的中断例程"></a> 实验17 编写包含多个功能子程序的中断例程</h1><p>第17章实验用BIOS提供的功能号分别为2, 3的中断例程int 13H实现对软盘扇区的读写，由于该实验大多是对mul，div的用法和中断例程安装程序的复习，且无法看见实验效果，所以就没做了<br /><a name="upigZ"></a></p><h2 id="练习17-1"><a class="markdownIt-Anchor" href="#练习17-1"></a> 练习17-1</h2><p>接受用户的键盘输入，输入&quot;r&quot;，“g”,“b”分别将屏幕上的字符设置为红色，绿色，蓝色</p><ol><li>编写源程序</li></ol><p>用功能号为0的int 16H中断例程读取键盘输入即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">push ax</span><br><span class="line">push es</span><br><span class="line">push di</span><br><span class="line"></span><br><span class="line">mov ah, 0</span><br><span class="line">int 16H</span><br><span class="line"></span><br><span class="line">mov bl, 1</span><br><span class="line">cmp al,&#x27;b&#x27;</span><br><span class="line">je showst</span><br><span class="line">shl bl, 1</span><br><span class="line">cmp al, &#x27;g&#x27;</span><br><span class="line">je showst</span><br><span class="line">shl bl, 1</span><br><span class="line">cmp al, &#x27;r&#x27;</span><br><span class="line">je showst</span><br><span class="line">jmp short FRet</span><br><span class="line"></span><br><span class="line">showst:</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov di, 1</span><br><span class="line">mov cx, 2000</span><br><span class="line">s:</span><br><span class="line">and byte ptr es:[di], 11111000B</span><br><span class="line">or es:[di], bl</span><br><span class="line">add di, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">FRet:</span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol start="2"><li>运行结果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431818731-db0edf92-bc54-4bfc-a35f-613c796dddda.png#averageHue=%230f0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u2f889938&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8416&amp;status=done&amp;style=none&amp;taskId=u3c7affc7-f57c-470f-9cab-1a94bcb3c74&amp;title=r-red&amp;width=642" alt="image.png" title="r-red" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431840911-15621108-ffb6-42ce-94ab-603c36fe9540.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u1bb9ce94&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8174&amp;status=done&amp;style=none&amp;taskId=u26c95d33-ee9d-414a-9861-7aa91427bc6&amp;title=g-green&amp;width=642" alt="image.png" title="g-green" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675431855013-727c9bbb-b9bf-43a5-9ca6-ea80957dfa92.png#averageHue=%230d0d0d&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ucb1b0f24&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=8133&amp;status=done&amp;style=none&amp;taskId=ub45cc602-bef7-4fba-9ec7-3d4b52f4485&amp;title=b-blue&amp;width=642" alt="image.png" title="b-blue" /><br /><a name="Wyllk"></a></p><h1 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h1><p><a name="QMCD1"></a></p><h2 id="1-理解assume伪指令的作用"><a class="markdownIt-Anchor" href="#1-理解assume伪指令的作用"></a> 1. 理解assume伪指令的作用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov si, 0</span><br><span class="line">mov cx, 8</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov ah, 0</span><br><span class="line">mov al, a[si]</span><br><span class="line">add b, ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol><li><code>assume ds:data ss:stack</code></li></ol><ul><li>assume是伪指令，不会被编译为机器指令，因此实际程序运行后，段寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mtext>、</mtext><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS、SS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中不会存放data和stack的地址，要更改段寄存器的内容需要在程序中用指令实现:<code>mov ax, data ``mov ds, ax</code></li><li>assume是伪指令，用于指示编译器将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi><mtext>、</mtext><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS、SS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>分别与data段和stack段关联。①关联是什么意思呢？就是<strong>在编译时默认data段中的数据标号a、b的段地址在</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><strong>中</strong>，因此如果要正确访问到a、b的内容，必须用指令将data填入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中。②数据标号自身就有段地址和偏移地址为什么还需要一个默认的段寄存器呢？这说明在程序段中的数据标号，仅含有偏移地址信息，它的段地址信息需要从默认段寄存器中取得。③此外，定义段的段标号data也不指代完整的地址，而仅仅代表段地址，因此<code>mov ax, data</code>在编译器看来是<code>mov ax, data段段地址</code>，如果data是指代一个32bits的完整地址，那么它将不能赋值给16bits的ax</li></ul><p>如果在程序中省略<code>assume ds:data</code>，则会出现_不能用段寄存器寻址_的错误<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675343108877-68cf68d3-97ef-4ecb-8b4f-6da330149c94.png#averageHue=%23161616&amp;clientId=u3f46bb08-d532-4&amp;from=paste&amp;height=388&amp;id=uffd0ec43&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13264&amp;status=done&amp;style=none&amp;taskId=ud9fb02f3-e117-4559-bfe1-1659d6727ee&amp;title=&amp;width=583.6363509863864" alt="image.png" /></p><ol start="2"><li><code>assume cs:codesg</code></li></ol><p>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>与代码段关联，在程序加载时将代码段(codesg)的段地址放入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中. 如果去掉该语句，则程序编译不通过，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">CS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的值不确定<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675341791119-4c9029f0-b9e3-4e2f-b1b9-aa5d02685f8f.png#averageHue=%230d0d0d&amp;clientId=u3f46bb08-d532-4&amp;from=paste&amp;height=276&amp;id=u952199f2&amp;name=image.png&amp;originHeight=304&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9905&amp;status=done&amp;style=none&amp;taskId=ud6cc6c48-9ce9-4df5-a654-02e53729a4d&amp;title=&amp;width=581.8181692076126" alt="image.png" /><br /><a name="wwfwW"></a></p><h2 id="2-理解数据标号"><a class="markdownIt-Anchor" href="#2-理解数据标号"></a> 2. 理解数据标号</h2><ol><li>数据标号与地址标号的不同</li></ol><p>地址标号仅指代了一个地址，而数据标号不仅指代一个地址，还指代了这个地址的数据单元长度(byte, word, double word)，进而我们可以说数据标号就代表一个内存单元（由地址和单元长度就足以确定一个单元）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, es:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov si, 0</span><br><span class="line">mov cx, 8</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov ah, 0</span><br><span class="line">mov al, a[si]</span><br><span class="line">add b, ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里的a和b分别指代了</p><ul><li><strong>地址为</strong><code>**seg data:0**</code><strong>, 长度为byte的字节单元</strong></li><li><strong>地址为</strong><code>**seg data:8**</code><strong>, 长度为word的字单元</strong></li></ul><ol start="2"><li>如何用数据标号以简洁形式访问内存中的数据</li></ol><p>在上一个程序中，我们用<code>mov al, a[si]</code> <code>add b, ax</code>访问了data段的内容，在编译器看来，这两条语句是这样的: <code>mov al, es:0[si]``add es:[8], ax</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409971871-70ff728a-fa74-48ac-a742-be8ec319d677.png#averageHue=%23191919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=u6e4d3ff6&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14859&amp;status=done&amp;style=none&amp;taskId=ua1726f99-29ec-46f7-ac48-ad448e15a63&amp;title=&amp;width=642" alt="image.png" /><br />我们现在用更熟悉的<code>mov al, [si+a]</code> <code>add b[0], ax</code>形式，从编译器角度来看，这两种形式没有区别<br />这说明了在指令中<strong>a等价于</strong><code>**byte ptr [0]**</code><strong>，b等价于</strong><code>**word ptr [8]**</code>（仅含偏移地址信息，默认段地址在es中，因为<code>assume es:data</code>）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675410379440-d032239f-bb7d-480f-a45d-f96f7d064cd3.png#averageHue=%231a1919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ubbac8493&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15290&amp;status=done&amp;style=none&amp;taskId=uce443a00-0b21-4ac2-89ac-bb7e70f3432&amp;title=&amp;width=642" alt="image.png" /></p><ol start="3"><li>将标号当作数据定义</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a, b</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov dx, 2</span><br><span class="line">mov dx, c</span><br><span class="line">mov ax, c[1]</span><br><span class="line"></span><br><span class="line">mov ax, 4C00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><code>c dw a, b</code>将数据标号当作数据定义，c指代地址为<code>seg data:000A</code>的字单元，<strong>该字单元的内容是a的偏移地址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0000</mn></mrow><annotation encoding="application/x-tex">0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，下面是验证<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409382345-20e1a2f2-8973-4150-992a-2a8acb141fa9.png#averageHue=%23191919&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=427&amp;id=ud990b41d&amp;name=image.png&amp;originHeight=427&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15496&amp;status=done&amp;style=none&amp;taskId=u9d64f540-f9d7-4f4d-a179-67094b0601b&amp;title=&amp;width=642" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1675409496753-347acc0d-300d-4502-b228-e202ee4504a4.png#averageHue=%23101010&amp;clientId=uaa2840e8-10be-4&amp;from=paste&amp;height=400&amp;id=u97a8ca97&amp;name=image.png&amp;originHeight=400&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12100&amp;status=done&amp;style=none&amp;taskId=u65363c06-9a66-4677-9782-717ab71b1b6&amp;title=&amp;width=640" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法C++》学习历程</title>
      <link href="/2022/10/25/D-A-C++/"/>
      <url>/2022/10/25/D-A-C++/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><a name="qIfKY"></a><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>以下记录了我2022年暑假开始学习数据结构的历程。从哈希表到图论，有着详细的思考过程。</p><span id="more"></span><hr /><p><a name="Aq9ue"></a></p><h1 id="chapter-1-listsstacks-and-queues"><a class="markdownIt-Anchor" href="#chapter-1-listsstacks-and-queues"></a> Chapter 1 Lists,Stacks and Queues</h1><p><a name="csZFb"></a></p><h3 id="1-对自制vector容器添加错误检查能力"><a class="markdownIt-Anchor" href="#1-对自制vector容器添加错误检查能力"></a> 1. 对自制vector容器添加错误检查能力</h3><blockquote><p>访问vector容器，可能会出现的错误的迭代器操作主要有两种</p><ol><li>错误的访存操作：迭代器未初始化，执行<code>*</code>操作</li><li>迭代器超出容器边界：迭代器在末尾执行<code>++iter/iter++</code>操作</li></ol></blockquote><p>另外，迭代器还会出现如<code>7</code>所述的失效的情况</p><p><a name="kxJtb"></a></p><h4 id="1处理错误操作在重载运算符和时检查current的值"><a class="markdownIt-Anchor" href="#1处理错误操作在重载运算符和时检查current的值"></a> 1.处理错误操作：在重载运算符<code>*</code>和<code>++</code>时检查current的值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="keyword">operator</span> *()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (const_iterator::current == <span class="literal">NULL</span>)  <span class="comment">// Check boundary</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: iterator is NULL!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(const_iterator::current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator&amp; <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (const_iterator::current == objects[theSize<span class="number">-1</span>]) <span class="comment">// Error:Cannot access objects</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: iterator is end!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">const_iterator::current++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator类与const_iterator类作为vector模板类的嵌套类，访问外部类的私有成员<code>objects</code>与<code>theSize</code>是一件比较困难的事情 <a href="https://stackoverflow.com/questions/486099/can-inner-classes-access-private-variables">StackOverFlow：Can inner classes access private variables?</a></p><blockquote><p>嵌套类与外部类之间没有访问特权</p></blockquote><p><a name="hHyA9"></a></p><h4 id="2处理失效的迭代器给迭代器添加一个数据成员用于指向当前表用一个函数用于判断迭代器是否指向正确的表-当发生扩容时原有的thevector指向的空间被释放-thevector-null感觉有点问题"><a class="markdownIt-Anchor" href="#2处理失效的迭代器给迭代器添加一个数据成员用于指向当前表用一个函数用于判断迭代器是否指向正确的表-当发生扩容时原有的thevector指向的空间被释放-thevector-null感觉有点问题"></a> 2.处理失效的迭代器：给迭代器添加一个数据成员用于指向当前表，用一个函数用于判断迭代器是否指向正确的表。当发生扩容时，原有的theVector指向的空间被释放。（<code>theVector == NULL</code>感觉有点问题）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">const_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Object* current;</span><br><span class="line">    <span class="type">const</span> vector&lt;Object&gt;* theVector;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assertIsValid</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(current == <span class="literal">NULL</span> || theVector == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;IteratorOutOfbounds&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fgUkk"></a></p><h3 id="2-搜寻链表的注意点"><a class="markdownIt-Anchor" href="#2-搜寻链表的注意点"></a> 2. 搜寻链表的注意点</h3><p>在链表搜寻值为x的节点时，显然需要保存两个节点的信息：当前节点<code>current</code>和上一个节点<code>foreCurrent</code>,要注意对这两个值不同的初始化，搜寻的条件也不同。有以下两种模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">current = head-&gt;next</span><br><span class="line">foreCurrent = head;</span><br><span class="line"><span class="keyword">while</span> (current &amp;&amp; current-&gt;data != x)</span><br><span class="line">&#123;</span><br><span class="line">    foreCurrent = current;</span><br><span class="line">    current = current-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node* current = head; <span class="comment">// Initially nullptr</span></span><br><span class="line">Node* foreCurrent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (current-&gt;next!= <span class="literal">nullptr</span> &amp;&amp; current-&gt;data != x )</span><br><span class="line">&#123;</span><br><span class="line">foreCurrent = current;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：混淆这两种模式将出现访存错误，如以下情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node* current = head-&gt;next;</span><br><span class="line">Node* foreCurrent = head;</span><br><span class="line"><span class="keyword">while</span> (current-&gt;next!= <span class="literal">nullptr</span> &amp;&amp; current-&gt;data != x )</span><br><span class="line">&#123;</span><br><span class="line">foreCurrent = current;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会出现的问题是：当链表中仅有一个头节点时，初始<code>current=head-&gt;next</code>值为<code>nullptr</code>，第3行的<code>current-&gt;next</code>将执行失败（实现iterator类后，尽可能的使用该类，该类不存在以上问题）<br /><a name="hF7j1"></a></p><h3 id="3平衡符号"><a class="markdownIt-Anchor" href="#3平衡符号"></a> 3.平衡符号</h3><p>创建一个空栈后读取文件，当读取到开放字符<code>(,&#123;,[,/*</code>时压入栈，当读取到封闭字符<code>),&#125;,],*/</code>时从栈顶弹出字符。</p><blockquote><ol><li>读取到封闭字符时，栈为空，则封闭字符不匹配，报错</li><li>弹出的字符与封闭字符不匹配，报错</li><li>读取到文件尾后，栈不为空，则开放字符不匹配，报错</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">balSymbol</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> current, prev;</span><br><span class="line"><span class="function">string <span class="title">left</span><span class="params">(<span class="string">&quot;&#123;[(*&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">right</span><span class="params">(<span class="string">&quot;&#125;])&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">iFile</span><span class="params">(<span class="string">&quot;3_21Sample.txt&quot;</span>)</span></span>;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; check;</span><br><span class="line"><span class="keyword">if</span> (!iFile.<span class="built_in">is_open</span>())</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">iFile &gt;&gt; current;</span><br><span class="line">prev = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (!iFile.<span class="built_in">eof</span>())</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// push open symbol in stack</span></span><br><span class="line"><span class="keyword">if</span> (left.<span class="built_in">find</span>(current) != string::npos) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(current !=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">check.<span class="built_in">push</span>(current);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;*&#x27;</span> &amp;&amp; prev == <span class="string">&#x27;/&#x27;</span>) <span class="comment">// push in &#x27;/*&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">check.<span class="built_in">push</span>(prev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// no push action for current ==&#x27;*&#x27; prev !=&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If it is a closed symbol and stack is not empty, the corresponding symbol will pop up</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current == <span class="string">&#x27;/&#x27;</span> &amp;&amp; prev == <span class="string">&#x27;*&#x27;</span>) <span class="comment">// special for &#x27;/&#x27;,&#x27;/&#x27; can be left or right</span></span><br><span class="line">&#123; <span class="comment">// for &#x27;*/&#x27;,no action for current ==&#x27;/&#x27; and stack is empty (/*....),</span></span><br><span class="line"><span class="keyword">if</span>(check.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//last mismatch closed symbol is a speical situation, which can not belong to error:eof()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(check.<span class="built_in">top</span>() == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">check.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (right.<span class="built_in">find</span>(current) != string::npos)   <span class="comment">// for (]&#125;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check.<span class="built_in">empty</span>()) <span class="comment">// prevent top() error</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//last mismatch closed symbol is a speical situation, which can not belong to error:eof()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; check.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">check.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;]&#x27;</span> &amp;&amp; check.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">check.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;)&#x27;</span> &amp;&amp; check.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">check.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// error: top stack symbol mismatch → eof() is false</span></span><br><span class="line">&#125;</span><br><span class="line">prev = current;</span><br><span class="line">iFile &gt;&gt; current; <span class="comment">// read next character in buffer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// judge</span></span><br><span class="line"><span class="keyword">if</span> (!iFile.<span class="built_in">eof</span>() )</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;closed symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!check.<span class="built_in">empty</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open symbol mismatch!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Successful!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JdH6s"></a></p><h3 id="4-中缀表达式转后缀表达式"><a class="markdownIt-Anchor" href="#4-中缀表达式转后缀表达式"></a> 4. 中缀表达式转后缀表达式</h3><p>1.为什么在向栈中压入运算符时，要先弹出优先级更高的运算符</p><blockquote><p>运算符的出栈顺序代表了运算符的执行顺序。显然的，优先级更高的运算符最先打印并出栈，即在后缀表达式中代表最早参与运算</p></blockquote><p>2.为什么直到碰到右括号<code>)</code>之前，不弹出左括号<code>(</code>，遇到右括号<code>)</code>后,弹出栈元素直到遇到<code>(</code></p><blockquote><p>该操作的意思是弹出括号内的所有运算符，显然的，括号内的各运算符优先级高于括号外的运算符</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">infixToPostFix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">iFile</span><span class="params">(<span class="string">&quot;3_23Sample.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!iFile.<span class="built_in">is_open</span>())</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">string operators = <span class="string">&quot;()+-/*&quot;</span>;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;keepOptors;</span><br><span class="line"><span class="type">char</span> current;</span><br><span class="line">iFile &gt;&gt; current;</span><br><span class="line"><span class="keyword">while</span> (!iFile.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (operators.<span class="built_in">find</span>(current) != string::npos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (keepOptors.<span class="built_in">empty</span>()) <span class="comment">// initial</span></span><br><span class="line">keepOptors.<span class="built_in">push</span>(current);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (operators.<span class="built_in">find</span>(keepOptors.<span class="built_in">top</span>(), <span class="number">2</span>)!= string::npos) <span class="comment">//top item is +, -,* or /</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; keepOptors.<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">keepOptors.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (keepOptors.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">keepOptors.<span class="built_in">push</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(current ==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (operators.<span class="built_in">find</span>(keepOptors.<span class="built_in">top</span>(), <span class="number">3</span>)) <span class="comment">//top item is -,* or /</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; keepOptors.<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">keepOptors.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (keepOptors.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">keepOptors.<span class="built_in">push</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;*&#x27;</span> || current == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">keepOptors.<span class="built_in">push</span>(current);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (keepOptors.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; keepOptors.<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">keepOptors.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">keepOptors.<span class="built_in">pop</span>(); <span class="comment">// pop up &#x27;(&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; current &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">iFile &gt;&gt; current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!keepOptors.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; keepOptors.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">keepOptors.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Kvu8h"></a></p><h3 id="5-后缀表达式转中缀表达式"><a class="markdownIt-Anchor" href="#5-后缀表达式转中缀表达式"></a> 5. 后缀表达式转中缀表达式</h3><p>想法与计算后缀表达式差不多，注意两个地方</p><blockquote><p>1.优先参与运算的运算符的运算结果是下一个运算符的操作数，想想怎么把表达式连接成一个整体<br />2.为每个计算式加上括号，确保在最终的中缀表达式中能清晰的表达计算顺序，如 8<em>5+3 与 (8</em>(5+3))</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postfixToInfix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;string&gt; expr;</span><br><span class="line"><span class="function">ifstream <span class="title">iFile</span><span class="params">(<span class="string">&quot;3_22Sample.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!iFile.<span class="built_in">is_open</span>())</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">string first, second;</span><br><span class="line"><span class="type">char</span> current;</span><br><span class="line">iFile &gt;&gt; current;</span><br><span class="line"><span class="keyword">while</span> (!iFile.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">48</span> &lt;= current &amp;&amp; current &lt;= <span class="number">57</span>)</span><br><span class="line">expr.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="number">1</span>,current));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">first = expr.<span class="built_in">top</span>();</span><br><span class="line">expr.<span class="built_in">pop</span>();</span><br><span class="line">second = expr.<span class="built_in">top</span>();</span><br><span class="line">expr.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (current == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">expr.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>+first + <span class="string">&#x27;*&#x27;</span>+second+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">expr.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>+first +<span class="string">&#x27;/&#x27;</span>+ second + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">expr.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span> + first + <span class="string">&#x27;+&#x27;</span> + second + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">expr.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span> + first + <span class="string">&#x27;-&#x27;</span> + second + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">iFile &gt;&gt; current;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; expr.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="OSFAk"></a></p><h3 id="6-逆向打印链表的两个方法"><a class="markdownIt-Anchor" href="#6-逆向打印链表的两个方法"></a> 6. 逆向打印链表的两个方法</h3><p><a name="UuJnf"></a></p><h4 id="1链表反转"><a class="markdownIt-Anchor" href="#1链表反转"></a> 1.链表反转</h4><p>改变单向链表的结构，反转其方向。需要用到三个结点的信息<code>prev、current、next</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_List</span><span class="params">()</span>  <span class="comment">// O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* prev, *current, *cNext;</span><br><span class="line">prev = <span class="literal">nullptr</span>;</span><br><span class="line">current = head-&gt;next;</span><br><span class="line">cNext = current-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cNext != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">current-&gt;next = prev; <span class="comment">// reverse direction</span></span><br><span class="line">prev = current;</span><br><span class="line">current = cNext;</span><br><span class="line">cNext = current-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">current-&gt;next = prev;</span><br><span class="line">head-&gt;next = current; <span class="comment">// head to tail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意同时声明多个指针时，不能写成<code>Node* prev, current, cNext</code>，这种声明下<code>current、cNext</code>是int型，只有一个<code>prev</code>是指针类型。应改为<code>Node* prev, *current, *cNext;</code></p></blockquote><p><a name="aAKjU"></a></p><h4 id="2利用栈"><a class="markdownIt-Anchor" href="#2利用栈"></a> 2.利用栈</h4><p>逆向打印可以利用栈先进后出的性质实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_Print_With_Stack</span><span class="params">()</span> <span class="comment">//  O(N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;T&gt; storage;</span><br><span class="line">    Node* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        storage.<span class="built_in">push</span>(p-&gt;value);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!storage.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; storage.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        storage.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QwIKh"></a></p><h3 id="7-环形缓冲区的满vs空问题"><a class="markdownIt-Anchor" href="#7-环形缓冲区的满vs空问题"></a> 7. 环形缓冲区的满vs空问题</h3><p>用<strong>数组</strong>实现队列通常有两种方式</p><ol><li>head 指向队列头，即第一个元素，tail 指向新元素即将插入的位置，即最后一个元素的下一个位置，enque后tail+1 (初始状态：head = tail = 0)</li><li>head 指向队列头，tail指向最后一个元素，enque前tail+1 （初始状态：front = 0 , tail = -1）</li></ol><p>两种情况下，均要保持队列最后一个元素不能使用，(n-1) 长度队列可以用长度为 n 的数组创建</p><ol><li><br /></li></ol><p>empty：<code>head = tail  </code><br />full：<code>head = (tail+1) % maxSize</code>  <br />如果完全填充数组，那么会导致full和empty情况下，均满足<code>head = tail </code></p><ol start="2"><li><br /></li></ol><p>empty : <code>head = (tail+1) % maxSize</code>  <br />full：<code>head = (tail+2) % maxSize</code> ？<br />如果完全填充数组，那么会导致full和empty情况下,均满足<code>head = (tail+1) % maxSize</code><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1660033289402-7374663e-99df-4e23-8d39-2bcb71e5622a.png" alt="image.png" /><br /><a name="mDKbV"></a></p><h3 id="8-判断链表是否有环的两个方法"><a class="markdownIt-Anchor" href="#8-判断链表是否有环的两个方法"></a> 8. 判断链表是否有环的两个方法</h3><blockquote><ol><li>用<code>hashset</code>存储遍历过的节点，用新节点对比，有重复则存在环</li><li>双指针遍历，速度不同，相遇则存在环</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detectloop</span><span class="params">(Node&lt;T&gt;* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node&lt;T&gt;* first, * second;</span><br><span class="line">first = second = head;</span><br><span class="line"><span class="comment">/*A walks faster than B, so only A is judged.</span></span><br><span class="line"><span class="comment">If A is the last node, you need to judge A-&gt;next*/</span></span><br><span class="line"><span class="keyword">while</span> (first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">first = first-&gt;next-&gt;next; <span class="comment">// two step</span></span><br><span class="line">second = second-&gt;next; <span class="comment">// one step</span></span><br><span class="line"><span class="keyword">if</span> (first == second)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;exist loop&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no loop&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>涉及的算法：<a href="https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/">Floyd’s Cycle Finding Algorithm</a></p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/31401474">知乎：如何判断链表有环</a><br /><a href="https://leetcode.com/problems/linked-list-cycle/discuss/1829489/C%2B%2B-oror-Easy-To-Understand-oror-2-Pointer-oror-Fast-and-Slow">LeetCode：Linked List Cycle</a><br /><a name="qdbBD"></a></p><h2 id="other-questions"><a class="markdownIt-Anchor" href="#other-questions"></a> other questions：</h2><ol><li><strong>stackoverflow示例中总是出现的foo ，bar 是什么意思</strong></li></ol><p>foo：File or Object，文件或对象。它用于代替对象变量或文件名，用于代码演示<br />bar：与foo的作用一样，表示变量或文件，用于代码演示2.VS2019调出监视窗口的办法</p><ol start="2"><li><strong>vs2019中调式调出监视窗口</strong></li></ol><p>设置断点，运行程序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1658310883417-a80aaf32-ea48-40bb-b554-2c6d8960689b.png" alt="屏幕截图 2022-07-20 175431.png" /></p><ol start="3"><li><strong>git上传项目到github</strong></li></ol><p><a href="https://zhuanlan.zhihu.com/p/369486197">知乎：github基础教学</a><br /><a name="IthCG"></a></p><h2 id="remaining-problem"><a class="markdownIt-Anchor" href="#remaining-problem"></a> remaining problem</h2><ol><li><strong>在vector中实现erase(iterator pos)</strong></li></ol><p>涉及萃取</p><ol start="2"><li><strong>实现能够指定容器的stack类</strong></li><li><strong>STL stack: emplace() vs push()</strong></li></ol><p>涉及右值引用，移动构造(?)</p><ol start="4"><li><strong>判断链表是否有环，为什么不直接判断最后一个节点指向是否为nullptr</strong></li></ol><p>我认为可能的原因：当最后一个节点指向本身时，其next也不为nullptr，而此时单链表中不存在环，所以该方法不适用。</p><hr /><p><a name="oX3jS"></a></p><h1 id="chapter-2-trees"><a class="markdownIt-Anchor" href="#chapter-2-trees"></a> Chapter 2 Trees</h1><p><a name="JBUuP"></a></p><h2 id="record"><a class="markdownIt-Anchor" href="#record"></a> record:</h2><p><a name="oEiO6"></a></p><h3 id="1-二叉查找树类中为什么要额外添加功能与公有函数相同但参数不同的同名私有函数"><a class="markdownIt-Anchor" href="#1-二叉查找树类中为什么要额外添加功能与公有函数相同但参数不同的同名私有函数"></a> 1. 二叉查找树类中为什么要额外添加功能与公有函数相同，但参数不同的同名私有函数</h3><p>在类外调用公有函数，而公有函数内部需要递归处理左右子树，需要传入新的根节点，所以需要有额外的能传入根节点参数的函数，因为这类函数只被公有函数所使用，所以设置为私有（辅助函数）<br /><a href="https://stackoverflow.com/questions/4505938/when-why-to-make-function-private-in-class">stackoverflow：When/why to make function private in class?</a><br /><a name="DpaEu"></a></p><h3 id="2搜索二叉树的insert成员函数结点指针t必须引用传递的原因"><a class="markdownIt-Anchor" href="#2搜索二叉树的insert成员函数结点指针t必须引用传递的原因"></a> 2.搜索二叉树的insert成员函数结点指针t必须引用传递的原因</h3><p>如果采用值传递，那么函数insert中的指针将是实参的副本，在函数insert中修改该副本，不能达到修改结点p的成员变量left or right的目的, remove函数同理<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1661568230165-1e7336ea-23dc-443d-afa4-e35e7a5a4058.jpeg" alt="" /><br /><a name="WEgNR"></a></p><h3 id="3-平衡二叉树"><a class="markdownIt-Anchor" href="#3-平衡二叉树"></a> 3. 平衡二叉树</h3><p>对BST的find操作，其运行时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>为结点的深度。给定一系列值，不同的插入序列对应不同的树结构，有着不同的平均结点深度，进而有不同的查找效率。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1661156478689-efe3aeff-b060-4bc9-80ee-099b96f5aa02.png" alt="image.png" /><br />创建高度为h的AVL树所需的最少结点数为斐波那契数列第h+2项的值减1（高度和项数均从0计数）<br /><a name="FZLgt"></a></p><h2 id="remaining-problem-2"><a class="markdownIt-Anchor" href="#remaining-problem-2"></a> remaining problem</h2><p><a name="Le4pv"></a></p><h3 id="1-给定一系列值确定构造bst的方法个数"><a class="markdownIt-Anchor" href="#1-给定一系列值确定构造bst的方法个数"></a> 1. 给定一系列值，确定构造BST的方法个数</h3><p><a href="https://stackoverflow.com/questions/17119116/how-many-ways-can-you-insert-a-series-of-values-into-a-bst-to-form-a-specific-tr">stackoverflow：How many ways can you insert a series of values into a BST to form a specific tree?</a></p><hr /><p><a name="Cieup"></a></p><h1 id="chapter-3-hashing"><a class="markdownIt-Anchor" href="#chapter-3-hashing"></a> Chapter 3 Hashing</h1><p><a name="RQFF9"></a></p><h2 id="1-为什么哈希表只能惰性删除lazy-deletion"><a class="markdownIt-Anchor" href="#1-为什么哈希表只能惰性删除lazy-deletion"></a> 1. 为什么哈希表只能惰性删除(lazy deletion)</h2><p>答：在插入其它元素A时，A可能与待删除元素B发生过冲突(collision),即可能有<code>myhash(A) == myhash(B)</code>,也可能是A在向前探测的过程中与B发生过冲突。 如果删除元素B，那么在寻找A就会失败，因为此时B所在的位置是EMPTY，那么findPos(A)在B的位置上会返回currentPos,查找结束，但currentPos是EMPTY而不是A所在的值。<br /><a name="mwjke"></a></p><h2 id="2-为什么要有哈希表是怎么达到高效性的"><a class="markdownIt-Anchor" href="#2-为什么要有哈希表是怎么达到高效性的"></a> 2. 为什么要有哈希表？是怎么达到高效性的？</h2><p>为了在<strong>常数时间</strong>内高效实现对数据的插入，删除，查找操作。 通过<strong>哈希函数</strong>（通常是 <code>hash(x) % tableSize</code>,<code>hash(x)</code>的作用是将x转化为数字，由key类提供，如果x本身就是数字，那么hash(x) = x），让待插入数据<strong>直接定位</strong>到哈希表中的一个位置（哈希表是什么？ 一个固定大小的存储项的数组， 哈希 = 散列）<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1664794253808-1aee7326-a1c4-44c2-986e-5ca40efa4d87.jpeg" alt="" /><br /><a name="Hcjq3"></a></p><h2 id="3-冲突collision是什么怎么解决冲突的"><a class="markdownIt-Anchor" href="#3-冲突collision是什么怎么解决冲突的"></a> 3. 冲突(collision)是什么？怎么解决冲突的？</h2><p>不同的数据可能会被哈希函数映射到相同的位置，而一个位置只能属于一个数据，因此产生了冲突。为解决冲突，很简单是想法就是：<strong>既然原本属于它的位置被占用了，那就将数据移到可以存放的空位置</strong><br />如何找到这个空位置呢？有两种方法</p><ol><li><strong>分离链接法（separate chaining）:</strong></li></ol><p>既然冲突是因为一个位置只能存放一个数据，那么引入链表以实现一个位置能够存放多个数据，冲突便解决了。哈希表中的一个位置对应一条链表，显然的，在某个位置发生的冲突越多，那么这条链表就越长。无论是执行查找还是删除操作，都要先找到链表（由哈希函数得到），再在链表里面找到数据。</p><ol start="2"><li><strong>开放定址法（open addressing）：</strong></li></ol><p>往前探测（probe），形式化为公式就是<code>hashi(x) = (hash(x) + f(i))</code>,<strong>i表示向前探测的次数</strong>，f(i)称为冲突解决策略（collision resolution strategy）,显然<code>f(0)=0</code>。根据f(i)形式的不同，分为线性(Linear)探测:<code>f(i)=i</code>、平方(quadratic)探测:<code>f(i) = i2</code>、双(double)散列:<code>f(i) = i*hash2(x)</code><br />**线性探测会引起一次聚集（<strong>primary cluster</strong>），平方探测会引起二次聚集（<strong>Secondary Clustering</strong>），**关于这一点：<a href="https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash">stackoverflow：What is primary and secondary clustering in hash?</a> 说的很清楚<br />为什么一次聚集对性能的影响会比二次聚集更大呢？首先要知道，聚集之所以会影响性能，是因为聚集导致hashPos之后的位置大部分被占用，进而导致探测次数增加。一次聚集是无间隔的聚集，那么只要在这堆聚集的项中发生了冲突，就基本上要一步一步的探测完所有聚集项才能找到空位置。而二次聚集是有间隔的，一次两步的探测会减少探测的发生。这个具体的描述比较困难，但是很好想。<br />双散列，消除了聚集问题，它应用了另一个哈希函数<code>hash2(x)</code>（<strong>哈希结果不能为0，则f(i)将失去意义</strong>），使得探测更趋于随机化，而不是集中在哈希位置附近。<br />注意点：</p><ul><li>哈希表的**大小(tableSize)为素数(Prime)**能更好的减少冲突的发生</li><li><strong>tableSize为素数且λ&lt;0.5</strong>（有一半以上空项）时平方探测能保证插入成功。否则甚至不如线性探测，因为插入可能会失败（书上有证明）</li><li>当计算哈希值代价较高时，性能角度上，双散列较之平方探测不是一个更好的选择</li></ul><p><strong>两个方法的对比：</strong> 前者不如后者，因为分离链表法会因为插入而分配新内存，这将降低执行效率；其次，分离链表法等于是哈希表与链表的结合，等于要求实现了另一种数据结构(而不是哈希表)，提高了程序的复杂性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findPos</span><span class="params">(<span class="type">const</span> hashedObj&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> currentPos = <span class="built_in">myhash</span>(x);</span><br><span class="line"><span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (array[currentPos].info != Empty &amp;&amp; array[currentPos].element != x)</span><br><span class="line">&#123;</span><br><span class="line">currentPos += offset;</span><br><span class="line">offset = <span class="built_in">pow</span>(offset,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (currentPos &gt;= array.<span class="built_in">size</span>())</span><br><span class="line">currentPos -= array.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currentPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vpuOb"></a></p><h2 id="4-为什么要再散列rehashing再散列要怎么做"><a class="markdownIt-Anchor" href="#4-为什么要再散列rehashing再散列要怎么做"></a> 4. 为什么要再散列(rehashing)？再散列要怎么做？</h2><p>当哈希表过于满(too full，λ too big)，查找操作将会变得非常缓慢（如之前所说，探测次数会非常多），进而影响插入和删除操作。解决这个困境的办法就是扩大哈希表以降低λ。<br />做法是：创建一个表长为大于2倍当前长度的第一个素数的新表（如当前长度是7，扩大后为17），相应的也产生了新的哈希函数，接着把原表中的所有数据通过新的哈希函数映射到新表中。<br />怎么界定哈希表是否需要再散列，一个好的方法是：当λ到达某个界定值时</p><hr /><p><a name="OulqF"></a></p><h1 id="chapter-4-heap"><a class="markdownIt-Anchor" href="#chapter-4-heap"></a> Chapter 4 Heap</h1><p><a name="KirP0"></a></p><h2 id="1-为什么要有二叉堆binary-heap-是怎么达到高效的"><a class="markdownIt-Anchor" href="#1-为什么要有二叉堆binary-heap-是怎么达到高效的"></a> 1. 为什么要有二叉堆(Binary Heap)? 是怎么达到高效的？</h2><p>为了实现<strong>优先级队列(priority queue)</strong>，即根据不同对象间的优先级排列而形成的队列，如操作系统中进程的优先级队列。相比于用队列(Queue)实现的根据对象到来的时间属性而确定优先级队列(即First Come First Served), 我们希望有一种数据结构，它有着更加灵活的优先级批判标准，而不是只看任务的到达时间。不仅如此，为了高效性，我们希望这个数据结构能够快速的找出队列中优先级最大的那一个。<br />由此我们引出二叉堆，二叉堆是一个**底层为数组的完全二叉树(complete binary tree)，**有结构性质和堆序性质<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1665135196819-0f05c687-059e-4b79-9c73-9c31e16de204.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Comparable&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == array.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">array.<span class="built_in">resize</span>(array.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hole = ++heapSize;</span><br><span class="line">Comparable copy = x;</span><br><span class="line">array[<span class="number">0</span>] = std::<span class="built_in">move</span>(copy);</span><br><span class="line"><span class="keyword">for</span> (; x &lt; array[hole / <span class="number">2</span>]; hole /= <span class="number">2</span>)  <span class="comment">// percolate up</span></span><br><span class="line">&#123;</span><br><span class="line">array[hole] = std::<span class="built_in">move</span>(array[hole / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">array[hole] = std::<span class="built_in">move</span>(array[<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hole = <span class="number">1</span>;</span><br><span class="line">Comparable x = std::<span class="built_in">move</span>(array[heapSize--]);</span><br><span class="line"><span class="keyword">for</span> (; hole &lt;= heapSize; hole*=<span class="number">2</span>) <span class="comment">// percolate down</span></span><br><span class="line">&#123;</span><br><span class="line">child = <span class="number">2</span> * hole;</span><br><span class="line"><span class="keyword">if</span> (child != heapSize &amp;&amp; array[child] &lt; array[child + <span class="number">1</span>])</span><br><span class="line">++child;</span><br><span class="line"><span class="keyword">if</span> (x &gt; array[child])</span><br><span class="line">array[hole] = std::<span class="built_in">move</span>(array[child]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">array[hole] = std::<span class="built_in">move</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = heapSize / <span class="number">2</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line"><span class="built_in">percolateDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p><a name="eHZpk"></a></p><h1 id="chapter-5-sorting"><a class="markdownIt-Anchor" href="#chapter-5-sorting"></a> Chapter 5 Sorting</h1><p><a name="SWGCy"></a></p><h2 id="insertion_sort"><a class="markdownIt-Anchor" href="#insertion_sort"></a> Insertion_Sort</h2><p><a name="Hw7N9"></a></p><h3 id="1-怎么插入的为什么结果能有序"><a class="markdownIt-Anchor" href="#1-怎么插入的为什么结果能有序"></a> 1. 怎么插入的？为什么结果能有序？</h3><p>对序列(Comparable)，假定第一个数据(array[0])是有序的，把从第二项到末尾的数据逐个插入到开头的有序序列中。<br />怎么插入的？将待插入项<code>tmp</code>与有序序列中的项逐个比较，遇到<code>array[i]&gt;tmp</code>(升序序列)，则将有序序列中的元素右移，为<code>tmp</code>提供插入位，接着插入<code>tmp</code>。等价于将位置为p的项放入前p+1项(从0开始索引)的正确位置(从小到大)。如果数组本身就比较有序，那么可以省去不少插入操作<br />为什么能有序？ straightforward，我觉得有些许减治法的感觉，先解决小问题，逐步解决大问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(std::vector&lt;Comparable&gt;&amp; array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> N = array.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt; N; ++p)</span><br><span class="line">&#123;</span><br><span class="line">Comparable tmp = std::<span class="built_in">move</span>(array[p]);</span><br><span class="line"><span class="type">int</span> j = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; array[j]; --j)</span><br><span class="line">&#123;</span><br><span class="line">array[j + <span class="number">1</span>] = std::<span class="built_in">move</span>(array[j]); <span class="comment">// j move right, p move left</span></span><br><span class="line">&#125;</span><br><span class="line">array[j + <span class="number">1</span>] = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="AXqXN"></a></p><h2 id="shell_sort"><a class="markdownIt-Anchor" href="#shell_sort"></a> Shell_Sort</h2><p><a name="NvzxL"></a></p><h3 id="1-为什么说希尔排序涉及了插入排序"><a class="markdownIt-Anchor" href="#1-为什么说希尔排序涉及了插入排序"></a> 1. 为什么说希尔排序涉及了插入排序？</h3><p>因为希尔排序先将序列分组，然后在组内进行插入排序<br /><a name="rqY4s"></a></p><h3 id="2-希尔排序是如何分组的"><a class="markdownIt-Anchor" href="#2-希尔排序是如何分组的"></a> 2. 希尔排序是如何分组的？</h3><p>使用一组增量h1，h2，h3， . . . , ht(就是代表了不同的跨度，h1 =1)。第一阶段，对任意位置i，把array[i]，array[i+ht]，array[i+2ht]…分为一组执行插入排序；第二阶段，对任意位置i，把array[i]，array[i+ht-1]，array[i+2ht-1]…分为一组执行插入排序。显然的，在最后阶段，使用增量h1=1时就是对整个序列执行插入排序。<br />选择合适的增量能使插入排序的时间复杂度低于插入排序，如 Hibbard增量： 1, 3, 7, . . . , 2k − 1。<br /><strong>执行一个增量为h<strong><strong>k</strong></strong>的排序(hk-Sort)，等价于对h<strong><strong>k</strong></strong>个子数组(subarray)执行插入排序(见下图)</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1665481444552-78d1a034-c95c-462b-b080-475d22f10d1c.jpeg" alt="" /><br /><a name="yUWsx"></a></p><h3 id="3-希尔排序是如何改进插入排序的-执行名副其实的插入排序前h1分组的作用是什么"><a class="markdownIt-Anchor" href="#3-希尔排序是如何改进插入排序的-执行名副其实的插入排序前h1分组的作用是什么"></a> 3. 希尔排序是如何改进插入排序的? 执行名副其实的插入排序前(h1)，分组的作用是什么？</h3><p>分组的作用是对数组执行<a href="https://zhuanlan.zhihu.com/p/87781731">预排序</a>，即在执行真正的插入排序前先使数组比较有序，以减少执行插入操作的次数。显然插入排序在1.元素个数少 2. 数组比较有序 的情况下执行效率高。分组营造了前一个条件以高效排序子数组，并为逐步减少分组的增量(跨度)以排序数组中的更多元素提供了第二个条件。所以显然的，希尔排序优于插入排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_Sort</span><span class="params">(std::vector&lt;Comparable&gt; array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> N = array.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = N/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// insertion Sort</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = gap; p &lt; N; ++p)   <span class="comment">// point: ++p here</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p - gap;</span><br><span class="line">Comparable tmp = std::<span class="built_in">move</span>(array[p]);</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp;  array[j] &gt; tmp; j-=gap)</span><br><span class="line">array[j + gap] = std::<span class="built_in">move</span>(array[j]);</span><br><span class="line">array[j + gap] = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="ZZpJ6"></a></p><h2 id="heap_sort"><a class="markdownIt-Anchor" href="#heap_sort"></a> Heap_Sort</h2><p><a name="mMQHg"></a></p><h3 id="1-如何利用堆实现排序"><a class="markdownIt-Anchor" href="#1-如何利用堆实现排序"></a> 1. 如何利用堆实现排序</h3><p>要利用堆(heap)将一个乱序的数组变成有序的数组，显然的，要首先构造一个堆(build heap)，即利用heapify的方法将N个元素组成堆的结构(本质还是数组)；接着，对这个堆执行N-1次<code>deleteMax</code>(或<code>deleteMin</code>)操作，在每次执行删除操作时，将删除的元素填入刚刚空出来的最后一个元素的位置上；最后能得到一个递增序列(最大堆)或递减序列(最小堆)。<br />关键是要认识到，在本质上，对堆执行deleteMax操作，是将堆的最后一个元素(<code>array[HeapSize]</code>)填在根(<code>array[0]</code>)的位置(覆盖原有的根值),接着把这个结点通过下滤(percolate down)放在合适位置。较之堆删除，堆排序只改变了一个操作，那就是把这个覆盖的过程，变成一个交换(swap)的过程。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1665664167534-eee32f0c-0cba-487b-a1aa-b684f3f02866.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;Comparable&gt; &amp; objects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// bulid heap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = objects.<span class="built_in">size</span>()/<span class="number">2</span><span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line"><span class="built_in">percDown</span>(objects, j, objects.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//make a decreasing array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = objects.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(objects[<span class="number">0</span>], objects[i]);</span><br><span class="line"><span class="built_in">percDown</span>(objects, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span>  <span class="title">leftChild</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percDown</span><span class="params">(vector&lt;Comparable&gt; &amp;objects , <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Comparable tmp = <span class="built_in">move</span>(objects[i]);</span><br><span class="line"><span class="type">int</span> child;<span class="comment">// left child </span></span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">leftChild</span>(i) &lt; n; i = child)</span><br><span class="line">&#123;</span><br><span class="line">child = <span class="built_in">leftChild</span>(i);</span><br><span class="line"><span class="keyword">if</span> (child != n<span class="number">-1</span> &amp;&amp; objects[child] &lt; objects[child + <span class="number">1</span>])</span><br><span class="line">++child;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; objects[child])</span><br><span class="line">objects[i] = <span class="built_in">move</span>(objects[child]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">objects[i] = <span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pNLGn"></a></p><h2 id="merge_sort"><a class="markdownIt-Anchor" href="#merge_sort"></a> Merge_Sort</h2><p><a name="cBdMT"></a></p><h3 id="1-归并排序是如何排序的为什么说体现了分而治之-divide-and-conquer的思想"><a class="markdownIt-Anchor" href="#1-归并排序是如何排序的为什么说体现了分而治之-divide-and-conquer的思想"></a> 1. 归并排序是如何排序的，为什么说体现了分而治之( divide-and-conquer)的思想？</h3><p>归并排序，最重要的基本操作就是<strong>将两个已排序的数组整合为一个</strong>，也就是Merge(合并)操作。要获取两个已排序的数组，首先将待排序的数组一分为二，然后对这两个子数组递归的调用归并排序（递归返回条件：子数组只剩一个元素<code> left &gt;= right</code>)。 <br />归并排序本质上是对<strong>逐步完成对子数组的排序进而完成大数组的排序</strong>。<br /><strong>divide：将数组一分为二    conquer：Merge</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;Comparable&gt;&amp; objects, vector&lt;Comparable&gt;&amp; tmpA, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) <span class="comment">// recursive call&#x27;s end condition : only one element </span></span><br><span class="line"><span class="keyword">return</span>;  </span><br><span class="line"><span class="type">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(objects, tmpA, left, center); <span class="comment">// merge first half </span></span><br><span class="line"><span class="built_in">mergeSort</span>(objects, tmpA, center + <span class="number">1</span>, right);  <span class="comment">// merge second half</span></span><br><span class="line"><span class="built_in">merge</span>(objects, tmpA, left, center + <span class="number">1</span>, right); <span class="comment">// patch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;Comparable&gt;&amp; objects)</span>  <span class="comment">// driver</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;Comparable&gt; <span class="title">tmpA</span><span class="params">(objects.size())</span></span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(objects, tmpA, <span class="number">0</span>, objects.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt; <span class="comment">// merge two sorted array into one</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;Comparable&gt;&amp; objects, vector&lt;Comparable&gt;&amp; tmpA, <span class="type">int</span> leftBegin, <span class="type">int</span> rightBegin, <span class="type">int</span> rightEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftEnd = rightBegin - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmpAIndex = leftBegin;</span><br><span class="line"><span class="type">int</span> N = rightEnd - leftBegin + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (leftBegin &lt;= leftEnd &amp;&amp; rightBegin &lt;= rightEnd) <span class="comment">// comparison between two halves</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (objects[leftBegin] &lt;= objects[rightBegin])</span><br><span class="line">tmpA[tmpAIndex++] = <span class="built_in">move</span>(objects[leftBegin++]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmpA[tmpAIndex++] = <span class="built_in">move</span>(objects[rightBegin++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (leftBegin &lt;= leftEnd) <span class="comment">// copy the remainder</span></span><br><span class="line">&#123;</span><br><span class="line">tmpA[tmpAIndex++] = <span class="built_in">move</span>(objects[leftBegin++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (rightBegin &lt;= rightEnd)</span><br><span class="line">&#123;</span><br><span class="line">tmpA[tmpAIndex++] = <span class="built_in">move</span>(objects[rightBegin++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// how to write back to objects</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i,--rightEnd )</span><br><span class="line">&#123;</span><br><span class="line">objects[rightEnd] = <span class="built_in">move</span>(tmpA[rightEnd]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29536731/1672988373854-be3e4874-5705-410b-8800-ad92faa15a40.jpeg" alt="" /><br /><a name="dIPOD"></a></p><h2 id="quick_sort"><a class="markdownIt-Anchor" href="#quick_sort"></a> Quick_Sort</h2><p><a name="SkElc"></a></p><h3 id="1-快速排序是如何排序的"><a class="markdownIt-Anchor" href="#1-快速排序是如何排序的"></a> 1. 快速排序是如何排序的</h3><p>与归并排序类似，快速排序也有分割数组的操作，但不同于归并排序一分为二的做法**，快速排序会先在数组中选取一个枢纽元(pivot)，然后把剩下的元素根据大于/小于pivot分为两组(group)，**产生两个子数组，放在pivot前后，接着递归的对子数组调用快速排序。<br /><a name="Tfhnl"></a></p><h3 id="2-为什么选择三数中值median-of-three-作为pivot的效率最高"><a class="markdownIt-Anchor" href="#2-为什么选择三数中值median-of-three-作为pivot的效率最高"></a> 2. 为什么选择三数中值(Median-of-Three )作为pivot的效率最高</h3><p>这里的三数中值，指的是数组最左边<code>array[0]</code>，最右边<code>array[size-1]</code>，和中间<code>array[(left+right)/2]</code>这三个值中大小排中间的那个。<br /><strong>选取pivot的原则是取尽可能靠近数组的中值(第 ⌈N/2⌉大的值)，这样做的目的是让分组(partition)后产生了两个子数组如归并排序般尽可能均匀，进而减少递归的层次。<strong>不随机选取三个数取中值的原因在于random函数的代价较高，会影响性能(不随机去一个pivot的原因也是如此)。直接选取第一个元素作为pivot是一个欠妥的做法，这样会导致算法在数组有预排序的情况下做无用功。<br /><strong>为什么将三者的最小值放在</strong><code>**array[left]**</code></strong>？</strong> 因为最小值必然小于pivot，避免了一次多余的交换，同时这个left还能作为partition过程中<code>j</code>的哨兵(sentinel)，避免j越界。<br /><strong>为什么将三者的最大值放在</strong><code>**array[right]**</code>**？**同理，避免了交换，但此处没有起到做哨兵的作用，因为我们会在选取pivot时就将pivot放在<code>array[right-1]</code>的位置,而i与j遇到equal to pivot的值都会停止，所以pivot也作为了<code>i</code>的哨兵。<br /><a name="XXNbN"></a></p><h3 id="3-如何分组"><a class="markdownIt-Anchor" href="#3-如何分组"></a> 3. 如何分组？</h3><p>我们的目标是把小于pivot的值放在数组左边，大于pivot的值放在数组右边。<strong>采取的策略时</strong><code>**i**</code><strong>从数组左边开始遍历，遇到大于pivot的值就停止(该值不属于左边)；</strong><code>**j**</code><strong>从数组右边开始遍历，遇到小于pivot的值就停止。接着交换</strong><code>**i**</code><strong>和</strong><code>**j**</code><strong>所在位置的元素。当i和j交叉时，把</strong><code>**pivot**</code><strong>与</strong><code>**i**</code><strong>所在位置的值交换</strong>(为什么是<code>i</code>而不是<code>j</code>？因为pivot预先被放在数组右边right-1的位置，如果被放在右边那pivot就是和<code>j</code>交换位置)<br />**如何处理等于pivot的元素？**先说结论，<code>**i**</code><strong>和</strong><code>**j**</code><strong>遇到这样的元素都要停下</strong>。<br />接着在极端情况(所有元素都一样)情况下讨论其它做法的低效性<br />**为什么不一个停下而另一个继续前进？**如果<code>i</code>停下而<code>j</code>不停下，则<code>i``j</code>交叉的位置会偏向左侧，而pivot要与i最后在的位置交换值，这样显然会导致子数组的大小不平衡。<br />**为什么不两个都不停下？**首先<code>i</code>，<code>j</code>显然可能会出界，即使存在<code>i``j</code>出界的代码，这样做会导致i最后所处的位置在靠近最右边的位置(取决于具体实现)，而pivot要与<code>i</code>交换位置，进而导致产生的子数组很不平衡，降低了算法效率<br /><a name="mt8ir"></a></p><h3 id="4-递归结束条件是什么什么是cutoff为什么要结合插入排序"><a class="markdownIt-Anchor" href="#4-递归结束条件是什么什么是cutoff为什么要结合插入排序"></a> 4. 递归结束条件是什么？什么是cutoff？为什么要结合插入排序？</h3><p>快速排序或许应该像归并排序那样，当子数组仅剩一个元素时递归返回。但是实际上并不这样设置递归返回条件，因为存在这样一个事实：<strong>当数组元素个数很少(5~20)时，快速排序的效率还不如插入排序。因此在partition之后如果子数组的大小小于某一界限(cutoff)，就停止递归调用，转而对子数组调用插入排序,进而提升算法的整体效率</strong><br />这里提到了<a href="https://stackoverflow.com/questions/70402/why-is-quicksort-better-than-mergesort">快速排序与归并排序的区别</a>，还有的区别点是快速排序不占用额外的内存，快速排序使用的是<a href="https://stackoverflow.com/questions/33923/what-is-tail-recursion">尾递归</a>等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparable <span class="title">Median</span><span class="params">(vector&lt;Comparable&gt; &amp; array,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (array[left] &gt; array[right])</span><br><span class="line"><span class="built_in">swap</span>(array[left], array[right]);</span><br><span class="line"><span class="keyword">if</span> (array[center] &gt; array[right])</span><br><span class="line"><span class="built_in">swap</span>(array[center], array[right]); <span class="comment">// keep left is min among three values</span></span><br><span class="line"><span class="keyword">if</span> (array[left] &gt; array[center])</span><br><span class="line"><span class="built_in">swap</span>(array[left], array[center]); <span class="comment">// keep right is max among three values</span></span><br><span class="line"><span class="built_in">swap</span>(array[center], array[right - <span class="number">1</span>]); <span class="comment">// put pivot into position right-1 </span></span><br><span class="line"><span class="keyword">return</span> array[right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;Comparable&gt;&amp; array, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> range = right - left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (range &gt; <span class="number">10</span>) <span class="comment">// cutoff = 10</span></span><br><span class="line">&#123;</span><br><span class="line">Comparable pivot = <span class="built_in">Median</span>(array, left, right);</span><br><span class="line"><span class="comment">// partition</span></span><br><span class="line"><span class="type">int</span> i = left; <span class="type">int</span> j = right - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (array[++i] &lt; pivot); <span class="comment">// increase before check , details see stackoverflow </span></span><br><span class="line"><span class="keyword">while</span> (array[--j] &gt; pivot);</span><br><span class="line"><span class="built_in">swap</span>(array[i], array[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(array[i], array[right - <span class="number">1</span>]);</span><br><span class="line"><span class="comment">// recursion</span></span><br><span class="line"><span class="built_in">quickSort</span>(array, left, i - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quickSort</span>(array, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">insertionSort</span>(array, left, right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Driver</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Comparable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;Comparable&gt;&amp; array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">quickSort</span>(array, <span class="number">0</span>, array.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="wPOyJ"></a></p><h1 id="chapter-6-disjoint-sets"><a class="markdownIt-Anchor" href="#chapter-6-disjoint-sets"></a> Chapter 6 Disjoint Sets</h1><p><a name="AHMCd"></a></p><h2 id="1-什么是不相交集什么是unionfind操作"><a class="markdownIt-Anchor" href="#1-什么是不相交集什么是unionfind操作"></a> 1. 什么是不相交集？什么是union/find操作？</h2><p>对于一个集合S，由一个关系R可将S划分为多个<a href="https://www.zhihu.com/question/276100093/answer/388155191">等价类</a>(equivalence class)，在一个等价类中的所有元素之间均存在关系R(即任意a，b ∈ S, a~b)。显然的，要判断任意给定的S中的元素a，b是否有关系，只需判断a,b是否属于同一个等价类，这也说明了<strong>等价类概念的提出是为了给出一个快速判断a,b是否存在关系的方法(我的理解)</strong>。显然的，等价类是S的一个子集(set)，一个元素也只属于一个等价类，<strong>不同的等价类们就是本章要讨论的不相交集(disjoint sets）</strong><br />什么是union/find操作？先查找元素a和b所在的等价类(find操作)，然后判断是不是同一个等价类(find(a) == find(b) ？ ),that is，<strong>判断a,b是否有关系。如果没有，就将a,b联系起来，也就是变得有关系</strong>，即将a,b的等价类合并为一个新的等价类(注意关系的传递性(Transitive)，a,b如果有关系，那么两者原来所在集合的所有元素间也存在了关系)，合并的过程就是union操作。如果本身就有关系，就不用操作了。<br /><a name="x95GB"></a></p><h2 id="2-如何表示不相交集"><a class="markdownIt-Anchor" href="#2-如何表示不相交集"></a> 2. 如何表示不相交集？</h2><p>初始状态，对于N个元素的集合S，假设N个元素间均不存在关系，因此有N个不相交集(每个集合仅有一个元素)。因为不存在comparison操作，所以我们并不在意元素的值是多少，因此我们<strong>把N个元素以0~N-1编号</strong>。<br />我们<strong>用树来表示一个集合，并把树的根作为集合的名字</strong>(某个元素编号)。初始状态时，每个集合名统一表示为-1。<br /><strong>树形态的不相交集不具备完全二叉树(堆)那样的规整性，为什么可以用数组来实现？<strong>因为对于每个元素我们只关心它所在的集合是哪个，即它所在的树的根是哪个，因此</strong>对于每个元素，我们仅需知道它所在的树的根值</strong>即可。不仅如此，数组的从0开始下标也与我们的编号符合，因此可以<strong>用大小为N的数组存储0~N-1个元素的父节点（即对第i个数组项，array[i]存储了编号i的父结点），提供了一个由任意结点开始向上遍历即可获取根结点（that is ，任意结点所在集合名）的途径。</strong><br /><a name="XuWqo"></a></p><h2 id="3-unionfind-如何执行"><a class="markdownIt-Anchor" href="#3-unionfind-如何执行"></a> 3. Union/find 如何执行 ？</h2><p>find操作要找到元素A所在树的根，即对A结点沿根节点方向向上遍历，直到数组值为 -1(<code>sets[i] &lt; 0</code>)，说明此数组编号为根节点(<code>return x</code>)。这其实就是一个不断获取父节点的过程，可使用递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sets[x] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(sets[x]); <span class="comment">// recursive</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Union操作<strong>要合并两个集合，只需要将一个集合的根结点，链接到另一个集合的根节点上</strong>，因为在我们的方法中，根节点才是集合的唯一标识。具体来说，假设root1(同样的，是一个编号)是某个集合的根结点(即，集合名)，root2是另一个集合的根节点，执行Union，就是执行array[root1] = root2 (执行前：array[root1] == array[root2] == -1 ; 执行后：array[root1] == root2 , array[root2] == -1)<br />如果实参不是根，而是元素编号，则需额外执行两次find</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unions</span><span class="params">(<span class="type">int</span> root1, <span class="type">int</span> root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sets[root2] = root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然的，因为数组是一个支持随机存取的数据结构，则获取set[x]的值是常数时间(that is O(1) )，find操作真正耗时的是向上探索的过程，也就是说<strong>影响find操作的主要是结点所在的深度</strong>。<br /><a name="xnSpG"></a></p><h2 id="4-如何改进union"><a class="markdownIt-Anchor" href="#4-如何改进union"></a> 4. 如何改进Union</h2><p>上述合并是有问题的，把两颗相同高度的树合并，或通过把一颗高树(larger height)根节点链接到一颗矮树的根节点以实现两颗不同高度树的合并，均<strong>会使新树的高度比原来最大的那颗还要多一，即增加了各结点的深度，这样会极大影响find的效率(根节点最大高度为N-1)</strong>。因此我们需要改进合并的方法。<br />很自然的想法就是<strong>把矮树的根节点链接到高树的根节点</strong>(注意本章所用的树不是二叉树，而是一颗多路树)，这样新树的高度还会保持与原来高树的一致；如果两棵树高度相同，那么谁链接到谁都可以，结果都会使新树高度增1(所以根节点最大高度为log2N)<br />如何确定高树和矮树？显然的，<strong>我们需要跟踪每棵树的高度，可以用现有的数组存储，原先根节点的数组值为-1，现在将其改写为其所代表集合的高度的负数</strong>(为什么是负数？或许是为了方便find函数的判断语句更好编写:<code>if (sets[x] &lt; 0 return x;</code>注意之前提到设置各集合初始值为-1，也与这里符合)<br />也可以根据数的大小(size)决定谁链接到谁，但显然由高度做决定更好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> root1, <span class="type">int</span> root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sets[root2] &lt; sets[root1]) <span class="comment">// set[root] keep track of height(negative)</span></span><br><span class="line">sets[root1] = root2; <span class="comment">// root2 is deeper</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sets[root2] == sets[root1])</span><br><span class="line">--sets[root1];</span><br><span class="line">sets[root2] = root1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="unJoe"></a></p><h2 id="5-如何改进find"><a class="markdownIt-Anchor" href="#5-如何改进find"></a> 5. 如何改进find</h2><p>在寻找编号为x的元素的根的过程中，我们使用<strong>路径压缩(Path Compression)<strong>的方法(自调整)，即</strong>把从x到root之间所有结点的父节点均改为根节点。</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/29536731/1666421236514-c4f89687-71a5-42a4-b5fe-19f8f379487a.png" alt="image.png" /><br />具体做法是<strong>递归的将根节点的编号赋值给路径上的结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sets[x] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> sets[x] = <span class="built_in">find</span>(sets[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fO0SW"></a></p><h1 id="chapter-7-graph-algorithms"><a class="markdownIt-Anchor" href="#chapter-7-graph-algorithms"></a> Chapter 7 Graph Algorithms</h1><p><a name="TOgKc"></a></p><h2 id="graph-implement"><a class="markdownIt-Anchor" href="#graph-implement"></a> <a href="https://stackoverflow.com/questions/5493474/graph-implementation-c">Graph implement</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1666956918039-3ebc54cf-6c4e-4feb-8f90-6473899dc634.jpeg" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vertex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, vertex* &gt; ve;</span><br><span class="line"><span class="type">int</span> name; </span><br><span class="line"><span class="type">int</span> seq;<span class="comment">// serial number</span></span><br><span class="line"><span class="type">int</span> ind; <span class="comment">// indegree</span></span><br><span class="line">    <span class="type">int</span> addition <span class="comment">// additional Message </span></span><br><span class="line">vector&lt;ve&gt; adj; <span class="comment">// adjacent list:cost of edge, destination vertex</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vertex</span>(<span class="type">int</span> n) :<span class="built_in">name</span>(n),<span class="built_in">seq</span>(<span class="number">0</span>),<span class="built_in">ind</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, vertex*&gt; vmap;</span><br><span class="line">vmap graph;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> from, <span class="type">const</span> <span class="type">int</span> to,<span class="type">const</span> <span class="type">int</span> weight)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> newSeq)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::addEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> from, <span class="type">const</span> <span class="type">int</span> to, <span class="type">const</span> <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vertex* f = graph.<span class="built_in">find</span>(from)-&gt;second;</span><br><span class="line">vertex* t = graph.<span class="built_in">find</span>(to)-&gt;second; </span><br><span class="line">pair&lt;<span class="type">int</span>, vertex*&gt; edge = <span class="built_in">make_pair</span>(weight, t);</span><br><span class="line">f-&gt;adj.<span class="built_in">push_back</span>(edge);</span><br><span class="line">    ++(t-&gt;ind);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::addVertex</span><span class="params">(<span class="type">int</span> newSeq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> iter = graph.<span class="built_in">find</span>(newSeq);</span><br><span class="line"><span class="keyword">if</span> (iter != graph.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">vertex * v;</span><br><span class="line">v = <span class="keyword">new</span> <span class="built_in">vertex</span>(newSeq);</span><br><span class="line">graph[newSeq] = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Graph::size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> graph.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitialGraph</span><span class="params">(Graph&amp; myGraph)</span>  <span class="comment">// a instance</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myGraph.<span class="built_in">addVertex</span>(<span class="number">0</span>);</span><br><span class="line">myGraph.<span class="built_in">addVertex</span>(<span class="number">1</span>);</span><br><span class="line">myGraph.<span class="built_in">addVertex</span>(<span class="number">2</span>); </span><br><span class="line">myGraph.<span class="built_in">addVertex</span>(<span class="number">3</span>);</span><br><span class="line">myGraph.<span class="built_in">addVertex</span>(<span class="number">4</span>);</span><br><span class="line">myGraph.<span class="built_in">addVertex</span>(<span class="number">5</span>);</span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">// as unweighted graph , weight = 1</span></span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>); </span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">myGraph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JeoiH"></a></p><h2 id="topological-sort"><a class="markdownIt-Anchor" href="#topological-sort"></a> Topological Sort</h2><p><a name="ueS0P"></a></p><h3 id="1-什么是拓扑排序意义是什么"><a class="markdownIt-Anchor" href="#1-什么是拓扑排序意义是什么"></a> 1. 什么是拓扑排序？意义是什么？</h3><p>首先先理解拓扑的含义：the way the parts of sth are arranged and related. 形象的来说：比如说一个人要自学计算机科学知识(sth)，而该领域知识由很多板块的内容(parts)构成，这些内容又相互关联(在学懂A课程前必须有B课程的基础，related)，那么他就面临一个问题，怎么安排学习顺序(路径，arranged)？一个显然不合理的安排是在学习操作系统先于数据结构与算法，因为数据结构与算法是学习OS的前置课程。<strong>一个不违反前置条件的学习路径就是一个拓扑排序，其意义就是得到一条合理的学习路径。<strong>说的更广泛一点，拓扑排序就是得到一个合理的处理顺序。<br />如果我们把各板块内容之间铺垫关系画成一张图，各板块为顶点，有向边作为关联(如 Vertex数据结构与算法指向Vertex操作系统)，那么</strong>拓扑排序在这个图中体现为一条沿着有向边方向的路径</strong>(即路径中任意一段单位路径u到v,不存在边(v,u))<br />显然，<strong>存在拓扑排序的图一定是有向无环图</strong>( directed acyclic graph，DAG),<a href="https://www.quora.com/Why-must-a-graph-with-a-topological-sort-be-acyclic-and-why-must-an-acyclic-graph-have-a-topological-sort">如果图是有环的，那么就找不到符合要求的路径，因为总会违反前置条件</a><br /><a name="yLpq8"></a></p><h3 id="2-如何实现拓扑排序算法怎样使其更高效"><a class="markdownIt-Anchor" href="#2-如何实现拓扑排序算法怎样使其更高效"></a> 2. 如何实现拓扑排序算法？怎样使其更高效？</h3><p>对于我们要选择的第一个顶点，显然的，它必须没有前置条件，即没有顶点指向它，入度(indegree为0)。我们选择这样一个点，然后<strong>在图中抹去该点和它的边</strong>(显然的，都是由它发出的边，与它相关的顶点入度也随之更新)，在剩下的图中重复这个步骤，直到图为空(如果找不到入度为0的顶点而图不为空，说明图不是DAG，存在环)。顶点被抹去的顺序，就是拓扑排序。<br />如何快速寻找到入度为0的点呢？如果通过遍历顶点集的方式，那么开销是很大的，特别是如果图很稀疏(边很少，sparse)，那么要去除的边也是很少的，因此每一步被影响到入度的顶点的数量也是很少的，即大部分的顶点入度是一直没变的，反复的遍历它们是pointless行为。<br />提升效率方法是<strong>将入度为0的点单独拿出来，我们可以用栈或队列来存储。在每次去掉顶点和边之后，我们将更新后入度变为0的顶点加入到队列中</strong>。显然的，队列的出队顺序就是我们要求的拓扑排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopologicalSort</span><span class="params">(Graph&amp; myGraph)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">queue&lt;vertex*&gt; zero;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> N = myGraph.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter :myGraph.graph) <span class="comment">// initalize vertexSet which indegree is zero</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (iter.second-&gt;ind == <span class="number">0</span>)</span><br><span class="line">zero.<span class="built_in">push</span>(iter.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!zero.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">vertex* v = zero.<span class="built_in">front</span>();</span><br><span class="line">zero.<span class="built_in">pop</span>();</span><br><span class="line">v-&gt;seq = ++counter;</span><br><span class="line">cout &lt;&lt; v-&gt;name &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="type">int</span> adjN = v-&gt;adj.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adjN; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(v-&gt;adj[i].second-&gt;ind) == <span class="number">0</span>)</span><br><span class="line">zero.<span class="built_in">push</span>(v-&gt;adj[i].second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (counter != N<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Ms2lL"></a></p><h2 id="shortest-path-algorithms"><a class="markdownIt-Anchor" href="#shortest-path-algorithms"></a> Shortest-Path Algorithms</h2><p><a name="TdCMl"></a></p><h3 id="1-什么是单源最短路径问题"><a class="markdownIt-Anchor" href="#1-什么是单源最短路径问题"></a> 1. 什么是单源最短路径问题？</h3><p>单源最短路径问题(Single-Source Shortest-Path Problem): <strong>给定一个有权图(weighted graph,可以有环)中的一个点</strong><code>**v**</code><strong>，求出</strong><code>**v**</code><strong>到其它所有顶点的最短路径</strong>，that is ,在答案所呈现的结果图中，<code>v</code>到结果图中任意一个顶点<code>w</code>的路径，其长度是<code>v</code>与<code>w</code>之间存在的所有路径中，长度最短的那条。<br />也可以从另一个角度理解这个问题，即如果把边长视为开销，那么<strong>该问题就是要以最小的开销，从源顶点开始，覆盖整张图的顶点</strong><br /><a name="q5MIP"></a></p><h3 id="2为什么breadth-first-search可以解决unweighted-shortest-paths"><a class="markdownIt-Anchor" href="#2为什么breadth-first-search可以解决unweighted-shortest-paths"></a> 2.为什么Breadth-First Search可以解决Unweighted Shortest-Paths?</h3><p>为了理解SSSP问题，我们先考虑无权图，无权图可视为权重为1的有权图<br />我们先设置问题的初始状态：<code>v</code>到任意<code>w</code>的距离都是无穷大，任意<code>w</code>的状态都是unknown(<code>v</code>到该<code>w</code>的最短路径还未确定)。<br />我们首先能确定的是<code>v</code>能直接到达的点(<code>v</code>的邻接点)，因为v只有唯一途径能到达这些点，所以这个唯一途径就是最短路径。我们把这些点称为第一层，其最短路径均为1。接着，我们能确定的点显然是第一层的邻接点，<strong>因为</strong><code>**v**</code><strong>能通过第一层的点去访问只有这些点</strong>，我们把这些点称为第二层，其最短路径自然为2。按照这样的一个广度优先搜索的逻辑，我们便能确定所有点的最短路径。<br />因为是无权图，所以不存在对路径长度的多次更新（关于该点可见后续讨论中的例子：不存在将s-&gt;w1-&gt;w3更改为s-&gt;w2-&gt;w3的可能），对每个顶点的处理，只需简单的将其distance信息设置为前一个顶点的distance+1即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::unweighted_Shortest_Path_with_queue</span><span class="params">(vertex&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;vertex*&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : graph)</span><br><span class="line">iter.second-&gt;dist = INFINITY;</span><br><span class="line">s.dist = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&amp;s);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">vertex v = *q.<span class="built_in">front</span>(); <span class="comment">// priority &#x27;.&#x27; &gt; &#x27;*&#x27;</span></span><br><span class="line">q.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; adjac : v.adj)</span><br><span class="line">&#123;</span><br><span class="line">adjac.second-&gt;dist = v.dist + <span class="number">1</span>; </span><br><span class="line">adjac.second-&gt;path = v.name;</span><br><span class="line">q.<span class="built_in">push</span>(adjac.second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::unweighted_Shortest_Path</span><span class="params">(vertex&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> NUM_VERTICES = <span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : graph) </span><br><span class="line">&#123;</span><br><span class="line">iter.second-&gt;dist = INFINITY;</span><br><span class="line">iter.second-&gt;known = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">s.dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> currDist = <span class="number">0</span>; currDist &lt; NUM_VERTICES; ++currDist) <span class="comment">// double for loops:inefficiency</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : graph) </span><br><span class="line"><span class="keyword">if</span> (!iter.second-&gt;known &amp;&amp; iter.second-&gt;dist == currDist)</span><br><span class="line">&#123;</span><br><span class="line">iter.second-&gt;known = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; adjac : (iter.second-&gt;adj))</span><br><span class="line">&#123;</span><br><span class="line">adjac.second-&gt;dist = currDist + <span class="number">1</span>; <span class="comment">// update distance</span></span><br><span class="line">adjac.second-&gt;path = iter.second-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YjF5L"></a></p><h3 id="3为什么dijkstra-algorithm每一步要选择最近的结点为什么该算法可以解决single-source-weighted"><a class="markdownIt-Anchor" href="#3为什么dijkstra-algorithm每一步要选择最近的结点为什么该算法可以解决single-source-weighted"></a> 3.为什么Dijkstra Algorithm每一步要选择最近的结点，为什么该算法可以解决Single-Source Weighted？</h3><p>与上一问一样，要找到<code>v</code>到所有顶点的最短路径，我们总得先知道<code>v</code>能到达哪些点。所以我们在用Dijkstra解决SSSP的时候，我们似乎也应该按照这样的结点选择顺序：首先找的是<code>v</code>的邻接点，然后再邻接点… 。但是我们需要注意，<strong>我们实际选择结点的顺序(选择结点即把结点变为known，说明找到了到它的最短路径)，是不断的选取未确定结点中离</strong><code>**v**</code><strong>距离最近的那一个，而不是像无权图中那样邻接点接着邻接点的广度搜索。</strong><br /><strong>为什么要选择最近的那一个？</strong><br />举个最简单的例子：在这个图中，我们首先探索了源顶点的邻接点w1,w2，更新其dist为ds+dcost，那么w1.dist=1，w2.dist =3。那么下一轮我们选择那个顶点进行探索(其邻接点)呢？显然是w1，因为在当前条件下，我们只知道源顶点离w1更近一些，那么到w3(后续未知结点)的最短路径自然更可能的在w1这边(我们还不知道后续顶点的dist信息)。<strong>因此我们在每次选择一个顶点以探索他的邻接点(更新dist信息)，都要选择当前距离v最近的那个，因为经过这样一个点的路径才最有可能是(到后续顶点)最短路径/开销可能最少。</strong><br />为什么在无权图中不用这样做？<br />无权图的边长权重都为1，开销的是一样的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29536731/1667390674960-21e67dd1-f11c-4336-a168-c237056626fe.jpeg" alt="" /><br />我们要有一个认知：<strong>源顶点</strong><code>**v**</code><strong>到某一目标顶点</strong><code>**w****t**</code><strong>之间的最短路径①上存在着几个中间顶点，那么v到任意一个中间结点</strong><code>**w****i**</code>**的最短路径②一定与①重合。**或者说v到目标顶点的最短路径，是目标顶点在该路径的上一个顶点的最短路径延长了一个边长所得到的。<br /><strong>因此我们逐步找到各顶点的最短路径，并从之前找到的最短路径(以开销最少的方式)延展到其它顶点上，便可以找到到所有顶点的最短路径。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::Dijkstra_Algorithm</span><span class="params">(vertex&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : graph)</span><br><span class="line">&#123;</span><br><span class="line">iter.second-&gt;dist = INFINITY;</span><br><span class="line">iter.second-&gt;known = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">s.dist = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">existUnknown</span>()) <span class="comment">//there is an unknown vertex</span></span><br><span class="line">&#123;</span><br><span class="line"> vertex* v = <span class="built_in">smallestUnknown</span>();   <span class="comment">// smallest unknown distance vertex</span></span><br><span class="line">v-&gt;known = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : v-&gt;adj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v-&gt;dist + iter.first &lt; iter.second-&gt;dist) </span><br><span class="line">&#123;</span><br><span class="line">iter.second-&gt;dist = v-&gt;dist + iter.first; <span class="comment">// update</span></span><br><span class="line">iter.second-&gt;path = v-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Graph:: <span class="built_in">existUnknown</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : graph)  <span class="comment">// iteration </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!iter.second-&gt;known)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vertex* <span class="title">Graph::smallestUnknown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vertex* min = graph.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : graph)  <span class="comment">// iteration </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!iter.second-&gt;known &amp;&amp; iter.second-&gt;dist &lt; min-&gt;dist)</span><br><span class="line">min = iter.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="b4gnk"></a></p><h3 id="4为什么dijkstra-algorithm不适用于有负权值边的图"><a class="markdownIt-Anchor" href="#4为什么dijkstra-algorithm不适用于有负权值边的图"></a> 4.为什么Dijkstra Algorithm不适用于有负权值边的图</h3><p>在Dijkstra算法中，我们<strong>一旦将一个顶点</strong><code>**v**</code><strong>由unknown标记为known，就说明由</strong><code>**s**</code><strong>到</strong><code>**v**</code><strong>的最短路径已经找到，且不会再改变，即算法不会在后续过程中回头(look back)修改到</strong><code>**v**</code><strong>的最短路程这一信息</strong>。如果我们用Dijkstra算法在图中确定了<code>v</code>的最短路径，然后发现<code>v</code>到某个邻接点<code>u</code>(状态为unknown)的边权值为负，那么此时<code>s</code>到<code>v</code>的实际最短路径就发生了变化：s-&gt;v-&gt;w-&gt;v，然而因为Dijkstra算法不会look back，所以算法继续保持之前的最短路径，因此会产生与事实不符的结果。<br /><a name="wzqMO"></a></p><h2 id="critical-path-problems"><a class="markdownIt-Anchor" href="#critical-path-problems"></a> Critical Path Problems</h2><p><a name="MCV9V"></a></p><h3 id="1-如何理解关键路径关键路径是什么"><a class="markdownIt-Anchor" href="#1-如何理解关键路径关键路径是什么"></a> 1. 如何理解关键路径？关键路径是什么？</h3><p>一个项目由多个可独立完成工作(jobs)组成，各工作之间存在优先级限制关系(precedence constraint)，即某一项工作必须在完成另一项(或多项)工作后才能启动。①如何确定项目的最快(早)完成时间？②如何确定某些工作的可延迟时间 (that is,slack time 松弛时间) 以不至于增加整个项目的完成时间？<br /><strong>关键路径这样一组工作序列：该工作序列可以用来确定项目的最快完成时间。对第二点，关键路径上的所有工作的可延迟时间均为0，关键路径上的任何一个工作被延迟，都会增加整个项目的完成时间，这也是为什么称之为&quot;关键&quot;。</strong><br />这样的项目可以体现在有向无环图中。为什么一定是无环？与拓扑排序一样的道理，如果有几个工作成环状相互制约，那就无法开启任何一项工作，因为总是违反其优先级限制关系。<strong>关键路径在这样的图中体现为从开始到结束的最长路径(longest path)</strong><br />注意路径的长度由边的权值(工作完成所需时间)决定而不是边的数量<br /><a name="oj5FV"></a></p><h3 id="2-为什么图的最长路径就是关键路径"><a class="markdownIt-Anchor" href="#2-为什么图的最长路径就是关键路径"></a> 2. 为什么图的最长路径就是关键路径？</h3><blockquote><p>关键路径是通过识别最长的相关活动并测量从开始到结束完成它们所需的时间来确定的 -wikipedia</p></blockquote><p>我们首先要理解一条路径上的各个工作节点之间存在着严格的先后关系，即优先级限制关系。这就说明<strong>各工作只能串行的执行</strong>，哪怕你有很多处理器(processors)也必须等待高优先级的工作执行完毕后再开启新的工作。互不关联(不在同一路径)的工作可以并行的执行，所以<strong>在最长路径上的最后一个工作执行完毕时，其它路径也一定执行完毕，即整个项目执行完毕。因此最长路径决定了项目的完成时间，不延迟的执行最长路径(上的工作)所花的时间，就是项目的最快完成时间。</strong><br /><a name="Aa03a"></a></p><h2 id="network-flow-problems"><a class="markdownIt-Anchor" href="#network-flow-problems"></a> Network Flow Problems</h2><p><a name="RBuq3"></a></p><h3 id="1-如何理解网络流问题"><a class="markdownIt-Anchor" href="#1-如何理解网络流问题"></a> 1. 如何理解网络流问题？</h3><p>网络流问题就是从一个端<code>s</code>往另一个端<code>t</code>发送流(Flow,如通水，运货，发送数据包等)，要经过数个中间节点，各节点间的边的传输容量是有限的(如水管的阈值，超过了这个值水管会破裂)，问从s发送到t的最大流(the maximum amount of ﬂow)是多少。显然的要找出这个最大流，<strong>我们要解决的根本问题是如何正确安排运输方案(即路径选择)以最大化流</strong>。<br /><strong>如何计算图中流的数量(the amount of ﬂow)？</strong> <strong>只需看从端</strong><code>**s**</code><strong>发出了多少流即可</strong>(端<code>t</code>肯定接受同样数量的流，除非“漏水”了)<br />**怎么验证我们得到的流的数量是最大的？**把图分割(cut)为两个部分，一部分包含s，另一部分包含t(其余结点随意，因此存在多种切割方式)，<strong>经过切割线上的边的容量总和决定了最大流的界限，容量总和的最小值即为图所能承受的最大流的值(the minimum cut capacity is exactly equal to the maximum ﬂow)</strong><br />由此我们可以看出，<strong>解决最大流问题的目的不是为了得到最大流的值，而是知道能达到最大流的运输方案</strong><br /><a href="https://www.youtube.com/watch?v=6DFWUgV5Osc&amp;list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&amp;index=8"><strong>网络流问题基础 Network Flow Problems</strong></a><br /><a name="LytbY"></a></p><h3 id="2-如何得到最大流"><a class="markdownIt-Anchor" href="#2-如何得到最大流"></a> 2. 如何得到最大流？</h3><p>首先考虑简单的算法(naive algorithm )，我们随机的选择路径( free to choose any path from s to t)，直到Gr中不存在s到t的路径，看能否得到最大流，事实证明，这样是不可靠的，得到的方案可能会使我们会得到一个小于最大流的值。<strong>该方法存在的缺陷是，一旦在某一步选中了错误的路径(不属于最大流方案的路径)，算法无法纠正错误，因此找不到最大流。</strong><br />我们改进一下这个算法，<strong>在每次进行一次路径选择(即在G<strong><strong>r</strong></strong>图中相应边执行了减法)之后，接着在相应边上加上一条方向相反的边，其权值就等于刚刚该边减去的值。称为Ford–Fulkerson algorithm</strong><br /><strong>这样做的目的，是让算法有了撤销(undo)的能力，可以把不好的路径撤销掉，因此该算法总能找到正确的路径，进而找到最大流。</strong><br /><a href="https://www.youtube.com/watch?v=8sLON0DqLZo&amp;list=PLvOO0btloRnsbnIIbX6ywvD8OZUTT0_ID&amp;index=9">**Ford-Fulkerson Algorithm 寻找网络最大流  -Dr Wang **</a></p>]]></content>
      
      
      <categories>
          
          <category> Data structure and Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Foundation </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
