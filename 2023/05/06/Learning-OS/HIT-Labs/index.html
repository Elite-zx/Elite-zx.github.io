<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>[HIT-OS]哈工大操作系统实验lab1~8 | ELITE-X</title><meta name="author" content="Elite-X"><meta name="copyright" content="Elite-X"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="# 前言 _Learning operating system by coding it！_  # 实验0 实验环境搭建  reference1reference2遇到的问题：在编译linux0.11时，出现fatal error：asm&#x2F;ioctl.h: No such file or directory，loctl.h这个文件是在库linux-lib-dev中的，而且我已经安装了这个库，但">
<meta property="og:type" content="article">
<meta property="og:title" content="[HIT-OS]哈工大操作系统实验lab1~8">
<meta property="og:url" content="http://example.com/2023/05/06/Learning-OS/HIT-Labs/index.html">
<meta property="og:site_name" content="ELITE-X">
<meta property="og:description" content="# 前言 _Learning operating system by coding it！_  # 实验0 实验环境搭建  reference1reference2遇到的问题：在编译linux0.11时，出现fatal error：asm&#x2F;ioctl.h: No such file or directory，loctl.h这个文件是在库linux-lib-dev中的，而且我已经安装了这个库，但">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2023-05-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-07T08:12:43.955Z">
<meta property="article:author" content="Elite-X">
<meta property="article:tag" content="Foundation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2023/05/06/Learning-OS/HIT-Labs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '[HIT-OS]哈工大操作系统实验lab1~8',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-07 16:12:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,200;1,300&display=swap"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: #453C67"><nav id="nav"><span id="blog-info"><a href="/" title="ELITE-X"><span class="site-name">ELITE-X</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">[HIT-OS]哈工大操作系统实验lab1~8</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-05T16:00:00.000Z" title="Created 2023-05-06 00:00:00">2023-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-07T08:12:43.955Z" title="Updated 2023-05-07 16:12:43">2023-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/HIT/">HIT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="[HIT-OS]哈工大操作系统实验lab1~8"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>
<a name="Sy3c5"></a>
# 前言
_Learning operating system by coding it！_
<a name="LIwaN"></a>
# 实验0 实验环境搭建
<hr />
<p><a target="_blank" rel="noopener" href="https://hoverwinter.gitbooks.io/hit-oslab-manual/content/environment.html">reference1</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/zy010101/article/details/108085192">reference2</a><br />遇到的问题：在编译linux0.11时，出现<code>fatal error：asm/ioctl.h: No such file or directory</code>，<code>loctl.h</code>这个文件是在库<code>linux-lib-dev</code>中的，而且我已经安装了这个库，但还是有这个错误<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679055607952-a7d970dc-d0af-4bf9-8a10-389fbf39cd71.png#averageHue=%23323130&amp;clientId=u3a7860c6-b5b9-4&amp;from=paste&amp;height=253&amp;id=ua58a300b&amp;originHeight=380&amp;originWidth=1554&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=169952&amp;status=done&amp;style=none&amp;taskId=u654359bb-fcf7-4d06-85f5-9faa172d7aa&amp;title=&amp;width=1036" alt="image.png" /><br /> 解决方法：使用i386版本的linux-libc-dev</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-libc-dev:i386</span><br></pre></td></tr></table></figure>
<p><a name="CgYpM"></a></p>
<h1 id="实验1-操作系统的引导"><a class="markdownIt-Anchor" href="#实验1-操作系统的引导"></a> 实验1 操作系统的引导</h1>
<hr />
<p><a name="rsI0N"></a></p>
<h2 id="1-改写bootsects"><a class="markdownIt-Anchor" href="#1-改写bootsects"></a> 1. 改写bootsect.s</h2>
<ol>
<li>我们只需要<code>bootsect.s</code>源码中打印字符串的部分，因为不涉及迁移<code>bootsect</code>从<code>0x07c00</code>到<code>0x90000</code>的操作，所以<code>bootsect.s</code>读入内存后还是在<code>0x07c00</code>的位置，因此要添加<code>mov es, #07c0</code>才能使<code>es:bp</code>指向正确的字符串起始位置。此外，<code>cx</code>参数的大小为字符串大小+6，这里的6是3个CR/LF (carriage return/line feed: 13 10)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679306853262-7e6f4ca7-68d6-4641-83f8-e0edbf6e9a65.png#averageHue=%23f0f0f0&amp;clientId=ub2e2e66c-6eae-4&amp;from=paste&amp;height=293&amp;id=u332a1dd5&amp;originHeight=293&amp;originWidth=1264&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104104&amp;status=done&amp;style=none&amp;taskId=u27f27fa8-2816-477c-8a4b-416f08ee4ee&amp;title=&amp;width=1264" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679120889905-e4fdb498-a155-4fbc-9485-851c42da41cc.png#averageHue=%23292928&amp;clientId=u2a122f00-1508-4&amp;from=paste&amp;height=164&amp;id=hO11h&amp;originHeight=246&amp;originWidth=994&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=69573&amp;status=done&amp;style=none&amp;taskId=u0269a0c9-fa2b-422e-b66d-5402077e146&amp;title=&amp;width=662.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679121050256-f419626e-7a21-4ac1-83f9-1b95d1360eb3.png#averageHue=%23292929&amp;clientId=u2a122f00-1508-4&amp;from=paste&amp;height=163&amp;id=TTKfL&amp;originHeight=245&amp;originWidth=1350&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=104566&amp;status=done&amp;style=none&amp;taskId=u6208cb08-47ef-43f9-90cb-c0dd2f14ca8&amp;title=&amp;width=900" alt="image.png" /></p>
<ol start="2">
<li>改写<code>bootsect.s</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">	mov	ah,#0x03		! read cursor pos</span><br><span class="line">	xor	bh,bh</span><br><span class="line">	int	0x10</span><br><span class="line">	</span><br><span class="line">	mov	cx,#34</span><br><span class="line">	mov	bx,#0x0007		! page 0, attribute 7 (normal)</span><br><span class="line">	mov	bp,#msg1</span><br><span class="line">	mov	ax,#0x07c0</span><br><span class="line">	mov	es,ax         ! set correct segment address</span><br><span class="line">	mov	ax,#0x1301		! write string, move cursor</span><br><span class="line">	int	0x10</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">        jmp inf_loop     ! keep not exit</span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">	.byte 13,10</span><br><span class="line">	.ascii &quot;EliteX system is Loading ...&quot;</span><br><span class="line">	.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510   ! jump over root_dev</span><br><span class="line">boot_flag:</span><br><span class="line">	.word 0xAA55         ! effective sign</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>要仅汇编<code>bootsect.s</code>得到<code>Image</code>，运行以下命令（在实模式下，as86工具用于汇编产生目标代码，ld86工具用于连接产生可执行文件）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as86 -0 -a -o bootsect.o bootsect.s</span><br><span class="line">ld86 -0 -s -o bootsect bootsect.o</span><br><span class="line"><span class="built_in">dd</span> bs=1 <span class="keyword">if</span>=bootsect of=Image skip=32</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679291194417-3bded04a-f0fa-42d5-881a-969e7b59420d.png#averageHue=%23171716&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=411&amp;id=u13c84d5d&amp;originHeight=552&amp;originWidth=946&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=45537&amp;status=done&amp;style=none&amp;taskId=uaf3fd5c0-d375-488d-a6e2-9636e569b0e&amp;title=&amp;width=704.65625" alt="image.png" /><br />
<a name="VRykQ"></a></p>
<h2 id="2-改写setups"><a class="markdownIt-Anchor" href="#2-改写setups"></a> 2. 改写setup.s</h2>
<p><a name="JS2dj"></a></p>
<h3 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> task1</h3>
<ol>
<li>在<code>setup.s</code>中写入<code>bootsect.s</code>的内容，对字符串信息作修改，修改<code>es</code>为<code>0x07e0</code>，因为<code>setup</code>在内存紧跟<code>bootsect</code>(0x07c00 + 0x200)之后 (这里将<code>cs</code>的值通过<code>ax</code>赋给<code>es</code>，因为此时<code>cs</code>的值就是<code>0x07e0</code>）)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">mov	ah,#0x03		! read cursor pos</span><br><span class="line">xor	bh,bh</span><br><span class="line">int	0x10</span><br><span class="line"></span><br><span class="line">mov	cx,#25</span><br><span class="line">mov	bx,#0x0007		! page 0, attribute 7 (normal)</span><br><span class="line">mov	bp,#msg1</span><br><span class="line">mov	ax,cs</span><br><span class="line">mov	es,ax</span><br><span class="line">mov	ax,#0x1301		! write string, move cursor</span><br><span class="line">int	0x10</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">jmp inf_loop </span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">.byte 13,10</span><br><span class="line">.ascii &quot;Now we are in SETUP&quot;</span><br><span class="line">.byte 13,10,13,10</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679295121521-d9f5ba9a-a2f3-406c-95b2-c032f4093a17.png#averageHue=%23f8f6f3&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=156&amp;id=u53cd6060&amp;originHeight=234&amp;originWidth=1106&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=true&amp;size=121487&amp;status=done&amp;style=none&amp;taskId=ueb27f2e8-c7ae-4f15-9709-13b57b4a98b&amp;title=int%200x13&amp;width=737.3333333333334" alt="int 0x13" title="int 0x13" /></p>
<ol start="2">
<li>在<code>**bootsect.s**</code>中添加源码中载入<code>setup</code>的部分，并修改<code>SETUPSEG</code>为<code>0x07e0</code>，原因还是在于我们没有移动<code>**bootsect**</code>**，**去掉循环并修改<code>SETUPLEN</code>为<code>2</code>，因为对我们的改写后的<code>setup</code>，仅需读入两个扇区就够了（其实一个扇区的大小也够了）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN = 1</span><br><span class="line">SETUPSEG = 0x07e0</span><br><span class="line"></span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">	mov	ah,#0x03		! read cursor pos</span><br><span class="line">	xor	bh,bh</span><br><span class="line">	int	0x10</span><br><span class="line">	</span><br><span class="line">	mov	cx,#34</span><br><span class="line">	mov	bx,#0x0007		! page 0, attribute 7 (normal)</span><br><span class="line">	mov	bp,#msg1</span><br><span class="line">	mov	ax,#0x07c0</span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	ax,#0x1301		! write string, move cursor</span><br><span class="line">	int	0x10</span><br><span class="line"></span><br><span class="line">load_setup:</span><br><span class="line">	mov	dx,#0x0000		! drive 0, head 0</span><br><span class="line">	mov	cx,#0x0002		! sector 2, track 0</span><br><span class="line">	mov	bx,#0x0200		! address = 512, in INITSEG</span><br><span class="line">	mov	ax,#0x0200+SETUPLEN	! service 2, nr of sectors</span><br><span class="line">	int	0x13			! read it</span><br><span class="line">	jnc	ok_load_setup		! ok - continue</span><br><span class="line">	mov	dx,#0x0000</span><br><span class="line">	mov	ax,#0x0000		! reset the diskette</span><br><span class="line">	int	0x13</span><br><span class="line">	j	load_setup</span><br><span class="line">	</span><br><span class="line">ok_load_setup:</span><br><span class="line">	jmpi	0,SETUPSEG </span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">	.byte 13,10</span><br><span class="line">	.ascii &quot;EliteX system is Loading ...&quot;</span><br><span class="line">	.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.org 510   ! jump over root_dev</span><br><span class="line">boot_flag:</span><br><span class="line">	.word 0xAA55         ! effective sign</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>linux-0.11/tool/build.c</code>注释掉最后部分，以便我们借助MakeFile编译<code>bootsect.s</code>与<code>setup.s</code>，而不用两个分别手动编译</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679294169436-70675d89-6d65-4daf-8497-da686fe3a38b.png#averageHue=%230b0b0b&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=339&amp;id=u8afde1bf&amp;originHeight=564&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=160589&amp;status=done&amp;style=none&amp;taskId=u11ec5c70-12de-4770-8679-70f759df314&amp;title=&amp;width=619" alt="image.png" /></p>
<ol start="4">
<li>结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679294501705-49ff1622-5adc-437a-8cff-1be4d2841e43.png#averageHue=%23191919&amp;clientId=ua87acfff-24aa-4&amp;from=paste&amp;height=490&amp;id=ub64002a5&amp;originHeight=536&amp;originWidth=826&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38308&amp;status=done&amp;style=none&amp;taskId=ue6cf2b2d-8218-4f57-977c-2368cbcf023&amp;title=&amp;width=754.65625" alt="image.png" /><br />
<a name="pW014"></a></p>
<h3 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> task2</h3>
<ol>
<li>我们需要<code>setup.s</code>源码中获取硬件信息的部分，需要解决的问题是将这些数据打印在屏幕上，利用了功能号为<code>0x0E</code>的<code>0x10</code>号中断，指导书写了一个<code>print_nl</code>来打印回车换行符，而我直接在打印的字符串中加入<code>13 10</code>实现回车换行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">INITSEG  = 0x9000</span><br><span class="line"></span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">    mov ah,#0x03     ; read cursor pos</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#25       ; Print &quot;NOW we are in SETUP&quot;</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg2 </span><br><span class="line">    mov ax,cs        ; cs: 0x07e0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">; Get Cursor Pos</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [0],dx  	; store in 9000:0</span><br><span class="line"></span><br><span class="line">; Get Memory Size</span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax      ; store in 9000:2</span><br><span class="line"></span><br><span class="line">; Get hd0 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax       ; modify ds</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax       </span><br><span class="line">    mov di,#0x0004  ; store in 9000:4</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line"></span><br><span class="line">! Be Ready to Print</span><br><span class="line">    mov ax,cs       ; 0x07e0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#INITSEG ; 9000</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">; print Cursor Position</span><br><span class="line">    mov cx,#18</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cursor</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov dx,[0]  ; pass hex number through register dx to function print_hex</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print Memory Size</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#14</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_memory</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov dx,[2]  </span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print KB</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#2</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_kb</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">; print Cyles</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#7</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cyles</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[4]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print Heads</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#8</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_heads</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[6]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">; print Secotrs</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#10</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_sectors</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[12]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line"></span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4   ; rotate left</span><br><span class="line">    mov    ax,#0xe0f </span><br><span class="line">    and    al,dl   ; fetch low 4 bits</span><br><span class="line">    add    al,#0x30    ; 0~9</span><br><span class="line">    cmp    al,#0x3a    </span><br><span class="line">    jl     outp</span><br><span class="line">    add    al,#0x07    ; a~f , add more 0x07</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop   print_digit</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;NOW we are in SETUP&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line">msg_cursor:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cursor position:&quot;</span><br><span class="line">msg_memory:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Memory Size:&quot;</span><br><span class="line">msg_cyles:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line">msg_heads:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line">msg_sectors:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line">msg_kb:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>结果</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679390498885-fa17ae6d-b23d-42a3-b330-8ebfc78ec9e1.png#averageHue=%231d1d1c&amp;clientId=u65b4c6eb-4a7f-4&amp;from=paste&amp;height=453&amp;id=uded74e2b&amp;originHeight=559&amp;originWidth=896&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=43381&amp;status=done&amp;style=none&amp;taskId=uf6a85f2d-73a3-4faa-9cc6-46206197425&amp;title=&amp;width=725.328125" alt="image.png" /><br />
<a name="zTa0D"></a></p>
<h1 id="实验2-系统调用"><a class="markdownIt-Anchor" href="#实验2-系统调用"></a> 实验2 系统调用</h1>
<hr />
<p><a name="JOp3O"></a></p>
<h2 id="1-编写接口函数iam-whoami"><a class="markdownIt-Anchor" href="#1-编写接口函数iam-whoami"></a> 1. 编写接口函数iam, whoami</h2>
<p>跟<code>write</code>一样，在接口函数文件内调用宏函数<code>_syscall1</code>或<code>_syscall2</code>（依参数个数而定），程序内包括后续用于测试系统调用的<code>main</code>函数。<br />iam.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__   <span class="comment">// 定义了这个宏，unistd.h中的一个条件编译块才会编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">_syscall1(<span class="type">int</span>, iam, <span class="type">const</span> <span class="type">char</span>*, name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">iam</span>(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>whoami.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">int</span>, whoami, <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">char</span> username[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">whoami</span>(username, <span class="number">23</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;username: %s\n&quot;</span>, username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="W3D3k"></a></p>
<h2 id="2-修改unistdh"><a class="markdownIt-Anchor" href="#2-修改unistdh"></a> 2. 修改unistd.h</h2>
<p>可以跳过这步，因为之后的编译过程所用到的<code>unistd.h</code>头文件并不在这个源码树下，而是在标准头文件<code>/usr/include</code>下。<br />在<code>linux-0.11/include/unistd.h</code>添加宏<code>_NR_whoami</code>、<code>_NR_iam</code>以在<code>_syscall*</code>函数中传递正确的参数给<code>0x80</code>号中断处理程序<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679572755150-a56cb4f4-d15c-4ae1-9805-281eeb789ef7.png#averageHue=%23292929&amp;clientId=uf07d0e56-512f-4&amp;from=paste&amp;height=413&amp;id=ufd549e7e&amp;originHeight=558&amp;originWidth=1370&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=241240&amp;status=done&amp;style=none&amp;taskId=u866e49d8-c96e-4501-a177-307f9157abc&amp;title=&amp;width=1014.814886503918" alt="image.png" /><br />
<a name="u7wVb"></a></p>
<h2 id="3-修改_sys_call_table函数表"><a class="markdownIt-Anchor" href="#3-修改_sys_call_table函数表"></a> 3. 修改_sys_call_table函数表</h2>
<p>在<code>linux-0.11/include/linux/sys.h</code>添加函数指针<code>sys_whoami</code>、<code>sys_iam</code>，函数在<code>sys_call_table</code>数组中的位置必须和在<code>&lt;unistd.h&gt;</code>文件中的<code>__NR_xxxxxx</code>的值对应上。在文件开头加上<code>extern</code>是让编译器在其它文件寻找这两个函数<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679573228960-b5285a35-85b6-4209-8ae9-b138c0d50cb6.png#averageHue=%232a2a2a&amp;clientId=u33e52eb9-8f95-4&amp;from=paste&amp;height=514&amp;id=ud13dda37&amp;originHeight=694&amp;originWidth=1410&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=416921&amp;status=done&amp;style=none&amp;taskId=u00862be4-becc-4d75-a056-a82d7ed996f&amp;title=&amp;width=1044.4445182266602" alt="image.png" /><br />
<a name="dhvNt"></a></p>
<h2 id="4-实现函数sys_whoami-sys_iam"><a class="markdownIt-Anchor" href="#4-实现函数sys_whoami-sys_iam"></a> 4. 实现函数sys_whoami, sys_iam</h2>
<p>在<code>linux-0.11/kernel/iamwho.c</code>中编写最终的执行函数，执行这两个函数是系统调用的最后一步<br />在 Linux-0.11 内核中，<code>get_fs_byte</code> 和 <code>put_fs_byte</code> 函数用于在用户空间和内核空间之间传输数据。<br /><code>get_fs_byte</code> 函数从用户空间读取一个字节到内核空间。它接受一个指向用户空间内存地址的指针，并返回从该地址读取的字节。<br /><code>put_fs_byte</code> 函数则将一个字节从内核空间写入用户空间。它接受一个字节值和一个指向用户空间内存地址的指针。它将字节值写入指定的用户空间地址。<br />这两个函数在数据传输过程中起到了关键作用，使得内核可以与用户空间的应用程序进行安全地数据交换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/segment.h&gt;</span>  <span class="comment">// get_fs_byte, put_fs_byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str_pos[<span class="number">24</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_iam</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = get_fs_byte(name+i)) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_pos[i] = c;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">23</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;elitezx lab2 string:  %s\n&quot;</span>,str_pos );	</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_whoami</span><span class="params">(<span class="type">char</span>* name, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;<span class="built_in">strlen</span>(str_pos))</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = str_pos[ans] )!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        put_fs_byte(c,name++);</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="aSQwE"></a></p>
<h2 id="5-执行"><a class="markdownIt-Anchor" href="#5-执行"></a> 5. 执行</h2>
<p>关于这部分，指导书说的比较详细了，我这里再补充一些：挂载hdc目录到虚拟机操作系统上，实现hdc目录在linux-0.11与ubuntu22.04之间的文件共享，我们把用于系统调用的测试程序<code>iam.c</code>，<code>whoami.c</code>复制到hdc目录就可以在Bochs模拟器下的linux-0.11环境中编译执行这两个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ./mount-hdc </span><br><span class="line"><span class="built_in">cp</span> iam.c whoami.c hdc/usr/root</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679722650168-38ca1876-eae9-4f73-bcd7-9049e23c5f19.png#averageHue=%231d1d1d&amp;clientId=uece2d1bc-2718-4&amp;from=paste&amp;height=376&amp;id=u8f16972f&amp;originHeight=507&amp;originWidth=777&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=32649&amp;status=done&amp;style=none&amp;taskId=u93898fba-d497-4c31-b847-ed2fc5b1fcd&amp;title=&amp;width=575.555596214266" alt="image.png" /><br />注意在<code>iam.c</code>,<code>whoami.c</code>程序内的头文件<code>&lt;unistd.h&gt;</code>是标准头文件，是由GCC编译器一同安装的，它们通常随着GCC一起打包并分发，通常位于<code>/usr/include</code>目录下，而不是在之前修过的源码树下的<code>include/unistd.h</code>, 因此我们要转入<code>hdc/usr/include</code>下修改<code>&lt;unistd.h&gt;</code>，加入两个宏<code>__NR_iam</code>,<code>__NR_whoami</code><br />编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o iam iam.c</span><br><span class="line">gcc -o <span class="built_in">whoami</span> whoami.c</span><br></pre></td></tr></table></figure>
<p><a name="GQLfS"></a></p>
<h2 id="6-验证结果"><a class="markdownIt-Anchor" href="#6-验证结果"></a> 6. 验证结果</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1679724796210-81f3aae1-2a44-4b80-aae6-3028a859b73f.png#averageHue=%23ab9f84&amp;clientId=uece2d1bc-2718-4&amp;from=paste&amp;height=430&amp;id=u8fb9b579&amp;originHeight=580&amp;originWidth=983&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=66303&amp;status=done&amp;style=none&amp;taskId=u266c3a1b-1d68-4099-b48b-b886c550c27&amp;title=&amp;width=728.1481995863879" alt="image.png" /><br />
<a name="ALw3l"></a></p>
<h1 id="实验3-进程运行轨迹的跟踪与统计"><a class="markdownIt-Anchor" href="#实验3-进程运行轨迹的跟踪与统计"></a> 实验3 进程运行轨迹的跟踪与统计</h1>
<hr />
<p><a name="Vy8dW"></a></p>
<h2 id="1-前提"><a class="markdownIt-Anchor" href="#1-前提"></a> 1. 前提</h2>
<p><a name="zXQo0"></a></p>
<h3 id="11-系统调用times"><a class="markdownIt-Anchor" href="#11-系统调用times"></a> 1.1. 系统调用times</h3>
<p><code>times</code>系统调用接受一个<code>struct tms*</code>类型的参数，该结构体用于保存进程和其子进程的 CPU 时间信息，同时 times 系统调用会返回一个滴答数，即时钟周期数，该滴答数表示自OS启动以来经过的时钟周期数。<br /><code>struct tms</code>类型在<code>include/sys/times.h</code>中定义如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680080228119-8e4f099c-80bb-400b-a9c4-1707bb900cb4.png#averageHue=%23fcfbfa&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=294&amp;id=u5c5af96f&amp;originHeight=463&amp;originWidth=915&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=86220&amp;status=done&amp;style=none&amp;taskId=u227088fb-be53-4659-8beb-57d4b3ebbc7&amp;title=&amp;width=581.77783203125" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680081641847-9ce0ae8e-ea7d-426d-982a-c4ab275e0050.png#averageHue=%23fdfcfc&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=81&amp;id=u1e48b640&amp;originHeight=109&amp;originWidth=1188&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=24401&amp;status=done&amp;style=none&amp;taskId=u110b85ba-8c80-4079-ae38-3ccfc24a576&amp;title=&amp;width=880.0000621654414" alt="image.png" /><br /><code>tms_stime</code>和<code>tms_utime</code>分别记录了进程在内核态和用户态下消耗的CPU时间总和，它们的和就是进程从开始执行到调用times系统调用所经过的时间。<code>tms_stime</code>和<code>tms_utime</code>并不包括进程在睡眠状态或等待I/O操作中所消耗的时间，因此它们的和也不等于进程的实际运行时间。<br />注意这里时间的单位是CPU的滴答时间（tick），一个滴答数表示两个时钟中断的间隔。在Linux系统中，时钟中断通常由硬件定时器产生，定时器会以固定的频率向CPU发送中断信号。**每当时钟中断发生时，内核会将当前进程的时间片计数器减 1，内核会检查当前进程的时间片（counter）是否已经用完，如果用完了，就将当前进程放到就绪队列中，然后调用调度函数 schedule 选择一个新的进程运行。**这个频率通常是100Hz，即一秒发生100次，也就是说时间中断的间隔为10ms（1/100s），每隔10ms就发生一次时钟中断，linux内核中的<code>jiffies</code>变量就记录了时间中断的个数，即滴答数。那么可以看出这里的时间单位既然是滴答数，而滴答数10ms产生一个，那么实际时间应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">ticks/100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> (秒)，100是常量<code>HZ</code>的值<br />由此，如果想获取一个进程从开始到结束的CPU使用时间，即用户态下CPU时间和内核态下CPU时间之和，可用如下函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tms</span> t;</span><br><span class="line">    <span class="type">clock_t</span> clock_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程的CPU时间统计信息</span></span><br><span class="line">    clock_time = <span class="built_in">times</span>(&amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算进程的总的CPU时间</span></span><br><span class="line">    <span class="type">double</span> cpu_time = (<span class="type">double</span>)(t.tms_utime + t.tms_stime) / HZ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total CPU time: %.2f seconds\n&quot;</span>, cpu_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用到的<code>clock_t</code>在<code>include/time.h</code>中定义如下<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680082042776-a6814d15-253d-43cb-be0a-4d3e2fa9819e.png#averageHue=%23fdfcfb&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=67&amp;id=uf3bbfd6f&amp;originHeight=91&amp;originWidth=1143&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=24657&amp;status=done&amp;style=none&amp;taskId=ub62b64bd-cb85-441a-bfbf-5d591e528b7&amp;title=&amp;width=846.6667264773564" alt="image.png" /><br />
<a name="eLIVz"></a></p>
<h3 id="12-系统调用wait"><a class="markdownIt-Anchor" href="#12-系统调用wait"></a> 1.2. 系统调用wait</h3>
<p><code>wait</code> 函数是一个系统调用（位于<code>include/sys/wait.h</code>）。在Unix/Linux操作系统中，<code>wait</code>函数可以等待子进程结束，并获取子进程的退出状态。在使用<code>wait</code>函数时，如果子进程已经结束，<code>wait</code>函数会立即返回并返回子进程的退出状态；如果子进程还没有结束，<code>wait</code>函数会阻塞父进程，直到子进程结束并返回其退出状态。具体来说，<code>wait</code> 函数的作用如下：<br />1 如果当前进程没有子进程，<code>wait</code> 函数会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>ECHILD</code>，表示当前进程没有子进程需要等待。<br />2 如果当前进程有一个或多个子进程正在运行，调用 <code>wait</code> 函数会阻塞当前进程，直到其中一个子进程结束。当子进程结束时，<code>wait </code>函数会返回该子进程的进程 ID，并将该子进程的退出状态保存到一个整型变量<code>status</code>中。<br />3 如果当前进程有多个子进程正在运行，调用<code>wait</code>函数会等待其中任意一个子进程结束，并且无法指定要等待哪个子进程。如果需要等待特定的子进程，可以使用 <code>waitpid</code>函数代替<code>wait</code>函数。<br />需要注意的是，如果当前进程没有调用wait函数等待其子进程结束，那么当子进程结束时，其退出状态可能会一直保存在内核中，直到当前进程调用<code>wait</code>或<code>waitpid</code>函数获取该状态。如果当前进程没有获取子进程的退出状态，那么该子进程就会成为僵尸进程（Zombie Process），占用系统资源并且无法被正常清理。<br />因此，在编写多进程程序时，通常需要在父进程中调用<code>wait</code>或<code>waitpid</code>函数等待子进程结束，并获取其退出状态，以避免产生僵尸进程。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680090411853-3ca6d5fc-a85f-4018-b853-38d6b5eab55c.png#averageHue=%23f0f0f0&amp;clientId=ud7b45409-87b8-4&amp;from=paste&amp;height=245&amp;id=uc11188b1&amp;originHeight=383&amp;originWidth=1132&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=153979&amp;status=done&amp;style=none&amp;taskId=ue946029c-b4a7-4c74-903e-d7348704955&amp;title=&amp;width=724.48" alt="image.png" /><br />对linux0.11 wait函数必须接受一个<code>int</code>参数以保存子进程退出状态，如果你不想保存该信息，可传递<code>NULL</code>。而在现代linux中，该参数为可选参数。<br />
<a name="qPe7c"></a></p>
<h3 id="13-linux011中进程的state值"><a class="markdownIt-Anchor" href="#13-linux011中进程的state值"></a> 1.3. linux0.11中进程的state值</h3>
<p>在Linux 0.11中，进程状态可以被表示为以下几个值：</p>
<ol>
<li><code>TASK_RUNNING</code>：进程正在执行，也就是说CPU正在执行它的指令。但是，如果一个进程的状态为<code>TASK_RUNNING</code>，而它又没有占用CPU时间片运行，那么它就是处于就绪态。</li>
<li><code>TASK_INTERRUPTIBLE</code>：进程正在等待某个事件的发生（例如，等待用户输入、等待网络数据等），它已经睡眠，并且可以响应一个信号以退出等待状态。</li>
<li><code>TASK_UNINTERRUPTIBLE</code>：和<code>TASK_INTERRUPTIBLE</code>一样，进程也是正在等待某个事件的发生，但是进程在等待期间不会响应信号，直到事件发生后才会退出等待状态，比如I/O操作。</li>
<li><code>TASK_STOPPED</code>：进程已经被停止，通常是收到了一个SIGSTOP信号。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680423221854-cc012464-a635-471f-8978-9e5a9bca7ae9.png#averageHue=%23fbf9f7&amp;clientId=u36208795-4bd0-4&amp;from=paste&amp;height=151&amp;id=u89a07fa0&amp;originHeight=204&amp;originWidth=1173&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=true&amp;size=108104&amp;status=done&amp;style=none&amp;taskId=u3d9817ff-dff7-4f86-84ad-0f193cbddb3&amp;title=include%2Flinux%2Fsched.h&amp;width=868.888950269413" alt="include/linux/sched.h" title="include/linux/sched.h" /><br />
<a name="BqcgZ"></a></p>
<h2 id="2-processc"><a class="markdownIt-Anchor" href="#2-processc"></a> 2. process.c</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> son_proc_pid[<span class="number">21</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;<span class="number">21</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(! (son_proc_pid[i] = fork()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cpuio_bound</span>(<span class="number">20</span>,i,<span class="number">20</span>-i);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;<span class="number">21</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child_process_pid: %d\n&quot;</span>, son_proc_pid[i]);</span><br><span class="line">		++i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> cpu_time, <span class="type">int</span> io_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tms</span> start, pre;</span><br><span class="line">	<span class="type">clock_t</span> sum_cpu_time = <span class="number">0</span> ;</span><br><span class="line">	<span class="type">clock_t</span> accumulate =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">times</span>(&amp;start);</span><br><span class="line">		<span class="keyword">while</span>(sum_cpu_time &lt; cpu_time)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">times</span>(&amp;pre);</span><br><span class="line">			sum_cpu_time = (pre.tms_utime - start.tms_utime + pre.tms_stime - pre.tms_stime)/<span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(sum_cpu_time&gt;=last) <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">		<span class="built_in">sleep</span>(io_time);   </span><br><span class="line">		<span class="keyword">if</span>((accumulate+= io_time + cpu_time)&gt;=last)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680091964283-677f3934-2877-4b47-bb90-8de524ca7631.png#averageHue=%23016b01&amp;clientId=ueafc2590-6fa1-4&amp;from=paste&amp;height=560&amp;id=u6a843c73&amp;originHeight=875&amp;originWidth=1271&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=321878&amp;status=done&amp;style=none&amp;taskId=u1fca88b5-6987-447d-a8dc-b9523e8f249&amp;title=&amp;width=813.44" alt="image.png" /><br />
<a name="TtxLI"></a></p>
<h2 id="3-生成log的前置工作"><a class="markdownIt-Anchor" href="#3-生成log的前置工作"></a> 3. 生成log的前置工作</h2>
<ol>
<li>修改<code>linux-0.11/init/main.c</code>，将文件描述符<code>3</code>与<code>process.log</code>关联。文件描述符是一个非负整数，它是操作系统内部用来标识一个特定文件的引用。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680092845738-eb1c4f7b-85cd-4bda-8eaf-a3c9f2965bd9.png#averageHue=%23404040&amp;clientId=uf8821459-f9ef-4&amp;from=paste&amp;height=356&amp;id=u59def16c&amp;originHeight=480&amp;originWidth=1482&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=257225&amp;status=done&amp;style=none&amp;taskId=u48dfe7b1-b671-4b96-b4c4-ab3217f6fa5&amp;title=&amp;width=1097.777855327596" alt="image.png" /></p>
<ol start="2">
<li>在内核中添加<code>fprintk</code>函数用于在程序中调用以写入log文件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> logbuf[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintk</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> * file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">m_inode</span> * inode;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line">    count=<span class="built_in">vsprintf</span>(logbuf, fmt, args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">3</span>)    <span class="comment">/* 如果输出到stdout或stderr，直接调用sys_write即可 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $logbuf\n\t&quot;</span> <span class="comment">/* 注意对于Windows环境来说，是_logbuf,下同 */</span></span><br><span class="line">            <span class="string">&quot;pushl %1\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call sys_write\n\t&quot;</span> <span class="comment">/* 注意对于Windows环境来说，是_sys_write,下同 */</span></span><br><span class="line">            <span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (count),<span class="string">&quot;r&quot;</span> (fd):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* 假定&gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(file=task[<span class="number">0</span>]-&gt;filp[fd]))    <span class="comment">/* 从进程0的文件描述符表中得到文件句柄 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        inode=file-&gt;f_inode;</span><br><span class="line"></span><br><span class="line">        __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $logbuf\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %1\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %2\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call file_write\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl $12,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (count),<span class="string">&quot;r&quot;</span> (file),<span class="string">&quot;r&quot;</span> (inode):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改fork.c</li>
</ol>
<p>进程在创建后就立马被设置为就绪态<code>TASK_RUNNING</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680418919364-03d91541-3641-4d47-a424-34ea2bca802d.png#averageHue=%23340a19&amp;clientId=uf67f330f-a4ae-4&amp;from=paste&amp;height=204&amp;id=u37425a43&amp;originHeight=276&amp;originWidth=1287&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=89012&amp;status=done&amp;style=none&amp;taskId=u293f4087-df5d-429c-990e-d462e4a802f&amp;title=&amp;width=953.3334006792281" alt="image.png" /></p>
<ol start="4">
<li>修改sched.c</li>
</ol>
<p>在进程的状态切换点打印进程的状态信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  linux/kernel/sched.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (C) 1991  Linus Torvalds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &#x27;sched.c&#x27; is the main kernel file. It contains scheduling primitives</span></span><br><span class="line"><span class="comment"> * (sleep_on, wakeup, schedule etc) as well as a number of simple system</span></span><br><span class="line"><span class="comment"> * call functions (type getpid(), which just extracts a field from</span></span><br><span class="line"><span class="comment"> * current-task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _S(nr) (1&lt;&lt;((nr)-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_task</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">4096</span>-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_struct);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%d: pid=%d, state=%d, &quot;</span>,nr,p-&gt;pid,p-&gt;state);</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j &amp;&amp; !((<span class="type">char</span> *)(p+<span class="number">1</span>))[i])</span><br><span class="line">        i++;</span><br><span class="line">    printk(<span class="string">&quot;%d (of %d) chars free in kernel stack\n\r&quot;</span>,i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_stat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_TASKS;i++)</span><br><span class="line">        <span class="keyword">if</span> (task[i])</span><br><span class="line">            show_task(i,task[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LATCH (1193180/HZ)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">mem_use</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">timer_interrupt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">system_call</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[PAGE_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="keyword">volatile</span> jiffies=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> startup_time=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span> =</span> &amp;(init_task.task);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">last_task_used_math</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] =</span> &#123;&amp;(init_task.task), &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> user_stack [ PAGE_SIZE&gt;&gt;<span class="number">2</span> ] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> * a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">&#125; stack_start = &#123; &amp; user_stack [PAGE_SIZE&gt;&gt;<span class="number">2</span>] , <span class="number">0x10</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;math_state_restore()&#x27; saves the current math information in the</span></span><br><span class="line"><span class="comment"> * old math state array, and gets the new ones from the current task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">math_state_restore</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    __asm__(<span class="string">&quot;fwait&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math) &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (last_task_used_math-&gt;tss.i387));</span><br><span class="line">    &#125;</span><br><span class="line">    last_task_used_math=current;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;used_math) &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;frstor %0&quot;</span>::<span class="string">&quot;m&quot;</span> (current-&gt;tss.i387));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __asm__(<span class="string">&quot;fninit&quot;</span>::);</span><br><span class="line">        current-&gt;used_math=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;schedule()&#x27; is the scheduler function. This is GOOD CODE! There</span></span><br><span class="line"><span class="comment"> * probably won&#x27;t be any reason to change this, as it should work well</span></span><br><span class="line"><span class="comment"> * in all circumstances (ie gives IO-bound processes good response etc).</span></span><br><span class="line"><span class="comment"> * The one thing you might take a look at is the signal-handler code here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   NOTE!!  Task 0 is the &#x27;idle&#x27; task, which gets called when no other</span></span><br><span class="line"><span class="comment"> * tasks can run. It can not be killed, and it cannot sleep. The &#x27;state&#x27;</span></span><br><span class="line"><span class="comment"> * information in task[0] is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,next,c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">                (*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">                (*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">                (*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">            &#123;</span><br><span class="line">                (*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">                <span class="comment">/*可中断睡眠 =&gt; 就绪*/</span></span><br><span class="line">                fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                (*p)-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*编号为next的进程 运行*/</span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;pid != task[next] -&gt;pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*时间片到时程序 =&gt; 就绪*/</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;state == TASK_RUNNING)</span><br><span class="line">            fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tR\t%d\n&quot;</span>,task[next]-&gt;pid,jiffies);</span><br><span class="line">    &#125;</span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	*当前进程  运行 =&gt; 可中断睡眠</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;pid != <span class="number">0</span>)</span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">        panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    tmp = *p;</span><br><span class="line">    *p = current;</span><br><span class="line">    current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	*当前进程进程 =&gt; 不可中断睡眠</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		*原等待队列 第一个进程 =&gt; 唤醒（就绪）</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,tmp-&gt;pid,jiffies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">        panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    tmp=*p;</span><br><span class="line">    *p=current;</span><br><span class="line">    repeat:	current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	*这一部分属于 唤醒队列中间进程，通过goto实现唤醒 队列头进程 过程中Wait</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tW\t%d\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">        (**p).state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		*当前进程进程 =&gt; 可中断睡眠 同上</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		*原等待队列 第一个进程 =&gt; 唤醒（就绪）</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,tmp-&gt;pid,jiffies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">        (**p).state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		*唤醒 最后进入等待序列的 进程</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        fprintk(<span class="number">3</span>,<span class="string">&quot;%d\tJ\t%d\n&quot;</span>,(*p)-&gt;pid,jiffies);</span><br><span class="line">        *p=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OK, here are some floppy things that shouldn&#x27;t be in the kernel</span></span><br><span class="line"><span class="comment"> * proper. They are here because the floppy needs a timer, and this</span></span><br><span class="line"><span class="comment"> * was the easiest way of doing it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">wait_motor</span>[4] =</span> &#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>  mon_timer[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> moff_timer[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> current_DOR = <span class="number">0x0C</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ticks_to_floppy_on</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> selected;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mask = <span class="number">0x10</span> &lt;&lt; nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nr&gt;<span class="number">3</span>)</span><br><span class="line">        panic(<span class="string">&quot;floppy_on: nr&gt;3&quot;</span>);</span><br><span class="line">    moff_timer[nr]=<span class="number">10000</span>;		<span class="comment">/* 100 s = very big :-) */</span></span><br><span class="line">    cli();				<span class="comment">/* use floppy_off to turn it off */</span></span><br><span class="line">    mask |= current_DOR;</span><br><span class="line">    <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">        mask &amp;= <span class="number">0xFC</span>;</span><br><span class="line">        mask |= nr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mask != current_DOR) &#123;</span><br><span class="line">        outb(mask,FD_DOR);</span><br><span class="line">        <span class="keyword">if</span> ((mask ^ current_DOR) &amp; <span class="number">0xf0</span>)</span><br><span class="line">            mon_timer[nr] = HZ/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mon_timer[nr] &lt; <span class="number">2</span>)</span><br><span class="line">            mon_timer[nr] = <span class="number">2</span>;</span><br><span class="line">        current_DOR = mask;</span><br><span class="line">    &#125;</span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> mon_timer[nr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floppy_on</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">while</span> (ticks_to_floppy_on(nr))</span><br><span class="line">        sleep_on(nr+wait_motor);</span><br><span class="line">    sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floppy_off</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    moff_timer[nr]=<span class="number">3</span>*HZ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_floppy_timer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mask = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">4</span> ; i++,mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(mask &amp; current_DOR))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (mon_timer[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--mon_timer[i])</span><br><span class="line">                wake_up(i+wait_motor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!moff_timer[i]) &#123;</span><br><span class="line">            current_DOR &amp;= ~mask;</span><br><span class="line">            outb(current_DOR,FD_DOR);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            moff_timer[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_REQUESTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> jiffies;</span><br><span class="line">    <span class="type">void</span> (*fn)();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; timer_list[TIME_REQUESTS], * next_timer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="type">long</span> jiffies, <span class="type">void</span> (*fn)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fn)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span> (jiffies &lt;= <span class="number">0</span>)</span><br><span class="line">        (fn)();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++)</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;fn)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= timer_list + TIME_REQUESTS)</span><br><span class="line">            panic(<span class="string">&quot;No more time requests free&quot;</span>);</span><br><span class="line">        p-&gt;fn = fn;</span><br><span class="line">        p-&gt;jiffies = jiffies;</span><br><span class="line">        p-&gt;next = next_timer;</span><br><span class="line">        next_timer = p;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123;</span><br><span class="line">            p-&gt;jiffies -= p-&gt;next-&gt;jiffies;</span><br><span class="line">            fn = p-&gt;fn;</span><br><span class="line">            p-&gt;fn = p-&gt;next-&gt;fn;</span><br><span class="line">            p-&gt;next-&gt;fn = fn;</span><br><span class="line">            jiffies = p-&gt;jiffies;</span><br><span class="line">            p-&gt;jiffies = p-&gt;next-&gt;jiffies;</span><br><span class="line">            p-&gt;next-&gt;jiffies = jiffies;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">long</span> cpl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> beepcount;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sysbeepstop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beepcount)</span><br><span class="line">        <span class="keyword">if</span> (!--beepcount)</span><br><span class="line">            sysbeepstop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpl)</span><br><span class="line">        current-&gt;utime++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        current-&gt;stime++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_timer) &#123;</span><br><span class="line">        next_timer-&gt;jiffies--;</span><br><span class="line">        <span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">void</span> (*fn)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">            fn = next_timer-&gt;fn;</span><br><span class="line">            next_timer-&gt;fn = <span class="literal">NULL</span>;</span><br><span class="line">            next_timer = next_timer-&gt;next;</span><br><span class="line">            (fn)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>)</span><br><span class="line">        do_floppy_timer();</span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    current-&gt;counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cpl) <span class="keyword">return</span>;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_alarm</span><span class="params">(<span class="type">long</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = current-&gt;alarm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old)</span><br><span class="line">        old = (old - jiffies) / HZ;</span><br><span class="line">    current-&gt;alarm = (seconds&gt;<span class="number">0</span>)?(jiffies+HZ*seconds):<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getppid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_geteuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;euid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getgid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;gid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_getegid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;egid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_nice</span><span class="params">(<span class="type">long</span> increment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;priority-increment&gt;<span class="number">0</span>)</span><br><span class="line">        current-&gt;priority -= increment;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction) != <span class="number">16</span>)</span><br><span class="line">        panic(<span class="string">&quot;Struct sigaction MUST be 16 bytes&quot;</span>);</span><br><span class="line">    set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">    set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">    p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">        task[i] = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Clear NT, so that we won&#x27;t have troubles with that later on */</span></span><br><span class="line">    __asm__(<span class="string">&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;</span>);</span><br><span class="line">    ltr(<span class="number">0</span>);</span><br><span class="line">    lldt(<span class="number">0</span>);</span><br><span class="line">    outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);		<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">    outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);	<span class="comment">/* LSB */</span></span><br><span class="line">    outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);	<span class="comment">/* MSB */</span></span><br><span class="line">    set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sys_pause在Linux0.11中，<code>sys_pause()</code>系统调用的主要作用是让进程暂停执行，直到接收到一个信号。当进程调用<code>sys_pause()</code>系统调用时，它会将自己的状态设置为<code>TASK_INTERRUPTIBLE</code>，并且将其添加到等待信号队列中。然后，进程会进入睡眠状态，直到收到一个信号或者被其他进程显式地唤醒。<br />这个系统调用通常用于实现等待信号的操作，比如等待一个定时器信号或者等待一个IO操作完成的信号。在这种情况下，进程可以使用<code>sys_pause()</code>系统调用进入睡眠状态，而不必浪费CPU资源等待信号的到来。当信号到来时，内核会唤醒进程，并且将信号传递给进程的信号处理程序进行处理。<br />需要注意的是，在Linux 2.6以后的版本中，<code>sys_pause()</code>系统调用已经被废弃，被<code>sys_rt_sigsuspend()</code>系统调用所取代。<code>sys_rt_sigsuspend()</code>系统调用可以实现类似的等待信号的操作，并且提供更多的控制选项。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680156794185-dce974ae-e57c-4560-b22c-5f6bf5caee22.png#averageHue=%23fbf8f6&amp;clientId=u11640b7c-d1e3-4&amp;from=paste&amp;height=364&amp;id=u46c71fba&amp;originHeight=491&amp;originWidth=1238&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=243762&amp;status=done&amp;style=none&amp;taskId=u9adb656e-5edb-4706-9773-14fee2abbf6&amp;title=&amp;width=917.037101818869" alt="image.png" /></p>
<ol start="5">
<li>修改exit.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));</span><br><span class="line">    free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)</span><br><span class="line">        <span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123;</span><br><span class="line">            task[i]-&gt;father = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (task[i]-&gt;state == TASK_ZOMBIE)</span><br><span class="line">                <span class="comment">/* assumption task[1] is always init */</span></span><br><span class="line">                (<span class="type">void</span>) send_sig(SIGCHLD, task[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;filp[i])</span><br><span class="line">            sys_close(i);</span><br><span class="line">    iput(current-&gt;pwd);</span><br><span class="line">    current-&gt;pwd=<span class="literal">NULL</span>;</span><br><span class="line">    iput(current-&gt;root);</span><br><span class="line">    current-&gt;root=<span class="literal">NULL</span>;</span><br><span class="line">    iput(current-&gt;executable);</span><br><span class="line">    current-&gt;executable=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= <span class="number">0</span>)</span><br><span class="line">        tty_table[current-&gt;tty].pgrp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">        last_task_used_math = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;leader)</span><br><span class="line">        kill_session();</span><br><span class="line">    current-&gt;state = TASK_ZOMBIE;</span><br><span class="line">    current-&gt;exit_code = code;</span><br><span class="line">    fprintk(<span class="number">3</span>,<span class="string">&quot;%ld\tE\t%ld\n&quot;</span>,current-&gt;pid,jiffies);</span><br><span class="line">    tell_father(current-&gt;father);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);	<span class="comment">/* just to suppress warnings */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>旁注：do_exit函数与sys_waitpid函数</strong></p>
<blockquote>
<p>在 Linux 0.11 中，<code>do_exit()</code> 函数负责终止一个进程。当一个进程调用 <code>do_exit()</code> 时，它会执行多个清理操作，包括释放进程持有的任何资源，如打开的文件和内存，并向父进程通知进程的退出状态。如果进程有任何子进程，则 <code>do_exit()</code> 也通过递归调用 <code>do_exit()</code> 终止它们。<br />
<code>sys_waitpid() </code>函数用于等待子进程终止并检索其退出状态。当进程调用 <code>sys_waitpid()</code> 时，它会阻塞，直到其中一个子进程终止。如果子进程已经终止，<code>sys_waitpid() </code>将立即返回该子进程的退出状态。否则，它将继续阻塞，直到子进程终止。<br />
除了等待特定的子进程外，<code>sys_waitpid() </code>还可以用于等待任何子进程终止，方法是通过传递<code> -1</code> 的 <code>pid</code> 参数。当一个进程有多个子进程并且想要等待第一个终止时，这很有用。</p>
</blockquote>
<p><a name="PLMGK"></a></p>
<h2 id="4-生成log"><a class="markdownIt-Anchor" href="#4-生成log"></a> 4. 生成log</h2>
<p>先共享文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mount-hdc</span><br></pre></td></tr></table></figure>
<p>移动多进程程序<code>process.c</code>到linux-0.11目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> process.c hdc/usr/root</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680102556459-4dae45b1-9b54-41b1-ac91-af3f975f8622.png#averageHue=%230cb804&amp;clientId=uc1e146a1-ff2e-4&amp;from=paste&amp;height=202&amp;id=u1b11e17d&amp;originHeight=182&amp;originWidth=801&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18239&amp;status=done&amp;style=none&amp;taskId=u50fc4245-9bac-45f5-96f1-e1e5dd0e51c&amp;title=&amp;width=890.000023576949" alt="image.png" /><br />编译运行, 最后执行一个<code>sync</code>命令，确保将文件系统中的所有缓存数据写入磁盘<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680156855136-d0cd08e2-6520-4ccf-b809-43de45b15990.png#averageHue=%23222121&amp;clientId=u11640b7c-d1e3-4&amp;from=paste&amp;height=376&amp;id=uf77324e2&amp;originHeight=507&amp;originWidth=786&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=29997&amp;status=done&amp;style=none&amp;taskId=u51aea8a4-a9b1-412e-bbf5-7de3992819e&amp;title=&amp;width=582.2222633518829" alt="image.png" /><br /><strong>旁注: sync命令</strong></p>
<blockquote>
<p>sync 命令是用于将文件系统中的所有缓存数据写入磁盘的命令。在 Linux 中，当一个进程修改了一个文件时，这个修改不会立即写入磁盘，而是会先被写入内存中的缓存，以提高文件系统的性能。然而，如果系统崩溃或出现其他问题，这些修改可能会丢失。因此，为了保证数据的完整性，我们需要将缓存数据定期地写入磁盘中。<br />
sync 命令会将所有的缓存数据写入磁盘中，并将所有被修改的元数据（如 i-node、目录结构等）更新到磁盘中。这样可以保证所有的修改都被写入到磁盘中，从而避免了数据的丢失。通常在关机前执行 sync 命令，以确保所有数据都已被保存到磁盘中。<br />
需要注意的是，执行 sync 命令并不能保证磁盘数据的完全一致性。在磁盘数据的写入过程中，如果发生了异常情况，可能会导致数据的损坏或丢失。因此，在执行 sync 命令后，建议再执行一次磁盘检查命令（如 fsck 命令）来确保文件系统的完整性。</p>
</blockquote>
<p>将生成的<code>process.log</code>移动到虚拟机下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mount-hdc</span><br><span class="line"><span class="built_in">cp</span> hdc/var/process.log process.log</span><br></pre></td></tr></table></figure>
<p>查看process.log，进程0在log关联文件描述符之前就已经在运行，因此未出现在log文件中<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680415902178-9c4c2da7-7edb-4723-b55a-e9fe72e794e9.png#averageHue=%232e2d3c&amp;clientId=uf67f330f-a4ae-4&amp;from=paste&amp;height=494&amp;id=u30477769&amp;originHeight=667&amp;originWidth=989&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=72543&amp;status=done&amp;style=none&amp;taskId=u9090ad80-0a07-40ab-b6df-2b16198c3e3&amp;title=&amp;width=732.5926443447992" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680157216292-d2746d2e-ef7a-47b7-ae49-89ac6630d367.png#averageHue=%232e3345&amp;clientId=u11640b7c-d1e3-4&amp;from=paste&amp;height=340&amp;id=u6d455e29&amp;originHeight=459&amp;originWidth=1069&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=121217&amp;status=done&amp;style=none&amp;taskId=u8f7744b6-ff01-47a1-a81c-74e61b5412a&amp;title=&amp;width=791.8519077902835" alt="image.png" /><br />
<a name="h8nod"></a></p>
<h2 id="5-分析log"><a class="markdownIt-Anchor" href="#5-分析log"></a> 5. 分析log</h2>
<p>用指导书给的py脚本程序<code>stat_log.py</code>分析log文件，在分析之前将py脚本文件的第一行<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2</code>（已安装python2）以适配版本，否则在python3环境下<code>print</code>函数会出错<br />为该脚本文件分配可执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x stat_log.py</span><br></pre></td></tr></table></figure>
<p>执行脚本，分析进程9、10、11、12的运行情况（多个指标：平均周转时间，平均等待时间）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stat_log.py process.log 9 10 11 12 -g | less</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680423652089-e86380f3-f4e9-4d79-ad11-0a1ebc9798ad.png#averageHue=%23231227&amp;clientId=uccfc5aea-4473-4&amp;from=paste&amp;height=474&amp;id=ud8daee23&amp;originHeight=640&amp;originWidth=1147&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=107108&amp;status=done&amp;style=none&amp;taskId=u28cc7fdb-6a4e-4903-b874-35caa352db5&amp;title=&amp;width=849.6296896496307" alt="image.png" /><br />
<a name="NJnrE"></a></p>
<h2 id="6-修改时间片重新分析log"><a class="markdownIt-Anchor" href="#6-修改时间片重新分析log"></a> 6. 修改时间片，重新分析log</h2>
<p>进程的时间片是进程的<code>counter</code>值，而counter在schedule函数中根据<code>priority</code>动态设置，因此进程的时间片受<code>counter</code>和<code>prioriy</code>两个变量的影响。进程的<code>priority</code>继承自父进程，进而所有进程的<code>priority</code>都来自于进程0 。<br />linux0.11中，<code>priority</code>和<code>counter</code>在<code>include/linux/sched.h</code>中定义<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680424066512-421f988e-49a3-4b66-a9b3-4e984c083da7.png#averageHue=%23f9f8f7&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=179&amp;id=u3cf28712&amp;originHeight=242&amp;originWidth=1399&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=102392&amp;status=done&amp;style=none&amp;taskId=udc7dd1be-caaf-44ac-8d33-1569af77da3&amp;title=&amp;width=1036.2963695029061" alt="image.png" /><br />我们修改这个值，然后重新执行process程序，分析log。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680425118028-6426a982-4e91-4b81-8fc4-7c2f2dcf7319.png#averageHue=%23320a1a&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=204&amp;id=uc99c017b&amp;originHeight=334&amp;originWidth=1215&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=77552&amp;status=done&amp;style=none&amp;taskId=u885ffd8c-f755-4bc9-8037-be7eab07b04&amp;title=&amp;width=742.0000610351562" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680425135373-cbb971da-57f6-43f9-a92b-c665b29e7410.png#averageHue=%23310a1b&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=196&amp;id=u78f7b710&amp;originHeight=287&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=66299&amp;status=done&amp;style=none&amp;taskId=u61617740-70c7-46bb-b3a7-329f0fd3129&amp;title=&amp;width=744.888916015625" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680425366848-3d2e176f-aaed-410d-a132-af6ac4df180c.png#averageHue=%23343e56&amp;clientId=uc4ca57e0-594c-4&amp;from=paste&amp;height=361&amp;id=ubd18199b&amp;originHeight=487&amp;originWidth=1101&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=83283&amp;status=done&amp;style=none&amp;taskId=u1a1720f5-a694-44f6-97d8-f4d20b23ae7&amp;title=&amp;width=815.5556131684772" alt="image.png" /><br />可以看到这里的时间平均周转时间变多了，有以下两种可能：</p>
<ol>
<li>当进程的执行时间很长时，增加时间片大小可能会导致进程在等待时间片结束时的等待时间变长，因为进程需要等待更长的时间才能获得 CPU</li>
<li>当进程的数量非常多时，增加时间片大小可能会导致进程在就绪队列中等待的时间变长，因为每个进程需要等待更长的时间才能获得 CPU。</li>
</ol>
<p>因此，时间片大小的设置需要根据具体情况进行调整，不能简单地认为增加时间片大小一定会减少平均周转时间。需要根据系统中进程的数量、执行时间等因素来选择合适的时间片大小，从而达到更好的系统性能。<br />
<a name="R9GH2"></a></p>
<h1 id="实验4-基于内核栈切换的进程切换"><a class="markdownIt-Anchor" href="#实验4-基于内核栈切换的进程切换"></a> 实验4 基于内核栈切换的进程切换</h1>
<hr />
<p>我这个实验做的不是很好，建议本实验参考其他的博客<br />
<a name="XtNKt"></a></p>
<h2 id="1-修改schedule函数"><a class="markdownIt-Anchor" href="#1-修改schedule函数"></a> 1.  修改schedule函数</h2>
<p>在TSS切换中，依赖TR寄存器找到下一个进程的tss，从而实现切换，因此在switch_to中没有next的PCB。要在<code>switch_to</code>函数中，将TSS的切换改为内核栈的切换，首先要在<code>schedule</code>函数中给<code>switch_to</code>函数传入next的PCB。因为这里没有TSS的切换，需要再单独做LDT表的切换。<br />在函数声明中，参数列表是从左到右依次列出的，而在函数栈帧中，参数是从右到左依次压入的。因此调用<code>switch_to</code>函数后，当前进程的内核中依次压入了LDT(next)，pnext和返回地址<br />因为这里涉及函数调用和栈，所以补充一下<code>%esp</code>和<code>%ebp</code>的知识：</p>
<blockquote>
<p>ESP寄存器用于指向当前栈帧的顶部，即栈中当前可用的最高地址。而EBP寄存器则通常用于指向当前函数的栈帧，也称为帧指针。EBP寄存器存储的是当前栈帧的起始位置，也就是栈中当前函数的参数和局部变量存储的位置。在函数执行期间，ESP寄存器的值会随着栈中数据的压入和弹出而不断变化，以保持其始终指向当前栈帧的顶部。而EBP寄存器的值通常不会被修改，以保持其一直指向当前函数的栈帧。这样可以确保函数能够正确地访问和修改栈帧中的参数、局部变量和返回地址等信息，而不会干扰其他函数的栈帧。<br />
在函数调用过程中，处理器会将该函数的参数值和返回地址等信息压入当前函数的栈帧中，并将ESP寄存器的值减少相应的字节数。如果在函数执行期间没有再将其他数据压入栈中，那么ESP寄存器的值将等于EBP寄存器的值，即它们都指向栈帧的底部。需要注意的是，函数栈帧的大小通常是在编译时确定的，因此在函数调用前，编译器就已经为该函数分配了足够的栈空间。如果在函数执行期间需要动态分配更多的栈空间，那么ESP和EBP寄存器的值就会发生变化，以指向新分配的栈空间的位置<br />
因此，ESP指向栈帧的顶部，EBP指向栈帧的起始位置，两者配合使用，能够在函数执行期间正确地访问和修改栈帧中的数据。</p>
</blockquote>
<p><strong>旁注：LDT表实现进程间的地址隔离</strong></p>
<blockquote>
<p>在x86架构中，进程与LDT（Local Descriptor Table）有密切的关系，LDT可以用来隔离和保护不同进程的地址空间。<br />
LDT是一种描述符表，用于存储局部数据段和局部代码段的信息。与全局描述符表（GDT）不同，LDT表是针对每个进程单独维护的，每个进程都可以有自己的LDT表。LDT表的主要作用是实现地址空间的隔离，以保护、不同进程的内存空间不被其他进程访问或修改。<br />
在x86架构中，进程的地址空间通常被划分为多个段，每个段都有自己的基地址和大小。通过使用LDT表中的描述符，可以将进程的地址空间划分为多个不同的段，并且每个进程都有自己独立的LDT表，这样可以实现不同进程的地址空间之间的隔离和保护。<strong>进程中的所有数据段和代码段都必须使用LDT中的描述符进行描述，以便在进程运行时能够正确地访问和修改这些段中的数据</strong>。<br />
在Linux 0.11内核中，进程的LDT表存储在进程控制块（PCB）中，每个进程都有自己独立的LDT表。当进程被调度执行时，LDT表的选择子被存储在进程的TSS（Task State Segment）中，用于访问进程的LDT表。通过使用LDT表，可以实现不同进程之间的地址空间隔离和保护，提高系统的安全性和稳定性。<br />
总之，LDT表是实现进程地址空间隔离和保护的重要手段，可以帮助操作系统实现不同进程之间的资源隔离和保护。在x86架构下，LDT表和进程的地址空间划分密切相关，每个进程都有自己独立的LDT表和地址空间划分。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,next,c;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> ** p;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *pnext = &amp;init_task.task ;  <span class="comment">//指向下一个进程的PCB的PCB指针,初始化指向进程0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">		<span class="keyword">if</span> (*p) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">					(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">					(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">			(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">				(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		c = <span class="number">-1</span>;</span><br><span class="line">		next = <span class="number">0</span>;</span><br><span class="line">		i = NR_TASKS;</span><br><span class="line">		p = &amp;task[NR_TASKS];</span><br><span class="line">		<span class="keyword">while</span> (--i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!*--p)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">				c = (*p)-&gt;counter, next = i, pnext = *p;  </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">						(*p)-&gt;priority;</span><br><span class="line">	&#125;</span><br><span class="line">	switch_to(pnext, _LDT(next));  <span class="comment">//  传递下一个进程的PCB (切换执行序列)和LDT (切换内存空间)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="R5KpS"></a></p>
<h2 id="2-修改switch_to函数"><a class="markdownIt-Anchor" href="#2-修改switch_to函数"></a> 2. 修改switch_to函数</h2>
<p><code>switch_to</code>函数是一个宏函数，位于<code>include/linux/sched.h</code>中，我们先注释掉这个原版<code>switch_to</code>，在<code>kernel/system_call.s</code>中编写新的<code>switch_to</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ESP0						= 0x04</span><br><span class="line">KERNEL_STACK    = 0x0C # kernel_stack变量在task_struct中的偏移量</span><br><span class="line">switch_to:</span><br><span class="line">        pushl %ebp     # 压入C函数schedule的栈帧</span><br><span class="line">        movl %esp,%ebp # 将当前进程的栈顶指针esp拷贝给%ebp，使它指向刚刚压入的esp值</span><br><span class="line">        pushl %ecx     # 这几个寄存器可能是调用函数schedule中用到的寄存器，因此先保存</span><br><span class="line">        pushl %ebx</span><br><span class="line">        pushl %eax</span><br><span class="line">        movl 8(%ebp),%ebx   #取出传入的pnext参数，即下一个进程的PCB指针</span><br><span class="line">        cmpl %ebx,current   </span><br><span class="line">        je 1f               # next是否是当前进程，如果是，则向前(Forward)跳转到标号1开始执行，不执行转换</span><br><span class="line"></span><br><span class="line"># PCB</span><br><span class="line">        movl %ebx,%eax</span><br><span class="line">        xchgl %eax,current  # exchange value, 切换进程PCB, 此时%eax指向当前进程，current指向下一个进程</span><br><span class="line"># TSS 使用户栈能找到内核栈，借用进程0的tss保存内核栈的esp0信息</span><br><span class="line">        movl tss, %ecx  # 在kernel/sched.c中定义tss = &amp; init_task.task.tss</span><br><span class="line">        addl $4096, %ebx   # 让ebx指向页表最高地址处，这里也是内核栈的基址</span><br><span class="line">        movl %ebx, ESP0(%ecx) # 修改tss中的esp0(偏移量为4)，使它指向内核栈的栈顶位置，此时就是栈基址</span><br><span class="line"># switch kernel_stack   切换的关键</span><br><span class="line">        movl %esp, KERNEL_STACK(%eax) # 取出CPU.esp 保存到当前进程的PCB中，task_struct中需要添加kernel_stack变量，并修改INIT_TASK</span><br><span class="line">        movl 8(%ebp),%ebx # 重新取出下一个进程的PCB</span><br><span class="line">        movl KERNEL_STACK(%ebx), %esp # 将下一个进程的PCB中的内核栈的栈顶信息esp放入CPU中</span><br><span class="line"># switch LDT</span><br><span class="line">        movl 12(%ebp), %ecx  # 取出传入的 LDT(next)参数</span><br><span class="line">        lldt %cx  # lldt指令用于将LDT的段选择子加载到LDTR寄存器中，LDTR寄存器是一个16位的寄存器，存储LDT的段选择子，硬件根据LDTR在GDT中查找以获取LDT的地址</span><br><span class="line">        movl $0x17,%ecx  # 重置 fs寄存器</span><br><span class="line">        mov %cx,%fs</span><br><span class="line"></span><br><span class="line">        cmpl %eax,last_task_used_math</span><br><span class="line">        jne 1f</span><br><span class="line">        clts</span><br><span class="line">1:  </span><br><span class="line">        popl %eax  # 返回C函数schedule，恢复寄存器(特别是帧指针%ebp)</span><br><span class="line">        popl %ebx</span><br><span class="line">        popl %ecx</span><br><span class="line">        popl %ebp</span><br><span class="line">        ret</span><br><span class="line">.align 2</span><br><span class="line">first_return_from_kernel:  # 一段包含iret的代码，用于返回用户栈</span><br><span class="line">        popl %edx</span><br><span class="line">        popl %edi</span><br><span class="line">        popl %esi</span><br><span class="line">        pop %gs</span><br><span class="line">        pop %fs</span><br><span class="line">        pop %es</span><br><span class="line">        pop %ds</span><br><span class="line">        iret</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680610298744-b96a1fb9-0bd5-42c3-92fa-db7cf014e26f.png#averageHue=%230e1d24&amp;clientId=uab8d30b7-e158-4&amp;from=paste&amp;height=359&amp;id=u135e04c6&amp;originHeight=570&amp;originWidth=307&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=25038&amp;status=done&amp;style=none&amp;taskId=uc3a9f8de-69d4-45ee-9bd4-59869b11bbe&amp;title=&amp;width=193.4074249267578" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680607901100-80e1fef7-6227-4666-8b92-b7f9e77c5157.png#averageHue=%2340403f&amp;clientId=ud7da80e5-6267-4&amp;from=paste&amp;height=213&amp;id=u9cffa745&amp;originHeight=288&amp;originWidth=1249&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=131127&amp;status=done&amp;style=none&amp;taskId=uf8d01083-566e-4751-9d00-bfefb9601b0&amp;title=&amp;width=925.1852505426231" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680607923866-24c74850-2ebb-41f3-b6f8-a6bf868dc1ec.png#averageHue=%23443a2c&amp;clientId=ud7da80e5-6267-4&amp;from=paste&amp;height=126&amp;id=u80a62313&amp;originHeight=170&amp;originWidth=972&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=79341&amp;status=done&amp;style=none&amp;taskId=uff96a90b-a025-4fab-9392-f3ca2b5aeca&amp;title=&amp;width=720.0000508626338" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680613819720-4f2243c4-a2ac-4182-8b85-b8b5c9075826.png#averageHue=%23414040&amp;clientId=uf8dab7e5-7478-4&amp;from=paste&amp;height=194&amp;id=u8850a003&amp;originHeight=262&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=87892&amp;status=done&amp;style=none&amp;taskId=u3d364175-505c-40bc-b73e-0a56a05f9ab&amp;title=&amp;width=762.2222760675413" alt="image.png" /><br />
<a name="Brx25"></a></p>
<h2 id="3-修改copy_process函数"><a class="markdownIt-Anchor" href="#3-修改copy_process函数"></a> 3.  修改copy_process函数</h2>
<p>在fork.c的copy_process部分添加以下代码用于设置进程的内核栈， 并注释掉设置tss的部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*set up kernel stack */</span><br><span class="line">	long * krnstack =(long)(PAGE_SIZE + (long)p);</span><br><span class="line">	*(--krnstack) = ss &amp; 0xffff;  # 压入SS:SP</span><br><span class="line">	*(--krnstack) = esp;</span><br><span class="line">	*(--krnstack) = eflags;</span><br><span class="line">	*(--krnstack) = cs &amp; 0xffff;  # 压入CS:IP</span><br><span class="line">	*(--krnstack) = eip;</span><br><span class="line"></span><br><span class="line">	*(--krnstack) = ds &amp; 0xffff;</span><br><span class="line">	*(--krnstack) = es &amp; 0xffff;</span><br><span class="line">	*(--krnstack) = fs &amp; 0xffff;</span><br><span class="line">	*(--krnstack) = gs &amp; 0xffff;</span><br><span class="line">	*(--krnstack) = esi;</span><br><span class="line">	*(--krnstack) = edi;</span><br><span class="line">	*(--krnstack) = edx;</span><br><span class="line"></span><br><span class="line">	*(--krnstack) = (long) first_return_from_kernel; // a code segment with iret instruction</span><br><span class="line"></span><br><span class="line">	*(--krnstack) = ebp;</span><br><span class="line">	*(--krnstack) = ecx;</span><br><span class="line">	*(--krnstack) = ebx;</span><br><span class="line">	*(--krnstack) = 0;</span><br><span class="line">	p-&gt;kernel_stack = krnstack;  # 设置PCB中的内核栈栈顶指针信息为初始化后的栈顶指针</span><br></pre></td></tr></table></figure>
<p><a name="jdsWH"></a></p>
<h1 id="实验5-信号量的实现与应用"><a class="markdownIt-Anchor" href="#实验5-信号量的实现与应用"></a> 实验5 信号量的实现与应用</h1>
<p><a name="omgks"></a></p>
<h2 id="1-前提-2"><a class="markdownIt-Anchor" href="#1-前提-2"></a> 1. 前提</h2>
<p><a name="DxhB5"></a></p>
<h3 id="1-系统调用open打开文件"><a class="markdownIt-Anchor" href="#1-系统调用open打开文件"></a> (1) 系统调用open打开文件</h3>
<p>要使用系统调用方式打开文件，可以使用 open 系统调用。该系统调用的原型定义在 &lt;fcntl.h&gt; 头文件中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，pathname 参数是要打开的文件名，可以是相对路径或绝对路径，可以包含目录名和文件名；flags 参数是打开文件的选项和标志，比如只读、只写、追加、创建等；mode 参数是创建文件时的权限，仅在创建文件时使用，可以指定文件的读写权限。<br />常用的打开选项和标志包括：</p>
<ul>
<li>O_RDONLY：只读模式打开文件。</li>
<li>O_WRONLY：只写模式打开文件。</li>
<li>O_RDWR：读写模式打开文件。</li>
<li>O_CREAT：如果文件不存在则创建文件。</li>
<li>O_TRUNC：如果文件已存在则清空文件内容。</li>
<li>O_APPEND：在文件末尾追加内容。</li>
<li>O_EXCL：在创建文件时，如果文件已存在则返回错误。</li>
</ul>
<p>如果成功打开文件，系统调用返回一个非负整数，即文件描述符（file descriptor），用于后续访问文件内容。如果出错，则返回一个负值，表示出错的类型。<br />对第2个参数flags，可以使用了<code>|</code>运算符将多个选项参数组合在一起。这是因为 open 系统调用的选项参数是一个位掩码，每个选项都有一个对应的位标志，可以使用位运算符组合多个选项。<br />对第3个参数mode，文件的访问权限是一个八进制数，表示文件的所有者、所属组和其他用户对文件的访问权限。<br />每个访问权限位的含义如下：</p>
<ul>
<li>读权限：4</li>
<li>写权限：2</li>
<li>执行权限：1</li>
</ul>
<p>在使用 open 系统调用创建文件时，可以通过一个八进制数来指定文件的访问权限。通常情况下，可以将三个访问权限位组合在一起，得到一个八进制数，作为 mode 参数传递给 open 系统调用。例如，如果要将文件的访问权限设置为所有用户都有<strong>写</strong>权限，可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file&quot;</span>, O_CREAT | O_WRONLY, <span class="number">0222</span>);  <span class="comment">// 0开头的数字表示这是一个八进制数</span></span><br></pre></td></tr></table></figure>
<p><a name="xl1MX"></a></p>
<h3 id="2-系统调用write写入文件"><a class="markdownIt-Anchor" href="#2-系统调用write写入文件"></a> (2) 系统调用write写入文件</h3>
<p>在 C 语言中，write 函数用于向文件或者文件描述符写入数据，其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>write 函数的三个参数分别表示：</p>
<ol>
<li>fd：文件描述符，它是一个整数，用于指定要写入数据的文件或设备。在 Linux 系统中，标准输入、标准输出和标准错误分别对应文件描述符 0、1 和 2。用户可以使用 open 函数打开其他文件或设备，并获得相应的文件描述符。</li>
<li>buf：指向要写入数据的缓冲区的指针。在写入数据之前，用户需要将数据存储在缓冲区中，然后将缓冲区的地址传递给 write 函数。</li>
<li>count：要写入的字节数。用户需要指定要写入数据的长度，以字节数为单位。如果缓冲区中的数据长度小于 count，则 write 函数只会写入部分数据；如果缓冲区中的数据长度大于 count，则 write 函数只会写入 count 字节的数据。</li>
</ol>
<p>当 write() 函数成功写入数据时，内核会更新文件偏移量，以便下一次读写操作从正确的位置开始。<br />需要注意的是，write 函数返回值是 ssize_t 类型，表示成功写入的字节数，如果返回值为负数，则表示写入失败。<br />
<a name="dvXWS"></a></p>
<h3 id="3-系统调用read从文件读取数据"><a class="markdownIt-Anchor" href="#3-系统调用read从文件读取数据"></a> (3) 系统调用read从文件读取数据</h3>
<p>在 Linux 系统中，read() 是一个用于从文件描述符中读取数据的系统调用。该调用的原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>read() 函数有三个参数：</p>
<ol>
<li>fd：要读取的文件的文件描述符。</li>
<li>buf：用于存储读取数据的缓冲区。</li>
<li>count：要读取的字节数。</li>
</ol>
<p>read() 函数会从指定的文件描述符 fd 中读取 count 个字节的数据，并将其存储到 buf 缓冲区中。函数返回实际读取的字节数，如果读取出错，则返回 -1。<br />read() 函数在读取数据时可能会阻塞进程，直到有数据可读或发生错误。如果读取到文件末尾，函数返回 0。如果读取的字节数小于 count，则可能是因为已经到达文件末尾或者因为发生了错误。<br />当使用 read() 函数读取数据时，内核会将文件偏移量更新为读取数据后的下一个位置。例如，如果你使用 read() 函数从文件的位置 100 处读取 50 个字节的数据，则文件偏移量会从 100 更新为 150 (100~149)。这样，下一次读取数据操作将从文件位置 150 处开始。使用 lseek() 函数可以显式地设置文件偏移量。<br />read() 函数可以用于读取文件、套接字、管道等类型的文件描述符。<br />
<a name="QqDWZ"></a></p>
<h3 id="4-系统调用lseek移动文件指针"><a class="markdownIt-Anchor" href="#4-系统调用lseek移动文件指针"></a> (4) 系统调用lseek移动文件指针</h3>
<p>lseek函数用于在文件中移动文件指针的位置。该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>; <span class="comment">// off_t 是long的别名，在&lt;sys/types.h&gt;中定义</span></span><br></pre></td></tr></table></figure>
<p>其中，fd 是已打开文件的文件描述符，offset 是需要移动的偏移量，whence 则用于指定相对于何处进行偏移，其取值可以为 SEEK_SET、SEEK_CUR 或 SEEK_END。这三个常量在&lt;unistd.h&gt; 头文件中定义<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1680944981675-ec549d1d-1e5d-4922-bd94-824e9a2fc219.png#averageHue=%23faf8f6&amp;clientId=u8d570fae-75fa-4&amp;from=paste&amp;height=131&amp;id=PmS6E&amp;originHeight=177&amp;originWidth=1031&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=84788&amp;status=done&amp;style=none&amp;taskId=u91542c12-b250-4808-bb4f-493451efd95&amp;title=&amp;width=763.7037576536784" alt="image.png" /></p>
<ul>
<li>当 whence 值为 SEEK_SET时，文件指针将被设置为相对于文件开头偏移 offset 个字节的位置。</li>
<li>当 whence 值为 SEEK_CUR时，文件指针将被设置为相对于当前位置偏移 offset 个字节的位置。</li>
<li>当 whence 值为 SEEK_END时，文件指针将被设置为相对于文件末尾偏移 offset 个字节的位置。</li>
</ul>
<p>lseek() 函数返回新的文件指针位置，如果出现错误则返回 -1。通过调用 lseek() 函数可以实现随机访问文件的功能，比如读取文件中的任意部分内容、覆盖文件中的任意部分内容等。<br />
<a name="SXM4Y"></a></p>
<h2 id="2-创建semaphore类型"><a class="markdownIt-Anchor" href="#2-创建semaphore类型"></a> 2. 创建semaphore类型</h2>
<p>在<code>include/linux/sem.h</code>写入以下内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SEM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SEM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span>   <span class="comment">// for task_struct definition</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_TABLE_LEN 	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_NAME_LEN	20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="type">char</span> name[SEM_NAME_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">queue</span>;</span>   <span class="comment">// wait queue</span></span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_table[SEM_TABLE_LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="V2My1"></a></p>
<h2 id="3-创建信号量相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建信号量相关的系统调用"></a> 3. 创建信号量相关的系统调用</h2>
<p>在<code>kernel/sem.c</code>中写入以下内容，包括信号量的创建<code>sys_sem_open</code>，P操作<code>sys_sem_wait</code>，V操作<code>sys_sem_post</code>，和释放信号量<code>sys_sem_unlink</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/fdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include&lt;string.h&gt;  // avoid unknowned error</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt;   <span class="comment">// the number of semaphores in sem_table, auto initial to zero</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> * <span class="title function_">sys_sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> value)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> name_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> isExist = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sem_name_len =<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> kernel_sem_name[<span class="number">25</span>]=&#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">	<span class="type">sem_t</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( (c = get_fs_byte(name+name_len))!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        kernel_sem_name[name_len] = c;</span><br><span class="line">        ++name_len;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// printk(&quot;name_len: %d\tstrlen: %d\n&quot;,name_len,strlen(kernel_sem_name));</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(name_len &gt; SEM_NAME_LEN) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;cnt; ++i) <span class="comment">/*find duplicate*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		sem_name_len = <span class="built_in">strlen</span>(sem_table[i].name);</span><br><span class="line">       <span class="comment">// printk(&quot;%d:%s!\t%d:%s!\n&quot;,sem_name_len,sem_table[cnt].name,name_len,kernel_sem_name);</span></span><br><span class="line">		<span class="keyword">if</span>(sem_name_len == name_len &amp;&amp; !<span class="built_in">strcmp</span>(kernel_sem_name, sem_table[i].name))</span><br><span class="line">		&#123;</span><br><span class="line">			isExist = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(isExist) </span><br><span class="line">	&#123;</span><br><span class="line">       <span class="comment">//printk(&quot;i am consumer!\n&quot;);</span></span><br><span class="line">		p = sem_table+i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(sem_table[cnt].name, kernel_sem_name);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// printk(&quot;ID:(%d)\t %d\t%s!\t%d\t%s!\n&quot;,cnt,strlen(sem_table[cnt].name),sem_table[cnt].name,strlen(kernel_sem_name),kernel_sem_name);</span></span><br><span class="line"></span><br><span class="line">		sem_table[cnt].value = value;</span><br><span class="line">		p = sem_table+cnt;</span><br><span class="line">		++cnt;</span><br><span class="line">        <span class="comment">//printk(&quot;i am producer!\n&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">if</span>(--sem-&gt;value &lt; <span class="number">0</span> ) sleep_on(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">if</span>(++sem-&gt;value &lt;= <span class="number">0</span>) wake_up(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> name_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(get_fs_byte(name+name_len)!=<span class="string">&#x27;\0&#x27;</span>) &#123;++name_len;&#125;</span><br><span class="line">	<span class="keyword">if</span>(name_len &gt; SEM_NAME_LEN)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> kernel_sem_name[<span class="number">25</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;name_len; ++i) &#123;kernel_sem_name[i] = get_fs_byte(name+i);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> isExist = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sem_name_len =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;cnt; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_name_len = <span class="built_in">strlen</span>(sem_table[i].name);</span><br><span class="line">		<span class="keyword">if</span>(sem_name_len == name_len &amp;&amp; !<span class="built_in">strcmp</span>(kernel_sem_name, sem_table[i].name))</span><br><span class="line">		&#123;</span><br><span class="line">			isExist = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(isExist)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(tmp=i;i&lt;cnt;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sem_table[tmp] = sem_table[tmp+<span class="number">1</span>]; <span class="comment">// overwrite</span></span><br><span class="line">		&#125;</span><br><span class="line">		--cnt;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将sys_function添加到内核的系统调用已在lab2讲解过，这里只上截图<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191314333-f237a891-d3aa-4009-a70a-caa03b5251f4.png#averageHue=%23320a1c&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=157&amp;id=ucafea307&amp;originHeight=212&amp;originWidth=1043&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=53782&amp;status=done&amp;style=none&amp;taskId=ubdbcf372-278d-4ac4-8df2-a83d86793b1&amp;title=&amp;width=772.5926471705011" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191398952-f295a310-8abb-420f-8dfd-82875874d4d9.png#averageHue=%232e0c2a&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=471&amp;id=u3a5df7fe&amp;originHeight=636&amp;originWidth=1626&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=238875&amp;status=done&amp;style=none&amp;taskId=uc4ed164c-d7db-431b-9e93-835b878669b&amp;title=&amp;width=1204.4445295294677" alt="image.png" /><br />修改Makefile<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191512033-b378a545-c5bb-4d3e-98d1-4666b3b778fb.png#averageHue=%23310a1c&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=121&amp;id=udb2561cb&amp;originHeight=163&amp;originWidth=1167&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38144&amp;status=done&amp;style=none&amp;taskId=ub0cbced6-d5cf-4454-a9af-16ec0f280e6&amp;title=&amp;width=864.4445055110017" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191532529-6e747c92-5ffb-4cff-bbfd-f3f0fee9c7c3.png#averageHue=%23370a1a&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=159&amp;id=ub275bef1&amp;originHeight=215&amp;originWidth=1422&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=63428&amp;status=done&amp;style=none&amp;taskId=u9f808bbe-8499-4256-8136-da26c49b809&amp;title=&amp;width=1053.333407743483" alt="image.png" /><br />
<a name="kx8cN"></a></p>
<h2 id="4-创建生产者-消费者进程"><a class="markdownIt-Anchor" href="#4-创建生产者-消费者进程"></a> 4. 创建生产者-消费者进程</h2>
<p>在<code>pc.c</code>中写入以下内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span>*, sem_open, <span class="type">const</span> <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, value)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_wait, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_post, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span>*, name)</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_CONSUMER = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_PRODUCTS = <span class="number">50</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pro_nr, csm_pro_nr; <span class="comment">/*product number, consumed product number*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* FILENAME = <span class="string">&quot;/usr/root/buffer_file&quot;</span>; <span class="comment">/*default buffer file*/</span></span><br><span class="line"><span class="type">sem_t</span> *mutex, *full, *empty;</span><br><span class="line"><span class="type">int</span> f_in;   <span class="comment">/* for producer*/</span></span><br><span class="line"><span class="type">int</span> f_out;  <span class="comment">/* for consumer*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * file_name = argc &gt; <span class="number">1</span> ? argv[<span class="number">1</span>] : FILENAME;</span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line">	<span class="type">int</span> cnt; <span class="comment">/* must declare cnt here */</span></span><br><span class="line"><span class="comment">/*open buffer file */</span></span><br><span class="line">	f_in = open(file_name, O_CREAT|O_TRUNC|O_WRONLY, <span class="number">0222</span>);</span><br><span class="line">	f_out = open(file_name,O_TRUNC|O_RDONLY, <span class="number">0444</span>);</span><br><span class="line"><span class="comment">/*create semaphores*/</span></span><br><span class="line">	mutex = sem_open(<span class="string">&quot;MUTEX&quot;</span>,<span class="number">1</span>);</span><br><span class="line">	full = sem_open(<span class="string">&quot;FULL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	empty = sem_open(<span class="string">&quot;EMPTY&quot;</span>,BUFFER_SIZE);</span><br><span class="line"><span class="comment">/*parent process as producer*/</span></span><br><span class="line">	pro_nr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(fork())</span><br><span class="line">	&#123;</span><br><span class="line">		pid = getpid();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pid %d:\t producer created!\n&quot;</span>,pid);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		<span class="keyword">while</span>(pro_nr &lt; NR_PRODUCTS) <span class="comment">/*until product all products then producer exit*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			sem_wait(empty);</span><br><span class="line">			sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(!(pro_nr % BUFFER_SIZE)) lseek(f_in, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/*10 products per turn*/</span></span><br><span class="line"></span><br><span class="line">			write(f_in,(<span class="type">char</span>*)&amp;pro_nr, <span class="keyword">sizeof</span>(pro_nr));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pid %d:\t produces product %d!\n&quot;</span>, pid, pro_nr);</span><br><span class="line">			fflush(<span class="built_in">stdout</span>);</span><br><span class="line">			++pro_nr;</span><br><span class="line"></span><br><span class="line">			sem_post(mutex);</span><br><span class="line">			sem_post(full);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*child process create child processes to be consumer*/</span></span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		cnt = NR_CONSUMER;</span><br><span class="line">		<span class="keyword">while</span>(cnt--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!(pid=fork()))</span><br><span class="line">			&#123;</span><br><span class="line">				pid = getpid();</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;pid %d:\t consumer %d created!\n&quot;</span>, pid, NR_CONSUMER-cnt);</span><br><span class="line">				fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(csm_pro_nr == NR_PRODUCTS) <span class="keyword">goto</span> OK;	</span><br><span class="line">					</span><br><span class="line">					sem_wait(full);</span><br><span class="line">					sem_wait(mutex);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(!read(f_out,(<span class="type">char</span>*)&amp;csm_pro_nr, <span class="keyword">sizeof</span>(csm_pro_nr))) <span class="comment">/*end of file,reset*/</span></span><br><span class="line">					&#123;</span><br><span class="line">						lseek(f_out, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">						read(f_out,(<span class="type">char</span>*)&amp;csm_pro_nr, <span class="keyword">sizeof</span>(csm_pro_nr));</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;pid:%d:\t consumer %d consume product %d\n&quot;</span>,pid, NR_CONSUMER-cnt,csm_pro_nr);</span><br><span class="line">					fflush(<span class="built_in">stdout</span>);</span><br><span class="line">					sem_post(mutex);</span><br><span class="line">					sem_post(empty);				</span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">OK:	</span><br><span class="line">	sem_unlink(<span class="string">&quot;MUTEX&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;FULL&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;EMPTY&quot;</span>);</span><br><span class="line"></span><br><span class="line">	close(f_in);</span><br><span class="line">	close(f_out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="d4Zs9"></a></p>
<h2 id="5-验证结果"><a class="markdownIt-Anchor" href="#5-验证结果"></a> 5. 验证结果</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#current catalogue: OSLab5</span></span><br><span class="line">./mount-hdc</span><br><span class="line"><span class="comment">#更新标准库</span></span><br><span class="line"><span class="built_in">cp</span> include/unistd.h hdc/usr/include   </span><br><span class="line"><span class="built_in">cp</span> include/linux/sem.h hdc/usr/include </span><br><span class="line"><span class="comment">#run</span></span><br><span class="line"><span class="built_in">cp</span> pc.c hdc/usr/root</span><br><span class="line">./run</span><br><span class="line"><span class="comment">#在bochs中执行</span></span><br><span class="line">gcc -o pc pc.c</span><br><span class="line">./pc &gt; sem_output <span class="comment"># 将输出结果重定向到文件sem_output，便于查看</span></span><br><span class="line"><span class="built_in">sync</span>  <span class="comment">#将所有的缓存数据写入磁盘，lab3中出现过</span></span><br><span class="line"><span class="comment">#回到ubuntu执行</span></span><br><span class="line">./mount-hdc</span><br><span class="line"><span class="built_in">cp</span> hdc/usr/root/sem_output sem_output</span><br><span class="line">gedit sem_output</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681190311067-7da9d91d-d3ad-429e-aa5f-9b1248637268.png#averageHue=%23222222&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=370&amp;id=ue8d7e426&amp;originHeight=499&amp;originWidth=723&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=31439&amp;status=done&amp;style=none&amp;taskId=u02dc2475-2333-4f29-9398-9089b4f3b91&amp;title=&amp;width=535.555593388564" alt="image.png" /><br />查看sem_output验证信号量机制的正确性<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1681191987779-91ab0753-403e-4c53-b14e-003cf1bc245d.png#averageHue=%232d2c2a&amp;clientId=ue6d07154-992c-4&amp;from=paste&amp;height=551&amp;id=u70a1ec26&amp;originHeight=744&amp;originWidth=915&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=163272&amp;status=done&amp;style=none&amp;taskId=u21388cc9-64a2-48f8-a033-aca3b00b29a&amp;title=&amp;width=677.7778256577262" alt="image.png" /><br />可以看出，producer每生产一轮，即填满容量为10的缓冲区后，5个consumer就开始消耗缓冲区，消耗完后producer又生产一轮，直到达到最大产品数量<code>NR_PRODUCTS = 50</code>(0~49)后退出，consumer在消耗完所有产品后也退出<br /><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mirage-mc/p/12913993.html">reference</a><br />
<a name="UBxgK"></a></p>
<h1 id="实验6-地址映射与共享"><a class="markdownIt-Anchor" href="#实验6-地址映射与共享"></a> 实验6 地址映射与共享</h1>
<p><a name="PCY7K"></a></p>
<h2 id="1-跟踪地址翻译过程"><a class="markdownIt-Anchor" href="#1-跟踪地址翻译过程"></a> 1. 跟踪地址翻译过程</h2>
<ol>
<li>启动调试，获取i的逻辑地址为<code>ds:0x3004</code>，ds表明该地址属于由ds寄存器指示的段 (后续称ds段)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682391942338-17dbc47e-efbe-4991-ac01-66a58fe29761.png#averageHue=%2361d6df&amp;clientId=u2a189deb-d8a3-4&amp;from=paste&amp;height=396&amp;id=u2fe5db91&amp;originHeight=535&amp;originWidth=1762&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=161011&amp;status=done&amp;style=none&amp;taskId=ucdae2cfd-9baf-417b-b5a5-19a5e7b74ce&amp;title=&amp;width=1305.1852773867909" alt="image.png" /></p>
<ol start="2">
<li>通过段表(LDT)，确定ds段的起始地址，进而将逻辑地址转化为虚拟地址。段表由LDTR指示，运行命令<code>sreg</code>查看LDTR的值，该寄存器用于从GDT中取出进程的LDT地址</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682392972667-b8028c87-04e2-4da8-adcf-d9c895eabed1.png#averageHue=%230c0b0a&amp;clientId=ud47c8188-ce02-4&amp;from=paste&amp;height=322&amp;id=u637c9f1f&amp;originHeight=435&amp;originWidth=1050&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=186768&amp;status=done&amp;style=none&amp;taskId=u42a2cb9c-2fc1-4b4e-8722-de778d6716e&amp;title=&amp;width=777.777832721981" alt="image.png" /><br />LDTR的值为<code>0x68 = 0x0000 0000 0110 1000</code>，取3~15位表示段选择子<code>1101</code>，说明目标LDT在GDT的第13项(从0索引)<br />GDT的地址已经由gdtr指出为<code>0x00005cb8</code>，因为GDT每项段描述符占8个字节，因此查看GDT的<code>0x00005cb8+8*13</code>处的8个字节，这8个字节就是目标LDT的段描述符<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682393215941-b8c0d04e-4f8b-4ada-97ad-911b7141413a.png#averageHue=%23393938&amp;clientId=ud47c8188-ce02-4&amp;from=paste&amp;height=84&amp;id=u9a33146e&amp;originHeight=113&amp;originWidth=1195&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=46789&amp;status=done&amp;style=none&amp;taskId=u3711d3a6-2bff-411f-add3-cd062bb1d5f&amp;title=&amp;width=885.1852477169211" alt="image.png" /><br />根据段描述符的结构，从0x<strong>52d0</strong>0068 0x<strong>00</strong>0082<strong>fd</strong>(0~64bits）提取出<code>0x00fd52d0</code>，这就是目标LDT的基地址<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682399305124-bdd7f27d-075f-4c4a-9a65-b7860c7dd623.png#averageHue=%23fefefe&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=177&amp;id=u622fb3b7&amp;originHeight=239&amp;originWidth=803&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=32904&amp;status=done&amp;style=none&amp;taskId=u2a4729cd-97c0-43ac-825d-5ce252d761a&amp;title=&amp;width=594.8148568340483" alt="image.png" /><br />ds段的基地址由ds寄存器(段选择子)在LDT中指示，我们先用<code>sreg</code>查看ds的值<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682399914102-d58b5df4-485d-4607-9f50-2e4b00465752.png#averageHue=%230b0c09&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=125&amp;id=u9052b12d&amp;originHeight=169&amp;originWidth=986&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=77799&amp;status=done&amp;style=none&amp;taskId=ucbc01f60-3bc3-438e-aacd-43cedd3cc58&amp;title=&amp;width=730.3704219655936" alt="image.png" /><br />段选择子ds的值是0x0017 = 0x <strong>0000 0000 0001 0</strong>111 (16bits)，根据段选择子的结构<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682399993383-cfebc5a1-1647-4904-b1c1-9063b2340ec1.png#averageHue=%231e1c1b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=133&amp;id=u32177cff&amp;originHeight=180&amp;originWidth=892&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=11920&amp;status=done&amp;style=none&amp;taskId=ub641d6b7-7444-4531-bc8d-931428ae182&amp;title=&amp;width=660.7407874171496" alt="image.png" /><br />从ds中提取出段选择符的索引<code>0x10</code>，可见ds段在LDT的第3项(从0编号)，于是接下来查看目标LDT的前四项(每项占四个字节)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682400415663-fca789c0-f4cb-4158-a1ee-871abca1e98b.png#averageHue=%232b2b2b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=111&amp;id=u3c133be0&amp;originHeight=150&amp;originWidth=1694&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=50932&amp;status=done&amp;style=none&amp;taskId=ucf49bcf4-23b3-4875-b05d-f39c9cacbcb&amp;title=&amp;width=1254.8149034581293" alt="image.png" /><br />获取了目标LDT中第3个段描述符的数据: 0x<strong>0000</strong>3fff 0x<strong>10</strong>c0f3<strong>00</strong>，根据段描述符的结构，提取出基地址: <code>1000 0000</code>，自此我们可以将<code>i</code>逻辑地址转化为虚拟地址(线性地址)了<br />虚拟地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>0000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>3004</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>1000</mn><mtext> </mtext><mn>3004</mn></mrow><annotation encoding="application/x-tex">base +offset=0x1000\,0000 + 0x3004 =0x1000\,3004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span></p>
<ol start="3">
<li>将虚拟地址映射到的物理地址</li>
</ol>
<p>根据虚拟地址结构，可知<code>0x1000 3004 = 0x0001 0000...0000 0011 000..0 0100</code>表示的物理地址在页目录64对应的页表中，页号为3(页号连续，因此由第3个页表项指示)，页内偏移为4<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682401178166-181bac16-0d2e-47a5-a656-3f6a96a16ea4.png#averageHue=%23050403&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=156&amp;id=u56695781&amp;originHeight=210&amp;originWidth=649&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=11892&amp;status=done&amp;style=none&amp;taskId=ubb61ef02-e3cd-4bab-b8a8-1e21ad2d939&amp;title=&amp;width=480.7407747014911" alt="image.png" /><br />内存中页目录表的位置由寄存器CR3指示，使用<code>creg</code>查看CR3寄存器的值<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682401466094-7fdd4c1a-1ada-4345-960e-2cd27d0154ca.png#averageHue=%232f2e2e&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=187&amp;id=ucb35aee7&amp;originHeight=253&amp;originWidth=1240&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=97062&amp;status=done&amp;style=none&amp;taskId=u2dc0d307-8e48-4cd6-9958-bd26cfd8156&amp;title=&amp;width=918.5185834050061" alt="image.png" /><br />CR3的值为0x00000000，所以页目录表从地址0x00000000开始，我们要获取第64项，页目录表每项占4个字节，因此使用<code>xp /2w 0+64*4</code>查看第64项的内容<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682401965918-a0fffb1d-1153-4de3-93fd-e7c0178570fe.png#averageHue=%23353434&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=90&amp;id=uf298b392&amp;originHeight=121&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=47037&amp;status=done&amp;style=none&amp;taskId=ub64f8ec9-bd77-47ac-8594-bec0aa10c5a&amp;title=&amp;width=808.8889460308602" alt="image.png" /><br />得到第64个页目录项的内容为: 0x<strong>00fa7</strong>027 0x00000000，根据页目录项的结构，前20位表示所指向的页表的地址的高20位 (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26858196/why-does-page-directory-entries-need-20-bits-to-point-210-page-tables">why</a>）为<code>0x00fa7</code>，因为页表物理地址的低12位为0（对齐到4KB的倍数），因此页表的最终的物理地址为<code>0x00fa7000</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682402023037-66c0d317-113a-4a4f-8681-31a71bc759df.png#averageHue=%23e5e5e5&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=242&amp;id=u15511423&amp;originHeight=327&amp;originWidth=551&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=61946&amp;status=done&amp;style=none&amp;taskId=ue2fe15e8-a2cb-4888-8886-e513e46cc59&amp;title=&amp;width=408.14817698077286" alt="image.png" /><br />一个页表项占4个字节，使用<code>xp /2w 0x00fa7000+4*3</code>查找目标页表的第3个页表项(物理页框)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682403935085-f76a7727-58a8-4ede-a0cd-cb73c3bf7051.png#averageHue=%230b0b0b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=84&amp;id=u5f7c6a64&amp;originHeight=113&amp;originWidth=1078&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=62441&amp;status=done&amp;style=none&amp;taskId=u3f8c8e4c-e96f-4f43-9699-47ea9589fe7&amp;title=&amp;width=798.5185749279004" alt="image.png" /><br />得到第3个页表项的内容为0x<strong>00fa6</strong>067 0x00000000<br />根据页表项的结构，前20项表示物理页框的高20位地址: 0x00fa6 (物理页面大小为4KB，基地址与4KB对齐，为 0x**** **** **** **** **** 0000 0000 0000) ,因此目标物理页框的基地址为0x00fa6000<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682403115415-dfde4404-b9c2-4a6c-bb2f-2f2999918190.png#averageHue=%23efefef&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=406&amp;id=u89e16b01&amp;originHeight=548&amp;originWidth=961&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=108043&amp;status=done&amp;style=none&amp;taskId=u4e8e6d00-8b0f-4a14-86a6-41307468cde&amp;title=&amp;width=711.8519021388797" alt="image.png" /><br />最后我们加上页内偏移4，得到最终的物理地址<code>0x00fa6004</code></p>
<ol start="4">
<li>验证</li>
</ol>
<p>执行<code>xp /w 0x00fa6004</code>查看我们确定的物理地址的数据内容<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682404195303-e372e6e4-8bc3-4140-b265-30c690f38f74.png#averageHue=%23272726&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=58&amp;id=u33afc753&amp;originHeight=78&amp;originWidth=822&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=18550&amp;status=done&amp;style=none&amp;taskId=ueddd5279-0ae1-4928-aace-a3f07eb3360&amp;title=&amp;width=608.8889319023508" alt="image.png" /><br />这个值与<code>i</code>在程序中的值相一致<br />用命令<code>setpmem 0x00fa6004 4 0</code>将<code>0x00fa6004</code>开始的4个字节(i为int型)全部设置为0，即设置i为0，则程序从原本的无限循环中退出<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682404491015-b0f59a2a-6474-4d82-b72e-b3f7cca247b0.png#averageHue=%232b2b2b&amp;clientId=u51acf4b0-f2b0-4&amp;from=paste&amp;height=116&amp;id=ud088a520&amp;originHeight=156&amp;originWidth=1326&amp;originalType=binary&amp;ratio=1.3499999046325684&amp;rotation=0&amp;showTitle=false&amp;size=47887&amp;status=done&amp;style=none&amp;taskId=u664cbb0f-3689-4614-8261-b74085ec6eb&amp;title=&amp;width=982.2222916089016" alt="image.png" /><br />
<a name="Thxvd"></a></p>
<h2 id="2-添加共享内存功能"><a class="markdownIt-Anchor" href="#2-添加共享内存功能"></a> 2. 添加共享内存功能</h2>
<p><a name="prXmy"></a></p>
<h3 id="1-前提-通过brk划分虚拟内存"><a class="markdownIt-Anchor" href="#1-前提-通过brk划分虚拟内存"></a> (1) 前提: 通过brk划分虚拟内存</h3>
<p>进程栈和堆之间的内存空间可以映射到共享的物理页面，brk作为指向进程堆的末尾的指针（即下图中处于下方的虚线），将brk加上进程数据段在虚拟内存中的基址，便可以得到brk的虚拟地址，以这个地址为起点，划分出大小为PAGE_SIZE的虚拟内存，再将这部分虚拟内存通过<code>put_page</code>映射到共享内存上<br /><img src="https://i.stack.imgur.com/1aV6B.png#from=url&amp;id=Lavvc&amp;originHeight=193&amp;originWidth=128&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" /><br />
<a name="loSCp"></a></p>
<h3 id="2-创建用于管理共享内存的数据结构"><a class="markdownIt-Anchor" href="#2-创建用于管理共享内存的数据结构"></a> (2) 创建用于管理共享内存的数据结构</h3>
<p><code>linux-0.11/include/linux/shm.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SHM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SHM</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 32 <span class="comment">/*Maximum number of shared pages*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">key_t</span> key;  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> size;  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> page; <span class="comment">/*shared page address */</span></span><br><span class="line">&#125;shm;</span><br><span class="line"></span><br><span class="line">shm shm_list[SHM_SIZE] =&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="VLVYG"></a></p>
<h3 id="3-创建共享内存相关的系统调用"><a class="markdownIt-Anchor" href="#3-创建共享内存相关的系统调用"></a> (3) 创建共享内存相关的系统调用</h3>
<p><code>linux-0.11/kernel/shm.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> <span class="comment">/*for current define*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span> <span class="comment">/* PAGE_SIZE,get_free_page */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*function: apply for a shared page, return shm_id according to key*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">void</span>* page;</span><br><span class="line">      <span class="comment">/*printk(&quot;hello, i am here for debug!\n&quot;);*/</span></span><br><span class="line">        <span class="keyword">if</span>(size &gt; PAGE_SIZE) <span class="comment">/*size beyond border*/</span></span><br><span class="line">        &#123;</span><br><span class="line">                printk(<span class="string">&quot;size beyond PAGE_SIZE!\n&quot;</span>);</span><br><span class="line">                errno = EINVAL;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;SHM_SIZE; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(shm_list[i].key == key)   <span class="comment">/*constructed before*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                        printk(<span class="string">&quot;constructed before!\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page = get_free_page();</span><br><span class="line">        <span class="keyword">if</span>(!page)   <span class="comment">/*no free memory*/</span></span><br><span class="line">        &#123;</span><br><span class="line">                printk(<span class="string">&quot;no free page!\n&quot;</span>);</span><br><span class="line">                errno = ENOMEM;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;shmget get memory&#x27;s address is 0x%08x\n&quot;</span>,page);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;SHM_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (!shm_list[i].key) <span class="comment">// record for manage</span></span><br><span class="line">                &#123;</span><br><span class="line">                        shm_list[i].key = key; </span><br><span class="line">                        shm_list[i].page = page;</span><br><span class="line">                        shm_list[i].size = size;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/*shm_list is full and key is invalid*/</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sys_shmat</span><span class="params">(<span class="type">int</span> shmid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> data_base;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> brk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(shmid&lt;<span class="number">0</span> || shmid&gt;=SHM_SIZE || shm_list[shmid].page == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                errno = EINVAL;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data_base = get_base(current-&gt;ldt[<span class="number">2</span>]); <span class="comment">/*I know get_base from copy_mem() function*/</span></span><br><span class="line">        printk(<span class="string">&quot;current data_base = 0x%08x, new page = 0x%08x\n&quot;</span>,data_base,shm_list[shmid].page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk is the end of heap section,</span></span><br><span class="line"><span class="comment">         * the virtual memory space between heap and stack can map to shared physical page,</span></span><br><span class="line"><span class="comment">         * so slice this part of virtual memory to map the shared page */</span></span><br><span class="line">        <span class="comment">/*logic address convert to virtual address by adding base address*/</span></span><br><span class="line">        brk = current-&gt;brk+data_base;</span><br><span class="line">        current-&gt;brk +=PAGE_SIZE;</span><br><span class="line">        put_page(shm_list[shmid].page, brk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)(current-&gt;brk - PAGE_SIZE); <span class="comment">/*logic address*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="wE6Zi"></a></p>
<h3 id="4-创建生产者进程"><a class="markdownIt-Anchor" href="#4-创建生产者进程"></a> (4) 创建生产者进程</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span>*, sem_open, <span class="type">const</span> <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, value)</span><br><span class="line">    _syscall1(<span class="type">void</span>, sem_wait, <span class="type">sem_t</span>*, sem)</span><br><span class="line">    _syscall1(<span class="type">void</span>, sem_post, <span class="type">sem_t</span>*, sem)</span><br><span class="line">    _syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span>*, name)</span><br><span class="line"></span><br><span class="line">    _syscall2(<span class="type">int</span>, shmget, <span class="type">unsigned</span> <span class="type">int</span>, key, <span class="type">size_t</span>, size)</span><br><span class="line">    _syscall1(<span class="type">void</span>*, shmat, <span class="type">int</span>, shmid)</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NR_PRODUCTS = <span class="number">50</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHM_KEY = <span class="number">2023</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">int</span>* ptr;  <span class="comment">/*point to the shared memory*/</span></span><br><span class="line">    <span class="type">int</span> i;    <span class="comment">/* products number */</span></span><br><span class="line">    <span class="type">int</span> buffer_pos = <span class="number">0</span>; </span><br><span class="line">    <span class="type">sem_t</span> *mutex, *full, *empty;</span><br><span class="line"></span><br><span class="line">    mutex = sem_open(<span class="string">&quot;MUTEX&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    full = sem_open(<span class="string">&quot;FULL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    empty = sem_open(<span class="string">&quot;EMPTY&quot;</span>,BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    shm_id = shmget(SHM_KEY,BUFFER_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (shm_id == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ptr = (<span class="type">int</span>*)shmat(shm_id)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NR_PRODUCTS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(empty);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        ptr[buffer_pos] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid %d:\tproducer produces product %d\n&quot;</span>, getpid(), i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(full);</span><br><span class="line"></span><br><span class="line">        buffer_pos = (buffer_pos+<span class="number">1</span>)%BUFFER_SIZE;  <span class="comment">/*end of the buffer,refresh*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="GfZrr"></a></p>
<h3 id="5-创建消费者进程"><a class="markdownIt-Anchor" href="#5-创建消费者进程"></a> (5) 创建消费者进程</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span>*, sem_open, <span class="type">const</span> <span class="type">char</span>*, name, <span class="type">unsigned</span> <span class="type">int</span>, value)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_wait, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">void</span>, sem_post, <span class="type">sem_t</span>*, sem)</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span>*, name)</span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">int</span>, shmget, <span class="type">unsigned</span> <span class="type">int</span>, key, <span class="type">size_t</span>, size)</span><br><span class="line">_syscall1(<span class="type">void</span>*, shmat, <span class="type">int</span>, shmid)</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_PRODUCTS = <span class="number">50</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHM_KEY = <span class="number">2023</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">    <span class="type">int</span> used_cnt = <span class="number">0</span>; <span class="comment">/*products count*/</span></span><br><span class="line">    <span class="type">int</span> buffer_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">sem_t</span> *mutex, *full, *empty;</span><br><span class="line">	mutex = sem_open(<span class="string">&quot;MUTEX&quot;</span>,<span class="number">1</span>);</span><br><span class="line">	full = sem_open(<span class="string">&quot;FULL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	empty = sem_open(<span class="string">&quot;EMPTY&quot;</span>,BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    shm_id = shmget(SHM_KEY,BUFFER_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (shm_id == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ptr = (<span class="type">int</span>*)shmat(shm_id)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(full);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid %d consumer consumes products %d\n&quot;</span>,getpid(),ptr[buffer_pos]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(empty);</span><br><span class="line"></span><br><span class="line">        buffer_pos = (buffer_pos+<span class="number">1</span>)%BUFFER_SIZE;  <span class="comment">/*end of the buffer,refresh*/</span></span><br><span class="line">        <span class="keyword">if</span>(++used_cnt == NR_PRODUCTS) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_unlink(<span class="string">&quot;EMPTY&quot;</span>);</span><br><span class="line">    sem_unlink(<span class="string">&quot;MUTEX&quot;</span>);</span><br><span class="line">    sem_unlink(<span class="string">&quot;FULL&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="krol7"></a></p>
<h3 id="6-添加到系统调用和修改makefile"><a class="markdownIt-Anchor" href="#6-添加到系统调用和修改makefile"></a> (6) 添加到系统调用和修改MakeFile</h3>
<ol>
<li>添加到系统调用</li>
</ol>
<p>如之前的lab一样，验证结果时将unistd.h复制到hdc/usr/include目录下，记得将shm.h也复制到对应目录中<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520527179-52dba4f9-2fca-42f4-a647-f84bcc96483c.png#averageHue=%23020101&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=283&amp;id=u569df7d6&amp;originHeight=378&amp;originWidth=1131&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=78872&amp;status=done&amp;style=none&amp;taskId=udd4d35b1-2183-47dc-b07a-d9ed4a2cf95&amp;title=&amp;width=846.1817626953125" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520564992-dc556e6f-47fa-458d-8125-5a2f99510aa5.png#averageHue=%230a0908&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=368&amp;id=u9b1b2c93&amp;originHeight=652&amp;originWidth=1557&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=184908&amp;status=done&amp;style=none&amp;taskId=u80068af6-8005-48d8-9237-55e59b18553&amp;title=&amp;width=877.6334228515625" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520600836-449dd10e-b55b-47f2-bf13-145e43483016.png#averageHue=%23040202&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=334&amp;id=u2a625bd5&amp;originHeight=436&amp;originWidth=1164&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=89550&amp;status=done&amp;style=none&amp;taskId=u7b41d7f9-6266-4a0a-a74f-eccd206e206&amp;title=&amp;width=892.1817626953125" alt="image.png" /></p>
<ol start="2">
<li>修改MakeFile</li>
</ol>
<p><code>linux-0.11/kernel/Makefile</code><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520876366-81586b4c-c432-4e3c-8e53-e64cff3cdaa4.png#averageHue=%23050404&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=152&amp;id=u00d33052&amp;originHeight=167&amp;originWidth=1093&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=25627&amp;status=done&amp;style=none&amp;taskId=ubd76bfd9-0a7c-475b-a3b2-3b08f53f50f&amp;title=&amp;width=993.636342099876" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520946452-d6ac0a1c-64c6-4e8e-9d73-1d25e0cceeb8.png#averageHue=%23080706&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=221&amp;id=u609f0929&amp;originHeight=385&amp;originWidth=1891&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=110463&amp;status=done&amp;style=none&amp;taskId=u7504a2f2-1ac2-4237-a4ad-93c287b33b0&amp;title=&amp;width=1086.6334228515625" alt="image.png" /><br />
<a name="eTe1e"></a></p>
<h3 id="7-踩的坑"><a class="markdownIt-Anchor" href="#7-踩的坑"></a> (7) 踩的坑</h3>
<ol>
<li>编译shm.c时，总是出现<code>parse error before int</code>的错误，耗时调试了一个小时还是无法解决，Google后发现原因在于linux0.11下的C标准为C89，要求声明变量的语句只能出现在非声明语句的前面 (声明同时又赋值语句的可以)</li>
<li>lab5的sem.c写的有问题，consumer进程一直处于sleep状态，添加了几条打印语句后发现，consumer进程和producer进程未使用同一套信号量，原因在于sem.c的sys_sem_open函数内定义kernel_sem_name未显式的初始化，我以为该变量会<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18688971/c-char-array-initialization-what-happens-if-there-are-less-characters-in-the-st">默认初始化为0值</a> (‘\0’)，但在c89的标准下，未显式初始化的字符数组不会被默认初始化，这将导致未知的行为，发现这点花了我不少时间。在显式初始化<code>char kernel_sem_name[25]=&#123;&quot;\0&quot;&#125;;</code>后结果正确</li>
<li>consumer进程会出现&quot;kernel panic: trying to free free page&quot;，出现这个问题的原因是producer进程和consumer进程共用一个页面，producer生产完全部产品后先退出同时释放共享内存，这将导致consumer进程退出时试图释放已经释放的页面，解决方法是注释掉memery.c文件中free_page函数中的相关panic语句</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682520309825-394372a9-02a9-4c5f-9dc2-58ee03e3ed95.png#averageHue=%23050403&amp;clientId=u4414e13a-93d5-4&amp;from=paste&amp;height=525&amp;id=ufc7965e9&amp;originHeight=577&amp;originWidth=1085&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=113475&amp;status=done&amp;style=none&amp;taskId=ub39a6e29-54eb-479a-974d-29d06b20ef8&amp;title=&amp;width=986.3636149847807" alt="image.png" /><br />
<a name="LfbWf"></a></p>
<h2 id="3-验证结果"><a class="markdownIt-Anchor" href="#3-验证结果"></a> 3. 验证结果</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682510527892-a3dc49b2-e1cb-46bb-96c5-fe0e7e047d40.png#averageHue=%23272726&amp;clientId=uba223810-dc1f-4&amp;from=paste&amp;height=452&amp;id=u977d19ee&amp;originHeight=508&amp;originWidth=779&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=43535&amp;status=done&amp;style=none&amp;taskId=u31918d60-b5af-4e51-a992-7b44e3423cc&amp;title=&amp;width=693.116455078125" alt="image.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./mount-hdc</span><br><span class="line">cp hdc/usr/root/c_output c_output.txt</span><br><span class="line">cp hdc/usr/root/p_output p_output.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682510598690-ebda0760-043b-4bd9-b4bc-9f315b8a4cba.png#averageHue=%23090807&amp;clientId=uba223810-dc1f-4&amp;from=paste&amp;height=358&amp;id=uc2dd2f1e&amp;originHeight=590&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=125426&amp;status=done&amp;style=none&amp;taskId=uf6ab358f-a3c6-4563-94bb-da662b0e4e8&amp;title=&amp;width=611.5151161705297" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1682510624205-9d8041cb-2d82-441f-b820-b7426cf66505.png#averageHue=%230e0c0b&amp;clientId=uba223810-dc1f-4&amp;from=paste&amp;height=383&amp;id=ub33ee8cf&amp;originHeight=632&amp;originWidth=911&amp;originalType=binary&amp;ratio=1.6500000953674316&amp;rotation=0&amp;showTitle=false&amp;size=128917&amp;status=done&amp;style=none&amp;taskId=ue065134f-aa21-4611-a01c-608e7acf726&amp;title=&amp;width=552.1211802094673" alt="image.png" /><br />
<a name="af4rt"></a></p>
<h1 id="实验7-终端设备的控制"><a class="markdownIt-Anchor" href="#实验7-终端设备的控制"></a> 实验7 终端设备的控制</h1>
<p><a name="DOBmZ"></a></p>
<h2 id="1-添加新的f12响应函数"><a class="markdownIt-Anchor" href="#1-添加新的f12响应函数"></a> 1. 添加新的f12响应函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> switch_by_f12_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">press_f12_handle</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (switch_by_f12_flag) &#123;</span><br><span class="line">        switch_by_f12_flag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        switch_by_f12_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683088730582-9f8b8b48-b558-4aa7-89bf-e102157de2fd.png#averageHue=%232a2e37&amp;clientId=u3918d10e-6997-4&amp;from=paste&amp;height=233&amp;id=ub2b26a91&amp;originHeight=349&amp;originWidth=878&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=54042&amp;status=done&amp;style=none&amp;taskId=uc6734c4c-d973-4e3e-a381-9fccec6e2d4&amp;title=&amp;width=585.3333333333334" alt="image.png" /><br />
<a name="uYQSo"></a></p>
<h2 id="2-设置响应函数入口"><a class="markdownIt-Anchor" href="#2-设置响应函数入口"></a> 2. 设置响应函数入口</h2>
<p>键盘输入后，操作系统会将键盘扫描码做为下标，调用key_table函数数组中保存的与该按键对应的响应函数，因此要让CPU在按下f12之后跳转到新的响应函数执行需要修改key_table，从该数组一旁的注释就可以看出f12对应的scan code是88D (58H)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683098473823-070b4fb1-1f7a-4a45-9cb0-961bb203c5c9.png#averageHue=%232a2e38&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=135&amp;id=u7de7afa4&amp;originHeight=202&amp;originWidth=1049&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=54945&amp;status=done&amp;style=none&amp;taskId=ub84941cf-e8e4-4871-8ba7-82283d9a8a6&amp;title=&amp;width=699.3333333333334" alt="image.png" /><br />
<a name="deXFF"></a></p>
<h2 id="3-修改con_write函数"><a class="markdownIt-Anchor" href="#3-修改con_write函数"></a> 3. 修改con_write函数</h2>
<p>con_write函数执行最终的输出显示器操作，该函数先用GETCH从输出缓冲区中提取一个字节字符到变量<code>c</code>，再写入显存中。我们根据flag修改变量<code>c</code>的值即可，为了实验结果更可观，我们选择只对字母和数字的输出进行转换<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683099712562-f91a9cf7-9e84-48c2-93e3-579a4f5ae4b5.png#averageHue=%23292e37&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=319&amp;id=u15b1877a&amp;originHeight=479&amp;originWidth=1191&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=81623&amp;status=done&amp;style=none&amp;taskId=uaa55ccf7-f1cd-41f6-8464-e0155d69970&amp;title=&amp;width=794" alt="image.png" /><br />
<a name="EB7eC"></a></p>
<h2 id="4-修改ttyh"><a class="markdownIt-Anchor" href="#4-修改ttyh"></a> 4. 修改tty.h</h2>
<p>在头文件中包含<code>switch_by_f12_flag</code>变量和响应函数的声明，以便在其他文件中使用<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683098924984-6c3708f3-4872-4e7b-ad63-08a64288554e.png#averageHue=%232a2f39&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=281&amp;id=uf5d8217e&amp;originHeight=422&amp;originWidth=874&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=72774&amp;status=done&amp;style=none&amp;taskId=u57c1131d-6702-4fab-a6e7-85f3a862c71&amp;title=&amp;width=582.6666666666666" alt="image.png" /><br />
<a name="eWnw0"></a></p>
<h2 id="5-验证结果-2"><a class="markdownIt-Anchor" href="#5-验证结果-2"></a> 5. 验证结果</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683100157855-0a67f662-2689-4526-8f5e-9a36485b54a8.png#averageHue=%23d6b078&amp;clientId=ubcc39749-940b-4&amp;from=paste&amp;height=361&amp;id=ucf7e2da6&amp;originHeight=542&amp;originWidth=921&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=48978&amp;status=done&amp;style=none&amp;taskId=uf25e680f-9f62-495d-9d8a-e452c1bff0f&amp;title=&amp;width=614" alt="image.png" /><br />
<a name="LY6DX"></a></p>
<h1 id="实验8-proc文件系统的实现"><a class="markdownIt-Anchor" href="#实验8-proc文件系统的实现"></a> 实验8 proc文件系统的实现</h1>
<p><a name="wqaCO"></a></p>
<h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2>
<p><a name="SCacJ"></a></p>
<h3 id="vsprintf函数"><a class="markdownIt-Anchor" href="#vsprintf函数"></a> vsprintf函数</h3>
<p>vsprintf 是一个C库函数，用于将可变参数列表（va_list）中的值格式化为字符串，并将结果字符串存储在指定的字符数组（缓冲区）中。vsprintf 是 sprintf 函数的可变参数版本，通常在需要处理可变数量参数的情况下使用。<br />vsprintf 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>str：指向目标字符数组（缓冲区）的指针，用于存储格式化后的字符串。</li>
<li>format：一个格式字符串，它描述了如何将参数列表中的值格式化为字符串。格式字符串可以包含普通字符和转换说明符（例如 %d、%s 等）。</li>
<li>ap：一个 va_list 类型的参数列表，用于存储需要格式化的值。</li>
</ol>
<p>返回值：vsprintf 函数返回写入目标字符数组（不包括最后的空字符）的字符数。如果发生错误，返回负值。<br />因为该函数接受一个va_list类型的参数而不是一个通常使用的可变参数，因此我们要使用va_start函数获取一个va_list的参数<br />va_start 是C语言标准库中的一个宏，用于处理可变参数列表。va_start 用于在可变参数函数中初始化一个 va_list 类型的变量，使其指向传入的第一个可变参数。通常与 va_arg 和 va_end 宏一起使用，分别用于访问可变参数列表中的参数和完成参数列表的处理 (va_end释放为 va_list 类型的变量分配的资源)。<br />va_start 宏的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list ap, last_arg)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>ap：一个 va_list 类型的变量，用于存储指向可变参数列表的状态。</li>
<li>last_arg：函数参数列表中最后一个<strong>固定参数</strong>的名称 (可变参数在固定参数之后)。在初始化 va_list 时，va_start 会找到此固定参数在内存中的位置，从而确定可变参数列表的起始位置。<br />
<a name="HKqfx"></a></li>
</ol>
<h3 id="mknod系统调用"><a class="markdownIt-Anchor" href="#mknod系统调用"></a> mknod系统调用</h3>
<p>mknod 系统调用用于创建特殊文件（设备文件）在文件系统中。特殊文件通常用于表示设备，如字符设备和块设备。字符设备通常用于表示可逐字符读写的设备，如终端设备；块设备通常用于表示可按块读写的设备，如磁盘设备。本实验用它来创建proc文件。<br />mknod 系统调用的主要参数包括：</p>
<ol>
<li>路径名（pathname）：要创建的特殊文件的路径名。</li>
<li>文件模式（mode）：描述新创建的特殊文件类型和权限的位掩码。文件类型可以是字符设备（S_IFCHR）或块设备（S_IFBLK）。</li>
<li>设备号（dev）：设备号用于唯一标识设备。通常分为主设备号和次设备号。主设备号用于标识设备类型或驱动程序，而次设备号用于标识同一类型设备的实例。</li>
</ol>
<p>当调用 mknod 系统调用时，操作系统会执行以下操作：</p>
<ol>
<li>根据提供的路径名找到目标目录。</li>
<li>在目标目录中创建一个新的目录项，设置其文件名和 inode 号(更新目录树)。</li>
<li>分配一个新的 inode，并将其与目录项关联。</li>
<li>设置 inode 的属性，如文件类型（字符设备或块设备）、权限和设备号等。</li>
<li>更新文件系统元数据，如目录和 inode 的更改时间等。</li>
</ol>
<p>创建特殊文件后，应用程序可以使用设备文件与相应的设备进行通信。例如，通过 open、read、write 和 ioctl 系统调用与设备驱动程序进行交互。这使得设备操作看起来与普通文件操作相似，简化了应用程序的开发。<br />
<a name="L6DWu"></a></p>
<h2 id="添加proc类型文件"><a class="markdownIt-Anchor" href="#添加proc类型文件"></a> 添加proc类型文件</h2>
<p>OS根据文件类型选择不同处理函数，从而实现对不同类型的文件的操作，我们先在linux0.11中添加proc类型文件，之后再编写对应的处理函数就能完成proc文件系统的添加了。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683344038857-05b21492-6ac6-44e0-b550-cfa4e091c11f.png#averageHue=%232a2f39&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=453&amp;id=ub1b8ac4b&amp;originHeight=566&amp;originWidth=939&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=117376&amp;status=done&amp;style=none&amp;taskId=u902c17e5-7d02-45ea-a89f-cb91bafcf81&amp;title=&amp;width=751.2" alt="image.png" /><br />
<a name="J0puW"></a></p>
<h2 id="修改mknod系统调用"><a class="markdownIt-Anchor" href="#修改mknod系统调用"></a> 修改mknod系统调用</h2>
<p>我们已经提到，mknod用于创建特殊文件，即块设备文件和字符流文件。现在我们要给它添加对proc文件的支持。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683344565695-25d10cda-e3c2-4db0-b456-342d34252c93.png#averageHue=%232c333d&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=148&amp;id=u81eb111d&amp;originHeight=185&amp;originWidth=955&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42267&amp;status=done&amp;style=none&amp;taskId=u5e6d4240-b9ac-400f-8674-5c86c82cae3&amp;title=&amp;width=764" alt="image.png" /><br />
<a name="Z3MKP"></a></p>
<h2 id="创建proc目录文件proc普通文件"><a class="markdownIt-Anchor" href="#创建proc目录文件proc普通文件"></a> 创建proc目录文件，proc普通文件</h2>
<p>在系统初始化时，根目录文件挂载之后 (这样传递给mknod的路径才有效)，创建proc文件系统的目录文件和文件。<br />因为此时在用户态，因此要通过添加系统调用的方式使用mkdir和mknod，而不能直接使用sys_mkdir和sys_mknod<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683346720336-d633b22f-bc22-4b07-a373-54bac4c02511.png#averageHue=%232a2f39&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=169&amp;id=u77aca2e7&amp;originHeight=211&amp;originWidth=1192&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=54630&amp;status=done&amp;style=none&amp;taskId=ua835db87-8c11-40fc-8647-5f478bb0d3a&amp;title=&amp;width=953.6" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683344746244-3a83df22-0727-478b-b33c-7629995477af.png#averageHue=%232a2f39&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=386&amp;id=uf6850421&amp;originHeight=483&amp;originWidth=992&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=106228&amp;status=done&amp;style=none&amp;taskId=ua5ef05d2-fdcd-43b0-8e65-129289cd21d&amp;title=&amp;width=793.6" alt="image.png" /><br />
<a name="gW5xS"></a></p>
<h2 id="验证文件是否创建成功"><a class="markdownIt-Anchor" href="#验证文件是否创建成功"></a> 验证文件是否创建成功</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683345269096-07a4e3fa-4d74-4671-b7b4-8788f81f56f1.png#averageHue=%231c1c1c&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=179&amp;id=ubff94101&amp;originHeight=224&amp;originWidth=525&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=9192&amp;status=done&amp;style=none&amp;taskId=u6a360e8c-a94f-4bb8-b4d0-bef4f08b435&amp;title=&amp;width=420" alt="image.png" /><br />可以看到，我们已经成功在根目录下创建了proc目录文件，并在该文件下创建了proc普通文件，这三个文件分别表示系统进程信息，系统硬件信息，系统存储信息<br />这里使用cat输出了一行信息和一行报错，要明白这两条信息怎么来的，首先要知道cat命令背后执行了什么操作: 用sys_open打开一个文件，用sys_read将文件内容读入缓冲区，最后用printf打印缓冲区的内容到屏幕上<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683345351627-af875807-b6e7-4414-87dc-3931056261db.png#averageHue=%23fefbf6&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=114&amp;id=u0eb7e43e&amp;originHeight=142&amp;originWidth=741&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=60182&amp;status=done&amp;style=none&amp;taskId=u5688375e-3cee-4ccd-8b3f-87e4ee3d67a&amp;title=&amp;width=592.8" alt="image.png" /><br />通过查看sys_read的源码，我们可以找到这两条信息的来源。当sys_read打开proc类型文件没有对应的处理函数时，就会出现这两条信息，因此我们接下来为proc类型文件编写对应的处理函数proc_read即可<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683345501591-9a30e972-a450-4a62-b646-c3cf609c774a.png#averageHue=%232a303a&amp;clientId=u9002f12d-0e7b-4&amp;from=paste&amp;height=574&amp;id=ub3f0c372&amp;originHeight=718&amp;originWidth=1163&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=158548&amp;status=done&amp;style=none&amp;taskId=ua74627e7-72f8-428b-9e9d-f492c9565ed&amp;title=&amp;width=930.4" alt="image.png" /><br />为proc文件添加处理分支<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683359020684-3518ed23-5359-432a-be5e-d9fa88f8691e.png#averageHue=%232a2f38&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=193&amp;id=u47a43b1e&amp;originHeight=241&amp;originWidth=1203&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47427&amp;status=done&amp;style=none&amp;taskId=ue8f26e3f-5760-413d-8759-456062cf094&amp;title=&amp;width=962.4" alt="image.png" /><br />
<a name="PNhv9"></a></p>
<h2 id="编写proc文件处理函数"><a class="markdownIt-Anchor" href="#编写proc文件处理函数"></a> 编写proc文件处理函数</h2>
<p>添加<code>linux-0.11/fs/proc_read.c</code>，这里只完成了进程信息的获取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span>  <span class="comment">// put_fs_byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span>  <span class="comment">// process-related variables: task struct, FIRST_TASK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>       <span class="comment">//  vs_start va_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> krnbuf[<span class="number">1024</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// initalize args to first changeable parameter</span></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="comment">// vsprintf function returns the number of characters written to the buffer</span></span><br><span class="line">    i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_psinfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> buf_offset = <span class="number">0</span>;</span><br><span class="line">    buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;pid\tstate\tfather\tcounter\tstart_time\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;LAST_TASK; p &gt;= &amp;FIRST_TASK; --p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;pid);</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;state);</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;father);</span><br><span class="line">            buf_offset += <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\t&quot;</span>, (*p)-&gt;counter);</span><br><span class="line">            buf_offset +=</span><br><span class="line">                <span class="built_in">sprintf</span>(krnbuf + buf_offset, <span class="string">&quot;%d\n&quot;</span>, (*p)-&gt;start_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_read</span><span class="params">(<span class="type">int</span> dev, <span class="type">off_t</span> *pos, <span class="type">char</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (*pos / BLOCK_SIZE == <span class="number">0</span>)  <span class="comment">// already read a whole block, start write</span></span><br><span class="line">    &#123;</span><br><span class="line">        get_psinfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (krnbuf[*pos + i] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;  <span class="comment">// end of message</span></span><br><span class="line">        put_fs_byte(krnbuf[*pos + i],</span><br><span class="line">                    buf + i + *pos);  <span class="comment">// synchronous replication</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pos += i; <span class="comment">// change f_pos</span></span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// return the actual number of bytes read</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="ej6HQ"></a></p>
<h2 id="修改makefile"><a class="markdownIt-Anchor" href="#修改makefile"></a> 修改Makefile</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683359075672-0ca43074-35e7-4167-97fa-921965a0eee0.png#averageHue=%232b3038&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=290&amp;id=u7d54a842&amp;originHeight=362&amp;originWidth=1110&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=63292&amp;status=done&amp;style=none&amp;taskId=u92de2be4-4696-4b77-b24a-9546f172053&amp;title=&amp;width=888" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683359107388-9a8e3ccf-81d7-4d45-b5ff-0eadbe9eaf32.png#averageHue=%232f353f&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=138&amp;id=uef988170&amp;originHeight=173&amp;originWidth=1139&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38277&amp;status=done&amp;style=none&amp;taskId=u4190510b-24d2-419c-b480-af056ec9165&amp;title=&amp;width=911.2" alt="image.png" /><br />
<a name="GwS7w"></a></p>
<h2 id="验证结果"><a class="markdownIt-Anchor" href="#验证结果"></a> 验证结果</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29536731/1683358947951-c0766d83-d70a-46b7-8dbd-f0880676086b.png#averageHue=%23202020&amp;clientId=u511059e4-198a-4&amp;from=paste&amp;height=394&amp;id=u29a576cb&amp;originHeight=493&amp;originWidth=801&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=24025&amp;status=done&amp;style=none&amp;taskId=u18bf1a2d-4fd4-431e-a56b-c40069b6f49&amp;title=&amp;width=640.8" alt="image.png" /><br /><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mirage-mc/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/">reference</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Elite-X</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/06/Learning-OS/HIT-Labs/">http://example.com/2023/05/06/Learning-OS/HIT-Labs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Foundation/">Foundation</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/27/ubuntu_mac/" title="ubuntu界面Mac化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">ubuntu界面Mac化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/10/25/D-A-C++/" title="《数据结构与算法C++》学习历程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">《数据结构与算法C++》学习历程</div></div></a></div><div><a href="/2023/02/04/assembly/" title="汇编语言【王爽】实验流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-04</div><div class="title">汇编语言【王爽】实验流程</div></div></a></div><div><a href="/2023/03/16/CSAPP-Lab/cachelab/" title="[CSAPP] cachelab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">[CSAPP] cachelab</div></div></a></div><div><a href="/2023/03/06/CSAPP-Lab/datalab-bomblab-attacklab/" title="[CSAPP] datalab, bomblab, attacklab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">[CSAPP] datalab, bomblab, attacklab</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Elite-X</div><div class="author-info__description">xun's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Elite-zx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">Here is my cosmos</div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC"><span class="toc-number">1.</span> <span class="toc-text"> 实验1 操作系统的引导</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%94%B9%E5%86%99bootsects"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. 改写bootsect.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%94%B9%E5%86%99setups"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 改写setup.s</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#task1"><span class="toc-number">1.2.1.</span> <span class="toc-text"> task1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task2"><span class="toc-number">1.2.2.</span> <span class="toc-text"> task2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> 实验2 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0iam-whoami"><span class="toc-number">2.1.</span> <span class="toc-text"> 1. 编写接口函数iam, whoami</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9unistdh"><span class="toc-number">2.2.</span> <span class="toc-text"> 2. 修改unistd.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9_sys_call_table%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 3. 修改_sys_call_table函数表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0sys_whoami-sys_iam"><span class="toc-number">2.4.</span> <span class="toc-text"> 4. 实现函数sys_whoami, sys_iam</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A7%E8%A1%8C"><span class="toc-number">2.5.</span> <span class="toc-text"> 5. 执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C"><span class="toc-number">2.6.</span> <span class="toc-text"> 6. 验证结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C3-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text"> 实验3 进程运行轨迹的跟踪与统计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E6%8F%90"><span class="toc-number">3.1.</span> <span class="toc-text"> 1. 前提</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8times"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 1.1. 系统调用times</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8wait"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 1.2. 系统调用wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-linux011%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84state%E5%80%BC"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 1.3. linux0.11中进程的state值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-processc"><span class="toc-number">3.2.</span> <span class="toc-text"> 2. process.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%9F%E6%88%90log%E7%9A%84%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text"> 3. 生成log的前置工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E6%88%90log"><span class="toc-number">3.4.</span> <span class="toc-text"> 4. 生成log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%86%E6%9E%90log"><span class="toc-number">3.5.</span> <span class="toc-text"> 5. 分析log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E7%89%87%E9%87%8D%E6%96%B0%E5%88%86%E6%9E%90log"><span class="toc-number">3.6.</span> <span class="toc-text"> 6. 修改时间片，重新分析log</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C4-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 实验4 基于内核栈切换的进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9schedule%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text"> 1.  修改schedule函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9switch_to%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text"> 2. 修改switch_to函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9copy_process%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text"> 3.  修改copy_process函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text"> 实验5 信号量的实现与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E6%8F%90-2"><span class="toc-number">5.1.</span> <span class="toc-text"> 1. 前提</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8open%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.1.</span> <span class="toc-text"> (1) 系统调用open打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8write%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text"> (2) 系统调用write写入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8read%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.3.</span> <span class="toc-text"> (3) 系统调用read从文件读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8lseek%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="toc-number">5.1.4.</span> <span class="toc-text"> (4) 系统调用lseek移动文件指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BAsemaphore%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text"> 2. 创建semaphore类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text"> 3. 创建信号量相关的系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text"> 4. 创建生产者-消费者进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C"><span class="toc-number">5.5.</span> <span class="toc-text"> 5. 验证结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C6-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB"><span class="toc-number">6.</span> <span class="toc-text"> 实验6 地址映射与共享</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B7%9F%E8%B8%AA%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text"> 1. 跟踪地址翻译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8A%9F%E8%83%BD"><span class="toc-number">6.2.</span> <span class="toc-text"> 2. 添加共享内存功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E6%8F%90-%E9%80%9A%E8%BF%87brk%E5%88%92%E5%88%86%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">6.2.1.</span> <span class="toc-text"> (1) 前提: 通过brk划分虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%94%A8%E4%BA%8E%E7%AE%A1%E7%90%86%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.2.</span> <span class="toc-text"> (2) 创建用于管理共享内存的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text"> (3) 创建共享内存相关的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85%E8%BF%9B%E7%A8%8B"><span class="toc-number">6.2.4.</span> <span class="toc-text"> (4) 创建生产者进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85%E8%BF%9B%E7%A8%8B"><span class="toc-number">6.2.5.</span> <span class="toc-text"> (5) 创建消费者进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E4%BF%AE%E6%94%B9makefile"><span class="toc-number">6.2.6.</span> <span class="toc-text"> (6) 添加到系统调用和修改MakeFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B8%A9%E7%9A%84%E5%9D%91"><span class="toc-number">6.2.7.</span> <span class="toc-text"> (7) 踩的坑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C"><span class="toc-number">6.3.</span> <span class="toc-text"> 3. 验证结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C7-%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text"> 实验7 终端设备的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84f12%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text"> 1. 添加新的f12响应函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text"> 2. 设置响应函数入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9con_write%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text"> 3. 修改con_write函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9ttyh"><span class="toc-number">7.4.</span> <span class="toc-text"> 4. 修改tty.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C-2"><span class="toc-number">7.5.</span> <span class="toc-text"> 5. 验证结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C8-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.</span> <span class="toc-text"> 实验8 proc文件系统的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%8F%90"><span class="toc-number">8.1.</span> <span class="toc-text"> 前提</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vsprintf%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.1.</span> <span class="toc-text"> vsprintf函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mknod%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">8.1.2.</span> <span class="toc-text"> mknod系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0proc%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.</span> <span class="toc-text"> 添加proc类型文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9mknod%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text"> 修改mknod系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAproc%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6proc%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text"> 创建proc目录文件，proc普通文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F"><span class="toc-number">8.5.</span> <span class="toc-text"> 验证文件是否创建成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99proc%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text"> 编写proc文件处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9makefile"><span class="toc-number">8.7.</span> <span class="toc-text"> 修改Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C"><span class="toc-number">8.8.</span> <span class="toc-text"> 验证结果</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/Learning-OS/HIT-Labs/" title="[HIT-OS]哈工大操作系统实验lab1~8">[HIT-OS]哈工大操作系统实验lab1~8</a><time datetime="2023-05-05T16:00:00.000Z" title="Created 2023-05-06 00:00:00">2023-05-06</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2023/03/27/ubuntu_mac/" title="ubuntu界面Mac化">ubuntu界面Mac化</a><time datetime="2023-03-26T16:00:00.000Z" title="Created 2023-03-27 00:00:00">2023-03-27</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2023/03/16/CSAPP-Lab/cachelab/" title="[CSAPP] cachelab">[CSAPP] cachelab</a><time datetime="2023-03-15T16:00:00.000Z" title="Created 2023-03-16 00:00:00">2023-03-16</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2023/03/06/CSAPP-Lab/datalab-bomblab-attacklab/" title="[CSAPP] datalab, bomblab, attacklab">[CSAPP] datalab, bomblab, attacklab</a><time datetime="2023-03-05T16:00:00.000Z" title="Created 2023-03-06 00:00:00">2023-03-06</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2023/02/04/assembly/" title="汇编语言【王爽】实验流程">汇编语言【王爽】实验流程</a><time datetime="2023-02-03T16:00:00.000Z" title="Created 2023-02-04 00:00:00">2023-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Elite-X</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'e81d3036a2dbceba447b',
      clientSecret: '4f031eb85eeebde1069ca0424a9660a810619614',
      repo: 'Elite-zx.github.io',
      owner: 'Elite-zx',
      admin: ['Elite-zx'],
      id: '41af84762270e9a2f94c9e18ea6b524e',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>